// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from musicxml.xsd.
 */

#ifndef MUSICXML_HXX
#define MUSICXML_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema {
// anyType and anySimpleType.
//

/**
 * @brief C++ type corresponding to the anyType XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::type type;

/**
 * @brief C++ type corresponding to the anySimpleType XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::simple_type<char, type> simple_type;

/**
 * @brief Alias for the anyType type.
 */
typedef ::xsd::cxx::tree::type container;

// 8-bit
//

/**
 * @brief C++ type corresponding to the byte XML Schema
 * built-in type.
 */
typedef signed char byte;

/**
 * @brief C++ type corresponding to the unsignedByte XML Schema
 * built-in type.
 */
typedef unsigned char unsigned_byte;

// 16-bit
//

/**
 * @brief C++ type corresponding to the short XML Schema
 * built-in type.
 */
typedef short short_;

/**
 * @brief C++ type corresponding to the unsignedShort XML Schema
 * built-in type.
 */
typedef unsigned short unsigned_short;

// 32-bit
//

/**
 * @brief C++ type corresponding to the int XML Schema
 * built-in type.
 */
typedef int int_;

/**
 * @brief C++ type corresponding to the unsignedInt XML Schema
 * built-in type.
 */
typedef unsigned int unsigned_int;

// 64-bit
//

/**
 * @brief C++ type corresponding to the long XML Schema
 * built-in type.
 */
typedef long long long_;

/**
 * @brief C++ type corresponding to the unsignedLong XML Schema
 * built-in type.
 */
typedef unsigned long long unsigned_long;

// Supposed to be arbitrary-length integral types.
//

/**
 * @brief C++ type corresponding to the integer XML Schema
 * built-in type.
 */
typedef long long integer;

/**
 * @brief C++ type corresponding to the nonPositiveInteger XML Schema
 * built-in type.
 */
typedef long long non_positive_integer;

/**
 * @brief C++ type corresponding to the nonNegativeInteger XML Schema
 * built-in type.
 */
typedef unsigned long long non_negative_integer;

/**
 * @brief C++ type corresponding to the positiveInteger XML Schema
 * built-in type.
 */
typedef unsigned long long positive_integer;

/**
 * @brief C++ type corresponding to the negativeInteger XML Schema
 * built-in type.
 */
typedef long long negative_integer;

// Boolean.
//

/**
 * @brief C++ type corresponding to the boolean XML Schema
 * built-in type.
 */
typedef bool boolean;

// Floating-point types.
//

/**
 * @brief C++ type corresponding to the float XML Schema
 * built-in type.
 */
typedef float float_;

/**
 * @brief C++ type corresponding to the double XML Schema
 * built-in type.
 */
typedef double double_;

/**
 * @brief C++ type corresponding to the decimal XML Schema
 * built-in type.
 */
typedef double decimal;

// String types.
//

/**
 * @brief C++ type corresponding to the string XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::string<char, simple_type> string;

/**
 * @brief C++ type corresponding to the normalizedString XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::normalized_string<char, string> normalized_string;

/**
 * @brief C++ type corresponding to the token XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::token<char, normalized_string> token;

/**
 * @brief C++ type corresponding to the Name XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::name<char, token> name;

/**
 * @brief C++ type corresponding to the NMTOKEN XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::nmtoken<char, token> nmtoken;

/**
 * @brief C++ type corresponding to the NMTOKENS XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::nmtokens<char, simple_type, nmtoken> nmtokens;

/**
 * @brief C++ type corresponding to the NCName XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::ncname<char, name> ncname;

/**
 * @brief C++ type corresponding to the language XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::language<char, token> language;

// ID/IDREF.
//

/**
 * @brief C++ type corresponding to the ID XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::id<char, ncname> id;

/**
 * @brief C++ type corresponding to the IDREF XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::idref<char, ncname, type> idref;

/**
 * @brief C++ type corresponding to the IDREFS XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::idrefs<char, simple_type, idref> idrefs;

// URI.
//

/**
 * @brief C++ type corresponding to the anyURI XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::uri<char, simple_type> uri;

// Qualified name.
//

/**
 * @brief C++ type corresponding to the QName XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::qname<char, simple_type, uri, ncname> qname;

// Binary.
//

/**
 * @brief Binary buffer type.
 */
typedef ::xsd::cxx::tree::buffer<char> buffer;

/**
 * @brief C++ type corresponding to the base64Binary XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::base64_binary<char, simple_type> base64_binary;

/**
 * @brief C++ type corresponding to the hexBinary XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::hex_binary<char, simple_type> hex_binary;

// Date/time.
//

/**
 * @brief Time zone type.
 */
typedef ::xsd::cxx::tree::time_zone time_zone;

/**
 * @brief C++ type corresponding to the date XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::date<char, simple_type> date;

/**
 * @brief C++ type corresponding to the dateTime XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::date_time<char, simple_type> date_time;

/**
 * @brief C++ type corresponding to the duration XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::duration<char, simple_type> duration;

/**
 * @brief C++ type corresponding to the gDay XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gday<char, simple_type> gday;

/**
 * @brief C++ type corresponding to the gMonth XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gmonth<char, simple_type> gmonth;

/**
 * @brief C++ type corresponding to the gMonthDay XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gmonth_day<char, simple_type> gmonth_day;

/**
 * @brief C++ type corresponding to the gYear XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gyear<char, simple_type> gyear;

/**
 * @brief C++ type corresponding to the gYearMonth XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gyear_month<char, simple_type> gyear_month;

/**
 * @brief C++ type corresponding to the time XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::time<char, simple_type> time;

// Entity.
//

/**
 * @brief C++ type corresponding to the ENTITY XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::entity<char, ncname> entity;

/**
 * @brief C++ type corresponding to the ENTITIES XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::entities<char, simple_type, entity> entities;

/**
 * @brief Content order sequence entry.
 */
typedef ::xsd::cxx::tree::content_order content_order;
// Namespace information and list stream. Used in
// serialization functions.
//
/**
 * @brief Namespace serialization information.
 */
typedef ::xsd::cxx::xml::dom::namespace_info<char> namespace_info;

/**
 * @brief Namespace serialization information map.
 */
typedef ::xsd::cxx::xml::dom::namespace_infomap<char> namespace_infomap;

/**
 * @brief List serialization stream.
 */
typedef ::xsd::cxx::tree::list_stream<char> list_stream;

/**
 * @brief Serialization wrapper for the %double type.
 */
typedef ::xsd::cxx::tree::as_double<double_> as_double;

/**
 * @brief Serialization wrapper for the %decimal type.
 */
typedef ::xsd::cxx::tree::as_decimal<decimal> as_decimal;

/**
 * @brief Simple type facet.
 */
typedef ::xsd::cxx::tree::facet facet;

// Flags and properties.
//

/**
 * @brief Parsing and serialization flags.
 */
typedef ::xsd::cxx::tree::flags flags;

/**
 * @brief Parsing properties.
 */
typedef ::xsd::cxx::tree::properties<char> properties;

// Parsing/serialization diagnostics.
//

/**
 * @brief Error severity.
 */
typedef ::xsd::cxx::tree::severity severity;

/**
 * @brief Error condition.
 */
typedef ::xsd::cxx::tree::error<char> error;

/**
 * @brief List of %error conditions.
 */
typedef ::xsd::cxx::tree::diagnostics<char> diagnostics;

// Exceptions.
//

/**
 * @brief Root of the C++/Tree %exception hierarchy.
 */
typedef ::xsd::cxx::tree::exception<char> exception;

/**
 * @brief Exception indicating that the size argument exceeds
 * the capacity argument.
 */
typedef ::xsd::cxx::tree::bounds<char> bounds;

/**
 * @brief Exception indicating that a duplicate ID value
 * was encountered in the object model.
 */
typedef ::xsd::cxx::tree::duplicate_id<char> duplicate_id;

/**
 * @brief Exception indicating a parsing failure.
 */
typedef ::xsd::cxx::tree::parsing<char> parsing;

/**
 * @brief Exception indicating that an expected element
 * was not encountered.
 */
typedef ::xsd::cxx::tree::expected_element<char> expected_element;

/**
 * @brief Exception indicating that an unexpected element
 * was encountered.
 */
typedef ::xsd::cxx::tree::unexpected_element<char> unexpected_element;

/**
 * @brief Exception indicating that an expected attribute
 * was not encountered.
 */
typedef ::xsd::cxx::tree::expected_attribute<char> expected_attribute;

/**
 * @brief Exception indicating that an unexpected enumerator
 * was encountered.
 */
typedef ::xsd::cxx::tree::unexpected_enumerator<char> unexpected_enumerator;

/**
 * @brief Exception indicating that the text content was
 * expected for an element.
 */
typedef ::xsd::cxx::tree::expected_text_content<char> expected_text_content;

/**
 * @brief Exception indicating that a prefix-namespace
 * mapping was not provided.
 */
typedef ::xsd::cxx::tree::no_prefix_mapping<char> no_prefix_mapping;

/**
 * @brief Exception indicating a serialization failure.
 */
typedef ::xsd::cxx::tree::serialization<char> serialization;

/**
 * @brief Error handler callback interface.
 */
typedef ::xsd::cxx::xml::error_handler<char> error_handler;

/**
 * @brief DOM interaction.
 */
namespace dom {
/**
 * @brief Automatic pointer for DOMDocument.
 */
using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
/**
 * @brief DOM user data key for back pointers to tree nodes.
 */
const XMLCh *const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
}
}

// Forward declarations.
//
namespace musicxml {
class above_below;
class beam_level;
class color;
class comma_separated_text;
class css_font_size;
class divisions;
class enclosure_shape;
class fermata_shape;
class font_size;
class font_style;
class font_weight;
class left_center_right;
class left_right;
class line_shape;
class line_type;
class midi_16;
class midi_128;
class midi_16384;
class mute;
class non_negative_decimal;
class number_level;
class number_of_lines;
class number_or_normal;
class over_under;
class percent;
class positive_decimal;
class positive_divisions;
class positive_integer_or_empty;
class rotation_degrees;
class semi_pitched;
class start_note;
class start_stop;
class start_stop_continue;
class start_stop_single;
class string_number;
class symbol_size;
class tenths;
class text_direction;
class time_only;
class top_bottom;
class trill_beats;
class trill_step;
class two_note_turn;
class up_down;
class upright_inverted;
class valign;
class valign_image;
class yes_no;
class yes_no_number;
class yyyy_mm_dd;
class cancel_location;
class clef_sign;
class fifths;
class mode;
class show_frets;
class staff_line;
class staff_number;
class staff_type;
class time_relation;
class time_separator;
class time_symbol;
class backward_forward;
class bar_style;
class ending_number;
class right_left_middle;
class start_stop_discontinue;
class winged;
class accordion_middle;
class beater_value;
class degree_symbol_value;
class degree_type_value;
class effect;
class glass;
class harmony_type;
class kind_value;
class line_end;
class measure_numbering_value;
class membrane;
class metal;
class on_off;
class pitched;
class principal_voice_symbol;
class start_stop_change_continue;
class tip_direction;
class stick_location;
class stick_material;
class stick_type;
class up_down_stop_continue;
class wedge_type;
class wood;
class distance_type;
class line_width_type;
class margin_type;
class millimeters;
class note_size_type;
class accidental_value;
class arrow_direction;
class arrow_style;
class beam_value;
class breath_mark_value;
class circular_arrow;
class fan;
class handbell_value;
class hole_closed_location;
class hole_closed_value;
class note_type_value;
class notehead_value;
class octave;
class semitones;
class show_tuplet;
class stem_value;
class step;
class syllabic;
class tremolo_marks;
class group_barline_value;
class group_symbol_value;
class accidental_text;
class dynamics;
class empty;
class empty_placement;
class empty_print_style;
class empty_print_style_align;
class empty_print_object_style_align;
class empty_trill_sound;
class horizontal_turn;
class fermata;
class fingering;
class formatted_text;
class fret;
class level;
class midi_device;
class midi_instrument;
class name_display;
class other_play;
class play;
class string;
class typed_text;
class wavy_line;
class attributes;
class beat_repeat;
class cancel;
class clef;
class interchangeable;
class key;
class key_octave;
class measure_repeat;
class measure_style;
class multiple_rest;
class part_symbol;
class slash;
class staff_details;
class staff_tuning;
class time;
class transpose;
class bar_style_color;
class barline;
class ending;
class repeat;
class accord;
class accordion_registration;
class barre;
class bass;
class bass_alter;
class bass_step;
class beater;
class bracket;
class dashes;
class degree;
class degree_alter;
class degree_type;
class degree_value;
class direction;
class direction_type;
class feature;
class first_fret;
class frame;
class frame_note;
class grouping;
class harmony;
class harp_pedals;
class image;
class inversion;
class kind;
class measure_numbering;
class metronome;
class metronome_beam;
class metronome_note;
class time_modification;
class metronome_tuplet;
class octave_shift;
class offset;
class other_direction;
class pedal;
class pedal_tuning;
class per_minute;
class percussion;
class principal_voice;
class print;
class root;
class root_alter;
class root_step;
class scordatura;
class sound;
class stick;
class string_mute;
class wedge;
class encoding;
class identification;
class miscellaneous;
class miscellaneous_field;
class supports;
class appearance;
class distance;
class line_width;
class measure_layout;
class note_size;
class other_appearance;
class page_layout;
class page_margins;
class scaling;
class staff_layout;
class system_dividers;
class system_layout;
class system_margins;
class bookmark;
class link;
class accidental;
class accidental_mark;
class arpeggiate;
class articulations;
class arrow;
class backup;
class beam;
class bend;
class breath_mark;
class empty_line;
class extend;
class figure;
class figured_bass;
class forward;
class glissando;
class grace;
class hammer_on_pull_off;
class handbell;
class harmonic;
class heel_toe;
class hole;
class hole_closed;
class instrument;
class lyric;
class mordent;
class non_arpeggiate;
class notations;
class note;
class note_type;
class notehead;
class notehead_text;
class ornaments;
class other_notation;
class pitch;
class placement_text;
class rest;
class slide;
class slur;
class stem;
class strong_accent;
class style_text;
class technical;
class text_element_data;
class text_font_color;
class tie;
class tied;
class tremolo;
class tuplet;
class tuplet_dot;
class tuplet_number;
class tuplet_portion;
class tuplet_type;
class unpitched;
class credit;
class defaults;
class empty_font;
class group_barline;
class group_name;
class group_symbol;
class lyric_font;
class lyric_language;
class opus;
class part_group;
class part_list;
class part_name;
class score_instrument;
class score_part;
class virtual_instrument;
class work;
class number_or_normal_member;
class positive_integer_or_empty_member;
class directive;
class score_partwise;
class score_timewise;
class part;
class measure;
class measure1;
class part1;
}

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move
#include <cstddef>   // std::size_t
#include <vector>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "xml.hxx"

#include "xlink.hxx"

/**
 * @brief C++ namespace for the %
 * schema namespace.
 */
namespace musicxml {
/**
 * @brief Enumeration class corresponding to the %above-below
 * schema type.
 *
 * The above-below type is used to indicate whether one element appears
 * above or below another element.
 */
class above_below : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { above, below };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  above_below(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  above_below(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  above_below(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  above_below(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  above_below(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  above_below(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  above_below(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  above_below(const above_below &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual above_below *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  above_below &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_above_below_convert(); }

  //@cond

protected:
  value _xsd_above_below_convert() const;

public:
  static const char *const _xsd_above_below_literals_[2];
  static const value _xsd_above_below_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %beam-level schema type.
 *
 * The MusicXML format supports six levels of beaming, up to 1024th
 * notes. Unlike the number-level type, the beam-level type identifies
 * concurrent beams in a beam group. It does not distinguish overlapping
 * beams such as grace notes within regular notes, or beams used in
 * different voices.
 *
 * @nosubgrouping
 */
class beam_level
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  beam_level(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beam_level(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beam_level(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beam_level(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beam_level(const beam_level &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual beam_level *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~beam_level();
};

/**
 * @brief Class corresponding to the %color schema type.
 *
 * The color type indicates the color of an element. Color may be
 * represented as hexadecimal RGB triples, as in HTML, or as hexadecimal
 * ARGB tuples, with the A indicating alpha of transparency. An alpha
 * value of 00 is totally transparent; FF is totally opaque. If RGB is
 * used, the A value is assumed to be FF.
 *
 * For instance, the RGB value "#800080" represents purple. An ARGB value
 * of "#40800080" would be a transparent purple.
 *
 * As in SVG 1.1, colors are defined in terms of the sRGB color space
 * (IEC 61966).
 *
 * @nosubgrouping
 */
class color : public ::xml_schema::token {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  color();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  color(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  color(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  color(const ::xml_schema::token &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  color(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  color(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  color(const ::std::string &s, const ::xercesc::DOMElement *e,
        ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  color(const color &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual color *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~color();
};

/**
 * @brief Class corresponding to the %comma-separated-text schema type.
 *
 * The comma-separated-text type is used to specify a comma-separated
 * list of text elements, as is used by the font-family attribute.
 *
 * @nosubgrouping
 */
class comma_separated_text : public ::xml_schema::token {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  comma_separated_text();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  comma_separated_text(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  comma_separated_text(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  comma_separated_text(const ::xml_schema::token &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  comma_separated_text(const ::xercesc::DOMElement &e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  comma_separated_text(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  comma_separated_text(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  comma_separated_text(const comma_separated_text &x, ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual comma_separated_text *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~comma_separated_text();
};

/**
 * @brief Enumeration class corresponding to the %css-font-size
 * schema type.
 *
 * The css-font-size type includes the CSS font sizes used as an
 * alternative to a numeric point size.
 */
class css_font_size : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { xx_small, x_small, small, medium, large, x_large, xx_large };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  css_font_size(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  css_font_size(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  css_font_size(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  css_font_size(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  css_font_size(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  css_font_size(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  css_font_size(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  css_font_size(const css_font_size &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual css_font_size *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  css_font_size &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_css_font_size_convert(); }

  //@cond

protected:
  value _xsd_css_font_size_convert() const;

public:
  static const char *const _xsd_css_font_size_literals_[7];
  static const value _xsd_css_font_size_indexes_[7];

  //@endcond
};

/**
 * @brief Class corresponding to the %divisions schema type.
 *
 * The divisions type is used to express values in terms of the musical
 * divisions defined by the divisions element. It is preferred that these
 * be integer values both for MIDI interoperability and to avoid roundoff
 * errors.
 *
 * @nosubgrouping
 */
class divisions : public ::xsd::cxx::tree::fundamental_base<
                    ::xml_schema::decimal, char, ::xml_schema::simple_type,
                    ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  divisions(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  divisions(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  divisions(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  divisions(const ::std::string &s, const ::xercesc::DOMElement *e,
            ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  divisions(const divisions &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual divisions *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~divisions();
};

/**
 * @brief Enumeration class corresponding to the %enclosure-shape
 * schema type.
 *
 * The enclosure-shape type describes the shape and presence / absence of
 * an enclosure around text or symbols. A bracket enclosure is similar to
 * a rectangle with the bottom line missing, as is common in jazz
 * notation.
 */
class enclosure_shape : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    rectangle,
    square,
    oval,
    circle,
    bracket,
    triangle,
    diamond,
    none
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  enclosure_shape(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  enclosure_shape(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  enclosure_shape(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  enclosure_shape(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  enclosure_shape(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  enclosure_shape(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  enclosure_shape(const ::std::string &s, const ::xercesc::DOMElement *e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  enclosure_shape(const enclosure_shape &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual enclosure_shape *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  enclosure_shape &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_enclosure_shape_convert(); }

  //@cond

protected:
  value _xsd_enclosure_shape_convert() const;

public:
  static const char *const _xsd_enclosure_shape_literals_[8];
  static const value _xsd_enclosure_shape_indexes_[8];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %fermata-shape
 * schema type.
 *
 * The fermata-shape type represents the shape of the fermata sign. The
 * empty value is equivalent to the normal value.
 */
class fermata_shape : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { normal, angled, square, empty };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  fermata_shape(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  fermata_shape(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  fermata_shape(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  fermata_shape(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fermata_shape(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fermata_shape(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fermata_shape(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fermata_shape(const fermata_shape &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual fermata_shape *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  fermata_shape &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_fermata_shape_convert(); }

  //@cond

protected:
  value _xsd_fermata_shape_convert() const;

public:
  static const char *const _xsd_fermata_shape_literals_[4];
  static const value _xsd_fermata_shape_indexes_[4];

  //@endcond
};

/**
 * @brief Union class corresponding to the %font-size
 * schema type.
 *
 * The mapping represents unions as strings.
 *
 * The font-size can be one of the CSS font sizes or a numeric point
size. */
class font_size : public ::xml_schema::string {
public:
  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  font_size(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  font_size(const ::std::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_size(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_size(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_size(const ::std::string &s, const ::xercesc::DOMElement *e,
            ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  font_size(const font_size &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual font_size *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;
};

/**
 * @brief Enumeration class corresponding to the %font-style
 * schema type.
 *
 * The font-style type represents a simplified version of the CSS
 * font-style property.
 */
class font_style : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { normal, italic };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  font_style(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  font_style(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  font_style(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  font_style(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_style(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_style(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_style(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  font_style(const font_style &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual font_style *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  font_style &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_font_style_convert(); }

  //@cond

protected:
  value _xsd_font_style_convert() const;

public:
  static const char *const _xsd_font_style_literals_[2];
  static const value _xsd_font_style_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %font-weight
 * schema type.
 *
 * The font-weight type represents a simplified version of the CSS
 * font-weight property.
 */
class font_weight : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { normal, bold };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  font_weight(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  font_weight(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  font_weight(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  font_weight(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_weight(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_weight(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  font_weight(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  font_weight(const font_weight &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual font_weight *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  font_weight &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_font_weight_convert(); }

  //@cond

protected:
  value _xsd_font_weight_convert() const;

public:
  static const char *const _xsd_font_weight_literals_[2];
  static const value _xsd_font_weight_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %left-center-right
 * schema type.
 *
 * The left-center-right type is used to define horizontal alignment and
 * text justification.
 */
class left_center_right : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { left, center, right };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  left_center_right(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  left_center_right(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  left_center_right(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  left_center_right(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  left_center_right(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  left_center_right(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  left_center_right(const ::std::string &s, const ::xercesc::DOMElement *e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  left_center_right(const left_center_right &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual left_center_right *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  left_center_right &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_left_center_right_convert(); }

  //@cond

protected:
  value _xsd_left_center_right_convert() const;

public:
  static const char *const _xsd_left_center_right_literals_[3];
  static const value _xsd_left_center_right_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %left-right
 * schema type.
 *
 * The left-right type is used to indicate whether one element appears to
 * the left or the right of another element.
 */
class left_right : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { left, right };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  left_right(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  left_right(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  left_right(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  left_right(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  left_right(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  left_right(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  left_right(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  left_right(const left_right &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual left_right *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  left_right &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_left_right_convert(); }

  //@cond

protected:
  value _xsd_left_right_convert() const;

public:
  static const char *const _xsd_left_right_literals_[2];
  static const value _xsd_left_right_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %line-shape
 * schema type.
 *
 * The line-shape type distinguishes between straight and curved lines.
 */
class line_shape : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { straight, curved };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  line_shape(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  line_shape(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  line_shape(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  line_shape(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_shape(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_shape(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_shape(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  line_shape(const line_shape &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual line_shape *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  line_shape &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_line_shape_convert(); }

  //@cond

protected:
  value _xsd_line_shape_convert() const;

public:
  static const char *const _xsd_line_shape_literals_[2];
  static const value _xsd_line_shape_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %line-type
 * schema type.
 *
 * The line-type type distinguishes between solid, dashed, dotted, and
 * wavy lines.
 */
class line_type : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { solid, dashed, dotted, wavy };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  line_type(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  line_type(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  line_type(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  line_type(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_type(const ::std::string &s, const ::xercesc::DOMElement *e,
            ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  line_type(const line_type &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual line_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  line_type &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_line_type_convert(); }

  //@cond

protected:
  value _xsd_line_type_convert() const;

public:
  static const char *const _xsd_line_type_literals_[4];
  static const value _xsd_line_type_indexes_[4];

  //@endcond
};

/**
 * @brief Class corresponding to the %midi-16 schema type.
 *
 * The midi-16 type is used to express MIDI 1.0 values that range from 1
 * to 16.
 *
 * @nosubgrouping
 */
class midi_16
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  midi_16(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_16(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_16(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_16(const ::std::string &s, const ::xercesc::DOMElement *e,
          ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  midi_16(const midi_16 &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual midi_16 *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~midi_16();
};

/**
 * @brief Class corresponding to the %midi-128 schema type.
 *
 * The midi-16 type is used to express MIDI 1.0 values that range from 1
 * to 128.
 *
 * @nosubgrouping
 */
class midi_128
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  midi_128(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_128(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_128(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_128(const ::std::string &s, const ::xercesc::DOMElement *e,
           ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  midi_128(const midi_128 &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual midi_128 *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~midi_128();
};

/**
 * @brief Class corresponding to the %midi-16384 schema type.
 *
 * The midi-16 type is used to express MIDI 1.0 values that range from 1
 * to 16,384.
 *
 * @nosubgrouping
 */
class midi_16384
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  midi_16384(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_16384(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_16384(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_16384(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  midi_16384(const midi_16384 &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual midi_16384 *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~midi_16384();
};

/**
 * @brief Enumeration class corresponding to the %mute
 * schema type.
 *
 * The mute type represents muting for different instruments, including
 * brass, winds, and strings. The on and off values are used for
 * undifferentiated mutes. The remaining values represent specific mutes.
 */
class mute : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    on,
    off,
    straight,
    cup,
    harmon_no_stem,
    harmon_stem,
    bucket,
    plunger,
    hat,
    solotone,
    practice,
    stop_mute,
    stop_hand,
    echo,
    palm
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  mute(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  mute(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  mute(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  mute(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  mute(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  mute(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  mute(const ::std::string &s, const ::xercesc::DOMElement *e,
       ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  mute(const mute &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual mute *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  mute &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_mute_convert(); }

  //@cond

protected:
  value _xsd_mute_convert() const;

public:
  static const char *const _xsd_mute_literals_[15];
  static const value _xsd_mute_indexes_[15];

  //@endcond
};

/**
 * @brief Class corresponding to the %non-negative-decimal schema type.
 *
 * The non-negative-decimal type specifies a non-negative decimal value.
 *
 * @nosubgrouping
 */
class non_negative_decimal
  : public ::xsd::cxx::tree::fundamental_base<
      ::xml_schema::decimal, char, ::xml_schema::simple_type,
      ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  non_negative_decimal(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  non_negative_decimal(const ::xercesc::DOMElement &e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  non_negative_decimal(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  non_negative_decimal(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  non_negative_decimal(const non_negative_decimal &x, ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual non_negative_decimal *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~non_negative_decimal();
};

/**
 * @brief Class corresponding to the %number-level schema type.
 *
 * Slurs, tuplets, and many other features can be concurrent and
 * overlapping within a single musical part. The number-level type
 * distinguishes up to six concurrent objects of the same type. A reading
 * program should be prepared to handle cases where the number-levels
 * stop in an arbitrary order. Different numbers are needed when the
 * features overlap in MusicXML document order. When a number-level value
 * is implied, the value is 1 by default.
 *
 * @nosubgrouping
 */
class number_level
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  number_level(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_level(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_level(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_level(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  number_level(const number_level &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual number_level *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~number_level();
};

/**
 * @brief Class corresponding to the %number-of-lines schema type.
 *
 * The number-of-lines type is used to specify the number of lines in
 * text decoration attributes.
 *
 * @nosubgrouping
 */
class number_of_lines
  : public ::xsd::cxx::tree::fundamental_base<
      ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  number_of_lines(const ::xml_schema::non_negative_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_of_lines(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_of_lines(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_of_lines(const ::std::string &s, const ::xercesc::DOMElement *e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  number_of_lines(const number_of_lines &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual number_of_lines *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~number_of_lines();
};

/**
 * @brief Union class corresponding to the %number-or-normal
 * schema type.
 *
 * The mapping represents unions as strings.
 *
 * The number-or-normal values can be either a decimal number or the
 * string "normal". This is used by the line-height and letter-spacing
 * attributes.
 */
class number_or_normal : public ::xml_schema::string {
public:
  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  number_or_normal(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  number_or_normal(const ::std::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_or_normal(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_or_normal(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_or_normal(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  number_or_normal(const number_or_normal &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual number_or_normal *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;
};

/**
 * @brief Enumeration class corresponding to the %over-under
 * schema type.
 *
 * The over-under type is used to indicate whether the tips of curved
 * lines such as slurs and ties are overhand (tips down) or underhand
 * (tips up).
 */
class over_under : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { over, under };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  over_under(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  over_under(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  over_under(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  over_under(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  over_under(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  over_under(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  over_under(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  over_under(const over_under &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual over_under *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  over_under &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_over_under_convert(); }

  //@cond

protected:
  value _xsd_over_under_convert() const;

public:
  static const char *const _xsd_over_under_literals_[2];
  static const value _xsd_over_under_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %percent schema type.
 *
 * The percent type specifies a percentage from 0 to 100.
 *
 * @nosubgrouping
 */
class percent : public ::xsd::cxx::tree::fundamental_base<
                  ::xml_schema::decimal, char, ::xml_schema::simple_type,
                  ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  percent(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  percent(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  percent(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  percent(const ::std::string &s, const ::xercesc::DOMElement *e,
          ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  percent(const percent &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual percent *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~percent();
};

/**
 * @brief Class corresponding to the %positive-decimal schema type.
 *
 * The positive-decimal type specifies a positive decimal value.
 *
 * @nosubgrouping
 */
class positive_decimal
  : public ::xsd::cxx::tree::fundamental_base<
      ::xml_schema::decimal, char, ::xml_schema::simple_type,
      ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  positive_decimal(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_decimal(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_decimal(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_decimal(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  positive_decimal(const positive_decimal &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual positive_decimal *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~positive_decimal();
};

/**
 * @brief Class corresponding to the %positive-divisions schema type.
 *
 * The positive-divisions type restricts divisions values to positive
 * numbers.
 *
 * @nosubgrouping
 */
class positive_divisions : public ::musicxml::divisions {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  positive_divisions(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_divisions(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_divisions(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_divisions(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  positive_divisions(const positive_divisions &x, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual positive_divisions *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~positive_divisions();
};

/**
 * @brief Union class corresponding to the %positive-integer-or-empty
 * schema type.
 *
 * The mapping represents unions as strings.
 *
 * The positive-integer-or-empty values can be either a positive integer
 * or an empty string.
 */
class positive_integer_or_empty : public ::xml_schema::string {
public:
  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  positive_integer_or_empty(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  positive_integer_or_empty(const ::std::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_integer_or_empty(const ::xercesc::DOMElement &e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_integer_or_empty(const ::xercesc::DOMAttr &a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_integer_or_empty(const ::std::string &s,
                            const ::xercesc::DOMElement *e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  positive_integer_or_empty(const positive_integer_or_empty &x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual positive_integer_or_empty *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;
};

/**
 * @brief Class corresponding to the %rotation-degrees schema type.
 *
 * The rotation-degrees type specifies rotation, pan, and elevation
 * values in degrees. Values range from -180 to 180.
 *
 * @nosubgrouping
 */
class rotation_degrees
  : public ::xsd::cxx::tree::fundamental_base<
      ::xml_schema::decimal, char, ::xml_schema::simple_type,
      ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  rotation_degrees(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  rotation_degrees(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  rotation_degrees(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  rotation_degrees(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  rotation_degrees(const rotation_degrees &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual rotation_degrees *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~rotation_degrees();
};

/**
 * @brief Enumeration class corresponding to the %semi-pitched
 * schema type.
 *
 * The semi-pitched type represents categories of indefinite pitch for
 * percussion instruments.
 */
class semi_pitched : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { high, medium_high, medium, medium_low, low, very_low };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  semi_pitched(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  semi_pitched(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  semi_pitched(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  semi_pitched(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  semi_pitched(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  semi_pitched(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  semi_pitched(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  semi_pitched(const semi_pitched &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual semi_pitched *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  semi_pitched &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_semi_pitched_convert(); }

  //@cond

protected:
  value _xsd_semi_pitched_convert() const;

public:
  static const char *const _xsd_semi_pitched_literals_[6];
  static const value _xsd_semi_pitched_indexes_[6];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %start-note
 * schema type.
 *
 * The start-note type describes the starting note of trills and mordents
 * for playback, relative to the current note.
 */
class start_note : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { upper, main, below };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  start_note(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  start_note(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  start_note(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  start_note(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_note(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_note(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_note(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  start_note(const start_note &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual start_note *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  start_note &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_start_note_convert(); }

  //@cond

protected:
  value _xsd_start_note_convert() const;

public:
  static const char *const _xsd_start_note_literals_[3];
  static const value _xsd_start_note_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %start-stop
 * schema type.
 *
 * The start-stop type is used for an attribute of musical elements that
 * can either start or stop, such as tuplets.
 *
 * The values of start and stop refer to how an element appears in
 * musical score order, not in MusicXML document order. An element with a
 * stop attribute may precede the corresponding element with a start
 * attribute within a MusicXML document. This is particularly common in
 * multi-staff music. For example, the stopping point for a tuplet may
 * appear in staff 1 before the starting point for the tuplet appears in
 * staff 2 later in the document.
 */
class start_stop : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { start, stop };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  start_stop(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  start_stop(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  start_stop(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  start_stop(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  start_stop(const start_stop &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual start_stop *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  start_stop &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_start_stop_convert(); }

  //@cond

protected:
  value _xsd_start_stop_convert() const;

public:
  static const char *const _xsd_start_stop_literals_[2];
  static const value _xsd_start_stop_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %start-stop-continue
 * schema type.
 *
 * The start-stop-continue type is used for an attribute of musical
 * elements that can either start or stop, but also need to refer to an
 * intermediate point in the symbol, as for complex slurs or for
 * formatting of symbols across system breaks.
 *
 * The values of start, stop, and continue refer to how an element
 * appears in musical score order, not in MusicXML document order. An
 * element with a stop attribute may precede the corresponding element
 * with a start attribute within a MusicXML document. This is
 * particularly common in multi-staff music. For example, the stopping
 * point for a slur may appear in staff 1 before the starting point for
 * the slur appears in staff 2 later in the document.
 */
class start_stop_continue : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { start, stop, continue_ };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  start_stop_continue(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  start_stop_continue(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  start_stop_continue(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  start_stop_continue(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_continue(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_continue(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_continue(const ::std::string &s, const ::xercesc::DOMElement *e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  start_stop_continue(const start_stop_continue &x, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual start_stop_continue *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  start_stop_continue &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_start_stop_continue_convert(); }

  //@cond

protected:
  value _xsd_start_stop_continue_convert() const;

public:
  static const char *const _xsd_start_stop_continue_literals_[3];
  static const value _xsd_start_stop_continue_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %start-stop-single
 * schema type.
 *
 * The start-stop-single type is used for an attribute of musical
 * elements that can be used for either multi-note or single-note musical
 * elements, as for tremolos.
 */
class start_stop_single : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { start, stop, single };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  start_stop_single(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  start_stop_single(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  start_stop_single(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  start_stop_single(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_single(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_single(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_single(const ::std::string &s, const ::xercesc::DOMElement *e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  start_stop_single(const start_stop_single &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual start_stop_single *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  start_stop_single &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_start_stop_single_convert(); }

  //@cond

protected:
  value _xsd_start_stop_single_convert() const;

public:
  static const char *const _xsd_start_stop_single_literals_[3];
  static const value _xsd_start_stop_single_indexes_[3];

  //@endcond
};

/**
 * @brief Class corresponding to the %string-number schema type.
 *
 * The string-number type indicates a string number. Strings are numbered
 * from high to low, with 1 being the highest pitched string.
 *
 * @nosubgrouping
 */
class string_number
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  string_number(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  string_number(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  string_number(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  string_number(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  string_number(const string_number &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual string_number *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~string_number();
};

/**
 * @brief Enumeration class corresponding to the %symbol-size
 * schema type.
 *
 * The symbol-size type is used to indicate full vs. cue-sized vs.
 * oversized symbols. The large value for oversized symbols was added in
 * version 1.1.
 */
class symbol_size : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { full, cue, large };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  symbol_size(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  symbol_size(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  symbol_size(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  symbol_size(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  symbol_size(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  symbol_size(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  symbol_size(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  symbol_size(const symbol_size &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual symbol_size *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  symbol_size &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_symbol_size_convert(); }

  //@cond

protected:
  value _xsd_symbol_size_convert() const;

public:
  static const char *const _xsd_symbol_size_literals_[3];
  static const value _xsd_symbol_size_indexes_[3];

  //@endcond
};

/**
 * @brief Class corresponding to the %tenths schema type.
 *
 * The tenths type is a number representing tenths of interline staff
 * space (positive or negative). Both integer and decimal values are
 * allowed, such as 5 for a half space and 2.5 for a quarter space.
 * Interline space is measured from the middle of a staff line.
 *
 * Distances in a MusicXML file are measured in tenths of staff space.
 * Tenths are then scaled to millimeters within the scaling element, used
 * in the defaults element at the start of a score. Individual staves can
 * apply a scaling factor to adjust staff size. When a MusicXML element
 * or attribute refers to tenths, it means the global tenths defined by
 * the scaling element, not the local tenths as adjusted by the
 * staff-size element.
 *
 * @nosubgrouping
 */
class tenths : public ::xsd::cxx::tree::fundamental_base<
                 ::xml_schema::decimal, char, ::xml_schema::simple_type,
                 ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tenths(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tenths(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tenths(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tenths(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tenths(const tenths &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tenths *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tenths();
};

/**
 * @brief Enumeration class corresponding to the %text-direction
 * schema type.
 *
 * The text-direction type is used to adjust and override the Unicode
 * bidirectional text algorithm, similar to the W3C Internationalization
 * Tag Set recommendation. Values are ltr (left-to-right embed), rtl
 * (right-to-left embed), lro (left-to-right bidi-override), and rlo
 * (right-to-left bidi-override). The default value is ltr. This type is
 * typically used by applications that store text in left-to-right visual
 * order rather than logical order. Such applications can use the lro
 * value to better communicate with other applications that more fully
 * support bidirectional text.
 */
class text_direction : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { ltr, rtl, lro, rlo };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  text_direction(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  text_direction(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  text_direction(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  text_direction(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  text_direction(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  text_direction(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  text_direction(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  text_direction(const text_direction &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual text_direction *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  text_direction &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_text_direction_convert(); }

  //@cond

protected:
  value _xsd_text_direction_convert() const;

public:
  static const char *const _xsd_text_direction_literals_[4];
  static const value _xsd_text_direction_indexes_[4];

  //@endcond
};

/**
 * @brief Class corresponding to the %time-only schema type.
 *
 * The time-only type is used to indicate that a particular
 * playback-related element only applies particular times through a
 * repeated section. The value is a comma-separated list of positive
 * integers arranged in ascending order, indicating which times through
 * the repeated section that the element applies.
 *
 * @nosubgrouping
 */
class time_only : public ::xml_schema::token {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  time_only();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  time_only(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  time_only(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  time_only(const ::xml_schema::token &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_only(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_only(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_only(const ::std::string &s, const ::xercesc::DOMElement *e,
            ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  time_only(const time_only &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual time_only *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~time_only();
};

/**
 * @brief Enumeration class corresponding to the %top-bottom
 * schema type.
 *
 * The top-bottom type is used to indicate the top or bottom part of a
 * vertical shape like non-arpeggiate.
 */
class top_bottom : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { top, bottom };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  top_bottom(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  top_bottom(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  top_bottom(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  top_bottom(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  top_bottom(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  top_bottom(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  top_bottom(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  top_bottom(const top_bottom &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual top_bottom *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  top_bottom &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_top_bottom_convert(); }

  //@cond

protected:
  value _xsd_top_bottom_convert() const;

public:
  static const char *const _xsd_top_bottom_literals_[2];
  static const value _xsd_top_bottom_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %trill-beats schema type.
 *
 * The trill-beats type specifies the beats used in a trill-sound or
 * bend-sound attribute group. It is a decimal value with a minimum value
 * of 2.
 *
 * @nosubgrouping
 */
class trill_beats : public ::xsd::cxx::tree::fundamental_base<
                      ::xml_schema::decimal, char, ::xml_schema::simple_type,
                      ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  trill_beats(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  trill_beats(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  trill_beats(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  trill_beats(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  trill_beats(const trill_beats &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual trill_beats *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~trill_beats();
};

/**
 * @brief Enumeration class corresponding to the %trill-step
 * schema type.
 *
 * The trill-step type describes the alternating note of trills and
 * mordents for playback, relative to the current note.
 */
class trill_step : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { whole, half, unison };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  trill_step(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  trill_step(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  trill_step(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  trill_step(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  trill_step(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  trill_step(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  trill_step(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  trill_step(const trill_step &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual trill_step *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  trill_step &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_trill_step_convert(); }

  //@cond

protected:
  value _xsd_trill_step_convert() const;

public:
  static const char *const _xsd_trill_step_literals_[3];
  static const value _xsd_trill_step_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %two-note-turn
 * schema type.
 *
 * The two-note-turn type describes the ending notes of trills and
 * mordents for playback, relative to the current note.
 */
class two_note_turn : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { whole, half, none };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  two_note_turn(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  two_note_turn(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  two_note_turn(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  two_note_turn(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  two_note_turn(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  two_note_turn(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  two_note_turn(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  two_note_turn(const two_note_turn &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual two_note_turn *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  two_note_turn &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_two_note_turn_convert(); }

  //@cond

protected:
  value _xsd_two_note_turn_convert() const;

public:
  static const char *const _xsd_two_note_turn_literals_[3];
  static const value _xsd_two_note_turn_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %up-down
 * schema type.
 *
 * The up-down type is used for the direction of arrows and other pointed
 * symbols like vertical accents, indicating which way the tip is
 * pointing.
 */
class up_down : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { up, down };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  up_down(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  up_down(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  up_down(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  up_down(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  up_down(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  up_down(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  up_down(const ::std::string &s, const ::xercesc::DOMElement *e,
          ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  up_down(const up_down &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual up_down *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  up_down &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_up_down_convert(); }

  //@cond

protected:
  value _xsd_up_down_convert() const;

public:
  static const char *const _xsd_up_down_literals_[2];
  static const value _xsd_up_down_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %upright-inverted
 * schema type.
 *
 * The upright-inverted type describes the appearance of a fermata
 * element. The value is upright if not specified.
 */
class upright_inverted : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { upright, inverted };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  upright_inverted(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  upright_inverted(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  upright_inverted(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  upright_inverted(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  upright_inverted(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  upright_inverted(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  upright_inverted(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  upright_inverted(const upright_inverted &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual upright_inverted *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  upright_inverted &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_upright_inverted_convert(); }

  //@cond

protected:
  value _xsd_upright_inverted_convert() const;

public:
  static const char *const _xsd_upright_inverted_literals_[2];
  static const value _xsd_upright_inverted_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %valign
 * schema type.
 *
 * The valign type is used to indicate vertical alignment to the top,
 * middle, bottom, or baseline of the text. Defaults are
 * implementation-dependent.
 */
class valign : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { top, middle, bottom, baseline };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  valign(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  valign(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  valign(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  valign(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  valign(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  valign(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  valign(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  valign(const valign &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual valign *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  valign &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_valign_convert(); }

  //@cond

protected:
  value _xsd_valign_convert() const;

public:
  static const char *const _xsd_valign_literals_[4];
  static const value _xsd_valign_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %valign-image
 * schema type.
 *
 * The valign-image type is used to indicate vertical alignment for
 * images and graphics, so it does not include a baseline value. Defaults
 * are implementation-dependent.
 */
class valign_image : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { top, middle, bottom };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  valign_image(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  valign_image(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  valign_image(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  valign_image(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  valign_image(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  valign_image(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  valign_image(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  valign_image(const valign_image &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual valign_image *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  valign_image &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_valign_image_convert(); }

  //@cond

protected:
  value _xsd_valign_image_convert() const;

public:
  static const char *const _xsd_valign_image_literals_[3];
  static const value _xsd_valign_image_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %yes-no
 * schema type.
 *
 * The yes-no type is used for boolean-like attributes. We cannot use W3C
 * XML Schema booleans due to their restrictions on expression of boolean
 * values.
 */
class yes_no : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { yes, no };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  yes_no(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  yes_no(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  yes_no(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  yes_no(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yes_no(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yes_no(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yes_no(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  yes_no(const yes_no &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual yes_no *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  yes_no &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_yes_no_convert(); }

  //@cond

protected:
  value _xsd_yes_no_convert() const;

public:
  static const char *const _xsd_yes_no_literals_[2];
  static const value _xsd_yes_no_indexes_[2];

  //@endcond
};

/**
 * @brief Union class corresponding to the %yes-no-number
 * schema type.
 *
 * The mapping represents unions as strings.
 *
 * The yes-no-number type is used for attributes that can be either
 * boolean or numeric values.
 */
class yes_no_number : public ::xml_schema::string {
public:
  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  yes_no_number(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  yes_no_number(const ::std::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yes_no_number(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yes_no_number(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yes_no_number(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  yes_no_number(const yes_no_number &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual yes_no_number *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;
};

/**
 * @brief Class corresponding to the %yyyy-mm-dd schema type.
 *
 * Calendar dates are represented yyyy-mm-dd format, following ISO 8601.
 * This is a W3C XML Schema date type, but without the optional timezone
 * data.
 *
 * @nosubgrouping
 */
class yyyy_mm_dd : public ::xml_schema::date {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  yyyy_mm_dd(const ::xml_schema::date &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yyyy_mm_dd(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yyyy_mm_dd(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yyyy_mm_dd(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  yyyy_mm_dd(const yyyy_mm_dd &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual yyyy_mm_dd *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~yyyy_mm_dd();
};

/**
 * @brief Enumeration class corresponding to the %cancel-location
 * schema type.
 *
 * The cancel-location type is used to indicate where a key signature
 * cancellation appears relative to a new key signature: to the left, to
 * the right, or before the barline and to the left. It is left by
 * default. For mid-measure key elements, a cancel-location of
 * before-barline should be treated like a cancel-location of left.
 */
class cancel_location : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { left, right, before_barline };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  cancel_location(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  cancel_location(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  cancel_location(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  cancel_location(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  cancel_location(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  cancel_location(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  cancel_location(const ::std::string &s, const ::xercesc::DOMElement *e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  cancel_location(const cancel_location &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual cancel_location *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  cancel_location &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_cancel_location_convert(); }

  //@cond

protected:
  value _xsd_cancel_location_convert() const;

public:
  static const char *const _xsd_cancel_location_literals_[3];
  static const value _xsd_cancel_location_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %clef-sign
 * schema type.
 *
 * The clef-sign element represents the different clef symbols. The
 * jianpu sign indicates that the music that follows should be in jianpu
 * numbered notation, just as the TAB sign indicates that the music that
 * follows should be in tablature notation. Unlike TAB, a jianpu sign
 * does not correspond to a visual clef notation.
 */
class clef_sign : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { G, F, C, percussion, TAB, jianpu, none };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  clef_sign(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  clef_sign(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  clef_sign(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  clef_sign(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  clef_sign(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  clef_sign(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  clef_sign(const ::std::string &s, const ::xercesc::DOMElement *e,
            ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  clef_sign(const clef_sign &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual clef_sign *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  clef_sign &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_clef_sign_convert(); }

  //@cond

protected:
  value _xsd_clef_sign_convert() const;

public:
  static const char *const _xsd_clef_sign_literals_[7];
  static const value _xsd_clef_sign_indexes_[7];

  //@endcond
};

/**
 * @brief Class corresponding to the %fifths schema type.
 *
 * The fifths type represents the number of flats or sharps in a
 * traditional key signature. Negative numbers are used for flats and
 * positive numbers for sharps, reflecting the key's placement within the
 * circle of fifths (hence the type name).
 *
 * @nosubgrouping
 */
class fifths : public ::xsd::cxx::tree::fundamental_base<
                 ::xml_schema::integer, char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  fifths(const ::xml_schema::integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fifths(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fifths(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fifths(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fifths(const fifths &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual fifths *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~fifths();
};

/**
 * @brief Class corresponding to the %mode schema type.
 *
 * The mode type is used to specify major/minor and other mode
 * distinctions. Valid mode values include major, minor, dorian,
 * phrygian, lydian, mixolydian, aeolian, ionian, locrian, and none.
 *
 * @nosubgrouping
 */
class mode : public ::xml_schema::string {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  mode();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  mode(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  mode(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  mode(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  mode(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  mode(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  mode(const ::std::string &s, const ::xercesc::DOMElement *e,
       ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  mode(const mode &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual mode *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~mode();
};

/**
 * @brief Enumeration class corresponding to the %show-frets
 * schema type.
 *
 * The show-frets type indicates whether to show tablature frets as
 * numbers (0, 1, 2) or letters (a, b, c). The default choice is numbers.
 */
class show_frets : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { numbers, letters };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  show_frets(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  show_frets(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  show_frets(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  show_frets(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  show_frets(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  show_frets(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  show_frets(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  show_frets(const show_frets &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual show_frets *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  show_frets &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_show_frets_convert(); }

  //@cond

protected:
  value _xsd_show_frets_convert() const;

public:
  static const char *const _xsd_show_frets_literals_[2];
  static const value _xsd_show_frets_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %staff-line schema type.
 *
 * The staff-line type indicates the line on a given staff. Staff lines
 * are numbered from bottom to top, with 1 being the bottom line on a
 * staff. Staff line values can be used to specify positions outside the
 * staff, such as a C clef positioned in the middle of a grand staff.
 *
 * @nosubgrouping
 */
class staff_line : public ::xsd::cxx::tree::fundamental_base<
                     ::xml_schema::integer, char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  staff_line(const ::xml_schema::integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_line(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_line(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_line(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_line(const staff_line &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual staff_line *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~staff_line();
};

/**
 * @brief Class corresponding to the %staff-number schema type.
 *
 * The staff-number type indicates staff numbers within a multi-staff
 * part. Staves are numbered from top to bottom, with 1 being the top
 * staff on a part.
 *
 * @nosubgrouping
 */
class staff_number
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  staff_number(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_number(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_number(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_number(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_number(const staff_number &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual staff_number *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~staff_number();
};

/**
 * @brief Enumeration class corresponding to the %staff-type
 * schema type.
 *
 * The staff-type value can be ossia, cue, editorial, regular, or
 * alternate. An alternate staff indicates one that shares the same
 * musical data as the prior staff, but displayed differently (e.g.,
 * treble and bass clef, standard notation and tab).
 */
class staff_type : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { ossia, cue, editorial, regular, alternate };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  staff_type(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  staff_type(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  staff_type(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  staff_type(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_type(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_type(const staff_type &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual staff_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  staff_type &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_staff_type_convert(); }

  //@cond

protected:
  value _xsd_staff_type_convert() const;

public:
  static const char *const _xsd_staff_type_literals_[5];
  static const value _xsd_staff_type_indexes_[5];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %time-relation
 * schema type.
 *
 * The time-relation type indicates the symbol used to represent the
 * interchangeable aspect of dual time signatures.
 */
class time_relation : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { parentheses, bracket, equals, slash, space, hyphen };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  time_relation(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  time_relation(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  time_relation(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  time_relation(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_relation(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_relation(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_relation(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  time_relation(const time_relation &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual time_relation *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  time_relation &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_time_relation_convert(); }

  //@cond

protected:
  value _xsd_time_relation_convert() const;

public:
  static const char *const _xsd_time_relation_literals_[6];
  static const value _xsd_time_relation_indexes_[6];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %time-separator
 * schema type.
 *
 * The time-separator type indicates how to display the arrangement
 * between the beats and beat-type values in a time signature. The
 * default value is none. The horizontal, diagonal, and vertical values
 * represent horizontal, diagonal lower-left to upper-right, and vertical
 * lines respectively. For these values, the beats and beat-type values
 * are arranged on either side of the separator line. The none value
 * represents no separator with the beats and beat-type arranged
 * vertically. The adjacent value represents no separator with the beats
 * and beat-type arranged horizontally.
 */
class time_separator : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { none, horizontal, diagonal, vertical, adjacent };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  time_separator(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  time_separator(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  time_separator(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  time_separator(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_separator(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_separator(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_separator(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  time_separator(const time_separator &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual time_separator *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  time_separator &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_time_separator_convert(); }

  //@cond

protected:
  value _xsd_time_separator_convert() const;

public:
  static const char *const _xsd_time_separator_literals_[5];
  static const value _xsd_time_separator_indexes_[5];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %time-symbol
 * schema type.
 *
 * The time-symbol type indicates how to display a time signature. The
 * normal value is the usual fractional display, and is the implied
 * symbol type if none is specified. Other options are the common and cut
 * time symbols, as well as a single number with an implied denominator.
 * The note symbol indicates that the beat-type should be represented
 * with the corresponding downstem note rather than a number. The
 * dotted-note symbol indicates that the beat-type should be represented
 * with a dotted downstem note that corresponds to three times the
 * beat-type value, and a numerator that is one third the beats value.
 */
class time_symbol : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { common, cut, single_number, note, dotted_note, normal };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  time_symbol(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  time_symbol(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  time_symbol(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  time_symbol(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_symbol(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_symbol(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_symbol(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  time_symbol(const time_symbol &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual time_symbol *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  time_symbol &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_time_symbol_convert(); }

  //@cond

protected:
  value _xsd_time_symbol_convert() const;

public:
  static const char *const _xsd_time_symbol_literals_[6];
  static const value _xsd_time_symbol_indexes_[6];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %backward-forward
 * schema type.
 *
 * The backward-forward type is used to specify repeat directions. The
 * start of the repeat has a forward direction while the end of the
 * repeat has a backward direction.
 */
class backward_forward : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { backward, forward };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  backward_forward(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  backward_forward(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  backward_forward(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  backward_forward(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  backward_forward(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  backward_forward(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  backward_forward(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  backward_forward(const backward_forward &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual backward_forward *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  backward_forward &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_backward_forward_convert(); }

  //@cond

protected:
  value _xsd_backward_forward_convert() const;

public:
  static const char *const _xsd_backward_forward_literals_[2];
  static const value _xsd_backward_forward_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %bar-style
 * schema type.
 *
 * The bar-style type represents barline style information. Choices are
 * regular, dotted, dashed, heavy, light-light, light-heavy, heavy-light,
 * heavy-heavy, tick (a short stroke through the top line), short (a
 * partial barline between the 2nd and 4th lines), and none.
 */
class bar_style : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    regular,
    dotted,
    dashed,
    heavy,
    light_light,
    light_heavy,
    heavy_light,
    heavy_heavy,
    tick,
    short_,
    none
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  bar_style(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  bar_style(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  bar_style(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  bar_style(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bar_style(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bar_style(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bar_style(const ::std::string &s, const ::xercesc::DOMElement *e,
            ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bar_style(const bar_style &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bar_style *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  bar_style &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_bar_style_convert(); }

  //@cond

protected:
  value _xsd_bar_style_convert() const;

public:
  static const char *const _xsd_bar_style_literals_[11];
  static const value _xsd_bar_style_indexes_[11];

  //@endcond
};

/**
 * @brief Class corresponding to the %ending-number schema type.
 *
 * The ending-number type is used to specify either a comma-separated
 * list of positive integers without leading zeros, or a string of zero
 * or more spaces. It is used for the number attribute of the ending
 * element. The zero or more spaces version is used when software knows
 * that an ending is present, but cannot determine the type of the
ending. *
 * @nosubgrouping
 */
class ending_number : public ::xml_schema::token {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  ending_number();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  ending_number(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  ending_number(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ending_number(const ::xml_schema::token &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ending_number(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ending_number(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ending_number(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ending_number(const ending_number &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ending_number *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~ending_number();
};

/**
 * @brief Enumeration class corresponding to the %right-left-middle
 * schema type.
 *
 * The right-left-middle type is used to specify barline location.
 */
class right_left_middle : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { right, left, middle };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  right_left_middle(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  right_left_middle(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  right_left_middle(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  right_left_middle(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  right_left_middle(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  right_left_middle(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  right_left_middle(const ::std::string &s, const ::xercesc::DOMElement *e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  right_left_middle(const right_left_middle &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual right_left_middle *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  right_left_middle &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_right_left_middle_convert(); }

  //@cond

protected:
  value _xsd_right_left_middle_convert() const;

public:
  static const char *const _xsd_right_left_middle_literals_[3];
  static const value _xsd_right_left_middle_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %start-stop-discontinue
 * schema type.
 *
 * The start-stop-discontinue type is used to specify ending types.
 * Typically, the start type is associated with the left barline of the
 * first measure in an ending. The stop and discontinue types are
 * associated with the right barline of the last measure in an ending.
 * Stop is used when the ending mark concludes with a downward jog, as is
 * typical for first endings. Discontinue is used when there is no
 * downward jog, as is typical for second endings that do not conclude a
 * piece.
 */
class start_stop_discontinue : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { start, stop, discontinue };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  start_stop_discontinue(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  start_stop_discontinue(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  start_stop_discontinue(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  start_stop_discontinue(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_discontinue(const ::xercesc::DOMElement &e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_discontinue(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_discontinue(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  start_stop_discontinue(const start_stop_discontinue &x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual start_stop_discontinue *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  start_stop_discontinue &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const {
    return _xsd_start_stop_discontinue_convert();
  }

  //@cond

protected:
  value _xsd_start_stop_discontinue_convert() const;

public:
  static const char *const _xsd_start_stop_discontinue_literals_[3];
  static const value _xsd_start_stop_discontinue_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %winged
 * schema type.
 *
 * The winged attribute indicates whether the repeat has winged
 * extensions that appear above and below the barline. The straight and
 * curved values represent single wings, while the double-straight and
 * double-curved values represent double wings. The none value indicates
 * no wings and is the default.
 */
class winged : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { none, straight, curved, double_straight, double_curved };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  winged(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  winged(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  winged(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  winged(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  winged(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  winged(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  winged(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  winged(const winged &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual winged *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  winged &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_winged_convert(); }

  //@cond

protected:
  value _xsd_winged_convert() const;

public:
  static const char *const _xsd_winged_literals_[5];
  static const value _xsd_winged_indexes_[5];

  //@endcond
};

/**
 * @brief Class corresponding to the %accordion-middle schema type.
 *
 * The accordion-middle type may have values of 1, 2, or 3, corresponding
 * to having 1 to 3 dots in the middle section of the accordion
 * registration symbol.
 *
 * @nosubgrouping
 */
class accordion_middle
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  accordion_middle(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accordion_middle(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accordion_middle(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accordion_middle(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accordion_middle(const accordion_middle &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual accordion_middle *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~accordion_middle();
};

/**
 * @brief Enumeration class corresponding to the %beater-value
 * schema type.
 *
 * The beater-value type represents pictograms for beaters, mallets, and
 * sticks that do not have different materials represented in the
 * pictogram. The finger and hammer values are in addition to Stone's
 * list.
 */
class beater_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    bow,
    chime_hammer,
    coin,
    finger,
    fingernail,
    fist,
    guiro_scraper,
    hammer,
    hand,
    jazz_stick,
    knitting_needle,
    metal_hammer,
    snare_stick,
    spoon_mallet,
    triangle_beater,
    triangle_beater_plain,
    wire_brush
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  beater_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  beater_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  beater_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  beater_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beater_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beater_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beater_value(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beater_value(const beater_value &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual beater_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  beater_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_beater_value_convert(); }

  //@cond

protected:
  value _xsd_beater_value_convert() const;

public:
  static const char *const _xsd_beater_value_literals_[17];
  static const value _xsd_beater_value_indexes_[17];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %degree-symbol-value
 * schema type.
 *
 * The degree-symbol-value type indicates indicates that a symbol should
 * be used in specifying the degree.
 */
class degree_symbol_value : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { major, minor, augmented, diminished, half_diminished };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  degree_symbol_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  degree_symbol_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  degree_symbol_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  degree_symbol_value(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_symbol_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_symbol_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_symbol_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree_symbol_value(const degree_symbol_value &x, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual degree_symbol_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  degree_symbol_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_degree_symbol_value_convert(); }

  //@cond

protected:
  value _xsd_degree_symbol_value_convert() const;

public:
  static const char *const _xsd_degree_symbol_value_literals_[5];
  static const value _xsd_degree_symbol_value_indexes_[5];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %degree-type-value
 * schema type.
 *
 * The degree-type-value type indicates whether the current degree
 * element is an addition, alteration, or subtraction to the kind of the
 * current chord in the harmony element.
 */
class degree_type_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { add, alter, subtract };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  degree_type_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  degree_type_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  degree_type_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  degree_type_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_type_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_type_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_type_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree_type_value(const degree_type_value &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual degree_type_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  degree_type_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_degree_type_value_convert(); }

  //@cond

protected:
  value _xsd_degree_type_value_convert() const;

public:
  static const char *const _xsd_degree_type_value_literals_[3];
  static const value _xsd_degree_type_value_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %effect
 * schema type.
 *
 * The effect type represents pictograms for sound effect percussion
 * instruments. The cannon value is in addition to Stone's list.
 */
class effect : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    anvil,
    auto_horn,
    bird_whistle,
    cannon,
    duck_call,
    gun_shot,
    klaxon_horn,
    lions_roar,
    police_whistle,
    siren,
    slide_whistle,
    thunder_sheet,
    wind_machine,
    wind_whistle
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  effect(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  effect(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  effect(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  effect(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  effect(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  effect(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  effect(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  effect(const effect &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual effect *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  effect &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_effect_convert(); }

  //@cond

protected:
  value _xsd_effect_convert() const;

public:
  static const char *const _xsd_effect_literals_[14];
  static const value _xsd_effect_indexes_[14];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %glass
 * schema type.
 *
 * The glass type represents pictograms for glass percussion instruments.
 */
class glass : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { wind_chimes };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  glass(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  glass(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  glass(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  glass(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  glass(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  glass(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  glass(const ::std::string &s, const ::xercesc::DOMElement *e,
        ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  glass(const glass &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual glass *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  glass &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_glass_convert(); }

  //@cond

protected:
  value _xsd_glass_convert() const;

public:
  static const char *const _xsd_glass_literals_[1];
  static const value _xsd_glass_indexes_[1];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %harmony-type
 * schema type.
 *
 * The harmony-type type differentiates different types of harmonies when
 * alternate harmonies are possible. Explicit harmonies have all note
 * present in the music; implied have some notes missing but implied;
 * alternate represents alternate analyses.
 */
class harmony_type : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { explicit_, implied, alternate };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  harmony_type(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  harmony_type(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  harmony_type(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  harmony_type(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  harmony_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  harmony_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  harmony_type(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  harmony_type(const harmony_type &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual harmony_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  harmony_type &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_harmony_type_convert(); }

  //@cond

protected:
  value _xsd_harmony_type_convert() const;

public:
  static const char *const _xsd_harmony_type_literals_[3];
  static const value _xsd_harmony_type_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %kind-value
 * schema type.
 *
 * A kind-value indicates the type of chord. Degree elements can then
 * add, subtract, or alter from these starting points. Values include:
 *
 * Triads:
 * major (major third, perfect fifth)
 * minor (minor third, perfect fifth)
 * augmented (major third, augmented fifth)
 * diminished (minor third, diminished fifth)
 * Sevenths:
 * dominant (major triad, minor seventh)
 * major-seventh (major triad, major seventh)
 * minor-seventh (minor triad, minor seventh)
 * diminished-seventh (diminished triad, diminished seventh)
 * augmented-seventh (augmented triad, minor seventh)
 * half-diminished (diminished triad, minor seventh)
 * major-minor (minor triad, major seventh)
 * Sixths:
 * major-sixth (major triad, added sixth)
 * minor-sixth (minor triad, added sixth)
 * Ninths:
 * dominant-ninth (dominant-seventh, major ninth)
 * major-ninth (major-seventh, major ninth)
 * minor-ninth (minor-seventh, major ninth)
 * 11ths (usually as the basis for alteration):
 * dominant-11th (dominant-ninth, perfect 11th)
 * major-11th (major-ninth, perfect 11th)
 * minor-11th (minor-ninth, perfect 11th)
 * 13ths (usually as the basis for alteration):
 * dominant-13th (dominant-11th, major 13th)
 * major-13th (major-11th, major 13th)
 * minor-13th (minor-11th, major 13th)
 * Suspended:
 * suspended-second (major second, perfect fifth)
 * suspended-fourth (perfect fourth, perfect fifth)
 * Functional sixths:
 * Neapolitan
 * Italian
 * French
 * German
 * Other:
 * pedal (pedal-point bass)
 * power (perfect fifth)
 * Tristan
 *
 * The "other" kind is used when the harmony is entirely composed of add
 * elements. The "none" kind is used to explicitly encode absence of
 * chords or functional harmony.
 */
class kind_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    major,
    minor,
    augmented,
    diminished,
    dominant,
    major_seventh,
    minor_seventh,
    diminished_seventh,
    augmented_seventh,
    half_diminished,
    major_minor,
    major_sixth,
    minor_sixth,
    dominant_ninth,
    major_ninth,
    minor_ninth,
    dominant_11th,
    major_11th,
    minor_11th,
    dominant_13th,
    major_13th,
    minor_13th,
    suspended_second,
    suspended_fourth,
    Neapolitan,
    Italian,
    French,
    German,
    pedal,
    power,
    Tristan,
    other,
    none
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  kind_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  kind_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  kind_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  kind_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  kind_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  kind_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  kind_value(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  kind_value(const kind_value &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual kind_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  kind_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_kind_value_convert(); }

  //@cond

protected:
  value _xsd_kind_value_convert() const;

public:
  static const char *const _xsd_kind_value_literals_[33];
  static const value _xsd_kind_value_indexes_[33];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %line-end
 * schema type.
 *
 * The line-end type specifies if there is a jog up or down (or both), an
 * arrow, or nothing at the start or end of a bracket.
 */
class line_end : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { up, down, both, arrow, none };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  line_end(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  line_end(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  line_end(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  line_end(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_end(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_end(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_end(const ::std::string &s, const ::xercesc::DOMElement *e,
           ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  line_end(const line_end &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual line_end *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  line_end &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_line_end_convert(); }

  //@cond

protected:
  value _xsd_line_end_convert() const;

public:
  static const char *const _xsd_line_end_literals_[5];
  static const value _xsd_line_end_indexes_[5];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %measure-numbering-value
 * schema type.
 *
 * The measure-numbering-value type describes how measure numbers are
 * displayed on this part: no numbers, numbers every measure, or numbers
 * every system.
 */
class measure_numbering_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { none, measure, system };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  measure_numbering_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  measure_numbering_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  measure_numbering_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  measure_numbering_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure_numbering_value(const ::xercesc::DOMElement &e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure_numbering_value(const ::xercesc::DOMAttr &a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure_numbering_value(const ::std::string &s,
                          const ::xercesc::DOMElement *e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_numbering_value(const measure_numbering_value &x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual measure_numbering_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  measure_numbering_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const {
    return _xsd_measure_numbering_value_convert();
  }

  //@cond

protected:
  value _xsd_measure_numbering_value_convert() const;

public:
  static const char *const _xsd_measure_numbering_value_literals_[3];
  static const value _xsd_measure_numbering_value_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %membrane
 * schema type.
 *
 * The membrane type represents pictograms for membrane percussion
 * instruments. The goblet drum value is in addition to Stone's list.
 */
class membrane : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    bass_drum,
    bass_drum_on_side,
    bongos,
    conga_drum,
    goblet_drum,
    military_drum,
    snare_drum,
    snare_drum_snares_off,
    tambourine,
    tenor_drum,
    timbales,
    tomtom
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  membrane(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  membrane(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  membrane(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  membrane(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  membrane(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  membrane(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  membrane(const ::std::string &s, const ::xercesc::DOMElement *e,
           ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  membrane(const membrane &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual membrane *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  membrane &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_membrane_convert(); }

  //@cond

protected:
  value _xsd_membrane_convert() const;

public:
  static const char *const _xsd_membrane_literals_[12];
  static const value _xsd_membrane_indexes_[12];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %metal
 * schema type.
 *
 * The metal type represents pictograms for metal percussion instruments.
 * The hi-hat value refers to a pictogram like Stone's high-hat cymbals
 * but without the long vertical line at the bottom.
 */
class metal : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    almglocken,
    bell,
    bell_plate,
    brake_drum,
    Chinese_cymbal,
    cowbell,
    crash_cymbals,
    crotale,
    cymbal_tongs,
    domed_gong,
    finger_cymbals,
    flexatone,
    gong,
    hi_hat,
    high_hat_cymbals,
    handbell,
    sistrum,
    sizzle_cymbal,
    sleigh_bells,
    suspended_cymbal,
    tam_tam,
    triangle,
    Vietnamese_hat
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  metal(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  metal(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  metal(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  metal(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  metal(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  metal(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  metal(const ::std::string &s, const ::xercesc::DOMElement *e,
        ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metal(const metal &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual metal *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  metal &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_metal_convert(); }

  //@cond

protected:
  value _xsd_metal_convert() const;

public:
  static const char *const _xsd_metal_literals_[23];
  static const value _xsd_metal_indexes_[23];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %on-off
 * schema type.
 *
 * The on-off type is used for notation elements such as string mutes.
 */
class on_off : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { on, off };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  on_off(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  on_off(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  on_off(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  on_off(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  on_off(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  on_off(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  on_off(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  on_off(const on_off &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual on_off *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  on_off &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_on_off_convert(); }

  //@cond

protected:
  value _xsd_on_off_convert() const;

public:
  static const char *const _xsd_on_off_literals_[2];
  static const value _xsd_on_off_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %pitched
 * schema type.
 *
 * The pitched type represents pictograms for pitched percussion
 * instruments. The chimes and tubular chimes values distinguish the
 * single-line and double-line versions of the pictogram. The mallet
 * value is in addition to Stone's list.
 */
class pitched : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    chimes,
    glockenspiel,
    mallet,
    marimba,
    tubular_chimes,
    vibraphone,
    xylophone
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  pitched(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  pitched(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  pitched(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  pitched(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  pitched(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  pitched(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  pitched(const ::std::string &s, const ::xercesc::DOMElement *e,
          ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  pitched(const pitched &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual pitched *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  pitched &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_pitched_convert(); }

  //@cond

protected:
  value _xsd_pitched_convert() const;

public:
  static const char *const _xsd_pitched_literals_[7];
  static const value _xsd_pitched_indexes_[7];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %principal-voice-symbol
 * schema type.
 *
 * The principal-voice-symbol type represents the type of symbol used to
 * indicate the start of a principal or secondary voice. The "plain"
 * value represents a plain square bracket. The value of "none" is used
 * for analysis markup when the principal-voice element does not have a
 * corresponding appearance in the score.
 */
class principal_voice_symbol : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { Hauptstimme, Nebenstimme, plain, none };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  principal_voice_symbol(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  principal_voice_symbol(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  principal_voice_symbol(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  principal_voice_symbol(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  principal_voice_symbol(const ::xercesc::DOMElement &e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  principal_voice_symbol(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  principal_voice_symbol(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  principal_voice_symbol(const principal_voice_symbol &x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual principal_voice_symbol *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  principal_voice_symbol &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const {
    return _xsd_principal_voice_symbol_convert();
  }

  //@cond

protected:
  value _xsd_principal_voice_symbol_convert() const;

public:
  static const char *const _xsd_principal_voice_symbol_literals_[4];
  static const value _xsd_principal_voice_symbol_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %start-stop-change-continue
 * schema type.
 *
 * The start-stop-change-continue type is used to distinguish types of
 * pedal directions.
 */
class start_stop_change_continue : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { start, stop, change, continue_ };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  start_stop_change_continue(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  start_stop_change_continue(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  start_stop_change_continue(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  start_stop_change_continue(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_change_continue(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_change_continue(const ::xercesc::DOMAttr &a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  start_stop_change_continue(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  start_stop_change_continue(const start_stop_change_continue &x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual start_stop_change_continue *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  start_stop_change_continue &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const {
    return _xsd_start_stop_change_continue_convert();
  }

  //@cond

protected:
  value _xsd_start_stop_change_continue_convert() const;

public:
  static const char *const _xsd_start_stop_change_continue_literals_[4];
  static const value _xsd_start_stop_change_continue_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %tip-direction
 * schema type.
 *
 * The tip-direction type represents the direction in which the tip of a
 * stick or beater points, using Unicode arrow terminology.
 */
class tip_direction : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    up,
    down,
    left,
    right,
    northwest,
    northeast,
    southeast,
    southwest
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  tip_direction(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  tip_direction(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  tip_direction(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  tip_direction(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tip_direction(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tip_direction(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tip_direction(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tip_direction(const tip_direction &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tip_direction *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  tip_direction &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_tip_direction_convert(); }

  //@cond

protected:
  value _xsd_tip_direction_convert() const;

public:
  static const char *const _xsd_tip_direction_literals_[8];
  static const value _xsd_tip_direction_indexes_[8];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %stick-location
 * schema type.
 *
 * The stick-location type represents pictograms for the location of
 * sticks, beaters, or mallets on cymbals, gongs, drums, and other
 * instruments.
 */
class stick_location : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { center, rim, cymbal_bell, cymbal_edge };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  stick_location(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  stick_location(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  stick_location(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  stick_location(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_location(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_location(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_location(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  stick_location(const stick_location &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual stick_location *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  stick_location &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_stick_location_convert(); }

  //@cond

protected:
  value _xsd_stick_location_convert() const;

public:
  static const char *const _xsd_stick_location_literals_[4];
  static const value _xsd_stick_location_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %stick-material
 * schema type.
 *
 * The stick-material type represents the material being displayed in a
 * stick pictogram.
 */
class stick_material : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { soft, medium, hard, shaded, x };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  stick_material(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  stick_material(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  stick_material(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  stick_material(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_material(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_material(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_material(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  stick_material(const stick_material &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual stick_material *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  stick_material &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_stick_material_convert(); }

  //@cond

protected:
  value _xsd_stick_material_convert() const;

public:
  static const char *const _xsd_stick_material_literals_[5];
  static const value _xsd_stick_material_indexes_[5];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %stick-type
 * schema type.
 *
 * The stick-type type represents the shape of pictograms where the
 * material
 * in the stick, mallet, or beater is represented in the pictogram.
 */
class stick_type : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { bass_drum, double_bass_drum, timpani, xylophone, yarn };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  stick_type(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  stick_type(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  stick_type(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  stick_type(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick_type(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  stick_type(const stick_type &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual stick_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  stick_type &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_stick_type_convert(); }

  //@cond

protected:
  value _xsd_stick_type_convert() const;

public:
  static const char *const _xsd_stick_type_literals_[5];
  static const value _xsd_stick_type_indexes_[5];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %up-down-stop-continue
 * schema type.
 *
 * The up-down-stop-continue type is used for octave-shift elements,
 * indicating the direction of the shift from their true pitched values
 * because of printing difficulty.
 */
class up_down_stop_continue : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { up, down, stop, continue_ };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  up_down_stop_continue(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  up_down_stop_continue(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  up_down_stop_continue(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  up_down_stop_continue(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  up_down_stop_continue(const ::xercesc::DOMElement &e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  up_down_stop_continue(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  up_down_stop_continue(const ::std::string &s, const ::xercesc::DOMElement *e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  up_down_stop_continue(const up_down_stop_continue &x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual up_down_stop_continue *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  up_down_stop_continue &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const {
    return _xsd_up_down_stop_continue_convert();
  }

  //@cond

protected:
  value _xsd_up_down_stop_continue_convert() const;

public:
  static const char *const _xsd_up_down_stop_continue_literals_[4];
  static const value _xsd_up_down_stop_continue_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %wedge-type
 * schema type.
 *
 * The wedge type is crescendo for the start of a wedge that is closed at
 * the left side, diminuendo for the start of a wedge that is closed on
 * the right side, and stop for the end of a wedge. The continue type is
 * used for formatting wedges over a system break, or for other
 * situations where a single wedge is divided into multiple segments.
 */
class wedge_type : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { crescendo, diminuendo, stop, continue_ };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  wedge_type(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  wedge_type(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  wedge_type(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  wedge_type(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  wedge_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  wedge_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  wedge_type(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  wedge_type(const wedge_type &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual wedge_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  wedge_type &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_wedge_type_convert(); }

  //@cond

protected:
  value _xsd_wedge_type_convert() const;

public:
  static const char *const _xsd_wedge_type_literals_[4];
  static const value _xsd_wedge_type_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %wood
 * schema type.
 *
 * The wood type represents pictograms for wood percussion instruments.
 * The maraca and maracas values distinguish the one- and two-maraca
 * versions of the pictogram. The vibraslap and castanets values are in
 * addition to Stone's list.
 */
class wood : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    board_clapper,
    cabasa,
    castanets,
    claves,
    guiro,
    log_drum,
    maraca,
    maracas,
    ratchet,
    sandpaper_blocks,
    slit_drum,
    temple_block,
    vibraslap,
    wood_block
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  wood(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  wood(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  wood(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  wood(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  wood(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  wood(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  wood(const ::std::string &s, const ::xercesc::DOMElement *e,
       ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  wood(const wood &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual wood *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  wood &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_wood_convert(); }

  //@cond

protected:
  value _xsd_wood_convert() const;

public:
  static const char *const _xsd_wood_literals_[14];
  static const value _xsd_wood_indexes_[14];

  //@endcond
};

/**
 * @brief Class corresponding to the %distance-type schema type.
 *
 * The distance-type defines what type of distance is being defined in a
 * distance element. Values include beam and hyphen. This is left as a
 * string so that other application-specific types can be defined, but it
 * is made a separate type so that it can be redefined more strictly.
 *
 * @nosubgrouping
 */
class distance_type : public ::xml_schema::token {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  distance_type();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  distance_type(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  distance_type(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  distance_type(const ::xml_schema::token &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  distance_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  distance_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  distance_type(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  distance_type(const distance_type &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual distance_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~distance_type();
};

/**
 * @brief Class corresponding to the %line-width-type schema type.
 *
 * The line-width-type defines what type of line is being defined in a
 * line-width element. Values include beam, bracket, dashes, enclosure,
 * ending, extend, heavy barline, leger, light barline, octave shift,
 * pedal, slur middle, slur tip, staff, stem, tie middle, tie tip, tuplet
 * bracket, and wedge. This is left as a string so that other
 * application-specific types can be defined, but it is made a separate
 * type so that it can be redefined more strictly.
 *
 * @nosubgrouping
 */
class line_width_type : public ::xml_schema::token {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  line_width_type();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  line_width_type(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  line_width_type(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  line_width_type(const ::xml_schema::token &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_width_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_width_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_width_type(const ::std::string &s, const ::xercesc::DOMElement *e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  line_width_type(const line_width_type &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual line_width_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~line_width_type();
};

/**
 * @brief Enumeration class corresponding to the %margin-type
 * schema type.
 *
 * The margin-type type specifies whether margins apply to even page, odd
 * pages, or both.
 */
class margin_type : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { odd, even, both };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  margin_type(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  margin_type(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  margin_type(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  margin_type(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  margin_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  margin_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  margin_type(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  margin_type(const margin_type &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual margin_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  margin_type &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_margin_type_convert(); }

  //@cond

protected:
  value _xsd_margin_type_convert() const;

public:
  static const char *const _xsd_margin_type_literals_[3];
  static const value _xsd_margin_type_indexes_[3];

  //@endcond
};

/**
 * @brief Class corresponding to the %millimeters schema type.
 *
 * The millimeters type is a number representing millimeters. This is
 * used in the scaling element to provide a default scaling from tenths
 * to physical units.
 *
 * @nosubgrouping
 */
class millimeters : public ::xsd::cxx::tree::fundamental_base<
                      ::xml_schema::decimal, char, ::xml_schema::simple_type,
                      ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  millimeters(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  millimeters(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  millimeters(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  millimeters(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  millimeters(const millimeters &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual millimeters *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~millimeters();
};

/**
 * @brief Enumeration class corresponding to the %note-size-type
 * schema type.
 *
 * The note-size-type type indicates the type of note being defined by a
 * note-size element. The grace type is used for notes of cue size that
 * that include a grace element. The cue type is used for all other notes
 * with cue size, whether defined explicitly or implicitly via a cue
 * element. The large type is used for notes of large size.
 */
class note_size_type : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { cue, grace, large };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  note_size_type(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  note_size_type(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  note_size_type(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  note_size_type(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note_size_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note_size_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note_size_type(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  note_size_type(const note_size_type &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual note_size_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  note_size_type &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_note_size_type_convert(); }

  //@cond

protected:
  value _xsd_note_size_type_convert() const;

public:
  static const char *const _xsd_note_size_type_literals_[3];
  static const value _xsd_note_size_type_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %accidental-value
 * schema type.
 *
 * The accidental-value type represents notated accidentals supported by
 * MusicXML. In the MusicXML 2.0 DTD this was a string with values that
 * could be included. The XSD strengthens the data typing to an
 * enumerated list. The quarter- and three-quarters- accidentals are
 * Tartini-style quarter-tone accidentals. The -down and -up accidentals
 * are quarter-tone accidentals that include arrows pointing down or up.
 * The slash- accidentals are used in Turkish classical music. The
 * numbered sharp and flat accidentals are superscripted versions of the
 * accidental signs, used in Turkish folk music. The sori and koron
 * accidentals are microtonal sharp and flat accidentals used in Iranian
 * and Persian music.
 */
class accidental_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    sharp,
    natural,
    flat,
    double_sharp,
    sharp_sharp,
    flat_flat,
    natural_sharp,
    natural_flat,
    quarter_flat,
    quarter_sharp,
    three_quarters_flat,
    three_quarters_sharp,
    sharp_down,
    sharp_up,
    natural_down,
    natural_up,
    flat_down,
    flat_up,
    triple_sharp,
    triple_flat,
    slash_quarter_sharp,
    slash_sharp,
    slash_flat,
    double_slash_flat,
    sharp_1,
    sharp_2,
    sharp_3,
    sharp_5,
    flat_1,
    flat_2,
    flat_3,
    flat_4,
    sori,
    koron
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  accidental_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  accidental_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  accidental_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  accidental_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accidental_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accidental_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accidental_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accidental_value(const accidental_value &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual accidental_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  accidental_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_accidental_value_convert(); }

  //@cond

protected:
  value _xsd_accidental_value_convert() const;

public:
  static const char *const _xsd_accidental_value_literals_[34];
  static const value _xsd_accidental_value_indexes_[34];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %arrow-direction
 * schema type.
 *
 * The arrow-direction type represents the direction in which an arrow
 * points, using Unicode arrow terminology.
 */
class arrow_direction : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    left,
    up,
    right,
    down,
    northwest,
    northeast,
    southeast,
    southwest,
    left_right,
    up_down,
    northwest_southeast,
    northeast_southwest,
    other
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  arrow_direction(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  arrow_direction(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  arrow_direction(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  arrow_direction(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  arrow_direction(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  arrow_direction(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  arrow_direction(const ::std::string &s, const ::xercesc::DOMElement *e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  arrow_direction(const arrow_direction &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual arrow_direction *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  arrow_direction &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_arrow_direction_convert(); }

  //@cond

protected:
  value _xsd_arrow_direction_convert() const;

public:
  static const char *const _xsd_arrow_direction_literals_[13];
  static const value _xsd_arrow_direction_indexes_[13];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %arrow-style
 * schema type.
 *
 * The arrow-style type represents the style of an arrow, using Unicode
 * arrow terminology. Filled and hollow arrows indicate polygonal single
 * arrows. Paired arrows are duplicate single arrows in the same
 * direction. Combined arrows apply to double direction arrows like left
 * right, indicating that an arrow in one direction should be combined
 * with an arrow in the other direction.
 */
class arrow_style : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { single, double_, filled, hollow, paired, combined, other };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  arrow_style(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  arrow_style(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  arrow_style(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  arrow_style(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  arrow_style(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  arrow_style(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  arrow_style(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  arrow_style(const arrow_style &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual arrow_style *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  arrow_style &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_arrow_style_convert(); }

  //@cond

protected:
  value _xsd_arrow_style_convert() const;

public:
  static const char *const _xsd_arrow_style_literals_[7];
  static const value _xsd_arrow_style_indexes_[7];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %beam-value
 * schema type.
 *
 * The beam-value type represents the type of beam associated with each
 * of 8 beam levels (up to 1024th notes) available for each note.
 */
class beam_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { begin, continue_, end, forward_hook, backward_hook };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  beam_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  beam_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  beam_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  beam_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beam_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beam_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beam_value(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beam_value(const beam_value &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual beam_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  beam_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_beam_value_convert(); }

  //@cond

protected:
  value _xsd_beam_value_convert() const;

public:
  static const char *const _xsd_beam_value_literals_[5];
  static const value _xsd_beam_value_indexes_[5];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %breath-mark-value
 * schema type.
 *
 * The breath-mark-value type represents the symbol used for a breath
 * mark.
 */
class breath_mark_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { empty, comma, tick };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  breath_mark_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  breath_mark_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  breath_mark_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  breath_mark_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  breath_mark_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  breath_mark_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  breath_mark_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  breath_mark_value(const breath_mark_value &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual breath_mark_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  breath_mark_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_breath_mark_value_convert(); }

  //@cond

protected:
  value _xsd_breath_mark_value_convert() const;

public:
  static const char *const _xsd_breath_mark_value_literals_[3];
  static const value _xsd_breath_mark_value_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %circular-arrow
 * schema type.
 *
 * The circular-arrow type represents the direction in which a circular
 * arrow points, using Unicode arrow terminology.
 */
class circular_arrow : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { clockwise, anticlockwise };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  circular_arrow(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  circular_arrow(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  circular_arrow(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  circular_arrow(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  circular_arrow(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  circular_arrow(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  circular_arrow(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  circular_arrow(const circular_arrow &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual circular_arrow *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  circular_arrow &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_circular_arrow_convert(); }

  //@cond

protected:
  value _xsd_circular_arrow_convert() const;

public:
  static const char *const _xsd_circular_arrow_literals_[2];
  static const value _xsd_circular_arrow_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %fan
 * schema type.
 *
 * The fan type represents the type of beam fanning present on a note,
 * used to represent accelerandos and ritardandos.
 */
class fan : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { accel, rit, none };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  fan(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  fan(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  fan(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  fan(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fan(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
      ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fan(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
      ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fan(const ::std::string &s, const ::xercesc::DOMElement *e,
      ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fan(const fan &x, ::xml_schema::flags f = 0,
      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual fan *_clone(::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  fan &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_fan_convert(); }

  //@cond

protected:
  value _xsd_fan_convert() const;

public:
  static const char *const _xsd_fan_literals_[3];
  static const value _xsd_fan_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %handbell-value
 * schema type.
 *
 * The handbell-value type represents the type of handbell technique
 * being notated.
 */
class handbell_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    damp,
    echo,
    gyro,
    hand_martellato,
    mallet_lift,
    mallet_table,
    martellato,
    martellato_lift,
    muted_martellato,
    pluck_lift,
    swing
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  handbell_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  handbell_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  handbell_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  handbell_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  handbell_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  handbell_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  handbell_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  handbell_value(const handbell_value &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual handbell_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  handbell_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_handbell_value_convert(); }

  //@cond

protected:
  value _xsd_handbell_value_convert() const;

public:
  static const char *const _xsd_handbell_value_literals_[11];
  static const value _xsd_handbell_value_indexes_[11];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %hole-closed-location
 * schema type.
 *
 * The hole-closed-location type indicates which portion of the hole is
 * filled in when the corresponding hole-closed-value is half.
 */
class hole_closed_location : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { right, bottom, left, top };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  hole_closed_location(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  hole_closed_location(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  hole_closed_location(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  hole_closed_location(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hole_closed_location(const ::xercesc::DOMElement &e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hole_closed_location(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hole_closed_location(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hole_closed_location(const hole_closed_location &x, ::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual hole_closed_location *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  hole_closed_location &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_hole_closed_location_convert(); }

  //@cond

protected:
  value _xsd_hole_closed_location_convert() const;

public:
  static const char *const _xsd_hole_closed_location_literals_[4];
  static const value _xsd_hole_closed_location_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %hole-closed-value
 * schema type.
 *
 * The hole-closed-value type represents whether the hole is closed,
 * open, or half-open.
 */
class hole_closed_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { yes, no, half };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  hole_closed_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  hole_closed_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  hole_closed_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  hole_closed_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hole_closed_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hole_closed_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hole_closed_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hole_closed_value(const hole_closed_value &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual hole_closed_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  hole_closed_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_hole_closed_value_convert(); }

  //@cond

protected:
  value _xsd_hole_closed_value_convert() const;

public:
  static const char *const _xsd_hole_closed_value_literals_[3];
  static const value _xsd_hole_closed_value_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %note-type-value
 * schema type.
 *
 * The note-type type is used for the MusicXML type element and
 * represents the graphic note type, from 1024th (shortest) to maxima
 * (longest).
 */
class note_type_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    cxx_1024th,
    cxx_512th,
    cxx_256th,
    cxx_128th,
    cxx_64th,
    cxx_32nd,
    cxx_16th,
    eighth,
    quarter,
    half,
    whole,
    breve,
    long_,
    maxima
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  note_type_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  note_type_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  note_type_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  note_type_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note_type_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note_type_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note_type_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  note_type_value(const note_type_value &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual note_type_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  note_type_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_note_type_value_convert(); }

  //@cond

protected:
  value _xsd_note_type_value_convert() const;

public:
  static const char *const _xsd_note_type_value_literals_[14];
  static const value _xsd_note_type_value_indexes_[14];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %notehead-value
 * schema type.
 *
 * The notehead type indicates shapes other than the open and closed
 * ovals associated with note durations. The values do, re, mi, fa, fa
 * up, so, la, and ti correspond to Aikin's 7-shape system.  The fa up
 * shape is typically used with upstems; the fa shape is typically used
 * with downstems or no stems.
 *
 * The arrow shapes differ from triangle and inverted triangle by being
 * centered on the stem. Slashed and back slashed notes include both the
 * normal notehead and a slash. The triangle shape has the tip of the
 * triangle pointing up; the inverted triangle shape has the tip of the
 * triangle pointing down. The left triangle shape is a right triangle
 * with the hypotenuse facing up and to the left.
 */
class notehead_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value {
    slash,
    triangle,
    diamond,
    square,
    cross,
    x,
    circle_x,
    inverted_triangle,
    arrow_down,
    arrow_up,
    slashed,
    back_slashed,
    normal,
    cluster,
    circle_dot,
    left_triangle,
    rectangle,
    none,
    do_,
    re,
    mi,
    fa,
    fa_up,
    so,
    la,
    ti
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  notehead_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  notehead_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  notehead_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  notehead_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  notehead_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  notehead_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  notehead_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  notehead_value(const notehead_value &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual notehead_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  notehead_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_notehead_value_convert(); }

  //@cond

protected:
  value _xsd_notehead_value_convert() const;

public:
  static const char *const _xsd_notehead_value_literals_[26];
  static const value _xsd_notehead_value_indexes_[26];

  //@endcond
};

/**
 * @brief Class corresponding to the %octave schema type.
 *
 * Octaves are represented by the numbers 0 to 9, where 4 indicates the
 * octave started by middle C.
 *
 * @nosubgrouping
 */
class octave : public ::xsd::cxx::tree::fundamental_base<
                 ::xml_schema::integer, char, ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  octave(const ::xml_schema::integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  octave(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  octave(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  octave(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  octave(const octave &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual octave *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~octave();
};

/**
 * @brief Class corresponding to the %semitones schema type.
 *
 * The semitones type is a number representing semitones, used for
 * chromatic alteration. A value of -1 corresponds to a flat and a value
 * of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used
 * for microtones.
 *
 * @nosubgrouping
 */
class semitones : public ::xsd::cxx::tree::fundamental_base<
                    ::xml_schema::decimal, char, ::xml_schema::simple_type,
                    ::xsd::cxx::tree::schema_type::decimal> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  semitones(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  semitones(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  semitones(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  semitones(const ::std::string &s, const ::xercesc::DOMElement *e,
            ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  semitones(const semitones &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual semitones *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~semitones();
};

/**
 * @brief Enumeration class corresponding to the %show-tuplet
 * schema type.
 *
 * The show-tuplet type indicates whether to show a part of a tuplet
 * relating to the tuplet-actual element, both the tuplet-actual and
 * tuplet-normal elements, or neither.
 */
class show_tuplet : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { actual, both, none };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  show_tuplet(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  show_tuplet(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  show_tuplet(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  show_tuplet(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  show_tuplet(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  show_tuplet(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  show_tuplet(const ::std::string &s, const ::xercesc::DOMElement *e,
              ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  show_tuplet(const show_tuplet &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual show_tuplet *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  show_tuplet &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_show_tuplet_convert(); }

  //@cond

protected:
  value _xsd_show_tuplet_convert() const;

public:
  static const char *const _xsd_show_tuplet_literals_[3];
  static const value _xsd_show_tuplet_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %stem-value
 * schema type.
 *
 * The stem type represents the notated stem direction.
 */
class stem_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { down, up, double_, none };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  stem_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  stem_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  stem_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  stem_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stem_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stem_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stem_value(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  stem_value(const stem_value &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual stem_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  stem_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_stem_value_convert(); }

  //@cond

protected:
  value _xsd_stem_value_convert() const;

public:
  static const char *const _xsd_stem_value_literals_[4];
  static const value _xsd_stem_value_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %step
 * schema type.
 *
 * The step type represents a step of the diatonic scale, represented
 * using the English letters A through G.
 */
class step : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { A, B, C, D, E, F, G };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  step(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  step(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  step(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  step(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  step(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  step(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  step(const ::std::string &s, const ::xercesc::DOMElement *e,
       ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  step(const step &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual step *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  step &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_step_convert(); }

  //@cond

protected:
  value _xsd_step_convert() const;

public:
  static const char *const _xsd_step_literals_[7];
  static const value _xsd_step_indexes_[7];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %syllabic
 * schema type.
 *
 * Lyric hyphenation is indicated by the syllabic type. The single,
 * begin, end, and middle values represent single-syllable words,
 * word-beginning syllables, word-ending syllables, and mid-word
 * syllables, respectively.
 */
class syllabic : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { single, begin, end, middle };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  syllabic(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  syllabic(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  syllabic(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  syllabic(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  syllabic(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  syllabic(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  syllabic(const ::std::string &s, const ::xercesc::DOMElement *e,
           ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  syllabic(const syllabic &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual syllabic *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  syllabic &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_syllabic_convert(); }

  //@cond

protected:
  value _xsd_syllabic_convert() const;

public:
  static const char *const _xsd_syllabic_literals_[4];
  static const value _xsd_syllabic_indexes_[4];

  //@endcond
};

/**
 * @brief Class corresponding to the %tremolo-marks schema type.
 *
 * The number of tremolo marks is represented by a number from 0 to 8:
 * the same as beam-level with 0 added.
 *
 * @nosubgrouping
 */
class tremolo_marks
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                              ::xml_schema::simple_type> {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tremolo_marks(const ::xml_schema::integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tremolo_marks(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tremolo_marks(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tremolo_marks(const ::std::string &s, const ::xercesc::DOMElement *e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tremolo_marks(const tremolo_marks &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tremolo_marks *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tremolo_marks();
};

/**
 * @brief Enumeration class corresponding to the %group-barline-value
 * schema type.
 *
 * The group-barline-value type indicates if the group should have common
 * barlines.
 */
class group_barline_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { yes, no, Mensurstrich };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  group_barline_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  group_barline_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  group_barline_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  group_barline_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_barline_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_barline_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_barline_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  group_barline_value(const group_barline_value &x, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual group_barline_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  group_barline_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_group_barline_value_convert(); }

  //@cond

protected:
  value _xsd_group_barline_value_convert() const;

public:
  static const char *const _xsd_group_barline_value_literals_[3];
  static const value _xsd_group_barline_value_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %group-symbol-value
 * schema type.
 *
 * The group-symbol-value type indicates how the symbol for a group is
 * indicated in the score. The default value is none.
 */
class group_symbol_value : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { none, brace, line, bracket, square };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  group_symbol_value(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  group_symbol_value(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  group_symbol_value(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  group_symbol_value(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_symbol_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_symbol_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_symbol_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  group_symbol_value(const group_symbol_value &x, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual group_symbol_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  group_symbol_value &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_group_symbol_value_convert(); }

  //@cond

protected:
  value _xsd_group_symbol_value_convert() const;

public:
  static const char *const _xsd_group_symbol_value_literals_[5];
  static const value _xsd_group_symbol_value_indexes_[5];

  //@endcond
};

/**
 * @brief Class corresponding to the %accidental-text schema type.
 *
 * The accidental-text type represents an element with an accidental
 * value and text-formatting attributes.
 *
 * @nosubgrouping
 */
class accidental_text : public ::musicxml::accidental_value {
public:
  /**
   * @name justify
   *
   * @brief Accessor and modifier functions for the %justify
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right justify_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<justify_type> justify_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<justify_type, char> justify_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const justify_optional &justify() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  justify_optional &justify();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void justify(const justify_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void justify(const justify_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void justify(::std::unique_ptr<justify_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name underline
   *
   * @brief Accessor and modifier functions for the %underline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines underline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<underline_type> underline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<underline_type, char> underline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const underline_optional &underline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  underline_optional &underline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void underline(const underline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void underline(const underline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void underline(::std::unique_ptr<underline_type> p);

  //@}

  /**
   * @name overline
   *
   * @brief Accessor and modifier functions for the %overline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines overline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<overline_type> overline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<overline_type, char> overline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const overline_optional &overline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  overline_optional &overline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void overline(const overline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void overline(const overline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void overline(::std::unique_ptr<overline_type> p);

  //@}

  /**
   * @name line-through
   *
   * @brief Accessor and modifier functions for the %line-through
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines line_through_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_through_type> line_through_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_through_type, char> line_through_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_through_optional &line_through() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_through_optional &line_through();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_through(const line_through_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_through(const line_through_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_through(::std::unique_ptr<line_through_type> p);

  //@}

  /**
   * @name rotation
   *
   * @brief Accessor and modifier functions for the %rotation
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::rotation_degrees rotation_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<rotation_type> rotation_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<rotation_type, char> rotation_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rotation_optional &rotation() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  rotation_optional &rotation();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void rotation(const rotation_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void rotation(const rotation_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void rotation(::std::unique_ptr<rotation_type> p);

  //@}

  /**
   * @name letter-spacing
   *
   * @brief Accessor and modifier functions for the %letter-spacing
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_or_normal letter_spacing_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<letter_spacing_type>
    letter_spacing_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<letter_spacing_type, char>
    letter_spacing_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const letter_spacing_optional &letter_spacing() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  letter_spacing_optional &letter_spacing();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void letter_spacing(const letter_spacing_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void letter_spacing(const letter_spacing_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void letter_spacing(::std::unique_ptr<letter_spacing_type> p);

  //@}

  /**
   * @name line-height
   *
   * @brief Accessor and modifier functions for the %line-height
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_or_normal line_height_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_height_type> line_height_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_height_type, char> line_height_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_height_optional &line_height() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_height_optional &line_height();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_height(const line_height_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_height(const line_height_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_height(::std::unique_ptr<line_height_type> p);

  //@}

  /**
   * @name lang
   *
   * @brief Accessor and modifier functions for the %lang
   * optional attribute.
   *
   * Attempting to install the relevant ISO 2- and 3-letter
   * codes as the enumerated possible values is probably never
   * going to be a realistic possibility.  See
   * RFC 3066 at http://www.ietf.org/rfc/rfc3066.txt and the IANA registry
   * at http://www.iana.org/assignments/lang-tag-apps.htm for
   * further information.
   *
   * The union allows for the 'un-declaration' of xml:lang with
   * the empty string.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::namespace_::lang lang_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<lang_type> lang_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<lang_type, char> lang_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const lang_optional &lang() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  lang_optional &lang();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void lang(const lang_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void lang(const lang_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void lang(::std::unique_ptr<lang_type> p);

  //@}

  /**
   * @name space
   *
   * @brief Accessor and modifier functions for the %space
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::namespace_::space space_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_type> space_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_type, char> space_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_optional &space() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_optional &space();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space(const space_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space(const space_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space(::std::unique_ptr<space_type> p);

  //@}

  /**
   * @name dir
   *
   * @brief Accessor and modifier functions for the %dir
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::text_direction dir_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dir_type> dir_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dir_type, char> dir_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dir_optional &dir() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dir_optional &dir();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dir(const dir_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dir(const dir_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dir(::std::unique_ptr<dir_type> p);

  //@}

  /**
   * @name enclosure
   *
   * @brief Accessor and modifier functions for the %enclosure
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::enclosure_shape enclosure_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<enclosure_type> enclosure_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<enclosure_type, char> enclosure_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const enclosure_optional &enclosure() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  enclosure_optional &enclosure();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void enclosure(const enclosure_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void enclosure(const enclosure_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void enclosure(::std::unique_ptr<enclosure_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  accidental_text(::musicxml::accidental_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  accidental_text(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  accidental_text(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  accidental_text(const ::musicxml::accidental_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accidental_text(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accidental_text(const accidental_text &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual accidental_text *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accidental_text &operator=(const accidental_text &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~accidental_text();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  justify_optional justify_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;
  underline_optional underline_;
  overline_optional overline_;
  line_through_optional line_through_;
  rotation_optional rotation_;
  letter_spacing_optional letter_spacing_;
  line_height_optional line_height_;
  lang_optional lang_;
  space_optional space_;
  dir_optional dir_;
  enclosure_optional enclosure_;

  //@endcond
};

/**
 * @brief Class corresponding to the %dynamics schema type.
 *
 * Dynamics can be associated either with a note or a general musical
 * direction. To avoid inconsistencies between and amongst the letter
 * abbreviations for dynamics (what is sf vs. sfz, standing alone or with
 * a trailing dynamic that is not always piano), we use the actual
 * letters as the names of these dynamic elements. The other-dynamics
 * element allows other dynamic marks that are not covered here, but many
 * of those should perhaps be included in a more general musical
 * direction element. Dynamics elements may also be combined to create
 * marks not covered by a single element, such as sfmp.
 *
 * These letter dynamic symbols are separated from crescendo,
 * decrescendo, and wedge indications. Dynamic representation is
 * inconsistent in scores. Many things are assumed by the composer and
 * left out, such as returns to original dynamics. Systematic
 * representations are quite complex: for example, Humdrum has at least 3
 * representation formats related to dynamics. The MusicXML format
 * captures what is in the score, but does not try to be optimal for
 * analysis or synthesis of dynamics.
 *
 * @nosubgrouping
 */
class dynamics : public ::xml_schema::type {
public:
  /**
   * @name p
   *
   * @brief Accessor and modifier functions for the %p
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty p_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<p_type> p_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef p_sequence::iterator p_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef p_sequence::const_iterator p_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<p_type, char> p_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const p_sequence &p() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  p_sequence &p();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void p(const p_sequence &s);

  //@}

  /**
   * @name pp
   *
   * @brief Accessor and modifier functions for the %pp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty pp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<pp_type> pp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef pp_sequence::iterator pp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef pp_sequence::const_iterator pp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pp_type, char> pp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const pp_sequence &pp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  pp_sequence &pp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void pp(const pp_sequence &s);

  //@}

  /**
   * @name ppp
   *
   * @brief Accessor and modifier functions for the %ppp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty ppp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<ppp_type> ppp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ppp_sequence::iterator ppp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ppp_sequence::const_iterator ppp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ppp_type, char> ppp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ppp_sequence &ppp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ppp_sequence &ppp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void ppp(const ppp_sequence &s);

  //@}

  /**
   * @name pppp
   *
   * @brief Accessor and modifier functions for the %pppp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty pppp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<pppp_type> pppp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef pppp_sequence::iterator pppp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef pppp_sequence::const_iterator pppp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pppp_type, char> pppp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const pppp_sequence &pppp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  pppp_sequence &pppp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void pppp(const pppp_sequence &s);

  //@}

  /**
   * @name ppppp
   *
   * @brief Accessor and modifier functions for the %ppppp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty ppppp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<ppppp_type> ppppp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ppppp_sequence::iterator ppppp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ppppp_sequence::const_iterator ppppp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ppppp_type, char> ppppp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ppppp_sequence &ppppp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ppppp_sequence &ppppp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void ppppp(const ppppp_sequence &s);

  //@}

  /**
   * @name pppppp
   *
   * @brief Accessor and modifier functions for the %pppppp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty pppppp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<pppppp_type> pppppp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef pppppp_sequence::iterator pppppp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef pppppp_sequence::const_iterator pppppp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pppppp_type, char> pppppp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const pppppp_sequence &pppppp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  pppppp_sequence &pppppp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void pppppp(const pppppp_sequence &s);

  //@}

  /**
   * @name f
   *
   * @brief Accessor and modifier functions for the %f
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty f_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<f_type> f_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef f_sequence::iterator f_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef f_sequence::const_iterator f_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<f_type, char> f_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const f_sequence &f() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  f_sequence &f();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void f(const f_sequence &s);

  //@}

  /**
   * @name ff
   *
   * @brief Accessor and modifier functions for the %ff
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty ff_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<ff_type> ff_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ff_sequence::iterator ff_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ff_sequence::const_iterator ff_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ff_type, char> ff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ff_sequence &ff() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ff_sequence &ff();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void ff(const ff_sequence &s);

  //@}

  /**
   * @name fff
   *
   * @brief Accessor and modifier functions for the %fff
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty fff_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fff_type> fff_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fff_sequence::iterator fff_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fff_sequence::const_iterator fff_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fff_type, char> fff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fff_sequence &fff() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fff_sequence &fff();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fff(const fff_sequence &s);

  //@}

  /**
   * @name ffff
   *
   * @brief Accessor and modifier functions for the %ffff
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty ffff_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<ffff_type> ffff_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ffff_sequence::iterator ffff_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ffff_sequence::const_iterator ffff_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ffff_type, char> ffff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ffff_sequence &ffff() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ffff_sequence &ffff();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void ffff(const ffff_sequence &s);

  //@}

  /**
   * @name fffff
   *
   * @brief Accessor and modifier functions for the %fffff
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty fffff_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fffff_type> fffff_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fffff_sequence::iterator fffff_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fffff_sequence::const_iterator fffff_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fffff_type, char> fffff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fffff_sequence &fffff() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fffff_sequence &fffff();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fffff(const fffff_sequence &s);

  //@}

  /**
   * @name ffffff
   *
   * @brief Accessor and modifier functions for the %ffffff
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty ffffff_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<ffffff_type> ffffff_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ffffff_sequence::iterator ffffff_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ffffff_sequence::const_iterator ffffff_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ffffff_type, char> ffffff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ffffff_sequence &ffffff() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ffffff_sequence &ffffff();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void ffffff(const ffffff_sequence &s);

  //@}

  /**
   * @name mp
   *
   * @brief Accessor and modifier functions for the %mp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty mp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<mp_type> mp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef mp_sequence::iterator mp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef mp_sequence::const_iterator mp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<mp_type, char> mp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const mp_sequence &mp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  mp_sequence &mp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void mp(const mp_sequence &s);

  //@}

  /**
   * @name mf
   *
   * @brief Accessor and modifier functions for the %mf
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty mf_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<mf_type> mf_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef mf_sequence::iterator mf_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef mf_sequence::const_iterator mf_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<mf_type, char> mf_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const mf_sequence &mf() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  mf_sequence &mf();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void mf(const mf_sequence &s);

  //@}

  /**
   * @name sf
   *
   * @brief Accessor and modifier functions for the %sf
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty sf_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<sf_type> sf_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sf_sequence::iterator sf_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sf_sequence::const_iterator sf_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sf_type, char> sf_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sf_sequence &sf() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sf_sequence &sf();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void sf(const sf_sequence &s);

  //@}

  /**
   * @name sfp
   *
   * @brief Accessor and modifier functions for the %sfp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty sfp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<sfp_type> sfp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sfp_sequence::iterator sfp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sfp_sequence::const_iterator sfp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sfp_type, char> sfp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sfp_sequence &sfp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sfp_sequence &sfp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void sfp(const sfp_sequence &s);

  //@}

  /**
   * @name sfpp
   *
   * @brief Accessor and modifier functions for the %sfpp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty sfpp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<sfpp_type> sfpp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sfpp_sequence::iterator sfpp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sfpp_sequence::const_iterator sfpp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sfpp_type, char> sfpp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sfpp_sequence &sfpp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sfpp_sequence &sfpp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void sfpp(const sfpp_sequence &s);

  //@}

  /**
   * @name fp
   *
   * @brief Accessor and modifier functions for the %fp
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty fp_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fp_type> fp_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fp_sequence::iterator fp_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fp_sequence::const_iterator fp_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fp_type, char> fp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fp_sequence &fp() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fp_sequence &fp();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fp(const fp_sequence &s);

  //@}

  /**
   * @name rf
   *
   * @brief Accessor and modifier functions for the %rf
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty rf_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<rf_type> rf_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef rf_sequence::iterator rf_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef rf_sequence::const_iterator rf_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rf_type, char> rf_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const rf_sequence &rf() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  rf_sequence &rf();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void rf(const rf_sequence &s);

  //@}

  /**
   * @name rfz
   *
   * @brief Accessor and modifier functions for the %rfz
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty rfz_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<rfz_type> rfz_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef rfz_sequence::iterator rfz_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef rfz_sequence::const_iterator rfz_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rfz_type, char> rfz_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const rfz_sequence &rfz() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  rfz_sequence &rfz();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void rfz(const rfz_sequence &s);

  //@}

  /**
   * @name sfz
   *
   * @brief Accessor and modifier functions for the %sfz
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty sfz_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<sfz_type> sfz_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sfz_sequence::iterator sfz_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sfz_sequence::const_iterator sfz_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sfz_type, char> sfz_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sfz_sequence &sfz() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sfz_sequence &sfz();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void sfz(const sfz_sequence &s);

  //@}

  /**
   * @name sffz
   *
   * @brief Accessor and modifier functions for the %sffz
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty sffz_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<sffz_type> sffz_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sffz_sequence::iterator sffz_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sffz_sequence::const_iterator sffz_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sffz_type, char> sffz_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sffz_sequence &sffz() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sffz_sequence &sffz();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void sffz(const sffz_sequence &s);

  //@}

  /**
   * @name fz
   *
   * @brief Accessor and modifier functions for the %fz
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty fz_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fz_type> fz_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fz_sequence::iterator fz_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fz_sequence::const_iterator fz_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fz_type, char> fz_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fz_sequence &fz() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fz_sequence &fz();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fz(const fz_sequence &s);

  //@}

  /**
   * @name other-dynamics
   *
   * @brief Accessor and modifier functions for the %other-dynamics
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string other_dynamics_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<other_dynamics_type>
    other_dynamics_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef other_dynamics_sequence::iterator other_dynamics_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef other_dynamics_sequence::const_iterator other_dynamics_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_dynamics_type, char>
    other_dynamics_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const other_dynamics_sequence &other_dynamics() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  other_dynamics_sequence &other_dynamics();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void other_dynamics(const other_dynamics_sequence &s);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name underline
   *
   * @brief Accessor and modifier functions for the %underline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines underline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<underline_type> underline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<underline_type, char> underline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const underline_optional &underline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  underline_optional &underline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void underline(const underline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void underline(const underline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void underline(::std::unique_ptr<underline_type> p);

  //@}

  /**
   * @name overline
   *
   * @brief Accessor and modifier functions for the %overline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines overline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<overline_type> overline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<overline_type, char> overline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const overline_optional &overline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  overline_optional &overline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void overline(const overline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void overline(const overline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void overline(::std::unique_ptr<overline_type> p);

  //@}

  /**
   * @name line-through
   *
   * @brief Accessor and modifier functions for the %line-through
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines line_through_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_through_type> line_through_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_through_type, char> line_through_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_through_optional &line_through() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_through_optional &line_through();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_through(const line_through_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_through(const line_through_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_through(::std::unique_ptr<line_through_type> p);

  //@}

  /**
   * @name enclosure
   *
   * @brief Accessor and modifier functions for the %enclosure
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::enclosure_shape enclosure_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<enclosure_type> enclosure_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<enclosure_type, char> enclosure_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const enclosure_optional &enclosure() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  enclosure_optional &enclosure();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void enclosure(const enclosure_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void enclosure(const enclosure_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void enclosure(::std::unique_ptr<enclosure_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  dynamics();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  dynamics(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  dynamics(const dynamics &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual dynamics *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  dynamics &operator=(const dynamics &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~dynamics();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  p_sequence p_;
  pp_sequence pp_;
  ppp_sequence ppp_;
  pppp_sequence pppp_;
  ppppp_sequence ppppp_;
  pppppp_sequence pppppp_;
  f_sequence f_;
  ff_sequence ff_;
  fff_sequence fff_;
  ffff_sequence ffff_;
  fffff_sequence fffff_;
  ffffff_sequence ffffff_;
  mp_sequence mp_;
  mf_sequence mf_;
  sf_sequence sf_;
  sfp_sequence sfp_;
  sfpp_sequence sfpp_;
  fp_sequence fp_;
  rf_sequence rf_;
  rfz_sequence rfz_;
  sfz_sequence sfz_;
  sffz_sequence sffz_;
  fz_sequence fz_;
  other_dynamics_sequence other_dynamics_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;
  placement_optional placement_;
  underline_optional underline_;
  overline_optional overline_;
  line_through_optional line_through_;
  enclosure_optional enclosure_;

  //@endcond
};

/**
 * @brief Class corresponding to the %empty schema type.
 *
 * The empty type represents an empty element with no attributes.
 *
 * @nosubgrouping
 */
class empty : public ::xml_schema::type {
public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  empty();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty(const ::std::string &s, const ::xercesc::DOMElement *e,
        ::xml_schema::flags f = 0, ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty(const empty &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual empty *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~empty();
};

/**
 * @brief Class corresponding to the %empty-placement schema type.
 *
 * The empty-placement type represents an empty element with print-style
 * and placement attributes.
 *
 * @nosubgrouping
 */
class empty_placement : public ::xml_schema::type {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  empty_placement();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty_placement(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_placement(const empty_placement &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual empty_placement *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_placement &operator=(const empty_placement &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~empty_placement();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %empty-print-style schema type.
 *
 * The empty-print-style type represents an empty element with
 * print-style attribute group.
 *
 * @nosubgrouping
 */
class empty_print_style : public ::xml_schema::type {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  empty_print_style();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty_print_style(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_print_style(const empty_print_style &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual empty_print_style *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_print_style &operator=(const empty_print_style &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~empty_print_style();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %empty-print-style-align schema type.
 *
 * The empty-print-style-align type represents an empty element with
 * print-style-align attribute group.
 *
 * @nosubgrouping
 */
class empty_print_style_align : public ::xml_schema::type {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  empty_print_style_align();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty_print_style_align(const ::xercesc::DOMElement &e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_print_style_align(const empty_print_style_align &x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual empty_print_style_align *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_print_style_align &operator=(const empty_print_style_align &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~empty_print_style_align();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %empty-print-object-style-align schema
 *type.
 *
 * The empty-print-style-align-object type represents an empty element
 * with print-object and print-style-align attribute groups.
 *
 * @nosubgrouping
 */
class empty_print_object_style_align : public ::xml_schema::type {
public:
  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  empty_print_object_style_align();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty_print_object_style_align(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_print_object_style_align(const empty_print_object_style_align &x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual empty_print_object_style_align *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_print_object_style_align &
  operator=(const empty_print_object_style_align &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~empty_print_object_style_align();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  print_object_optional print_object_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %empty-trill-sound schema type.
 *
 * The empty-trill-sound type represents an empty element with
 * print-style, placement, and trill-sound attributes.
 *
 * @nosubgrouping
 */
class empty_trill_sound : public ::xml_schema::type {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name start-note
   *
   * @brief Accessor and modifier functions for the %start-note
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_note start_note_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<start_note_type> start_note_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<start_note_type, char> start_note_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const start_note_optional &start_note() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  start_note_optional &start_note();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void start_note(const start_note_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void start_note(const start_note_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void start_note(::std::unique_ptr<start_note_type> p);

  //@}

  /**
   * @name trill-step
   *
   * @brief Accessor and modifier functions for the %trill-step
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::trill_step trill_step_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<trill_step_type> trill_step_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<trill_step_type, char> trill_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const trill_step_optional &trill_step() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  trill_step_optional &trill_step();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void trill_step(const trill_step_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void trill_step(const trill_step_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void trill_step(::std::unique_ptr<trill_step_type> p);

  //@}

  /**
   * @name two-note-turn
   *
   * @brief Accessor and modifier functions for the %two-note-turn
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::two_note_turn two_note_turn_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<two_note_turn_type> two_note_turn_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<two_note_turn_type, char>
    two_note_turn_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const two_note_turn_optional &two_note_turn() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  two_note_turn_optional &two_note_turn();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void two_note_turn(const two_note_turn_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void two_note_turn(const two_note_turn_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void two_note_turn(::std::unique_ptr<two_note_turn_type> p);

  //@}

  /**
   * @name accelerate
   *
   * @brief Accessor and modifier functions for the %accelerate
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no accelerate_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accelerate_type> accelerate_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<accelerate_type, char> accelerate_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accelerate_optional &accelerate() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  accelerate_optional &accelerate();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void accelerate(const accelerate_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void accelerate(const accelerate_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accelerate(::std::unique_ptr<accelerate_type> p);

  //@}

  /**
   * @name beats
   *
   * @brief Accessor and modifier functions for the %beats
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::trill_beats beats_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<beats_type> beats_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<beats_type, char> beats_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const beats_optional &beats() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  beats_optional &beats();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void beats(const beats_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void beats(const beats_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void beats(::std::unique_ptr<beats_type> p);

  //@}

  /**
   * @name second-beat
   *
   * @brief Accessor and modifier functions for the %second-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent second_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<second_beat_type> second_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<second_beat_type, char> second_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const second_beat_optional &second_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  second_beat_optional &second_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void second_beat(const second_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void second_beat(const second_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void second_beat(::std::unique_ptr<second_beat_type> p);

  //@}

  /**
   * @name last-beat
   *
   * @brief Accessor and modifier functions for the %last-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent last_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<last_beat_type> last_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<last_beat_type, char> last_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const last_beat_optional &last_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  last_beat_optional &last_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void last_beat(const last_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void last_beat(const last_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void last_beat(::std::unique_ptr<last_beat_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  empty_trill_sound();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty_trill_sound(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_trill_sound(const empty_trill_sound &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual empty_trill_sound *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_trill_sound &operator=(const empty_trill_sound &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~empty_trill_sound();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;
  start_note_optional start_note_;
  trill_step_optional trill_step_;
  two_note_turn_optional two_note_turn_;
  accelerate_optional accelerate_;
  beats_optional beats_;
  second_beat_optional second_beat_;
  last_beat_optional last_beat_;

  //@endcond
};

/**
 * @brief Class corresponding to the %horizontal-turn schema type.
 *
 * The horizontal-turn type represents turn elements that are horizontal
 * rather than vertical. These are empty elements with print-style,
 * placement, trill-sound, and slash attributes. If the slash attribute
 * is yes, then a vertical line is used to slash the turn; it is no by
 * default.
 *
 * @nosubgrouping
 */
class horizontal_turn : public ::xml_schema::type {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name start-note
   *
   * @brief Accessor and modifier functions for the %start-note
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_note start_note_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<start_note_type> start_note_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<start_note_type, char> start_note_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const start_note_optional &start_note() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  start_note_optional &start_note();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void start_note(const start_note_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void start_note(const start_note_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void start_note(::std::unique_ptr<start_note_type> p);

  //@}

  /**
   * @name trill-step
   *
   * @brief Accessor and modifier functions for the %trill-step
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::trill_step trill_step_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<trill_step_type> trill_step_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<trill_step_type, char> trill_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const trill_step_optional &trill_step() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  trill_step_optional &trill_step();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void trill_step(const trill_step_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void trill_step(const trill_step_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void trill_step(::std::unique_ptr<trill_step_type> p);

  //@}

  /**
   * @name two-note-turn
   *
   * @brief Accessor and modifier functions for the %two-note-turn
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::two_note_turn two_note_turn_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<two_note_turn_type> two_note_turn_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<two_note_turn_type, char>
    two_note_turn_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const two_note_turn_optional &two_note_turn() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  two_note_turn_optional &two_note_turn();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void two_note_turn(const two_note_turn_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void two_note_turn(const two_note_turn_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void two_note_turn(::std::unique_ptr<two_note_turn_type> p);

  //@}

  /**
   * @name accelerate
   *
   * @brief Accessor and modifier functions for the %accelerate
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no accelerate_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accelerate_type> accelerate_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<accelerate_type, char> accelerate_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accelerate_optional &accelerate() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  accelerate_optional &accelerate();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void accelerate(const accelerate_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void accelerate(const accelerate_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accelerate(::std::unique_ptr<accelerate_type> p);

  //@}

  /**
   * @name beats
   *
   * @brief Accessor and modifier functions for the %beats
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::trill_beats beats_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<beats_type> beats_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<beats_type, char> beats_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const beats_optional &beats() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  beats_optional &beats();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void beats(const beats_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void beats(const beats_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void beats(::std::unique_ptr<beats_type> p);

  //@}

  /**
   * @name second-beat
   *
   * @brief Accessor and modifier functions for the %second-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent second_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<second_beat_type> second_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<second_beat_type, char> second_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const second_beat_optional &second_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  second_beat_optional &second_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void second_beat(const second_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void second_beat(const second_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void second_beat(::std::unique_ptr<second_beat_type> p);

  //@}

  /**
   * @name last-beat
   *
   * @brief Accessor and modifier functions for the %last-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent last_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<last_beat_type> last_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<last_beat_type, char> last_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const last_beat_optional &last_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  last_beat_optional &last_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void last_beat(const last_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void last_beat(const last_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void last_beat(::std::unique_ptr<last_beat_type> p);

  //@}

  /**
   * @name slash
   *
   * @brief Accessor and modifier functions for the %slash
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no slash_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<slash_type> slash_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<slash_type, char> slash_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const slash_optional &slash() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  slash_optional &slash();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void slash(const slash_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void slash(const slash_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void slash(::std::unique_ptr<slash_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  horizontal_turn();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  horizontal_turn(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  horizontal_turn(const horizontal_turn &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual horizontal_turn *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  horizontal_turn &operator=(const horizontal_turn &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~horizontal_turn();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;
  start_note_optional start_note_;
  trill_step_optional trill_step_;
  two_note_turn_optional two_note_turn_;
  accelerate_optional accelerate_;
  beats_optional beats_;
  second_beat_optional second_beat_;
  last_beat_optional last_beat_;
  slash_optional slash_;

  //@endcond
};

/**
 * @brief Class corresponding to the %fermata schema type.
 *
 * The fermata text content represents the shape of the fermata sign. An
 * empty fermata element represents a normal fermata. The fermata type is
 * upright if not specified.
 *
 * @nosubgrouping
 */
class fermata : public ::musicxml::fermata_shape {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::upright_inverted type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<type_type> type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional &type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  type_optional &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void type(const type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  fermata(::musicxml::fermata_shape::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  fermata(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  fermata(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  fermata(const ::musicxml::fermata_shape &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fermata(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fermata(const fermata &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual fermata *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fermata &operator=(const fermata &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~fermata();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  type_optional type_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %fingering schema type.
 *
 * Fingering is typically indicated 1,2,3,4,5. Multiple fingerings may be
 * given, typically to substitute fingerings in the middle of a note. The
 * substitution and alternate values are "no" if the attribute is not
 * present. For guitar and other fretted instruments, the fingering
 * element represents the fretting finger; the pluck element represents
 * the plucking finger.
 *
 * @nosubgrouping
 */
class fingering : public ::xml_schema::string {
public:
  /**
   * @name substitution
   *
   * @brief Accessor and modifier functions for the %substitution
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no substitution_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<substitution_type> substitution_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<substitution_type, char> substitution_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const substitution_optional &substitution() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  substitution_optional &substitution();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void substitution(const substitution_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void substitution(const substitution_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void substitution(::std::unique_ptr<substitution_type> p);

  //@}

  /**
   * @name alternate
   *
   * @brief Accessor and modifier functions for the %alternate
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no alternate_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<alternate_type> alternate_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<alternate_type, char> alternate_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const alternate_optional &alternate() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  alternate_optional &alternate();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void alternate(const alternate_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void alternate(const alternate_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void alternate(::std::unique_ptr<alternate_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  fingering();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  fingering(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  fingering(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  fingering(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fingering(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fingering(const fingering &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual fingering *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fingering &operator=(const fingering &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~fingering();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  substitution_optional substitution_;
  alternate_optional alternate_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %formatted-text schema type.
 *
 * The formatted-text type represents a text element with text-formatting
 * attributes.
 *
 * @nosubgrouping
 */
class formatted_text : public ::xml_schema::string {
public:
  /**
   * @name justify
   *
   * @brief Accessor and modifier functions for the %justify
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right justify_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<justify_type> justify_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<justify_type, char> justify_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const justify_optional &justify() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  justify_optional &justify();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void justify(const justify_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void justify(const justify_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void justify(::std::unique_ptr<justify_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name underline
   *
   * @brief Accessor and modifier functions for the %underline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines underline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<underline_type> underline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<underline_type, char> underline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const underline_optional &underline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  underline_optional &underline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void underline(const underline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void underline(const underline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void underline(::std::unique_ptr<underline_type> p);

  //@}

  /**
   * @name overline
   *
   * @brief Accessor and modifier functions for the %overline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines overline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<overline_type> overline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<overline_type, char> overline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const overline_optional &overline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  overline_optional &overline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void overline(const overline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void overline(const overline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void overline(::std::unique_ptr<overline_type> p);

  //@}

  /**
   * @name line-through
   *
   * @brief Accessor and modifier functions for the %line-through
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines line_through_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_through_type> line_through_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_through_type, char> line_through_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_through_optional &line_through() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_through_optional &line_through();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_through(const line_through_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_through(const line_through_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_through(::std::unique_ptr<line_through_type> p);

  //@}

  /**
   * @name rotation
   *
   * @brief Accessor and modifier functions for the %rotation
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::rotation_degrees rotation_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<rotation_type> rotation_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<rotation_type, char> rotation_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rotation_optional &rotation() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  rotation_optional &rotation();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void rotation(const rotation_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void rotation(const rotation_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void rotation(::std::unique_ptr<rotation_type> p);

  //@}

  /**
   * @name letter-spacing
   *
   * @brief Accessor and modifier functions for the %letter-spacing
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_or_normal letter_spacing_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<letter_spacing_type>
    letter_spacing_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<letter_spacing_type, char>
    letter_spacing_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const letter_spacing_optional &letter_spacing() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  letter_spacing_optional &letter_spacing();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void letter_spacing(const letter_spacing_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void letter_spacing(const letter_spacing_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void letter_spacing(::std::unique_ptr<letter_spacing_type> p);

  //@}

  /**
   * @name line-height
   *
   * @brief Accessor and modifier functions for the %line-height
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_or_normal line_height_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_height_type> line_height_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_height_type, char> line_height_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_height_optional &line_height() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_height_optional &line_height();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_height(const line_height_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_height(const line_height_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_height(::std::unique_ptr<line_height_type> p);

  //@}

  /**
   * @name lang
   *
   * @brief Accessor and modifier functions for the %lang
   * optional attribute.
   *
   * Attempting to install the relevant ISO 2- and 3-letter
   * codes as the enumerated possible values is probably never
   * going to be a realistic possibility.  See
   * RFC 3066 at http://www.ietf.org/rfc/rfc3066.txt and the IANA registry
   * at http://www.iana.org/assignments/lang-tag-apps.htm for
   * further information.
   *
   * The union allows for the 'un-declaration' of xml:lang with
   * the empty string.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::namespace_::lang lang_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<lang_type> lang_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<lang_type, char> lang_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const lang_optional &lang() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  lang_optional &lang();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void lang(const lang_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void lang(const lang_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void lang(::std::unique_ptr<lang_type> p);

  //@}

  /**
   * @name space
   *
   * @brief Accessor and modifier functions for the %space
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::namespace_::space space_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_type> space_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_type, char> space_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_optional &space() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_optional &space();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space(const space_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space(const space_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space(::std::unique_ptr<space_type> p);

  //@}

  /**
   * @name dir
   *
   * @brief Accessor and modifier functions for the %dir
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::text_direction dir_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dir_type> dir_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dir_type, char> dir_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dir_optional &dir() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dir_optional &dir();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dir(const dir_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dir(const dir_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dir(::std::unique_ptr<dir_type> p);

  //@}

  /**
   * @name enclosure
   *
   * @brief Accessor and modifier functions for the %enclosure
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::enclosure_shape enclosure_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<enclosure_type> enclosure_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<enclosure_type, char> enclosure_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const enclosure_optional &enclosure() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  enclosure_optional &enclosure();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void enclosure(const enclosure_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void enclosure(const enclosure_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void enclosure(::std::unique_ptr<enclosure_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  formatted_text();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  formatted_text(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  formatted_text(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  formatted_text(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  formatted_text(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  formatted_text(const formatted_text &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual formatted_text *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  formatted_text &operator=(const formatted_text &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~formatted_text();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  justify_optional justify_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;
  underline_optional underline_;
  overline_optional overline_;
  line_through_optional line_through_;
  rotation_optional rotation_;
  letter_spacing_optional letter_spacing_;
  line_height_optional line_height_;
  lang_optional lang_;
  space_optional space_;
  dir_optional dir_;
  enclosure_optional enclosure_;

  //@endcond
};

/**
 * @brief Class corresponding to the %fret schema type.
 *
 * The fret element is used with tablature notation and chord diagrams.
 * Fret numbers start with 0 for an open string and 1 for the first fret.
 *
 * @nosubgrouping
 */
class fret
  : public ::xsd::cxx::tree::fundamental_base<
      ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> {
public:
  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  fret(const ::xml_schema::non_negative_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  fret(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fret(const fret &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual fret *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  fret &operator=(const fret &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~fret();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %level schema type.
 *
 * The level type is used to specify editorial information for different
 * MusicXML elements. If the reference attribute for the level element is
 * yes, this indicates editorial information that is for display only and
 * should not affect playback. For instance, a modern edition of older
 * music may set reference="yes" on the attributes containing the music's
 * original clef, key, and time signature. It is no by default.
 *
 * @nosubgrouping
 */
class level : public ::xml_schema::string {
public:
  /**
   * @name reference
   *
   * @brief Accessor and modifier functions for the %reference
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no reference_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<reference_type> reference_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<reference_type, char> reference_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const reference_optional &reference() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  reference_optional &reference();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void reference(const reference_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void reference(const reference_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void reference(::std::unique_ptr<reference_type> p);

  //@}

  /**
   * @name parentheses
   *
   * @brief Accessor and modifier functions for the %parentheses
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no parentheses_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<parentheses_type> parentheses_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<parentheses_type, char> parentheses_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const parentheses_optional &parentheses() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  parentheses_optional &parentheses();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void parentheses(const parentheses_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void parentheses(const parentheses_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void parentheses(::std::unique_ptr<parentheses_type> p);

  //@}

  /**
   * @name bracket
   *
   * @brief Accessor and modifier functions for the %bracket
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no bracket_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bracket_type> bracket_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bracket_type, char> bracket_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bracket_optional &bracket() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bracket_optional &bracket();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bracket(const bracket_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bracket(const bracket_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bracket(::std::unique_ptr<bracket_type> p);

  //@}

  /**
   * @name size
   *
   * @brief Accessor and modifier functions for the %size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::symbol_size size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<size_type> size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<size_type, char> size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const size_optional &size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  size_optional &size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void size(const size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void size(const size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void size(::std::unique_ptr<size_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  level();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  level(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  level(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  level(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  level(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  level(const level &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual level *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  level &operator=(const level &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~level();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  reference_optional reference_;
  parentheses_optional parentheses_;
  bracket_optional bracket_;
  size_optional size_;

  //@endcond
};

/**
 * @brief Class corresponding to the %midi-device schema type.
 *
 * The midi-device type corresponds to the DeviceName meta event in
 * Standard MIDI Files. The optional port attribute is a number from 1 to
 * 16 that can be used with the unofficial MIDI port (or cable) meta
 * event. Unlike the DeviceName meta event, there can be multiple
 * midi-device elements per MusicXML part starting in MusicXML 3.0. The
 * optional id attribute refers to the score-instrument assigned to this
 * device. If missing, the device assignment affects all score-instrument
 * elements in the score-part.
 *
 * @nosubgrouping
 */
class midi_device : public ::xml_schema::string {
public:
  /**
   * @name port
   *
   * @brief Accessor and modifier functions for the %port
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::midi_16 port_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<port_type> port_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<port_type, char> port_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const port_optional &port() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  port_optional &port();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void port(const port_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void port(const port_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void port(::std::unique_ptr<port_type> p);

  //@}

  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::idref id_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<id_type> id_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const id_optional &id() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  id_optional &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void id(const id_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  midi_device();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  midi_device(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  midi_device(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  midi_device(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_device(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  midi_device(const midi_device &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual midi_device *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  midi_device &operator=(const midi_device &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~midi_device();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  port_optional port_;
  id_optional id_;

  //@endcond
};

/**
 * @brief Class corresponding to the %midi-instrument schema type.
 *
 * The midi-instrument type defines MIDI 1.0 instrument playback. The
 * midi-instrument element can be a part of either the score-instrument
 * element at the start of a part, or the sound element within a part.
 * The id attribute refers to the score-instrument affected by the
change. *
 * @nosubgrouping
 */
class midi_instrument : public ::xml_schema::type {
public:
  /**
   * @name midi-channel
   *
   * @brief Accessor and modifier functions for the %midi-channel
   * optional element.
   *
   * The midi-channel element specifies a MIDI 1.0 channel numbers ranging
   * from 1 to 16.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::midi_16 midi_channel_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<midi_channel_type> midi_channel_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_channel_type, char> midi_channel_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const midi_channel_optional &midi_channel() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  midi_channel_optional &midi_channel();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void midi_channel(const midi_channel_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void midi_channel(const midi_channel_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void midi_channel(::std::unique_ptr<midi_channel_type> p);

  //@}

  /**
   * @name midi-name
   *
   * @brief Accessor and modifier functions for the %midi-name
   * optional element.
   *
   * The midi-name element corresponds to a ProgramName meta-event within a
   * Standard MIDI File.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string midi_name_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<midi_name_type> midi_name_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_name_type, char> midi_name_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const midi_name_optional &midi_name() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  midi_name_optional &midi_name();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void midi_name(const midi_name_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void midi_name(const midi_name_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void midi_name(::std::unique_ptr<midi_name_type> p);

  //@}

  /**
   * @name midi-bank
   *
   * @brief Accessor and modifier functions for the %midi-bank
   * optional element.
   *
   * The midi-bank element specified a MIDI 1.0 bank number ranging from 1
   * to 16,384.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::midi_16384 midi_bank_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<midi_bank_type> midi_bank_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_bank_type, char> midi_bank_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const midi_bank_optional &midi_bank() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  midi_bank_optional &midi_bank();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void midi_bank(const midi_bank_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void midi_bank(const midi_bank_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void midi_bank(::std::unique_ptr<midi_bank_type> p);

  //@}

  /**
   * @name midi-program
   *
   * @brief Accessor and modifier functions for the %midi-program
   * optional element.
   *
   * The midi-program element specifies a MIDI 1.0 program number ranging
   * from 1 to 128.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::midi_128 midi_program_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<midi_program_type> midi_program_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_program_type, char> midi_program_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const midi_program_optional &midi_program() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  midi_program_optional &midi_program();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void midi_program(const midi_program_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void midi_program(const midi_program_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void midi_program(::std::unique_ptr<midi_program_type> p);

  //@}

  /**
   * @name midi-unpitched
   *
   * @brief Accessor and modifier functions for the %midi-unpitched
   * optional element.
   *
   * For unpitched instruments, the midi-unpitched element specifies a MIDI
   * 1.0 note number ranging from 1 to 128. It is usually used with MIDI
   * banks for percussion. Note that MIDI 1.0 note numbers are generally
   * specified from 0 to 127 rather than the 1 to 128 numbering used in
   * this element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::midi_128 midi_unpitched_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<midi_unpitched_type>
    midi_unpitched_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_unpitched_type, char>
    midi_unpitched_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const midi_unpitched_optional &midi_unpitched() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  midi_unpitched_optional &midi_unpitched();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void midi_unpitched(const midi_unpitched_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void midi_unpitched(const midi_unpitched_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void midi_unpitched(::std::unique_ptr<midi_unpitched_type> p);

  //@}

  /**
   * @name volume
   *
   * @brief Accessor and modifier functions for the %volume
   * optional element.
   *
   * The volume element value is a percentage of the maximum ranging from 0
   * to 100, with decimal values allowed. This corresponds to a scaling
   * value for the MIDI 1.0 channel volume controller.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::percent volume_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<volume_type> volume_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<volume_type, char> volume_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const volume_optional &volume() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  volume_optional &volume();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void volume(const volume_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void volume(const volume_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void volume(::std::unique_ptr<volume_type> p);

  //@}

  /**
   * @name pan
   *
   * @brief Accessor and modifier functions for the %pan
   * optional element.
   *
   * The pan and elevation elements allow placing of sound in a 3-D space
   * relative to the listener. Both are expressed in degrees ranging from
   * -180 to 180. For pan, 0 is straight ahead, -90 is hard left, 90 is
   * hard right, and -180 and 180 are directly behind the listener.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::rotation_degrees pan_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<pan_type> pan_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pan_type, char> pan_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const pan_optional &pan() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  pan_optional &pan();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void pan(const pan_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void pan(const pan_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void pan(::std::unique_ptr<pan_type> p);

  //@}

  /**
   * @name elevation
   *
   * @brief Accessor and modifier functions for the %elevation
   * optional element.
   *
   * The elevation and pan elements allow placing of sound in a 3-D space
   * relative to the listener. Both are expressed in degrees ranging from
   * -180 to 180. For elevation, 0 is level with the listener, 90 is
   * directly above, and -90 is directly below.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::rotation_degrees elevation_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<elevation_type> elevation_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<elevation_type, char> elevation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const elevation_optional &elevation() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  elevation_optional &elevation();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void elevation(const elevation_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void elevation(const elevation_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void elevation(::std::unique_ptr<elevation_type> p);

  //@}

  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::idref id_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const id_type &id() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  id_type &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  midi_instrument(const id_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  midi_instrument(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  midi_instrument(const midi_instrument &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual midi_instrument *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  midi_instrument &operator=(const midi_instrument &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~midi_instrument();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  midi_channel_optional midi_channel_;
  midi_name_optional midi_name_;
  midi_bank_optional midi_bank_;
  midi_program_optional midi_program_;
  midi_unpitched_optional midi_unpitched_;
  volume_optional volume_;
  pan_optional pan_;
  elevation_optional elevation_;
  ::xsd::cxx::tree::one<id_type> id_;

  //@endcond
};

/**
 * @brief Class corresponding to the %name-display schema type.
 *
 * The name-display type is used for exact formatting of multi-font text
 * in part and group names to the left of the system. The print-object
 * attribute can be used to determine what, if anything, is printed at
 * the start of each system. Enclosure for the display-text element is
 * none by default. Language for the display-text element is Italian
 * ("it") by default.
 *
 * @nosubgrouping
 */
class name_display : public ::xml_schema::type {
public:
  /**
   * @name display-text
   *
   * @brief Accessor and modifier functions for the %display-text
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text display_text_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<display_text_type> display_text_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef display_text_sequence::iterator display_text_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef display_text_sequence::const_iterator display_text_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<display_text_type, char> display_text_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const display_text_sequence &display_text() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  display_text_sequence &display_text();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void display_text(const display_text_sequence &s);

  //@}

  /**
   * @name accidental-text
   *
   * @brief Accessor and modifier functions for the %accidental-text
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accidental_text accidental_text_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<accidental_text_type>
    accidental_text_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef accidental_text_sequence::iterator accidental_text_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef accidental_text_sequence::const_iterator
    accidental_text_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accidental_text_type, char>
    accidental_text_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const accidental_text_sequence &accidental_text() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  accidental_text_sequence &accidental_text();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void accidental_text(const accidental_text_sequence &s);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  name_display();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  name_display(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  name_display(const name_display &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual name_display *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  name_display &operator=(const name_display &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~name_display();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  display_text_sequence display_text_;
  accidental_text_sequence accidental_text_;
  print_object_optional print_object_;

  //@endcond
};

/**
 * @brief Class corresponding to the %other-play schema type.
 *
 * The other-play element represents other types of playback. The
 * required type attribute indicates the type of playback to which the
 * element content applies.
 *
 * @nosubgrouping
 */
class other_play : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  other_play(const type_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  other_play(const char *, const type_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  other_play(const ::std::string &, const type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  other_play(const ::xml_schema::string &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  other_play(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  other_play(const other_play &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual other_play *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  other_play &operator=(const other_play &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~other_play();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %play schema type.
 *
 * The play type, new in Version 3.0, specifies playback techniques to be
 * used in conjunction with the instrument-sound element. When used as
 * part of a sound element, it applies to all notes going forward in
 * score order. In multi-instrument parts, the affected instrument should
 * be specified using the id attribute. When used as part of a note
 * element, it applies to the current note only.
 *
 * @nosubgrouping
 */
class play : public ::xml_schema::type {
public:
  /**
   * @name ipa
   *
   * @brief Accessor and modifier functions for the %ipa
   * sequence element.
   *
   * The ipa element represents International Phonetic Alphabet (IPA)
   * sounds for vocal music. String content is limited to IPA 2005 symbols
   * represented in Unicode 6.0.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string ipa_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<ipa_type> ipa_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ipa_sequence::iterator ipa_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ipa_sequence::const_iterator ipa_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ipa_type, char> ipa_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ipa_sequence &ipa() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ipa_sequence &ipa();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void ipa(const ipa_sequence &s);

  //@}

  /**
   * @name mute
   *
   * @brief Accessor and modifier functions for the %mute
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::mute mute_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<mute_type> mute_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef mute_sequence::iterator mute_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef mute_sequence::const_iterator mute_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<mute_type, char> mute_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const mute_sequence &mute() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  mute_sequence &mute();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void mute(const mute_sequence &s);

  //@}

  /**
   * @name semi-pitched
   *
   * @brief Accessor and modifier functions for the %semi-pitched
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::semi_pitched semi_pitched_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<semi_pitched_type> semi_pitched_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef semi_pitched_sequence::iterator semi_pitched_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef semi_pitched_sequence::const_iterator semi_pitched_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<semi_pitched_type, char> semi_pitched_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const semi_pitched_sequence &semi_pitched() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  semi_pitched_sequence &semi_pitched();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void semi_pitched(const semi_pitched_sequence &s);

  //@}

  /**
   * @name other-play
   *
   * @brief Accessor and modifier functions for the %other-play
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::other_play other_play_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<other_play_type> other_play_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef other_play_sequence::iterator other_play_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef other_play_sequence::const_iterator other_play_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_play_type, char> other_play_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const other_play_sequence &other_play() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  other_play_sequence &other_play();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void other_play(const other_play_sequence &s);

  //@}

  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::idref id_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<id_type> id_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const id_optional &id() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  id_optional &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void id(const id_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  play();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  play(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  play(const play &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual play *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  play &operator=(const play &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~play();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ipa_sequence ipa_;
  mute_sequence mute_;
  semi_pitched_sequence semi_pitched_;
  other_play_sequence other_play_;
  id_optional id_;

  //@endcond
};

/**
 * @brief Class corresponding to the %string schema type.
 *
 * The string type is used with tablature notation, regular notation
 * (where it is often circled), and chord diagrams. String numbers start
 * with 1 for the highest string.
 *
 * @nosubgrouping
 */
class string : public ::musicxml::string_number {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  string(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  string(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  string(const string &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual string *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  string &operator=(const string &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~string();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %typed-text schema type.
 *
 * The typed-text type represents a text element with a type attributes.
 *
 * @nosubgrouping
 */
class typed_text : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<type_type> type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional &type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  type_optional &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void type(const type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  typed_text();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  typed_text(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  typed_text(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  typed_text(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  typed_text(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  typed_text(const typed_text &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual typed_text *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  typed_text &operator=(const typed_text &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~typed_text();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  type_optional type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %wavy-line schema type.
 *
 * Wavy lines are one way to indicate trills. When used with a measure
 * element, they should always have type="continue" set.
 *
 * @nosubgrouping
 */
class wavy_line : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_continue type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name start-note
   *
   * @brief Accessor and modifier functions for the %start-note
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_note start_note_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<start_note_type> start_note_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<start_note_type, char> start_note_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const start_note_optional &start_note() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  start_note_optional &start_note();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void start_note(const start_note_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void start_note(const start_note_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void start_note(::std::unique_ptr<start_note_type> p);

  //@}

  /**
   * @name trill-step
   *
   * @brief Accessor and modifier functions for the %trill-step
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::trill_step trill_step_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<trill_step_type> trill_step_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<trill_step_type, char> trill_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const trill_step_optional &trill_step() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  trill_step_optional &trill_step();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void trill_step(const trill_step_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void trill_step(const trill_step_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void trill_step(::std::unique_ptr<trill_step_type> p);

  //@}

  /**
   * @name two-note-turn
   *
   * @brief Accessor and modifier functions for the %two-note-turn
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::two_note_turn two_note_turn_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<two_note_turn_type> two_note_turn_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<two_note_turn_type, char>
    two_note_turn_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const two_note_turn_optional &two_note_turn() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  two_note_turn_optional &two_note_turn();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void two_note_turn(const two_note_turn_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void two_note_turn(const two_note_turn_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void two_note_turn(::std::unique_ptr<two_note_turn_type> p);

  //@}

  /**
   * @name accelerate
   *
   * @brief Accessor and modifier functions for the %accelerate
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no accelerate_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accelerate_type> accelerate_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<accelerate_type, char> accelerate_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accelerate_optional &accelerate() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  accelerate_optional &accelerate();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void accelerate(const accelerate_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void accelerate(const accelerate_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accelerate(::std::unique_ptr<accelerate_type> p);

  //@}

  /**
   * @name beats
   *
   * @brief Accessor and modifier functions for the %beats
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::trill_beats beats_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<beats_type> beats_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<beats_type, char> beats_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const beats_optional &beats() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  beats_optional &beats();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void beats(const beats_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void beats(const beats_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void beats(::std::unique_ptr<beats_type> p);

  //@}

  /**
   * @name second-beat
   *
   * @brief Accessor and modifier functions for the %second-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent second_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<second_beat_type> second_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<second_beat_type, char> second_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const second_beat_optional &second_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  second_beat_optional &second_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void second_beat(const second_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void second_beat(const second_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void second_beat(::std::unique_ptr<second_beat_type> p);

  //@}

  /**
   * @name last-beat
   *
   * @brief Accessor and modifier functions for the %last-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent last_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<last_beat_type> last_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<last_beat_type, char> last_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const last_beat_optional &last_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  last_beat_optional &last_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void last_beat(const last_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void last_beat(const last_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void last_beat(::std::unique_ptr<last_beat_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  wavy_line(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  wavy_line(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  wavy_line(const wavy_line &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual wavy_line *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  wavy_line &operator=(const wavy_line &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~wavy_line();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  number_optional number_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  placement_optional placement_;
  color_optional color_;
  start_note_optional start_note_;
  trill_step_optional trill_step_;
  two_note_turn_optional two_note_turn_;
  accelerate_optional accelerate_;
  beats_optional beats_;
  second_beat_optional second_beat_;
  last_beat_optional last_beat_;

  //@endcond
};

/**
 * @brief Class corresponding to the %attributes schema type.
 *
 * The attributes element contains musical information that typically
 * changes on measure boundaries. This includes key and time signatures,
 * clefs, transpositions, and staving. When attributes are changed
 * mid-measure, it affects the music in score order, not in MusicXML
 * document order.
 *
 * @nosubgrouping
 */
class attributes : public ::xml_schema::type {
public:
  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name divisions
   *
   * @brief Accessor and modifier functions for the %divisions
   * optional element.
   *
   * Musical notation duration is commonly represented as fractions. The
   * divisions element indicates how many divisions per quarter note are
   * used to indicate a note's duration. For example, if duration = 1 and
   * divisions = 2, this is an eighth note duration. Duration and divisions
   * are used directly for generating sound output, so they must be chosen
   * to take tuplets into account. Using a divisions element lets us use
   * just one number to represent a duration for each note in the score,
   * while retaining the full power of a fractional representation. If
   * maximum compatibility with Standard MIDI 1.0 files is important, do
   * not have the divisions value exceed 16383.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::positive_divisions divisions_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<divisions_type> divisions_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<divisions_type, char> divisions_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const divisions_optional &divisions() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  divisions_optional &divisions();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void divisions(const divisions_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void divisions(const divisions_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void divisions(::std::unique_ptr<divisions_type> p);

  //@}

  /**
   * @name key
   *
   * @brief Accessor and modifier functions for the %key
   * sequence element.
   *
   * The key element represents a key signature. Both traditional and
   * non-traditional key signatures are supported. The optional number
   * attribute refers to staff numbers. If absent, the key signature
   * applies to all staves in the part.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::key key_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<key_type> key_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef key_sequence::iterator key_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef key_sequence::const_iterator key_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<key_type, char> key_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const key_sequence &key() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  key_sequence &key();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void key(const key_sequence &s);

  //@}

  /**
   * @name time
   *
   * @brief Accessor and modifier functions for the %time
   * sequence element.
   *
   * Time signatures are represented by the beats element for the numerator
   * and the beat-type element for the denominator.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::time time_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<time_type> time_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef time_sequence::iterator time_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef time_sequence::const_iterator time_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<time_type, char> time_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const time_sequence &time() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  time_sequence &time();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void time(const time_sequence &s);

  //@}

  /**
   * @name staves
   *
   * @brief Accessor and modifier functions for the %staves
   * optional element.
   *
   * The staves element is used if there is more than one staff represented
   * in the given part (e.g., 2 staves for typical piano parts). If absent,
   * a value of 1 is assumed. Staves are ordered from top to bottom in a
   * part in numerical order, with staff 1 above staff 2.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::non_negative_integer staves_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staves_type> staves_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staves_type, char> staves_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staves_optional &staves() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staves_optional &staves();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staves(const staves_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staves(const staves_optional &x);

  //@}

  /**
   * @name part-symbol
   *
   * @brief Accessor and modifier functions for the %part-symbol
   * optional element.
   *
   * The part-symbol element indicates how a symbol for a multi-staff part
   * is indicated in the score.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::part_symbol part_symbol_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<part_symbol_type> part_symbol_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_symbol_type, char> part_symbol_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const part_symbol_optional &part_symbol() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  part_symbol_optional &part_symbol();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_symbol(const part_symbol_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void part_symbol(const part_symbol_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void part_symbol(::std::unique_ptr<part_symbol_type> p);

  //@}

  /**
   * @name instruments
   *
   * @brief Accessor and modifier functions for the %instruments
   * optional element.
   *
   * The instruments element is only used if more than one instrument is
   * represented in the part (e.g., oboe I and II where they play together
   * most of the time). If absent, a value of 1 is assumed.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::non_negative_integer instruments_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<instruments_type> instruments_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<instruments_type, char> instruments_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const instruments_optional &instruments() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  instruments_optional &instruments();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void instruments(const instruments_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void instruments(const instruments_optional &x);

  //@}

  /**
   * @name clef
   *
   * @brief Accessor and modifier functions for the %clef
   * sequence element.
   *
   * Clefs are represented by a combination of sign, line, and
   * clef-octave-change elements.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::clef clef_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<clef_type> clef_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef clef_sequence::iterator clef_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef clef_sequence::const_iterator clef_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<clef_type, char> clef_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const clef_sequence &clef() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  clef_sequence &clef();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void clef(const clef_sequence &s);

  //@}

  /**
   * @name staff-details
   *
   * @brief Accessor and modifier functions for the %staff-details
   * sequence element.
   *
   * The staff-details element is used to indicate different types of
   * staves.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::staff_details staff_details_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<staff_details_type> staff_details_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef staff_details_sequence::iterator staff_details_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef staff_details_sequence::const_iterator staff_details_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_details_type, char>
    staff_details_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const staff_details_sequence &staff_details() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  staff_details_sequence &staff_details();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void staff_details(const staff_details_sequence &s);

  //@}

  /**
   * @name transpose
   *
   * @brief Accessor and modifier functions for the %transpose
   * sequence element.
   *
   * If the part is being encoded for a transposing instrument in written
   * vs. concert pitch, the transposition must be encoded in the transpose
   * element using the transpose type.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::transpose transpose_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<transpose_type> transpose_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef transpose_sequence::iterator transpose_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef transpose_sequence::const_iterator transpose_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<transpose_type, char> transpose_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const transpose_sequence &transpose() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  transpose_sequence &transpose();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void transpose(const transpose_sequence &s);

  //@}

  /**
   * @name directive
   *
   * @brief Accessor and modifier functions for the %directive
   * sequence element.
   *
   * Directives are like directions, but can be grouped together with
   * attributes for convenience. This is typically used for tempo markings
   * at the beginning of a piece of music. This element has been deprecated
   * in Version 2.0 in favor of the directive attribute for direction
   * elements. Language names come from ISO 639, with optional country
   * subcodes from ISO 3166.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::directive directive_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<directive_type> directive_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef directive_sequence::iterator directive_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef directive_sequence::const_iterator directive_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<directive_type, char> directive_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const directive_sequence &directive() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  directive_sequence &directive();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void directive(const directive_sequence &s);

  //@}

  /**
   * @name measure-style
   *
   * @brief Accessor and modifier functions for the %measure-style
   * sequence element.
   *
   * A measure-style indicates a special way to print partial to multiple
   * measures within a part. This includes multiple rests over several
   * measures, repeats of beats, single, or multiple measures, and use of
   * slash notation.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::measure_style measure_style_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<measure_style_type> measure_style_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef measure_style_sequence::iterator measure_style_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef measure_style_sequence::const_iterator measure_style_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<measure_style_type, char>
    measure_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const measure_style_sequence &measure_style() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  measure_style_sequence &measure_style();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void measure_style(const measure_style_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  attributes();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  attributes(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  attributes(const attributes &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual attributes *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  attributes &operator=(const attributes &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~attributes();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  footnote_optional footnote_;
  level_optional level_;
  divisions_optional divisions_;
  key_sequence key_;
  time_sequence time_;
  staves_optional staves_;
  part_symbol_optional part_symbol_;
  instruments_optional instruments_;
  clef_sequence clef_;
  staff_details_sequence staff_details_;
  transpose_sequence transpose_;
  directive_sequence directive_;
  measure_style_sequence measure_style_;

  //@endcond
};

/**
 * @brief Class corresponding to the %beat-repeat schema type.
 *
 * The beat-repeat type is used to indicate that a single beat (but
 * possibly many notes) is repeated. Both the start and stop of the beat
 * being repeated should be specified. The slashes attribute specifies
 * the number of slashes to use in the symbol. The use-dots attribute
 * indicates whether or not to use dots as well (for instance, with mixed
 * rhythm patterns). By default, the value for slashes is 1 and the value
 * for use-dots is no.
 *
 * The beat-repeat element specifies a notation style for repetitions.
 * The actual music being repeated needs to be repeated within the
 * MusicXML file. This element specifies the notation that indicates the
 * repeat.
 *
 * @nosubgrouping
 */
class beat_repeat : public ::xml_schema::type {
public:
  /**
   * @name slash-type
   *
   * @brief Accessor and modifier functions for the %slash-type
   * optional element.
   *
   * The slash-type element indicates the graphical note type to use for
   * the display of repetition marks.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note_type_value slash_type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<slash_type_type> slash_type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<slash_type_type, char> slash_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const slash_type_optional &slash_type() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  slash_type_optional &slash_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void slash_type(const slash_type_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void slash_type(const slash_type_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void slash_type(::std::unique_ptr<slash_type_type> p);

  //@}

  /**
   * @name slash-dot
   *
   * @brief Accessor and modifier functions for the %slash-dot
   * sequence element.
   *
   * The slash-dot element is used to specify any augmentation dots in the
   * note type used to display repetition marks.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty slash_dot_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<slash_dot_type> slash_dot_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef slash_dot_sequence::iterator slash_dot_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef slash_dot_sequence::const_iterator slash_dot_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<slash_dot_type, char> slash_dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const slash_dot_sequence &slash_dot() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  slash_dot_sequence &slash_dot();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void slash_dot(const slash_dot_sequence &s);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name slashes
   *
   * @brief Accessor and modifier functions for the %slashes
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer slashes_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<slashes_type> slashes_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<slashes_type, char> slashes_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const slashes_optional &slashes() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  slashes_optional &slashes();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void slashes(const slashes_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void slashes(const slashes_optional &x);

  //@}

  /**
   * @name use-dots
   *
   * @brief Accessor and modifier functions for the %use-dots
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no use_dots_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<use_dots_type> use_dots_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<use_dots_type, char> use_dots_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const use_dots_optional &use_dots() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  use_dots_optional &use_dots();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void use_dots(const use_dots_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void use_dots(const use_dots_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void use_dots(::std::unique_ptr<use_dots_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  beat_repeat(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beat_repeat(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beat_repeat(const beat_repeat &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual beat_repeat *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beat_repeat &operator=(const beat_repeat &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~beat_repeat();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  slash_type_optional slash_type_;
  slash_dot_sequence slash_dot_;
  ::xsd::cxx::tree::one<type_type> type_;
  slashes_optional slashes_;
  use_dots_optional use_dots_;

  //@endcond
};

/**
 * @brief Class corresponding to the %cancel schema type.
 *
 * A cancel element indicates that the old key signature should be
 * cancelled before the new one appears. This will always happen when
 * changing to C major or A minor and need not be specified then. The
 * cancel value matches the fifths value of the cancelled key signature
 * (e.g., a cancel of -2 will provide an explicit cancellation for
 * changing from B flat major to F major). The optional location
 * attribute indicates whether the cancellation appears relative to the
 * new key signature.
 *
 * @nosubgrouping
 */
class cancel : public ::musicxml::fifths {
public:
  /**
   * @name location
   *
   * @brief Accessor and modifier functions for the %location
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::cancel_location location_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<location_type> location_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<location_type, char> location_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const location_optional &location() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  location_optional &location();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void location(const location_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void location(const location_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void location(::std::unique_ptr<location_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  cancel(const ::xml_schema::integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  cancel(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  cancel(const cancel &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual cancel *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  cancel &operator=(const cancel &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~cancel();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  location_optional location_;

  //@endcond
};

/**
 * @brief Class corresponding to the %clef schema type.
 *
 * Clefs are represented by a combination of sign, line, and
 * clef-octave-change elements. The optional number attribute refers to
 * staff numbers within the part. A value of 1 is assumed if not present.
 *
 * Sometimes clefs are added to the staff in non-standard line positions,
 * either to indicate cue passages, or when there are multiple clefs
 * present simultaneously on one staff. In this situation, the additional
 * attribute is set to "yes" and the line value is ignored. The size
 * attribute is used for clefs where the additional attribute is "yes".
 * It is typically used to indicate cue clefs.
 *
 * Sometimes clefs at the start of a measure need to appear after the
 * barline rather than before, as for cues or for use after a repeated
 * section. The after-barline attribute is set to "yes" in this
 * situation. The attribute is ignored for mid-measure clefs.
 *
 * Clefs appear at the start of each system unless the print-object
 * attribute has been set to "no" or the additional attribute has been
 * set to "yes".
 *
 * @nosubgrouping
 */
class clef : public ::xml_schema::type {
public:
  /**
   * @name sign
   *
   * @brief Accessor and modifier functions for the %sign
   * required element.
   *
   * The sign element represents the clef symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::clef_sign sign_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sign_type, char> sign_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const sign_type &sign() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  sign_type &sign();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void sign(const sign_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void sign(::std::unique_ptr<sign_type> p);

  //@}

  /**
   * @name line
   *
   * @brief Accessor and modifier functions for the %line
   * optional element.
   *
   * Line numbers are counted from the bottom of the staff. Standard values
   * are 2 for the G sign (treble clef), 4 for the F sign (bass clef), 3
   * for the C sign (alto clef) and 5 for TAB (on a 6-line staff).
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::staff_line line_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type> line_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type, char> line_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_optional &line() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  line_optional &line();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void line(const line_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void line(const line_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line(::std::unique_ptr<line_type> p);

  //@}

  /**
   * @name clef-octave-change
   *
   * @brief Accessor and modifier functions for the %clef-octave-change
   * optional element.
   *
   * The clef-octave-change element is used for transposing clefs. A treble
   * clef for tenors would have a value of -1.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::integer clef_octave_change_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<clef_octave_change_type>
    clef_octave_change_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<clef_octave_change_type, char>
    clef_octave_change_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const clef_octave_change_optional &clef_octave_change() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  clef_octave_change_optional &clef_octave_change();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void clef_octave_change(const clef_octave_change_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void clef_octave_change(const clef_octave_change_optional &x);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name additional
   *
   * @brief Accessor and modifier functions for the %additional
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no additional_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<additional_type> additional_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<additional_type, char> additional_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const additional_optional &additional() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  additional_optional &additional();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void additional(const additional_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void additional(const additional_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void additional(::std::unique_ptr<additional_type> p);

  //@}

  /**
   * @name size
   *
   * @brief Accessor and modifier functions for the %size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::symbol_size size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<size_type> size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<size_type, char> size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const size_optional &size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  size_optional &size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void size(const size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void size(const size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void size(::std::unique_ptr<size_type> p);

  //@}

  /**
   * @name after-barline
   *
   * @brief Accessor and modifier functions for the %after-barline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no after_barline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<after_barline_type> after_barline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<after_barline_type, char>
    after_barline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const after_barline_optional &after_barline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  after_barline_optional &after_barline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void after_barline(const after_barline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void after_barline(const after_barline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void after_barline(::std::unique_ptr<after_barline_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  clef(const sign_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  clef(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  clef(const clef &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual clef *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  clef &operator=(const clef &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~clef();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<sign_type> sign_;
  line_optional line_;
  clef_octave_change_optional clef_octave_change_;
  number_optional number_;
  additional_optional additional_;
  size_optional size_;
  after_barline_optional after_barline_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  print_object_optional print_object_;

  //@endcond
};

/**
 * @brief Class corresponding to the %interchangeable schema type.
 *
 * The interchangeable type is used to represent the second in a pair of
 * interchangeable dual time signatures, such as the 6/8 in 3/4 (6/8). A
 * separate symbol attribute value is available compared to the time
 * element's symbol attribute, which applies to the first of the dual
 * time signatures. The parentheses attribute value is yes by default.
 *
 * @nosubgrouping
 */
class interchangeable : public ::xml_schema::type {
public:
  /**
   * @name time-relation
   *
   * @brief Accessor and modifier functions for the %time-relation
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::time_relation time_relation_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<time_relation_type> time_relation_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<time_relation_type, char>
    time_relation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const time_relation_optional &time_relation() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  time_relation_optional &time_relation();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void time_relation(const time_relation_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void time_relation(const time_relation_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void time_relation(::std::unique_ptr<time_relation_type> p);

  //@}

  /**
   * @name beats
   *
   * @brief Accessor and modifier functions for the %beats
   * sequence element.
   *
   * The beats element indicates the number of beats, as found in the
   * numerator of a time signature.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string beats_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<beats_type> beats_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef beats_sequence::iterator beats_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef beats_sequence::const_iterator beats_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beats_type, char> beats_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const beats_sequence &beats() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  beats_sequence &beats();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void beats(const beats_sequence &s);

  //@}

  /**
   * @name beat-type
   *
   * @brief Accessor and modifier functions for the %beat-type
   * sequence element.
   *
   * The beat-type element indicates the beat unit, as found in the
   * denominator of a time signature.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string beat_type_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<beat_type_type> beat_type_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef beat_type_sequence::iterator beat_type_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef beat_type_sequence::const_iterator beat_type_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beat_type_type, char> beat_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const beat_type_sequence &beat_type() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  beat_type_sequence &beat_type();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void beat_type(const beat_type_sequence &s);

  //@}

  /**
   * @name symbol
   *
   * @brief Accessor and modifier functions for the %symbol
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::time_symbol symbol_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<symbol_type> symbol_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<symbol_type, char> symbol_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const symbol_optional &symbol() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  symbol_optional &symbol();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void symbol(const symbol_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void symbol(const symbol_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void symbol(::std::unique_ptr<symbol_type> p);

  //@}

  /**
   * @name separator
   *
   * @brief Accessor and modifier functions for the %separator
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::time_separator separator_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<separator_type> separator_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<separator_type, char> separator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const separator_optional &separator() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  separator_optional &separator();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void separator(const separator_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void separator(const separator_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void separator(::std::unique_ptr<separator_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  interchangeable();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  interchangeable(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  interchangeable(const interchangeable &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual interchangeable *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  interchangeable &operator=(const interchangeable &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~interchangeable();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  time_relation_optional time_relation_;
  beats_sequence beats_;
  beat_type_sequence beat_type_;
  symbol_optional symbol_;
  separator_optional separator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %key schema type.
 *
 * The key type represents a key signature. Both traditional and
 * non-traditional key signatures are supported. The optional number
 * attribute refers to staff numbers. If absent, the key signature
 * applies to all staves in the part. Key signatures appear at the start
 * of each system unless the print-object attribute has been set to "no".
 *
 * @nosubgrouping
 */
class key : public ::xml_schema::type {
public:
  /**
   * @name cancel
   *
   * @brief Accessor and modifier functions for the %cancel
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::cancel cancel_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<cancel_type> cancel_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<cancel_type, char> cancel_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const cancel_optional &cancel() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  cancel_optional &cancel();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void cancel(const cancel_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void cancel(const cancel_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void cancel(::std::unique_ptr<cancel_type> p);

  //@}

  /**
   * @name fifths
   *
   * @brief Accessor and modifier functions for the %fifths
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::fifths fifths_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<fifths_type> fifths_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fifths_type, char> fifths_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const fifths_optional &fifths() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  fifths_optional &fifths();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void fifths(const fifths_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void fifths(const fifths_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void fifths(::std::unique_ptr<fifths_type> p);

  //@}

  /**
   * @name mode
   *
   * @brief Accessor and modifier functions for the %mode
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::mode mode_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<mode_type> mode_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<mode_type, char> mode_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const mode_optional &mode() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  mode_optional &mode();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void mode(const mode_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void mode(const mode_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void mode(::std::unique_ptr<mode_type> p);

  //@}

  /**
   * @name key-step
   *
   * @brief Accessor and modifier functions for the %key-step
   * sequence element.
   *
   * Non-traditional key signatures can be represented using the
   * Humdrum/Scot concept of a list of altered tones. The key-step element
   * indicates the pitch step to be altered, represented using the same
   * names as in the step element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::step key_step_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<key_step_type> key_step_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef key_step_sequence::iterator key_step_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef key_step_sequence::const_iterator key_step_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<key_step_type, char> key_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const key_step_sequence &key_step() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  key_step_sequence &key_step();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void key_step(const key_step_sequence &s);

  //@}

  /**
   * @name key-alter
   *
   * @brief Accessor and modifier functions for the %key-alter
   * sequence element.
   *
   * Non-traditional key signatures can be represented using the
   * Humdrum/Scot concept of a list of altered tones. The key-alter element
   * represents the alteration for a given pitch step, represented with
   * semitones in the same manner as the alter element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::semitones key_alter_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<key_alter_type> key_alter_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef key_alter_sequence::iterator key_alter_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef key_alter_sequence::const_iterator key_alter_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<key_alter_type, char> key_alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const key_alter_sequence &key_alter() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  key_alter_sequence &key_alter();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void key_alter(const key_alter_sequence &s);

  //@}

  /**
   * @name key-accidental
   *
   * @brief Accessor and modifier functions for the %key-accidental
   * sequence element.
   *
   * Non-traditional key signatures can be represented using the
   * Humdrum/Scot concept of a list of altered tones. The key-accidental
   * element indicates the accidental to be displayed in the key signature,
   * represented in the same manner as the accidental element. It is used
   * for disambiguating microtonal accidentals.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accidental_value key_accidental_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<key_accidental_type>
    key_accidental_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef key_accidental_sequence::iterator key_accidental_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef key_accidental_sequence::const_iterator key_accidental_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<key_accidental_type, char>
    key_accidental_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const key_accidental_sequence &key_accidental() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  key_accidental_sequence &key_accidental();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void key_accidental(const key_accidental_sequence &s);

  //@}

  /**
   * @name key-octave
   *
   * @brief Accessor and modifier functions for the %key-octave
   * sequence element.
   *
   * The optional list of key-octave elements is used to specify in which
   * octave each element of the key signature appears.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::key_octave key_octave_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<key_octave_type> key_octave_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef key_octave_sequence::iterator key_octave_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef key_octave_sequence::const_iterator key_octave_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<key_octave_type, char> key_octave_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const key_octave_sequence &key_octave() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  key_octave_sequence &key_octave();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void key_octave(const key_octave_sequence &s);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  key();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  key(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  key(const key &x, ::xml_schema::flags f = 0,
      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual key *_clone(::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  key &operator=(const key &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~key();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  cancel_optional cancel_;
  fifths_optional fifths_;
  mode_optional mode_;
  key_step_sequence key_step_;
  key_alter_sequence key_alter_;
  key_accidental_sequence key_accidental_;
  key_octave_sequence key_octave_;
  number_optional number_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  print_object_optional print_object_;

  //@endcond
};

/**
 * @brief Class corresponding to the %key-octave schema type.
 *
 * The key-octave element specifies in which octave an element of a key
 * signature appears. The content specifies the octave value using the
 * same values as the display-octave element. The number attribute is a
 * positive integer that refers to the key signature element in
 * left-to-right order. If the cancel attribute is set to yes, then this
 * number refers to an element specified by the cancel element. It is no
 * by default.
 *
 * @nosubgrouping
 */
class key_octave : public ::musicxml::octave {
public:
  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  //@}

  /**
   * @name cancel
   *
   * @brief Accessor and modifier functions for the %cancel
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no cancel_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<cancel_type> cancel_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<cancel_type, char> cancel_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const cancel_optional &cancel() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  cancel_optional &cancel();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void cancel(const cancel_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void cancel(const cancel_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void cancel(::std::unique_ptr<cancel_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  key_octave(const ::xml_schema::integer &, const number_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  key_octave(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  key_octave(const key_octave &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual key_octave *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  key_octave &operator=(const key_octave &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~key_octave();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<number_type> number_;
  cancel_optional cancel_;

  //@endcond
};

/**
 * @brief Class corresponding to the %measure-repeat schema type.
 *
 * The measure-repeat type is used for both single and multiple measure
 * repeats. The text of the element indicates the number of measures to
 * be repeated in a single pattern. The slashes attribute specifies the
 * number of slashes to use in the repeat sign. It is 1 if not specified.
 * Both the start and the stop of the measure-repeat must be specified.
 * The text of the element is ignored when the type is stop.
 *
 * The measure-repeat element specifies a notation style for repetitions.
 * The actual music being repeated needs to be repeated within the
 * MusicXML file. This element specifies the notation that indicates the
 * repeat.
 *
 * @nosubgrouping
 */
class measure_repeat : public ::musicxml::positive_integer_or_empty {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name slashes
   *
   * @brief Accessor and modifier functions for the %slashes
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer slashes_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<slashes_type> slashes_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<slashes_type, char> slashes_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const slashes_optional &slashes() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  slashes_optional &slashes();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void slashes(const slashes_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void slashes(const slashes_optional &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  measure_repeat(const char *, const type_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  measure_repeat(const ::std::string &, const type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  measure_repeat(const ::musicxml::positive_integer_or_empty &,
                 const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure_repeat(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_repeat(const measure_repeat &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual measure_repeat *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_repeat &operator=(const measure_repeat &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~measure_repeat();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  slashes_optional slashes_;

  //@endcond
};

/**
 * @brief Class corresponding to the %measure-style schema type.
 *
 * A measure-style indicates a special way to print partial to multiple
 * measures within a part. This includes multiple rests over several
 * measures, repeats of beats, single, or multiple measures, and use of
 * slash notation.
 *
 * The multiple-rest and measure-repeat symbols indicate the number of
 * measures covered in the element content. The beat-repeat and slash
 * elements can cover partial measures. All but the multiple-rest element
 * use a type attribute to indicate starting and stopping the use of the
 * style. The optional number attribute specifies the staff number from
 * top to bottom on the system, as with clef.
 *
 * @nosubgrouping
 */
class measure_style : public ::xml_schema::type {
public:
  /**
   * @name multiple-rest
   *
   * @brief Accessor and modifier functions for the %multiple-rest
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::multiple_rest multiple_rest_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<multiple_rest_type> multiple_rest_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<multiple_rest_type, char>
    multiple_rest_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const multiple_rest_optional &multiple_rest() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  multiple_rest_optional &multiple_rest();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void multiple_rest(const multiple_rest_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void multiple_rest(const multiple_rest_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void multiple_rest(::std::unique_ptr<multiple_rest_type> p);

  //@}

  /**
   * @name measure-repeat
   *
   * @brief Accessor and modifier functions for the %measure-repeat
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::measure_repeat measure_repeat_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<measure_repeat_type>
    measure_repeat_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<measure_repeat_type, char>
    measure_repeat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const measure_repeat_optional &measure_repeat() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  measure_repeat_optional &measure_repeat();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void measure_repeat(const measure_repeat_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void measure_repeat(const measure_repeat_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void measure_repeat(::std::unique_ptr<measure_repeat_type> p);

  //@}

  /**
   * @name beat-repeat
   *
   * @brief Accessor and modifier functions for the %beat-repeat
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::beat_repeat beat_repeat_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<beat_repeat_type> beat_repeat_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beat_repeat_type, char> beat_repeat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const beat_repeat_optional &beat_repeat() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  beat_repeat_optional &beat_repeat();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void beat_repeat(const beat_repeat_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void beat_repeat(const beat_repeat_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void beat_repeat(::std::unique_ptr<beat_repeat_type> p);

  //@}

  /**
   * @name slash
   *
   * @brief Accessor and modifier functions for the %slash
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::slash slash_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<slash_type> slash_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<slash_type, char> slash_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const slash_optional &slash() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  slash_optional &slash();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void slash(const slash_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void slash(const slash_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void slash(::std::unique_ptr<slash_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  measure_style();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure_style(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_style(const measure_style &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual measure_style *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_style &operator=(const measure_style &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~measure_style();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  multiple_rest_optional multiple_rest_;
  measure_repeat_optional measure_repeat_;
  beat_repeat_optional beat_repeat_;
  slash_optional slash_;
  number_optional number_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %multiple-rest schema type.
 *
 * The text of the multiple-rest type indicates the number of measures in
 * the multiple rest. Multiple rests may use the 1-bar / 2-bar / 4-bar
 * rest symbols, or a single shape. The use-symbols attribute indicates
 * which to use; it is no if not specified. The element text is ignored
 * when the type is stop.
 *
 * @nosubgrouping
 */
class multiple_rest : public ::musicxml::positive_integer_or_empty {
public:
  /**
   * @name use-symbols
   *
   * @brief Accessor and modifier functions for the %use-symbols
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no use_symbols_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<use_symbols_type> use_symbols_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<use_symbols_type, char> use_symbols_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const use_symbols_optional &use_symbols() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  use_symbols_optional &use_symbols();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void use_symbols(const use_symbols_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void use_symbols(const use_symbols_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void use_symbols(::std::unique_ptr<use_symbols_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  multiple_rest(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  multiple_rest(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  multiple_rest(const ::musicxml::positive_integer_or_empty &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  multiple_rest(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  multiple_rest(const multiple_rest &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual multiple_rest *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  multiple_rest &operator=(const multiple_rest &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~multiple_rest();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  use_symbols_optional use_symbols_;

  //@endcond
};

/**
 * @brief Class corresponding to the %part-symbol schema type.
 *
 * The part-symbol type indicates how a symbol for a multi-staff part is
 * indicated in the score; brace is the default value. The top-staff and
 * bottom-staff elements are used when the brace does not extend across
 * the entire part. For example, in a 3-staff organ part, the top-staff
 * will typically be 1 for the right hand, while the bottom-staff will
 * typically be 2 for the left hand. Staff 3 for the pedals is usually
 * outside the brace.
 *
 * @nosubgrouping
 */
class part_symbol : public ::musicxml::group_symbol_value {
public:
  /**
   * @name top-staff
   *
   * @brief Accessor and modifier functions for the %top-staff
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number top_staff_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<top_staff_type> top_staff_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<top_staff_type, char> top_staff_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const top_staff_optional &top_staff() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  top_staff_optional &top_staff();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void top_staff(const top_staff_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void top_staff(const top_staff_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void top_staff(::std::unique_ptr<top_staff_type> p);

  //@}

  /**
   * @name bottom-staff
   *
   * @brief Accessor and modifier functions for the %bottom-staff
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number bottom_staff_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bottom_staff_type> bottom_staff_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bottom_staff_type, char> bottom_staff_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bottom_staff_optional &bottom_staff() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bottom_staff_optional &bottom_staff();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bottom_staff(const bottom_staff_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bottom_staff(const bottom_staff_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bottom_staff(::std::unique_ptr<bottom_staff_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  part_symbol(::musicxml::group_symbol_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  part_symbol(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  part_symbol(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  part_symbol(const ::musicxml::group_symbol_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  part_symbol(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part_symbol(const part_symbol &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual part_symbol *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part_symbol &operator=(const part_symbol &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~part_symbol();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  top_staff_optional top_staff_;
  bottom_staff_optional bottom_staff_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %slash schema type.
 *
 * The slash type is used to indicate that slash notation is to be used.
 * If the slash is on every beat, use-stems is no (the default). To
 * indicate rhythms but not pitches, use-stems is set to yes. The type
 * attribute indicates whether this is the start or stop of a slash
 * notation style. The use-dots attribute works as for the beat-repeat
 * element, and only has effect if use-stems is no.
 *
 * @nosubgrouping
 */
class slash : public ::xml_schema::type {
public:
  /**
   * @name slash-type
   *
   * @brief Accessor and modifier functions for the %slash-type
   * optional element.
   *
   * The slash-type element indicates the graphical note type to use for
   * the display of repetition marks.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note_type_value slash_type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<slash_type_type> slash_type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<slash_type_type, char> slash_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const slash_type_optional &slash_type() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  slash_type_optional &slash_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void slash_type(const slash_type_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void slash_type(const slash_type_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void slash_type(::std::unique_ptr<slash_type_type> p);

  //@}

  /**
   * @name slash-dot
   *
   * @brief Accessor and modifier functions for the %slash-dot
   * sequence element.
   *
   * The slash-dot element is used to specify any augmentation dots in the
   * note type used to display repetition marks.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty slash_dot_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<slash_dot_type> slash_dot_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef slash_dot_sequence::iterator slash_dot_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef slash_dot_sequence::const_iterator slash_dot_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<slash_dot_type, char> slash_dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const slash_dot_sequence &slash_dot() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  slash_dot_sequence &slash_dot();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void slash_dot(const slash_dot_sequence &s);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name use-dots
   *
   * @brief Accessor and modifier functions for the %use-dots
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no use_dots_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<use_dots_type> use_dots_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<use_dots_type, char> use_dots_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const use_dots_optional &use_dots() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  use_dots_optional &use_dots();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void use_dots(const use_dots_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void use_dots(const use_dots_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void use_dots(::std::unique_ptr<use_dots_type> p);

  //@}

  /**
   * @name use-stems
   *
   * @brief Accessor and modifier functions for the %use-stems
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no use_stems_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<use_stems_type> use_stems_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<use_stems_type, char> use_stems_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const use_stems_optional &use_stems() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  use_stems_optional &use_stems();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void use_stems(const use_stems_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void use_stems(const use_stems_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void use_stems(::std::unique_ptr<use_stems_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  slash(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  slash(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  slash(const slash &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual slash *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  slash &operator=(const slash &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~slash();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  slash_type_optional slash_type_;
  slash_dot_sequence slash_dot_;
  ::xsd::cxx::tree::one<type_type> type_;
  use_dots_optional use_dots_;
  use_stems_optional use_stems_;

  //@endcond
};

/**
 * @brief Class corresponding to the %staff-details schema type.
 *
 * The staff-details element is used to indicate different types of
 * staves. The optional number attribute specifies the staff number from
 * top to bottom on the system, as with clef. The print-object attribute
 * is used to indicate when a staff is not printed in a part, usually in
 * large scores where empty parts are omitted. It is yes by default. If
 * print-spacing is yes while print-object is no, the score is printed in
 * cutaway format where vertical space is left for the empty part.
 *
 * @nosubgrouping
 */
class staff_details : public ::xml_schema::type {
public:
  /**
   * @name staff-type
   *
   * @brief Accessor and modifier functions for the %staff-type
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::staff_type staff_type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_type_type> staff_type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_type_type, char> staff_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_type_optional &staff_type() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staff_type_optional &staff_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staff_type(const staff_type_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staff_type(const staff_type_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void staff_type(::std::unique_ptr<staff_type_type> p);

  //@}

  /**
   * @name staff-lines
   *
   * @brief Accessor and modifier functions for the %staff-lines
   * optional element.
   *
   * The staff-lines element specifies the number of lines for a non 5-line
   * staff.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::non_negative_integer staff_lines_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_lines_type> staff_lines_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_lines_type, char> staff_lines_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_lines_optional &staff_lines() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staff_lines_optional &staff_lines();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staff_lines(const staff_lines_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staff_lines(const staff_lines_optional &x);

  //@}

  /**
   * @name staff-tuning
   *
   * @brief Accessor and modifier functions for the %staff-tuning
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::staff_tuning staff_tuning_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<staff_tuning_type> staff_tuning_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef staff_tuning_sequence::iterator staff_tuning_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef staff_tuning_sequence::const_iterator staff_tuning_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_tuning_type, char> staff_tuning_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const staff_tuning_sequence &staff_tuning() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  staff_tuning_sequence &staff_tuning();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void staff_tuning(const staff_tuning_sequence &s);

  //@}

  /**
   * @name capo
   *
   * @brief Accessor and modifier functions for the %capo
   * optional element.
   *
   * The capo element indicates at which fret a capo should be placed on a
   * fretted instrument. This changes the open tuning of the strings
   * specified by staff-tuning by the specified number of half-steps.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::non_negative_integer capo_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<capo_type> capo_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<capo_type, char> capo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const capo_optional &capo() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  capo_optional &capo();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void capo(const capo_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void capo(const capo_optional &x);

  //@}

  /**
   * @name staff-size
   *
   * @brief Accessor and modifier functions for the %staff-size
   * optional element.
   *
   * The staff-size element indicates how large a staff space is on this
   * staff, expressed as a percentage of the work's default scaling. Values
   * less than 100 make the staff space smaller while values over 100 make
   * the staff space larger. A staff-type of cue, ossia, or editorial
   * implies a staff-size of less than 100, but the exact value is
   * implementation-dependent unless specified here. Staff size affects
   * staff height only, not the relationship of the staff to the left and
   * right margins.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::non_negative_decimal staff_size_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_size_type> staff_size_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_size_type, char> staff_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_size_optional &staff_size() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staff_size_optional &staff_size();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staff_size(const staff_size_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staff_size(const staff_size_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void staff_size(::std::unique_ptr<staff_size_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name show-frets
   *
   * @brief Accessor and modifier functions for the %show-frets
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::show_frets show_frets_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<show_frets_type> show_frets_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<show_frets_type, char> show_frets_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const show_frets_optional &show_frets() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  show_frets_optional &show_frets();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void show_frets(const show_frets_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void show_frets(const show_frets_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void show_frets(::std::unique_ptr<show_frets_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name print-spacing
   *
   * @brief Accessor and modifier functions for the %print-spacing
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_spacing_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_spacing_type> print_spacing_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_spacing_type, char>
    print_spacing_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_spacing_optional &print_spacing() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_spacing_optional &print_spacing();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_spacing(const print_spacing_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_spacing(const print_spacing_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_spacing(::std::unique_ptr<print_spacing_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  staff_details();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_details(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_details(const staff_details &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual staff_details *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_details &operator=(const staff_details &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~staff_details();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  staff_type_optional staff_type_;
  staff_lines_optional staff_lines_;
  staff_tuning_sequence staff_tuning_;
  capo_optional capo_;
  staff_size_optional staff_size_;
  number_optional number_;
  show_frets_optional show_frets_;
  print_object_optional print_object_;
  print_spacing_optional print_spacing_;

  //@endcond
};

/**
 * @brief Class corresponding to the %staff-tuning schema type.
 *
 * The staff-tuning type specifies the open, non-capo tuning of the lines
 * on a tablature staff.
 *
 * @nosubgrouping
 */
class staff_tuning : public ::xml_schema::type {
public:
  /**
   * @name tuning-step
   *
   * @brief Accessor and modifier functions for the %tuning-step
   * required element.
   *
   * The tuning-step element is represented like the step element, with a
   * different name to reflect is different function.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::step tuning_step_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuning_step_type, char> tuning_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const tuning_step_type &tuning_step() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  tuning_step_type &tuning_step();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuning_step(const tuning_step_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void tuning_step(::std::unique_ptr<tuning_step_type> p);

  //@}

  /**
   * @name tuning-alter
   *
   * @brief Accessor and modifier functions for the %tuning-alter
   * optional element.
   *
   * The tuning-alter element is represented like the alter element, with a
   * different name to reflect is different function.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::semitones tuning_alter_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tuning_alter_type> tuning_alter_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuning_alter_type, char> tuning_alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tuning_alter_optional &tuning_alter() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tuning_alter_optional &tuning_alter();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuning_alter(const tuning_alter_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void tuning_alter(const tuning_alter_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tuning_alter(::std::unique_ptr<tuning_alter_type> p);

  //@}

  /**
   * @name tuning-octave
   *
   * @brief Accessor and modifier functions for the %tuning-octave
   * required element.
   *
   * The tuning-octave element is represented like the octave element, with
   * a different name to reflect is different function.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::octave tuning_octave_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuning_octave_type, char>
    tuning_octave_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const tuning_octave_type &tuning_octave() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  tuning_octave_type &tuning_octave();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuning_octave(const tuning_octave_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void tuning_octave(::std::unique_ptr<tuning_octave_type> p);

  //@}

  /**
   * @name line
   *
   * @brief Accessor and modifier functions for the %line
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_line line_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type> line_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type, char> line_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_optional &line() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_optional &line();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line(const line_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line(const line_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line(::std::unique_ptr<line_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  staff_tuning(const tuning_step_type &, const tuning_octave_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_tuning(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_tuning(const staff_tuning &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual staff_tuning *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_tuning &operator=(const staff_tuning &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~staff_tuning();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<tuning_step_type> tuning_step_;
  tuning_alter_optional tuning_alter_;
  ::xsd::cxx::tree::one<tuning_octave_type> tuning_octave_;
  line_optional line_;

  //@endcond
};

/**
 * @brief Class corresponding to the %time schema type.
 *
 * Time signatures are represented by the beats element for the numerator
 * and the beat-type element for the denominator. The symbol attribute is
 * used indicate common and cut time symbols as well as a single number
 * display. Multiple pairs of beat and beat-type elements are used for
 * composite time signatures with multiple denominators, such as 2/4 +
 * 3/8. A composite such as 3+2/8 requires only one beat/beat-type pair.
 *
 * The print-object attribute allows a time signature to be specified but
 * not printed, as is the case for excerpts from the middle of a score.
 * The value is "yes" if not present. The optional number attribute
 * refers to staff numbers within the part. If absent, the time signature
 * applies to all staves in the part.
 *
 * @nosubgrouping
 */
class time : public ::xml_schema::type {
public:
  /**
   * @name beats
   *
   * @brief Accessor and modifier functions for the %beats
   * sequence element.
   *
   * The beats element indicates the number of beats, as found in the
   * numerator of a time signature.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string beats_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<beats_type> beats_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef beats_sequence::iterator beats_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef beats_sequence::const_iterator beats_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beats_type, char> beats_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const beats_sequence &beats() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  beats_sequence &beats();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void beats(const beats_sequence &s);

  //@}

  /**
   * @name beat-type
   *
   * @brief Accessor and modifier functions for the %beat-type
   * sequence element.
   *
   * The beat-type element indicates the beat unit, as found in the
   * denominator of a time signature.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string beat_type_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<beat_type_type> beat_type_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef beat_type_sequence::iterator beat_type_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef beat_type_sequence::const_iterator beat_type_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beat_type_type, char> beat_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const beat_type_sequence &beat_type() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  beat_type_sequence &beat_type();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void beat_type(const beat_type_sequence &s);

  //@}

  /**
   * @name interchangeable
   *
   * @brief Accessor and modifier functions for the %interchangeable
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::interchangeable interchangeable_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<interchangeable_type>
    interchangeable_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<interchangeable_type, char>
    interchangeable_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const interchangeable_optional &interchangeable() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  interchangeable_optional &interchangeable();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void interchangeable(const interchangeable_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void interchangeable(const interchangeable_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void interchangeable(::std::unique_ptr<interchangeable_type> p);

  //@}

  /**
   * @name senza-misura
   *
   * @brief Accessor and modifier functions for the %senza-misura
   * optional element.
   *
   * A senza-misura element explicitly indicates that no time signature is
   * present. The optional element content indicates the symbol to be used,
   * if any, such as an X. The time element's symbol attribute is not used
   * when a senza-misura element is present.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string senza_misura_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<senza_misura_type> senza_misura_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<senza_misura_type, char> senza_misura_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const senza_misura_optional &senza_misura() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  senza_misura_optional &senza_misura();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void senza_misura(const senza_misura_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void senza_misura(const senza_misura_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void senza_misura(::std::unique_ptr<senza_misura_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name symbol
   *
   * @brief Accessor and modifier functions for the %symbol
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::time_symbol symbol_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<symbol_type> symbol_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<symbol_type, char> symbol_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const symbol_optional &symbol() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  symbol_optional &symbol();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void symbol(const symbol_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void symbol(const symbol_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void symbol(::std::unique_ptr<symbol_type> p);

  //@}

  /**
   * @name separator
   *
   * @brief Accessor and modifier functions for the %separator
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::time_separator separator_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<separator_type> separator_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<separator_type, char> separator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const separator_optional &separator() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  separator_optional &separator();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void separator(const separator_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void separator(const separator_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void separator(::std::unique_ptr<separator_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  time();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  time(const time &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual time *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  time &operator=(const time &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~time();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  beats_sequence beats_;
  beat_type_sequence beat_type_;
  interchangeable_optional interchangeable_;
  senza_misura_optional senza_misura_;
  number_optional number_;
  symbol_optional symbol_;
  separator_optional separator_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;
  print_object_optional print_object_;

  //@endcond
};

/**
 * @brief Class corresponding to the %transpose schema type.
 *
 * The transpose type represents what must be added to a written pitch to
 * get a correct sounding pitch. The optional number attribute refers to
 * staff numbers, from top to bottom on the system. If absent, the
 * transposition applies to all staves in the part. Per-staff
 * transposition is most often used in parts that represent multiple
 * instruments.
 *
 * @nosubgrouping
 */
class transpose : public ::xml_schema::type {
public:
  /**
   * @name diatonic
   *
   * @brief Accessor and modifier functions for the %diatonic
   * optional element.
   *
   * The diatonic element specifies the number of pitch steps needed to go
   * from written to sounding pitch. This allows for correct spelling of
   * enharmonic transpositions.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::integer diatonic_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<diatonic_type> diatonic_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<diatonic_type, char> diatonic_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const diatonic_optional &diatonic() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  diatonic_optional &diatonic();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void diatonic(const diatonic_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void diatonic(const diatonic_optional &x);

  //@}

  /**
   * @name chromatic
   *
   * @brief Accessor and modifier functions for the %chromatic
   * required element.
   *
   * The chromatic element represents the number of semitones needed to get
   * from written to sounding pitch. This value does not include
   * octave-change values; the values for both elements need to be added to
   * the written pitch to get the correct sounding pitch.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::semitones chromatic_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<chromatic_type, char> chromatic_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const chromatic_type &chromatic() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  chromatic_type &chromatic();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void chromatic(const chromatic_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void chromatic(::std::unique_ptr<chromatic_type> p);

  //@}

  /**
   * @name octave-change
   *
   * @brief Accessor and modifier functions for the %octave-change
   * optional element.
   *
   * The octave-change element indicates how many octaves to add to get
   * from written pitch to sounding pitch.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::integer octave_change_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<octave_change_type> octave_change_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<octave_change_type, char>
    octave_change_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const octave_change_optional &octave_change() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  octave_change_optional &octave_change();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void octave_change(const octave_change_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void octave_change(const octave_change_optional &x);

  //@}

  /**
   * @name double
   *
   * @brief Accessor and modifier functions for the %double
   * optional element.
   *
   * If the double element is present, it indicates that the music is
   * doubled one octave down from what is currently written (as is the case
   * for mixed cello / bass parts in orchestral literature).
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty double_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<double_type> double_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<double_type, char> double_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const double_optional &double_() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  double_optional &double_();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void double_(const double_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void double_(const double_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void double_(::std::unique_ptr<double_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  transpose(const chromatic_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  transpose(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  transpose(const transpose &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual transpose *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  transpose &operator=(const transpose &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~transpose();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  diatonic_optional diatonic_;
  ::xsd::cxx::tree::one<chromatic_type> chromatic_;
  octave_change_optional octave_change_;
  double_optional double__;
  number_optional number_;

  //@endcond
};

/**
 * @brief Class corresponding to the %bar-style-color schema type.
 *
 * The bar-style-color type contains barline style and color information.
 *
 * @nosubgrouping
 */
class bar_style_color : public ::musicxml::bar_style {
public:
  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  bar_style_color(::musicxml::bar_style::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  bar_style_color(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  bar_style_color(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  bar_style_color(const ::musicxml::bar_style &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bar_style_color(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bar_style_color(const bar_style_color &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bar_style_color *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bar_style_color &operator=(const bar_style_color &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~bar_style_color();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %barline schema type.
 *
 * If a barline is other than a normal single barline, it should be
 * represented by a barline type that describes it. This includes
 * information about repeats and multiple endings, as well as line style.
 * Barline data is on the same level as the other musical data in a score
 * - a child of a measure in a partwise score, or a part in a timewise
 * score. This allows for barlines within measures, as in dotted barlines
 * that subdivide measures in complex meters. The two fermata elements
 * allow for fermatas on both sides of the barline (the lower one
 * inverted).
 *
 * Barlines have a location attribute to make it easier to process
 * barlines independently of the other musical data in a score. It is
 * often easier to set up measures separately from entering notes. The
 * location attribute must match where the barline element occurs within
 * the rest of the musical data in the score. If location is left, it
 * should be the first element in the measure, aside from the print,
 * bookmark, and link elements. If location is right, it should be the
 * last element, again with the possible exception of the print,
 * bookmark, and link elements. If no location is specified, the right
 * barline is the default. The segno, coda, and divisions attributes work
 * the same way as in the sound element. They are used for playback when
 * barline elements contain segno or coda child elements.
 *
 * @nosubgrouping
 */
class barline : public ::xml_schema::type {
public:
  /**
   * @name bar-style
   *
   * @brief Accessor and modifier functions for the %bar-style
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bar_style_color bar_style_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bar_style_type> bar_style_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bar_style_type, char> bar_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bar_style_optional &bar_style() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  bar_style_optional &bar_style();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void bar_style(const bar_style_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void bar_style(const bar_style_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bar_style(::std::unique_ptr<bar_style_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name wavy-line
   *
   * @brief Accessor and modifier functions for the %wavy-line
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::wavy_line wavy_line_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<wavy_line_type> wavy_line_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<wavy_line_type, char> wavy_line_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const wavy_line_optional &wavy_line() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  wavy_line_optional &wavy_line();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void wavy_line(const wavy_line_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void wavy_line(const wavy_line_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void wavy_line(::std::unique_ptr<wavy_line_type> p);

  //@}

  /**
   * @name segno
   *
   * @brief Accessor and modifier functions for the %segno
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_style_align segno_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<segno_type> segno_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<segno_type, char> segno_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const segno_optional &segno() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  segno_optional &segno();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void segno(const segno_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void segno(const segno_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void segno(::std::unique_ptr<segno_type> p);

  //@}

  /**
   * @name coda
   *
   * @brief Accessor and modifier functions for the %coda
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_style_align coda_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<coda_type> coda_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<coda_type, char> coda_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const coda_optional &coda() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  coda_optional &coda();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void coda(const coda_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void coda(const coda_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void coda(::std::unique_ptr<coda_type> p);

  //@}

  /**
   * @name fermata
   *
   * @brief Accessor and modifier functions for the %fermata
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::fermata fermata_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fermata_type> fermata_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fermata_sequence::iterator fermata_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fermata_sequence::const_iterator fermata_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fermata_type, char> fermata_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fermata_sequence &fermata() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fermata_sequence &fermata();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fermata(const fermata_sequence &s);

  //@}

  /**
   * @name ending
   *
   * @brief Accessor and modifier functions for the %ending
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::ending ending_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<ending_type> ending_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ending_type, char> ending_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ending_optional &ending() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  ending_optional &ending();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void ending(const ending_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void ending(const ending_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void ending(::std::unique_ptr<ending_type> p);

  //@}

  /**
   * @name repeat
   *
   * @brief Accessor and modifier functions for the %repeat
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::repeat repeat_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<repeat_type> repeat_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<repeat_type, char> repeat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const repeat_optional &repeat() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  repeat_optional &repeat();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void repeat(const repeat_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void repeat(const repeat_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void repeat(::std::unique_ptr<repeat_type> p);

  //@}

  /**
   * @name location
   *
   * @brief Accessor and modifier functions for the %location
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::right_left_middle location_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<location_type, char> location_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const location_type &location() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  location_type &location();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void location(const location_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void location(::std::unique_ptr<location_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const location_type &location_default_value();

  //@}

  /**
   * @name segno
   *
   * @brief Accessor and modifier functions for the %segno
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token segno1_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<segno1_type> segno1_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<segno1_type, char> segno1_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const segno1_optional &segno1() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  segno1_optional &segno1();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void segno1(const segno1_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void segno1(const segno1_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void segno1(::std::unique_ptr<segno1_type> p);

  //@}

  /**
   * @name coda
   *
   * @brief Accessor and modifier functions for the %coda
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token coda1_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<coda1_type> coda1_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<coda1_type, char> coda1_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const coda1_optional &coda1() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  coda1_optional &coda1();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void coda1(const coda1_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void coda1(const coda1_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void coda1(::std::unique_ptr<coda1_type> p);

  //@}

  /**
   * @name divisions
   *
   * @brief Accessor and modifier functions for the %divisions
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions divisions_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<divisions_type> divisions_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<divisions_type, char> divisions_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const divisions_optional &divisions() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  divisions_optional &divisions();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void divisions(const divisions_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void divisions(const divisions_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void divisions(::std::unique_ptr<divisions_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  barline();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  barline(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  barline(const barline &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual barline *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  barline &operator=(const barline &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~barline();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  bar_style_optional bar_style_;
  footnote_optional footnote_;
  level_optional level_;
  wavy_line_optional wavy_line_;
  segno_optional segno_;
  coda_optional coda_;
  fermata_sequence fermata_;
  ending_optional ending_;
  repeat_optional repeat_;
  ::xsd::cxx::tree::one<location_type> location_;
  static const location_type location_default_value_;
  segno1_optional segno1_;
  coda1_optional coda1_;
  divisions_optional divisions_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ending schema type.
 *
 * The ending type represents multiple (e.g. first and second) endings.
 * Typically, the start type is associated with the left barline of the
 * first measure in an ending. The stop and discontinue types are
 * associated with the right barline of the last measure in an ending.
 * Stop is used when the ending mark concludes with a downward jog, as is
 * typical for first endings. Discontinue is used when there is no
 * downward jog, as is typical for second endings that do not conclude a
 * piece. The length of the jog can be specified using the end-length
 * attribute. The text-x and text-y attributes are offsets that specify
 * where the baseline of the start of the ending text appears, relative
 * to the start of the ending line.
 *
 * The number attribute reflects the numeric values of what is under the
 * ending line. Single endings such as "1" or comma-separated multiple
 * endings such as "1,2" may be used. The ending element text is used
 * when the text displayed in the ending is different than what appears
 * in the number attribute. The print-object element is used to indicate
 * when an ending is present but not printed, as is often the case for
 * many parts in a full score.
 *
 * @nosubgrouping
 */
class ending : public ::xml_schema::string {
public:
  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::ending_number number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_discontinue type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name end-length
   *
   * @brief Accessor and modifier functions for the %end-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths end_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<end_length_type> end_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<end_length_type, char> end_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const end_length_optional &end_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  end_length_optional &end_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void end_length(const end_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void end_length(const end_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void end_length(::std::unique_ptr<end_length_type> p);

  //@}

  /**
   * @name text-x
   *
   * @brief Accessor and modifier functions for the %text-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths text_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<text_x_type> text_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_x_type, char> text_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const text_x_optional &text_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  text_x_optional &text_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void text_x(const text_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void text_x(const text_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void text_x(::std::unique_ptr<text_x_type> p);

  //@}

  /**
   * @name text-y
   *
   * @brief Accessor and modifier functions for the %text-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths text_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<text_y_type> text_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_y_type, char> text_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const text_y_optional &text_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  text_y_optional &text_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void text_y(const text_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void text_y(const text_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void text_y(::std::unique_ptr<text_y_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  ending(const number_type &, const type_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  ending(const char *, const number_type &, const type_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  ending(const ::std::string &, const number_type &, const type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ending(const ::xml_schema::string &, const number_type &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ending(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ending(const ending &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ending *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ending &operator=(const ending &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~ending();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<number_type> number_;
  ::xsd::cxx::tree::one<type_type> type_;
  print_object_optional print_object_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  end_length_optional end_length_;
  text_x_optional text_x_;
  text_y_optional text_y_;

  //@endcond
};

/**
 * @brief Class corresponding to the %repeat schema type.
 *
 * The repeat type represents repeat marks. The start of the repeat has a
 * forward direction while the end of the repeat has a backward
 * direction. Backward repeats that are not part of an ending can use the
 * times attribute to indicate the number of times the repeated section
 * is played.
 *
 * @nosubgrouping
 */
class repeat : public ::xml_schema::type {
public:
  /**
   * @name direction
   *
   * @brief Accessor and modifier functions for the %direction
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::backward_forward direction_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<direction_type, char> direction_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const direction_type &direction() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  direction_type &direction();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void direction(const direction_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void direction(::std::unique_ptr<direction_type> p);

  //@}

  /**
   * @name times
   *
   * @brief Accessor and modifier functions for the %times
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer times_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<times_type> times_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<times_type, char> times_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const times_optional &times() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  times_optional &times();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void times(const times_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void times(const times_optional &x);

  //@}

  /**
   * @name winged
   *
   * @brief Accessor and modifier functions for the %winged
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::winged winged_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<winged_type> winged_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<winged_type, char> winged_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const winged_optional &winged() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  winged_optional &winged();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void winged(const winged_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void winged(const winged_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void winged(::std::unique_ptr<winged_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  repeat(const direction_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  repeat(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  repeat(const repeat &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual repeat *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  repeat &operator=(const repeat &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~repeat();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<direction_type> direction_;
  times_optional times_;
  winged_optional winged_;

  //@endcond
};

/**
 * @brief Class corresponding to the %accord schema type.
 *
 * The accord type represents the tuning of a single string in the
 * scordatura element. It uses the same group of elements as the
 * staff-tuning element. Strings are numbered from high to low.
 *
 * @nosubgrouping
 */
class accord : public ::xml_schema::type {
public:
  /**
   * @name tuning-step
   *
   * @brief Accessor and modifier functions for the %tuning-step
   * required element.
   *
   * The tuning-step element is represented like the step element, with a
   * different name to reflect is different function.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::step tuning_step_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuning_step_type, char> tuning_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const tuning_step_type &tuning_step() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  tuning_step_type &tuning_step();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuning_step(const tuning_step_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void tuning_step(::std::unique_ptr<tuning_step_type> p);

  //@}

  /**
   * @name tuning-alter
   *
   * @brief Accessor and modifier functions for the %tuning-alter
   * optional element.
   *
   * The tuning-alter element is represented like the alter element, with a
   * different name to reflect is different function.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::semitones tuning_alter_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tuning_alter_type> tuning_alter_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuning_alter_type, char> tuning_alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tuning_alter_optional &tuning_alter() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tuning_alter_optional &tuning_alter();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuning_alter(const tuning_alter_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void tuning_alter(const tuning_alter_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tuning_alter(::std::unique_ptr<tuning_alter_type> p);

  //@}

  /**
   * @name tuning-octave
   *
   * @brief Accessor and modifier functions for the %tuning-octave
   * required element.
   *
   * The tuning-octave element is represented like the octave element, with
   * a different name to reflect is different function.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::octave tuning_octave_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuning_octave_type, char>
    tuning_octave_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const tuning_octave_type &tuning_octave() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  tuning_octave_type &tuning_octave();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuning_octave(const tuning_octave_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void tuning_octave(::std::unique_ptr<tuning_octave_type> p);

  //@}

  /**
   * @name string
   *
   * @brief Accessor and modifier functions for the %string
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::string_number string_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<string_type> string_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<string_type, char> string_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const string_optional &string() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  string_optional &string();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void string(const string_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void string(const string_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void string(::std::unique_ptr<string_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  accord(const tuning_step_type &, const tuning_octave_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accord(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accord(const accord &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual accord *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accord &operator=(const accord &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~accord();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<tuning_step_type> tuning_step_;
  tuning_alter_optional tuning_alter_;
  ::xsd::cxx::tree::one<tuning_octave_type> tuning_octave_;
  string_optional string_;

  //@endcond
};

/**
 * @brief Class corresponding to the %accordion-registration schema type.
 *
 * The accordion-registration type is use for accordion registration
 * symbols. These are circular symbols divided horizontally into high,
 * middle, and low sections that correspond to 4', 8', and 16' pipes.
 * Each accordion-high, accordion-middle, and accordion-low element
 * represents the presence of one or more dots in the registration
 * diagram. An accordion-registration element needs to have at least one
 * of the child elements present.
 *
 * @nosubgrouping
 */
class accordion_registration : public ::xml_schema::type {
public:
  /**
   * @name accordion-high
   *
   * @brief Accessor and modifier functions for the %accordion-high
   * optional element.
   *
   * The accordion-high element indicates the presence of a dot in the high
   * (4') section of the registration symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty accordion_high_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accordion_high_type>
    accordion_high_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accordion_high_type, char>
    accordion_high_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accordion_high_optional &accordion_high() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  accordion_high_optional &accordion_high();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void accordion_high(const accordion_high_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void accordion_high(const accordion_high_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accordion_high(::std::unique_ptr<accordion_high_type> p);

  //@}

  /**
   * @name accordion-middle
   *
   * @brief Accessor and modifier functions for the %accordion-middle
   * optional element.
   *
   * The accordion-middle element indicates the presence of 1 to 3 dots in
   * the middle (8') section of the registration symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accordion_middle accordion_middle_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accordion_middle_type>
    accordion_middle_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accordion_middle_type, char>
    accordion_middle_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accordion_middle_optional &accordion_middle() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  accordion_middle_optional &accordion_middle();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void accordion_middle(const accordion_middle_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void accordion_middle(const accordion_middle_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accordion_middle(::std::unique_ptr<accordion_middle_type> p);

  //@}

  /**
   * @name accordion-low
   *
   * @brief Accessor and modifier functions for the %accordion-low
   * optional element.
   *
   * The accordion-low element indicates the presence of a dot in the low
   * (16') section of the registration symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty accordion_low_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accordion_low_type> accordion_low_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accordion_low_type, char>
    accordion_low_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accordion_low_optional &accordion_low() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  accordion_low_optional &accordion_low();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void accordion_low(const accordion_low_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void accordion_low(const accordion_low_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accordion_low(::std::unique_ptr<accordion_low_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  accordion_registration();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accordion_registration(const ::xercesc::DOMElement &e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accordion_registration(const accordion_registration &x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual accordion_registration *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accordion_registration &operator=(const accordion_registration &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~accordion_registration();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  accordion_high_optional accordion_high_;
  accordion_middle_optional accordion_middle_;
  accordion_low_optional accordion_low_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %barre schema type.
 *
 * The barre element indicates placing a finger over multiple strings on
 * a single fret. The type is "start" for the lowest pitched string
 * (e.g., the string with the highest MusicXML number) and is "stop" for
 * the highest pitched string.
 *
 * @nosubgrouping
 */
class barre : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  barre(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  barre(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  barre(const barre &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual barre *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  barre &operator=(const barre &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~barre();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %bass schema type.
 *
 * The bass type is used to indicate a bass note in popular music chord
 * symbols, e.g. G/C. It is generally not used in functional harmony, as
 * inversion is generally not used in pop chord symbols. As with root, it
 * is divided into step and alter elements, similar to pitches.
 *
 * @nosubgrouping
 */
class bass : public ::xml_schema::type {
public:
  /**
   * @name bass-step
   *
   * @brief Accessor and modifier functions for the %bass-step
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bass_step bass_step_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bass_step_type, char> bass_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const bass_step_type &bass_step() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  bass_step_type &bass_step();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void bass_step(const bass_step_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void bass_step(::std::unique_ptr<bass_step_type> p);

  //@}

  /**
   * @name bass-alter
   *
   * @brief Accessor and modifier functions for the %bass-alter
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bass_alter bass_alter_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bass_alter_type> bass_alter_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bass_alter_type, char> bass_alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bass_alter_optional &bass_alter() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  bass_alter_optional &bass_alter();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void bass_alter(const bass_alter_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void bass_alter(const bass_alter_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bass_alter(::std::unique_ptr<bass_alter_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  bass(const bass_step_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  bass(::std::unique_ptr<bass_step_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bass(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bass(const bass &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bass *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bass &operator=(const bass &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~bass();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<bass_step_type> bass_step_;
  bass_alter_optional bass_alter_;

  //@endcond
};

/**
 * @brief Class corresponding to the %bass-alter schema type.
 *
 * The bass-alter type represents the chromatic alteration of the bass of
 * the current chord within the harmony element. In some chord styles,
 * the text for the bass-step element may include bass-alter information.
 * In that case, the print-object attribute of the bass-alter element can
 * be set to no. The location attribute indicates whether the alteration
 * should appear to the left or the right of the bass-step; it is right
 * by default.
 *
 * @nosubgrouping
 */
class bass_alter : public ::musicxml::semitones {
public:
  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name location
   *
   * @brief Accessor and modifier functions for the %location
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_right location_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<location_type> location_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<location_type, char> location_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const location_optional &location() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  location_optional &location();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void location(const location_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void location(const location_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void location(::std::unique_ptr<location_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  bass_alter(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bass_alter(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bass_alter(const bass_alter &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bass_alter *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bass_alter &operator=(const bass_alter &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~bass_alter();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  print_object_optional print_object_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  location_optional location_;

  //@endcond
};

/**
 * @brief Class corresponding to the %bass-step schema type.
 *
 * The bass-step type represents the pitch step of the bass of the
 * current chord within the harmony element. The text attribute indicates
 * how the bass should appear in a score if not using the element
 * contents.
 *
 * @nosubgrouping
 */
class bass_step : public ::musicxml::step {
public:
  /**
   * @name text
   *
   * @brief Accessor and modifier functions for the %text
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token text_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<text_type> text_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_type, char> text_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const text_optional &text() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  text_optional &text();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void text(const text_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void text(const text_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void text(::std::unique_ptr<text_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  bass_step(::musicxml::step::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  bass_step(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  bass_step(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  bass_step(const ::musicxml::step &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bass_step(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bass_step(const bass_step &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bass_step *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bass_step &operator=(const bass_step &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~bass_step();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  text_optional text_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %beater schema type.
 *
 * The beater type represents pictograms for beaters, mallets, and sticks
 * that do not have different materials represented in the pictogram.
 *
 * @nosubgrouping
 */
class beater : public ::musicxml::beater_value {
public:
  /**
   * @name tip
   *
   * @brief Accessor and modifier functions for the %tip
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tip_direction tip_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tip_type> tip_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<tip_type, char> tip_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tip_optional &tip() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  tip_optional &tip();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void tip(const tip_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void tip(const tip_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tip(::std::unique_ptr<tip_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  beater(::musicxml::beater_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  beater(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  beater(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  beater(const ::musicxml::beater_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beater(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beater(const beater &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual beater *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beater &operator=(const beater &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~beater();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  tip_optional tip_;

  //@endcond
};

/**
 * @brief Class corresponding to the %bracket schema type.
 *
 * Brackets are combined with words in a variety of modern directions.
 * The line-end attribute specifies if there is a jog up or down (or
 * both), an arrow, or nothing at the start or end of the bracket. If the
 * line-end is up or down, the length of the jog can be specified using
 * the end-length attribute. The line-type is solid by default.
 *
 * @nosubgrouping
 */
class bracket : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_continue type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name line-end
   *
   * @brief Accessor and modifier functions for the %line-end
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_end line_end_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_end_type, char> line_end_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const line_end_type &line_end() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  line_end_type &line_end();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_end(const line_end_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void line_end(::std::unique_ptr<line_end_type> p);

  //@}

  /**
   * @name end-length
   *
   * @brief Accessor and modifier functions for the %end-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths end_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<end_length_type> end_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<end_length_type, char> end_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const end_length_optional &end_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  end_length_optional &end_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void end_length(const end_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void end_length(const end_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void end_length(::std::unique_ptr<end_length_type> p);

  //@}

  /**
   * @name line-type
   *
   * @brief Accessor and modifier functions for the %line-type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_type line_type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type_type> line_type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type_type, char> line_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_type_optional &line_type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_type_optional &line_type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_type(const line_type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_type(const line_type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_type(::std::unique_ptr<line_type_type> p);

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  bracket(const type_type &, const line_end_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bracket(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bracket(const bracket &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bracket *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bracket &operator=(const bracket &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~bracket();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  number_optional number_;
  ::xsd::cxx::tree::one<line_end_type> line_end_;
  end_length_optional end_length_;
  line_type_optional line_type_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %dashes schema type.
 *
 * The dashes type represents dashes, used for instance with cresc. and
 * dim. marks.
 *
 * @nosubgrouping
 */
class dashes : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_continue type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  dashes(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  dashes(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  dashes(const dashes &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual dashes *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  dashes &operator=(const dashes &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~dashes();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  number_optional number_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %degree schema type.
 *
 * The degree type is used to add, alter, or subtract individual notes in
 * the chord. The print-object attribute can be used to keep the degree
 * from printing separately when it has already taken into account in the
 * text attribute of the kind element. The degree-value and degree-type
 * text attributes specify how the value and type of the degree should be
 * displayed.
 *
 * A harmony of kind "other" can be spelled explicitly by using a series
 * of degree elements together with a root.
 *
 * @nosubgrouping
 */
class degree : public ::xml_schema::type {
public:
  /**
   * @name degree-value
   *
   * @brief Accessor and modifier functions for the %degree-value
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::degree_value degree_value_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<degree_value_type, char> degree_value_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const degree_value_type &degree_value() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  degree_value_type &degree_value();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void degree_value(const degree_value_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void degree_value(::std::unique_ptr<degree_value_type> p);

  //@}

  /**
   * @name degree-alter
   *
   * @brief Accessor and modifier functions for the %degree-alter
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::degree_alter degree_alter_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<degree_alter_type, char> degree_alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const degree_alter_type &degree_alter() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  degree_alter_type &degree_alter();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void degree_alter(const degree_alter_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void degree_alter(::std::unique_ptr<degree_alter_type> p);

  //@}

  /**
   * @name degree-type
   *
   * @brief Accessor and modifier functions for the %degree-type
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::degree_type degree_type_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<degree_type_type, char> degree_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const degree_type_type &degree_type() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  degree_type_type &degree_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void degree_type(const degree_type_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void degree_type(::std::unique_ptr<degree_type_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  degree(const degree_value_type &, const degree_alter_type &,
         const degree_type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  degree(::std::unique_ptr<degree_value_type>,
         ::std::unique_ptr<degree_alter_type>,
         ::std::unique_ptr<degree_type_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree(const degree &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual degree *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree &operator=(const degree &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~degree();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<degree_value_type> degree_value_;
  ::xsd::cxx::tree::one<degree_alter_type> degree_alter_;
  ::xsd::cxx::tree::one<degree_type_type> degree_type_;
  print_object_optional print_object_;

  //@endcond
};

/**
 * @brief Class corresponding to the %degree-alter schema type.
 *
 * The degree-alter type represents the chromatic alteration for the
 * current degree. If the degree-type value is alter or subtract, the
 * degree-alter value is relative to the degree already in the chord
 * based on its kind element. If the degree-type value is add, the
 * degree-alter is relative to a dominant chord (major and perfect
 * intervals except for a minor seventh). The plus-minus attribute is
 * used to indicate if plus and minus symbols should be used instead of
 * sharp and flat symbols to display the degree alteration; it is no by
 * default.
 *
 * @nosubgrouping
 */
class degree_alter : public ::musicxml::semitones {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name plus-minus
   *
   * @brief Accessor and modifier functions for the %plus-minus
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no plus_minus_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<plus_minus_type> plus_minus_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<plus_minus_type, char> plus_minus_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const plus_minus_optional &plus_minus() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  plus_minus_optional &plus_minus();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void plus_minus(const plus_minus_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void plus_minus(const plus_minus_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void plus_minus(::std::unique_ptr<plus_minus_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  degree_alter(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_alter(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree_alter(const degree_alter &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual degree_alter *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree_alter &operator=(const degree_alter &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~degree_alter();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  plus_minus_optional plus_minus_;

  //@endcond
};

/**
 * @brief Class corresponding to the %degree-type schema type.
 *
 * The degree-type type indicates if this degree is an addition,
 * alteration, or subtraction relative to the kind of the current chord.
 * The value of the degree-type element affects the interpretation of the
 * value of the degree-alter element. The text attribute specifies how
 * the type of the degree should be displayed in a score.
 *
 * @nosubgrouping
 */
class degree_type : public ::musicxml::degree_type_value {
public:
  /**
   * @name text
   *
   * @brief Accessor and modifier functions for the %text
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token text_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<text_type> text_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_type, char> text_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const text_optional &text() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  text_optional &text();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void text(const text_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void text(const text_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void text(::std::unique_ptr<text_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  degree_type(::musicxml::degree_type_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  degree_type(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  degree_type(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  degree_type(const ::musicxml::degree_type_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree_type(const degree_type &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual degree_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree_type &operator=(const degree_type &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~degree_type();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  text_optional text_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %degree-value schema type.
 *
 * The content of the degree-value type is a number indicating the degree
 * of the chord (1 for the root, 3 for third, etc). The text attribute
 * specifies how the type of the degree should be displayed in a score.
 * The degree-value symbol attribute indicates that a symbol should be
 * used in specifying the degree. If the symbol attribute is present, the
 * value of the text attribute follows the symbol.
 *
 * @nosubgrouping
 */
class degree_value
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name symbol
   *
   * @brief Accessor and modifier functions for the %symbol
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::degree_symbol_value symbol_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<symbol_type> symbol_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<symbol_type, char> symbol_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const symbol_optional &symbol() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  symbol_optional &symbol();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void symbol(const symbol_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void symbol(const symbol_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void symbol(::std::unique_ptr<symbol_type> p);

  //@}

  /**
   * @name text
   *
   * @brief Accessor and modifier functions for the %text
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token text_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<text_type> text_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_type, char> text_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const text_optional &text() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  text_optional &text();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void text(const text_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void text(const text_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void text(::std::unique_ptr<text_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  degree_value(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  degree_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree_value(const degree_value &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual degree_value *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  degree_value &operator=(const degree_value &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~degree_value();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  symbol_optional symbol_;
  text_optional text_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %direction schema type.
 *
 * A direction is a musical indication that is not attached to a specific
 * note. Two or more may be combined to indicate starts and stops of
 * wedges, dashes, etc.
 *
 * By default, a series of direction-type elements and a series of child
 * elements of a direction-type within a single direction element follow
 * one another in sequence visually. For a series of direction-type
 * children, non-positional formatting attributes are carried over from
 * the previous element by default.
 *
 * @nosubgrouping
 */
class direction : public ::xml_schema::type {
public:
  /**
   * @name direction-type
   *
   * @brief Accessor and modifier functions for the %direction-type
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::direction_type direction_type_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<direction_type_type>
    direction_type_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef direction_type_sequence::iterator direction_type_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef direction_type_sequence::const_iterator direction_type_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<direction_type_type, char>
    direction_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const direction_type_sequence &direction_type() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  direction_type_sequence &direction_type();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void direction_type(const direction_type_sequence &s);

  //@}

  /**
   * @name offset
   *
   * @brief Accessor and modifier functions for the %offset
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::offset offset_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<offset_type> offset_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<offset_type, char> offset_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const offset_optional &offset() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  offset_optional &offset();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void offset(const offset_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void offset(const offset_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void offset(::std::unique_ptr<offset_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name voice
   *
   * @brief Accessor and modifier functions for the %voice
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string voice_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<voice_type> voice_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<voice_type, char> voice_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const voice_optional &voice() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  voice_optional &voice();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void voice(const voice_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void voice(const voice_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void voice(::std::unique_ptr<voice_type> p);

  //@}

  /**
   * @name staff
   *
   * @brief Accessor and modifier functions for the %staff
   * optional element.
   *
   * Staff assignment is only needed for music notated on multiple staves.
   * Used by both notes and directions. Staff values are numbers, with 1
   * referring to the top-most staff in a part.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::positive_integer staff_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_type> staff_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_type, char> staff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_optional &staff() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staff_optional &staff();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staff(const staff_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staff(const staff_optional &x);

  //@}

  /**
   * @name sound
   *
   * @brief Accessor and modifier functions for the %sound
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::sound sound_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<sound_type> sound_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sound_type, char> sound_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sound_optional &sound() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sound_optional &sound();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void sound(const sound_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void sound(const sound_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void sound(::std::unique_ptr<sound_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name directive
   *
   * @brief Accessor and modifier functions for the %directive
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no directive_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<directive_type> directive_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<directive_type, char> directive_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const directive_optional &directive() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  directive_optional &directive();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void directive(const directive_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void directive(const directive_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void directive(::std::unique_ptr<directive_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  direction();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  direction(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  direction(const direction &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual direction *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  direction &operator=(const direction &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~direction();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  direction_type_sequence direction_type_;
  offset_optional offset_;
  footnote_optional footnote_;
  level_optional level_;
  voice_optional voice_;
  staff_optional staff_;
  sound_optional sound_;
  placement_optional placement_;
  directive_optional directive_;

  //@endcond
};

/**
 * @brief Class corresponding to the %direction-type schema type.
 *
 * Textual direction types may have more than 1 component due to multiple
 * fonts. The dynamics element may also be used in the notations element.
 * Attribute groups related to print suggestions apply to the individual
 * direction-type, not to the overall direction.
 *
 * @nosubgrouping
 */
class direction_type : public ::xml_schema::type {
public:
  /**
   * @name rehearsal
   *
   * @brief Accessor and modifier functions for the %rehearsal
   * sequence element.
   *
   * The rehearsal type specifies a rehearsal mark. Language is Italian
   * ("it") by default. Enclosure is square by default. Left justification
   * is assumed if not specified.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text rehearsal_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<rehearsal_type> rehearsal_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef rehearsal_sequence::iterator rehearsal_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef rehearsal_sequence::const_iterator rehearsal_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rehearsal_type, char> rehearsal_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const rehearsal_sequence &rehearsal() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  rehearsal_sequence &rehearsal();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void rehearsal(const rehearsal_sequence &s);

  //@}

  /**
   * @name segno
   *
   * @brief Accessor and modifier functions for the %segno
   * sequence element.
   *
   * The segno element is the visual indicator of a segno sign. A sound
   * element is needed to guide playback applications reliably.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_style_align segno_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<segno_type> segno_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef segno_sequence::iterator segno_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef segno_sequence::const_iterator segno_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<segno_type, char> segno_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const segno_sequence &segno() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  segno_sequence &segno();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void segno(const segno_sequence &s);

  //@}

  /**
   * @name words
   *
   * @brief Accessor and modifier functions for the %words
   * sequence element.
   *
   * The words element specifies a standard text direction. Left
   * justification is assumed if not specified. Language is Italian ("it")
   * by default. Enclosure is none by default.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text words_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<words_type> words_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef words_sequence::iterator words_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef words_sequence::const_iterator words_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<words_type, char> words_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const words_sequence &words() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  words_sequence &words();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void words(const words_sequence &s);

  //@}

  /**
   * @name coda
   *
   * @brief Accessor and modifier functions for the %coda
   * sequence element.
   *
   * The coda element is the visual indicator of a coda sign. A sound
   * element is needed to guide playback applications reliably.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_style_align coda_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<coda_type> coda_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef coda_sequence::iterator coda_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef coda_sequence::const_iterator coda_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<coda_type, char> coda_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const coda_sequence &coda() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  coda_sequence &coda();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void coda(const coda_sequence &s);

  //@}

  /**
   * @name wedge
   *
   * @brief Accessor and modifier functions for the %wedge
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::wedge wedge_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<wedge_type> wedge_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<wedge_type, char> wedge_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const wedge_optional &wedge() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  wedge_optional &wedge();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void wedge(const wedge_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void wedge(const wedge_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void wedge(::std::unique_ptr<wedge_type> p);

  //@}

  /**
   * @name dynamics
   *
   * @brief Accessor and modifier functions for the %dynamics
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::dynamics dynamics_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<dynamics_type> dynamics_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef dynamics_sequence::iterator dynamics_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef dynamics_sequence::const_iterator dynamics_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<dynamics_type, char> dynamics_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const dynamics_sequence &dynamics() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  dynamics_sequence &dynamics();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void dynamics(const dynamics_sequence &s);

  //@}

  /**
   * @name dashes
   *
   * @brief Accessor and modifier functions for the %dashes
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::dashes dashes_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dashes_type> dashes_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<dashes_type, char> dashes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dashes_optional &dashes() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  dashes_optional &dashes();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void dashes(const dashes_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void dashes(const dashes_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dashes(::std::unique_ptr<dashes_type> p);

  //@}

  /**
   * @name bracket
   *
   * @brief Accessor and modifier functions for the %bracket
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bracket bracket_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bracket_type> bracket_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bracket_type, char> bracket_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bracket_optional &bracket() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  bracket_optional &bracket();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void bracket(const bracket_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void bracket(const bracket_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bracket(::std::unique_ptr<bracket_type> p);

  //@}

  /**
   * @name pedal
   *
   * @brief Accessor and modifier functions for the %pedal
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::pedal pedal_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<pedal_type> pedal_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pedal_type, char> pedal_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const pedal_optional &pedal() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  pedal_optional &pedal();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void pedal(const pedal_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void pedal(const pedal_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void pedal(::std::unique_ptr<pedal_type> p);

  //@}

  /**
   * @name metronome
   *
   * @brief Accessor and modifier functions for the %metronome
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::metronome metronome_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<metronome_type> metronome_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<metronome_type, char> metronome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const metronome_optional &metronome() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  metronome_optional &metronome();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void metronome(const metronome_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void metronome(const metronome_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void metronome(::std::unique_ptr<metronome_type> p);

  //@}

  /**
   * @name octave-shift
   *
   * @brief Accessor and modifier functions for the %octave-shift
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::octave_shift octave_shift_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<octave_shift_type> octave_shift_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<octave_shift_type, char> octave_shift_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const octave_shift_optional &octave_shift() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  octave_shift_optional &octave_shift();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void octave_shift(const octave_shift_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void octave_shift(const octave_shift_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void octave_shift(::std::unique_ptr<octave_shift_type> p);

  //@}

  /**
   * @name harp-pedals
   *
   * @brief Accessor and modifier functions for the %harp-pedals
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::harp_pedals harp_pedals_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<harp_pedals_type> harp_pedals_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<harp_pedals_type, char> harp_pedals_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const harp_pedals_optional &harp_pedals() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  harp_pedals_optional &harp_pedals();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void harp_pedals(const harp_pedals_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void harp_pedals(const harp_pedals_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void harp_pedals(::std::unique_ptr<harp_pedals_type> p);

  //@}

  /**
   * @name damp
   *
   * @brief Accessor and modifier functions for the %damp
   * optional element.
   *
   * The damp element specifies a harp damping mark.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_style_align damp_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<damp_type> damp_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<damp_type, char> damp_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const damp_optional &damp() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  damp_optional &damp();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void damp(const damp_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void damp(const damp_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void damp(::std::unique_ptr<damp_type> p);

  //@}

  /**
   * @name damp-all
   *
   * @brief Accessor and modifier functions for the %damp-all
   * optional element.
   *
   * The damp-all element specifies a harp damping mark for all strings.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_style_align damp_all_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<damp_all_type> damp_all_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<damp_all_type, char> damp_all_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const damp_all_optional &damp_all() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  damp_all_optional &damp_all();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void damp_all(const damp_all_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void damp_all(const damp_all_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void damp_all(::std::unique_ptr<damp_all_type> p);

  //@}

  /**
   * @name eyeglasses
   *
   * @brief Accessor and modifier functions for the %eyeglasses
   * optional element.
   *
   * The eyeglasses element specifies the eyeglasses symbol, common in
   * commercial music.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_style_align eyeglasses_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<eyeglasses_type> eyeglasses_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<eyeglasses_type, char> eyeglasses_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const eyeglasses_optional &eyeglasses() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  eyeglasses_optional &eyeglasses();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void eyeglasses(const eyeglasses_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void eyeglasses(const eyeglasses_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void eyeglasses(::std::unique_ptr<eyeglasses_type> p);

  //@}

  /**
   * @name string-mute
   *
   * @brief Accessor and modifier functions for the %string-mute
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::string_mute string_mute_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<string_mute_type> string_mute_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<string_mute_type, char> string_mute_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const string_mute_optional &string_mute() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  string_mute_optional &string_mute();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void string_mute(const string_mute_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void string_mute(const string_mute_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void string_mute(::std::unique_ptr<string_mute_type> p);

  //@}

  /**
   * @name scordatura
   *
   * @brief Accessor and modifier functions for the %scordatura
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::scordatura scordatura_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<scordatura_type> scordatura_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<scordatura_type, char> scordatura_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const scordatura_optional &scordatura() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  scordatura_optional &scordatura();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void scordatura(const scordatura_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void scordatura(const scordatura_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void scordatura(::std::unique_ptr<scordatura_type> p);

  //@}

  /**
   * @name image
   *
   * @brief Accessor and modifier functions for the %image
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::image image_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<image_type> image_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<image_type, char> image_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const image_optional &image() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  image_optional &image();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void image(const image_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void image(const image_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void image(::std::unique_ptr<image_type> p);

  //@}

  /**
   * @name principal-voice
   *
   * @brief Accessor and modifier functions for the %principal-voice
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::principal_voice principal_voice_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<principal_voice_type>
    principal_voice_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<principal_voice_type, char>
    principal_voice_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const principal_voice_optional &principal_voice() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  principal_voice_optional &principal_voice();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void principal_voice(const principal_voice_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void principal_voice(const principal_voice_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void principal_voice(::std::unique_ptr<principal_voice_type> p);

  //@}

  /**
   * @name accordion-registration
   *
   * @brief Accessor and modifier functions for the %accordion-registration
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accordion_registration accordion_registration_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accordion_registration_type>
    accordion_registration_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accordion_registration_type, char>
    accordion_registration_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accordion_registration_optional &accordion_registration() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  accordion_registration_optional &accordion_registration();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void accordion_registration(const accordion_registration_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void accordion_registration(const accordion_registration_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accordion_registration(::std::unique_ptr<accordion_registration_type> p);

  //@}

  /**
   * @name percussion
   *
   * @brief Accessor and modifier functions for the %percussion
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::percussion percussion_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<percussion_type> percussion_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef percussion_sequence::iterator percussion_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef percussion_sequence::const_iterator percussion_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<percussion_type, char> percussion_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const percussion_sequence &percussion() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  percussion_sequence &percussion();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void percussion(const percussion_sequence &s);

  //@}

  /**
   * @name other-direction
   *
   * @brief Accessor and modifier functions for the %other-direction
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::other_direction other_direction_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<other_direction_type>
    other_direction_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_direction_type, char>
    other_direction_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const other_direction_optional &other_direction() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  other_direction_optional &other_direction();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void other_direction(const other_direction_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void other_direction(const other_direction_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void other_direction(::std::unique_ptr<other_direction_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  direction_type();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  direction_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  direction_type(const direction_type &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual direction_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  direction_type &operator=(const direction_type &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~direction_type();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  rehearsal_sequence rehearsal_;
  segno_sequence segno_;
  words_sequence words_;
  coda_sequence coda_;
  wedge_optional wedge_;
  dynamics_sequence dynamics_;
  dashes_optional dashes_;
  bracket_optional bracket_;
  pedal_optional pedal_;
  metronome_optional metronome_;
  octave_shift_optional octave_shift_;
  harp_pedals_optional harp_pedals_;
  damp_optional damp_;
  damp_all_optional damp_all_;
  eyeglasses_optional eyeglasses_;
  string_mute_optional string_mute_;
  scordatura_optional scordatura_;
  image_optional image_;
  principal_voice_optional principal_voice_;
  accordion_registration_optional accordion_registration_;
  percussion_sequence percussion_;
  other_direction_optional other_direction_;

  //@endcond
};

/**
 * @brief Class corresponding to the %feature schema type.
 *
 * The feature type is a part of the grouping element used for musical
 * analysis. The type attribute represents the type of the feature and
 * the element content represents its value. This type is flexible to
 * allow for different analyses.
 *
 * @nosubgrouping
 */
class feature : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<type_type> type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional &type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  type_optional &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void type(const type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  feature();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  feature(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  feature(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  feature(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  feature(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  feature(const feature &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual feature *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  feature &operator=(const feature &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~feature();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  type_optional type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %first-fret schema type.
 *
 * The first-fret type indicates which fret is shown in the top space of
 * the frame; it is fret 1 if the element is not present. The optional
 * text attribute indicates how this is represented in the fret diagram,
 * while the location attribute indicates whether the text appears to the
 * left or right of the frame.
 *
 * @nosubgrouping
 */
class first_fret
  : public ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer,
                                              char, ::xml_schema::simple_type> {
public:
  /**
   * @name text
   *
   * @brief Accessor and modifier functions for the %text
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token text_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<text_type> text_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_type, char> text_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const text_optional &text() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  text_optional &text();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void text(const text_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void text(const text_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void text(::std::unique_ptr<text_type> p);

  //@}

  /**
   * @name location
   *
   * @brief Accessor and modifier functions for the %location
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_right location_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<location_type> location_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<location_type, char> location_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const location_optional &location() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  location_optional &location();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void location(const location_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void location(const location_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void location(::std::unique_ptr<location_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  first_fret(const ::xml_schema::positive_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  first_fret(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  first_fret(const first_fret &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual first_fret *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  first_fret &operator=(const first_fret &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~first_fret();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  text_optional text_;
  location_optional location_;

  //@endcond
};

/**
 * @brief Class corresponding to the %frame schema type.
 *
 * The frame type represents a frame or fretboard diagram used together
 * with a chord symbol. The representation is based on the NIFF guitar
 * grid with additional information. The frame type's unplayed attribute
 * indicates what to display above a string that has no associated
 * frame-note element. Typical values are x and the empty string. If the
 * attribute is not present, the display of the unplayed string is
 * application-defined.
 *
 * @nosubgrouping
 */
class frame : public ::xml_schema::type {
public:
  /**
   * @name frame-strings
   *
   * @brief Accessor and modifier functions for the %frame-strings
   * required element.
   *
   * The frame-strings element gives the overall size of the frame in
   * vertical lines (strings).
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::positive_integer frame_strings_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<frame_strings_type, char>
    frame_strings_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const frame_strings_type &frame_strings() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  frame_strings_type &frame_strings();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void frame_strings(const frame_strings_type &x);

  //@}

  /**
   * @name frame-frets
   *
   * @brief Accessor and modifier functions for the %frame-frets
   * required element.
   *
   * The frame-frets element gives the overall size of the frame in
   * horizontal spaces (frets).
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::positive_integer frame_frets_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<frame_frets_type, char> frame_frets_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const frame_frets_type &frame_frets() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  frame_frets_type &frame_frets();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void frame_frets(const frame_frets_type &x);

  //@}

  /**
   * @name first-fret
   *
   * @brief Accessor and modifier functions for the %first-fret
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::first_fret first_fret_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<first_fret_type> first_fret_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<first_fret_type, char> first_fret_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const first_fret_optional &first_fret() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  first_fret_optional &first_fret();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void first_fret(const first_fret_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void first_fret(const first_fret_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void first_fret(::std::unique_ptr<first_fret_type> p);

  //@}

  /**
   * @name frame-note
   *
   * @brief Accessor and modifier functions for the %frame-note
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::frame_note frame_note_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<frame_note_type> frame_note_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef frame_note_sequence::iterator frame_note_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef frame_note_sequence::const_iterator frame_note_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<frame_note_type, char> frame_note_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const frame_note_sequence &frame_note() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  frame_note_sequence &frame_note();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void frame_note(const frame_note_sequence &s);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign_image valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name height
   *
   * @brief Accessor and modifier functions for the %height
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths height_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<height_type> height_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<height_type, char> height_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const height_optional &height() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  height_optional &height();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void height(const height_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void height(const height_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void height(::std::unique_ptr<height_type> p);

  //@}

  /**
   * @name width
   *
   * @brief Accessor and modifier functions for the %width
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths width_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<width_type> width_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<width_type, char> width_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const width_optional &width() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  width_optional &width();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void width(const width_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void width(const width_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void width(::std::unique_ptr<width_type> p);

  //@}

  /**
   * @name unplayed
   *
   * @brief Accessor and modifier functions for the %unplayed
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token unplayed_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<unplayed_type> unplayed_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<unplayed_type, char> unplayed_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const unplayed_optional &unplayed() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  unplayed_optional &unplayed();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void unplayed(const unplayed_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void unplayed(const unplayed_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void unplayed(::std::unique_ptr<unplayed_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  frame(const frame_strings_type &, const frame_frets_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  frame(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  frame(const frame &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual frame *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  frame &operator=(const frame &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~frame();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<frame_strings_type> frame_strings_;
  ::xsd::cxx::tree::one<frame_frets_type> frame_frets_;
  first_fret_optional first_fret_;
  frame_note_sequence frame_note_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;
  height_optional height_;
  width_optional width_;
  unplayed_optional unplayed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %frame-note schema type.
 *
 * The frame-note type represents each note included in the frame. An
 * open string will have a fret value of 0, while a muted string will not
 * be associated with a frame-note element.
 *
 * @nosubgrouping
 */
class frame_note : public ::xml_schema::type {
public:
  /**
   * @name string
   *
   * @brief Accessor and modifier functions for the %string
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::string string_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<string_type, char> string_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const string_type &string() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  string_type &string();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void string(const string_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void string(::std::unique_ptr<string_type> p);

  //@}

  /**
   * @name fret
   *
   * @brief Accessor and modifier functions for the %fret
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::fret fret_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fret_type, char> fret_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const fret_type &fret() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  fret_type &fret();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void fret(const fret_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void fret(::std::unique_ptr<fret_type> p);

  //@}

  /**
   * @name fingering
   *
   * @brief Accessor and modifier functions for the %fingering
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::fingering fingering_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<fingering_type> fingering_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fingering_type, char> fingering_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const fingering_optional &fingering() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  fingering_optional &fingering();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void fingering(const fingering_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void fingering(const fingering_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void fingering(::std::unique_ptr<fingering_type> p);

  //@}

  /**
   * @name barre
   *
   * @brief Accessor and modifier functions for the %barre
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::barre barre_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<barre_type> barre_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<barre_type, char> barre_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const barre_optional &barre() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  barre_optional &barre();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void barre(const barre_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void barre(const barre_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void barre(::std::unique_ptr<barre_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  frame_note(const string_type &, const fret_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  frame_note(::std::unique_ptr<string_type>, ::std::unique_ptr<fret_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  frame_note(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  frame_note(const frame_note &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual frame_note *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  frame_note &operator=(const frame_note &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~frame_note();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<string_type> string_;
  ::xsd::cxx::tree::one<fret_type> fret_;
  fingering_optional fingering_;
  barre_optional barre_;

  //@endcond
};

/**
 * @brief Class corresponding to the %grouping schema type.
 *
 * The grouping type is used for musical analysis. When the type
 * attribute is "start" or "single", it usually contains one or more
 * feature elements. The number attribute is used for distinguishing
 * between overlapping and hierarchical groupings. The member-of
 * attribute allows for easy distinguishing of what grouping elements are
 * in what hierarchy. Feature elements contained within a "stop" type of
 * grouping may be ignored.
 *
 * This element is flexible to allow for different types of analyses.
 * Future versions of the MusicXML format may add elements that can
 * represent more standardized categories of analysis data, allowing for
 * easier data sharing.
 *
 * @nosubgrouping
 */
class grouping : public ::xml_schema::type {
public:
  /**
   * @name feature
   *
   * @brief Accessor and modifier functions for the %feature
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::feature feature_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<feature_type> feature_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef feature_sequence::iterator feature_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef feature_sequence::const_iterator feature_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<feature_type, char> feature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const feature_sequence &feature() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  feature_sequence &feature();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void feature(const feature_sequence &s);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_single type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const number_type &number_default_value();

  //@}

  /**
   * @name member-of
   *
   * @brief Accessor and modifier functions for the %member-of
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token member_of_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<member_of_type> member_of_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<member_of_type, char> member_of_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const member_of_optional &member_of() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  member_of_optional &member_of();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void member_of(const member_of_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void member_of(const member_of_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void member_of(::std::unique_ptr<member_of_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  grouping(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  grouping(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  grouping(const grouping &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual grouping *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  grouping &operator=(const grouping &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~grouping();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  feature_sequence feature_;
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<number_type> number_;
  static const number_type number_default_value_;
  member_of_optional member_of_;

  //@endcond
};

/**
 * @brief Class corresponding to the %harmony schema type.
 *
 * The harmony type is based on Humdrum's **harm encoding, extended to
 * support chord symbols in popular music as well as functional harmony
 * analysis in classical music.
 *
 * If there are alternate harmonies possible, this can be specified using
 * multiple harmony elements differentiated by type. Explicit harmonies
 * have all note present in the music; implied have some notes missing
 * but implied; alternate represents alternate analyses.
 *
 * The harmony object may be used for analysis or for chord symbols. The
 * print-object attribute controls whether or not anything is printed due
 * to the harmony element. The print-frame attribute controls printing of
 * a frame or fretboard diagram. The print-style attribute group sets the
 * default for the harmony, but individual elements can override this
 * with their own print-style values.
 *
 * @nosubgrouping
 */
class harmony : public ::xml_schema::type {
public:
  /**
   * @name root
   *
   * @brief Accessor and modifier functions for the %root
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::root root_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<root_type> root_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef root_sequence::iterator root_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef root_sequence::const_iterator root_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<root_type, char> root_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const root_sequence &root() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  root_sequence &root();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void root(const root_sequence &s);

  //@}

  /**
   * @name function
   *
   * @brief Accessor and modifier functions for the %function
   * sequence element.
   *
   * The function element is used to represent classical functional harmony
   * with an indication like I, II, III rather than C, D, E. It is relative
   * to the key that is specified in the MusicXML encoding.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::style_text function_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<function_type> function_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef function_sequence::iterator function_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef function_sequence::const_iterator function_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<function_type, char> function_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const function_sequence &function() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  function_sequence &function();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void function(const function_sequence &s);

  //@}

  /**
   * @name kind
   *
   * @brief Accessor and modifier functions for the %kind
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::kind kind_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<kind_type> kind_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef kind_sequence::iterator kind_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef kind_sequence::const_iterator kind_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<kind_type, char> kind_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const kind_sequence &kind() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  kind_sequence &kind();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void kind(const kind_sequence &s);

  //@}

  /**
   * @name inversion
   *
   * @brief Accessor and modifier functions for the %inversion
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::inversion inversion_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<inversion_type> inversion_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef inversion_sequence::iterator inversion_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef inversion_sequence::const_iterator inversion_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<inversion_type, char> inversion_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const inversion_sequence &inversion() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  inversion_sequence &inversion();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void inversion(const inversion_sequence &s);

  //@}

  /**
   * @name bass
   *
   * @brief Accessor and modifier functions for the %bass
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bass bass_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<bass_type> bass_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef bass_sequence::iterator bass_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef bass_sequence::const_iterator bass_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bass_type, char> bass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const bass_sequence &bass() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  bass_sequence &bass();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void bass(const bass_sequence &s);

  //@}

  /**
   * @name degree
   *
   * @brief Accessor and modifier functions for the %degree
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::degree degree_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<degree_type> degree_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef degree_sequence::iterator degree_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef degree_sequence::const_iterator degree_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<degree_type, char> degree_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const degree_sequence &degree() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  degree_sequence &degree();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void degree(const degree_sequence &s);

  //@}

  /**
   * @name frame
   *
   * @brief Accessor and modifier functions for the %frame
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::frame frame_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<frame_type> frame_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<frame_type, char> frame_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const frame_optional &frame() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  frame_optional &frame();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void frame(const frame_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void frame(const frame_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void frame(::std::unique_ptr<frame_type> p);

  //@}

  /**
   * @name offset
   *
   * @brief Accessor and modifier functions for the %offset
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::offset offset_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<offset_type> offset_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<offset_type, char> offset_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const offset_optional &offset() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  offset_optional &offset();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void offset(const offset_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void offset(const offset_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void offset(::std::unique_ptr<offset_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name staff
   *
   * @brief Accessor and modifier functions for the %staff
   * optional element.
   *
   * Staff assignment is only needed for music notated on multiple staves.
   * Used by both notes and directions. Staff values are numbers, with 1
   * referring to the top-most staff in a part.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::positive_integer staff_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_type> staff_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_type, char> staff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_optional &staff() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staff_optional &staff();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staff(const staff_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staff(const staff_optional &x);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::harmony_type type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<type_type> type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional &type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  type_optional &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void type(const type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name print-frame
   *
   * @brief Accessor and modifier functions for the %print-frame
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_frame_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_frame_type> print_frame_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_frame_type, char> print_frame_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_frame_optional &print_frame() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_frame_optional &print_frame();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_frame(const print_frame_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_frame(const print_frame_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_frame(::std::unique_ptr<print_frame_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  harmony();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  harmony(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  harmony(const harmony &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual harmony *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  harmony &operator=(const harmony &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~harmony();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  root_sequence root_;
  function_sequence function_;
  kind_sequence kind_;
  inversion_sequence inversion_;
  bass_sequence bass_;
  degree_sequence degree_;
  frame_optional frame_;
  offset_optional offset_;
  footnote_optional footnote_;
  level_optional level_;
  staff_optional staff_;
  type_optional type_;
  print_object_optional print_object_;
  print_frame_optional print_frame_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %harp-pedals schema type.
 *
 * The harp-pedals type is used to create harp pedal diagrams. The
 * pedal-step and pedal-alter elements use the same values as the step
 * and alter elements. For easiest reading, the pedal-tuning elements
 * should follow standard harp pedal order, with pedal-step values of D,
 * C, B, E, F, G, and A.
 *
 * @nosubgrouping
 */
class harp_pedals : public ::xml_schema::type {
public:
  /**
   * @name pedal-tuning
   *
   * @brief Accessor and modifier functions for the %pedal-tuning
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::pedal_tuning pedal_tuning_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<pedal_tuning_type> pedal_tuning_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef pedal_tuning_sequence::iterator pedal_tuning_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef pedal_tuning_sequence::const_iterator pedal_tuning_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pedal_tuning_type, char> pedal_tuning_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const pedal_tuning_sequence &pedal_tuning() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  pedal_tuning_sequence &pedal_tuning();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void pedal_tuning(const pedal_tuning_sequence &s);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  harp_pedals();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  harp_pedals(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  harp_pedals(const harp_pedals &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual harp_pedals *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  harp_pedals &operator=(const harp_pedals &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~harp_pedals();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  pedal_tuning_sequence pedal_tuning_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %image schema type.
 *
 * The image type is used to include graphical images in a score.
 *
 * @nosubgrouping
 */
class image : public ::xml_schema::type {
public:
  /**
   * @name source
   *
   * @brief Accessor and modifier functions for the %source
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::uri source_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<source_type, char> source_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const source_type &source() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  source_type &source();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void source(const source_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void source(::std::unique_ptr<source_type> p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign_image valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  image(const source_type &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  image(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  image(const image &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual image *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  image &operator=(const image &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~image();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<source_type> source_;
  ::xsd::cxx::tree::one<type_type> type_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %inversion schema type.
 *
 * The inversion type represents harmony inversions. The value is a
 * number indicating which inversion is used: 0 for root position, 1 for
 * first inversion, etc.
 *
 * @nosubgrouping
 */
class inversion
  : public ::xsd::cxx::tree::fundamental_base<
      ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  inversion(const ::xml_schema::non_negative_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  inversion(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  inversion(const inversion &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual inversion *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  inversion &operator=(const inversion &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~inversion();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %kind schema type.
 *
 * Kind indicates the type of chord. Degree elements can then add,
 * subtract, or alter from these starting points
 *
 * The attributes are used to indicate the formatting of the symbol.
 * Since the kind element is the constant in all the harmony-chord groups
 * that can make up a polychord, many formatting attributes are here.
 *
 * The use-symbols attribute is yes if the kind should be represented
 * when possible with harmony symbols rather than letters and numbers.
 * These symbols include:
 *
 * major: a triangle, like Unicode 25B3
 * minor: -, like Unicode 002D
 * augmented: +, like Unicode 002B
 * diminished: ?, like Unicode 00B0
 * half-diminished: ?, like Unicode 00F8
 *
 * For the major-minor kind, only the minor symbol is used when
 * use-symbols is yes. The major symbol is set using the symbol attribute
 * in the degree-value element. The corresponding degree-alter value will
 * usually be 0 in this case.
 *
 * The text attribute describes how the kind should be spelled in a
 * score. If use-symbols is yes, the value of the text attribute follows
 * the symbol. The stack-degrees attribute is yes if the degree elements
 * should be stacked above each other. The parentheses-degrees attribute
 * is yes if all the degrees should be in parentheses. The
 * bracket-degrees attribute is yes if all the degrees should be in a
 * bracket. If not specified, these values are implementation-specific.
 * The alignment attributes are for the entire harmony-chord group of
 * which this kind element is a part.
 *
 * @nosubgrouping
 */
class kind : public ::musicxml::kind_value {
public:
  /**
   * @name use-symbols
   *
   * @brief Accessor and modifier functions for the %use-symbols
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no use_symbols_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<use_symbols_type> use_symbols_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<use_symbols_type, char> use_symbols_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const use_symbols_optional &use_symbols() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  use_symbols_optional &use_symbols();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void use_symbols(const use_symbols_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void use_symbols(const use_symbols_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void use_symbols(::std::unique_ptr<use_symbols_type> p);

  //@}

  /**
   * @name text
   *
   * @brief Accessor and modifier functions for the %text
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token text_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<text_type> text_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_type, char> text_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const text_optional &text() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  text_optional &text();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void text(const text_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void text(const text_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void text(::std::unique_ptr<text_type> p);

  //@}

  /**
   * @name stack-degrees
   *
   * @brief Accessor and modifier functions for the %stack-degrees
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no stack_degrees_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<stack_degrees_type> stack_degrees_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<stack_degrees_type, char>
    stack_degrees_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const stack_degrees_optional &stack_degrees() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  stack_degrees_optional &stack_degrees();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void stack_degrees(const stack_degrees_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void stack_degrees(const stack_degrees_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void stack_degrees(::std::unique_ptr<stack_degrees_type> p);

  //@}

  /**
   * @name parentheses-degrees
   *
   * @brief Accessor and modifier functions for the %parentheses-degrees
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no parentheses_degrees_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<parentheses_degrees_type>
    parentheses_degrees_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<parentheses_degrees_type, char>
    parentheses_degrees_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const parentheses_degrees_optional &parentheses_degrees() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  parentheses_degrees_optional &parentheses_degrees();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void parentheses_degrees(const parentheses_degrees_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void parentheses_degrees(const parentheses_degrees_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void parentheses_degrees(::std::unique_ptr<parentheses_degrees_type> p);

  //@}

  /**
   * @name bracket-degrees
   *
   * @brief Accessor and modifier functions for the %bracket-degrees
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no bracket_degrees_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bracket_degrees_type>
    bracket_degrees_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bracket_degrees_type, char>
    bracket_degrees_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bracket_degrees_optional &bracket_degrees() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bracket_degrees_optional &bracket_degrees();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bracket_degrees(const bracket_degrees_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bracket_degrees(const bracket_degrees_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bracket_degrees(::std::unique_ptr<bracket_degrees_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  kind(::musicxml::kind_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  kind(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  kind(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  kind(const ::musicxml::kind_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  kind(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  kind(const kind &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual kind *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  kind &operator=(const kind &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~kind();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  use_symbols_optional use_symbols_;
  text_optional text_;
  stack_degrees_optional stack_degrees_;
  parentheses_degrees_optional parentheses_degrees_;
  bracket_degrees_optional bracket_degrees_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %measure-numbering schema type.
 *
 * The measure-numbering type describes how frequently measure numbers
 * are displayed on this part. The number attribute from the measure
 * element is used for printing. Measures with an implicit attribute set
 * to "yes" never display a measure number, regardless of the
 * measure-numbering setting.
 *
 * @nosubgrouping
 */
class measure_numbering : public ::musicxml::measure_numbering_value {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  measure_numbering(::musicxml::measure_numbering_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  measure_numbering(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  measure_numbering(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  measure_numbering(const ::musicxml::measure_numbering_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure_numbering(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_numbering(const measure_numbering &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual measure_numbering *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_numbering &operator=(const measure_numbering &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~measure_numbering();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %metronome schema type.
 *
 * The metronome type represents metronome marks and other metric
 * relationships. The beat-unit group and per-minute element specify
 * regular metronome marks. The metronome-note and metronome-relation
 * elements allow for the specification of more complicated metric
 * relationships, such as swing tempo marks where two eighths are equated
 * to a quarter note / eighth note triplet. The parentheses attribute
 * indicates whether or not to put the metronome mark in parentheses; its
 * value is no if not specified.
 *
 * @nosubgrouping
 */
class metronome : public ::xml_schema::type {
public:
  /**
   * @name beat-unit
   *
   * @brief Accessor and modifier functions for the %beat-unit
   * sequence element.
   *
   * The beat-unit element indicates the graphical note type to use in a
   * metronome mark.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note_type_value beat_unit_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<beat_unit_type> beat_unit_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef beat_unit_sequence::iterator beat_unit_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef beat_unit_sequence::const_iterator beat_unit_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beat_unit_type, char> beat_unit_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const beat_unit_sequence &beat_unit() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  beat_unit_sequence &beat_unit();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void beat_unit(const beat_unit_sequence &s);

  //@}

  /**
   * @name beat-unit-dot
   *
   * @brief Accessor and modifier functions for the %beat-unit-dot
   * sequence element.
   *
   * The beat-unit-dot element is used to specify any augmentation dots for
   * a metronome mark note.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty beat_unit_dot_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<beat_unit_dot_type> beat_unit_dot_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef beat_unit_dot_sequence::iterator beat_unit_dot_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef beat_unit_dot_sequence::const_iterator beat_unit_dot_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beat_unit_dot_type, char>
    beat_unit_dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const beat_unit_dot_sequence &beat_unit_dot() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  beat_unit_dot_sequence &beat_unit_dot();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void beat_unit_dot(const beat_unit_dot_sequence &s);

  //@}

  /**
   * @name per-minute
   *
   * @brief Accessor and modifier functions for the %per-minute
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::per_minute per_minute_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<per_minute_type> per_minute_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<per_minute_type, char> per_minute_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const per_minute_optional &per_minute() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  per_minute_optional &per_minute();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void per_minute(const per_minute_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void per_minute(const per_minute_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void per_minute(::std::unique_ptr<per_minute_type> p);

  //@}

  /**
   * @name metronome-note
   *
   * @brief Accessor and modifier functions for the %metronome-note
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::metronome_note metronome_note_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<metronome_note_type>
    metronome_note_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef metronome_note_sequence::iterator metronome_note_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef metronome_note_sequence::const_iterator metronome_note_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<metronome_note_type, char>
    metronome_note_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const metronome_note_sequence &metronome_note() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  metronome_note_sequence &metronome_note();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void metronome_note(const metronome_note_sequence &s);

  //@}

  /**
   * @name metronome-relation
   *
   * @brief Accessor and modifier functions for the %metronome-relation
   * optional element.
   *
   * The metronome-relation element describes the relationship symbol that
   * goes between the two sets of metronome-note elements. The currently
   * allowed value is equals, but this may expand in future versions. If
   * the element is empty, the equals value is used.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string metronome_relation_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<metronome_relation_type>
    metronome_relation_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<metronome_relation_type, char>
    metronome_relation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const metronome_relation_optional &metronome_relation() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  metronome_relation_optional &metronome_relation();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void metronome_relation(const metronome_relation_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void metronome_relation(const metronome_relation_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void metronome_relation(::std::unique_ptr<metronome_relation_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name justify
   *
   * @brief Accessor and modifier functions for the %justify
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right justify_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<justify_type> justify_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<justify_type, char> justify_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const justify_optional &justify() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  justify_optional &justify();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void justify(const justify_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void justify(const justify_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void justify(::std::unique_ptr<justify_type> p);

  //@}

  /**
   * @name parentheses
   *
   * @brief Accessor and modifier functions for the %parentheses
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no parentheses_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<parentheses_type> parentheses_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<parentheses_type, char> parentheses_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const parentheses_optional &parentheses() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  parentheses_optional &parentheses();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void parentheses(const parentheses_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void parentheses(const parentheses_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void parentheses(::std::unique_ptr<parentheses_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  metronome();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  metronome(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metronome(const metronome &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual metronome *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metronome &operator=(const metronome &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~metronome();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  beat_unit_sequence beat_unit_;
  beat_unit_dot_sequence beat_unit_dot_;
  per_minute_optional per_minute_;
  metronome_note_sequence metronome_note_;
  metronome_relation_optional metronome_relation_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;
  justify_optional justify_;
  parentheses_optional parentheses_;

  //@endcond
};

/**
 * @brief Class corresponding to the %metronome-beam schema type.
 *
 * The metronome-beam type works like the beam type in defining metric
 * relationships, but does not include all the attributes available in
 * the beam type.
 *
 * @nosubgrouping
 */
class metronome_beam : public ::musicxml::beam_value {
public:
  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::beam_level number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static number_type number_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  metronome_beam(::musicxml::beam_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  metronome_beam(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  metronome_beam(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  metronome_beam(const ::musicxml::beam_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  metronome_beam(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metronome_beam(const metronome_beam &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual metronome_beam *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metronome_beam &operator=(const metronome_beam &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~metronome_beam();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<number_type> number_;

  //@endcond
};

/**
 * @brief Class corresponding to the %metronome-note schema type.
 *
 * The metronome-note type defines the appearance of a note within a
 * metric relationship mark.
 *
 * @nosubgrouping
 */
class metronome_note : public ::xml_schema::type {
public:
  /**
   * @name metronome-type
   *
   * @brief Accessor and modifier functions for the %metronome-type
   * required element.
   *
   * The metronome-type element works like the type element in defining
   * metric relationships.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note_type_value metronome_type_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<metronome_type_type, char>
    metronome_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const metronome_type_type &metronome_type() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  metronome_type_type &metronome_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void metronome_type(const metronome_type_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void metronome_type(::std::unique_ptr<metronome_type_type> p);

  //@}

  /**
   * @name metronome-dot
   *
   * @brief Accessor and modifier functions for the %metronome-dot
   * sequence element.
   *
   * The metronome-dot element works like the dot element in defining
   * metric relationships.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty metronome_dot_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<metronome_dot_type> metronome_dot_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef metronome_dot_sequence::iterator metronome_dot_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef metronome_dot_sequence::const_iterator metronome_dot_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<metronome_dot_type, char>
    metronome_dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const metronome_dot_sequence &metronome_dot() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  metronome_dot_sequence &metronome_dot();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void metronome_dot(const metronome_dot_sequence &s);

  //@}

  /**
   * @name metronome-beam
   *
   * @brief Accessor and modifier functions for the %metronome-beam
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::metronome_beam metronome_beam_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<metronome_beam_type>
    metronome_beam_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef metronome_beam_sequence::iterator metronome_beam_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef metronome_beam_sequence::const_iterator metronome_beam_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<metronome_beam_type, char>
    metronome_beam_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const metronome_beam_sequence &metronome_beam() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  metronome_beam_sequence &metronome_beam();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void metronome_beam(const metronome_beam_sequence &s);

  //@}

  /**
   * @name metronome-tuplet
   *
   * @brief Accessor and modifier functions for the %metronome-tuplet
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::metronome_tuplet metronome_tuplet_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<metronome_tuplet_type>
    metronome_tuplet_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<metronome_tuplet_type, char>
    metronome_tuplet_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const metronome_tuplet_optional &metronome_tuplet() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  metronome_tuplet_optional &metronome_tuplet();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void metronome_tuplet(const metronome_tuplet_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void metronome_tuplet(const metronome_tuplet_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void metronome_tuplet(::std::unique_ptr<metronome_tuplet_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  metronome_note(const metronome_type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  metronome_note(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metronome_note(const metronome_note &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual metronome_note *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metronome_note &operator=(const metronome_note &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~metronome_note();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<metronome_type_type> metronome_type_;
  metronome_dot_sequence metronome_dot_;
  metronome_beam_sequence metronome_beam_;
  metronome_tuplet_optional metronome_tuplet_;

  //@endcond
};

/**
 * @brief Class corresponding to the %time-modification schema type.
 *
 * Time modification indicates tuplets, double-note tremolos, and other
 * durational changes. A time-modification element shows how the
 * cumulative, sounding effect of tuplets and double-note tremolos
 * compare to the written note type represented by the type and dot
 * elements. Nested tuplets and other notations that use more detailed
 * information need both the time-modification and tuplet elements to be
 * represented accurately.
 *
 * @nosubgrouping
 */
class time_modification : public ::xml_schema::type {
public:
  /**
   * @name actual-notes
   *
   * @brief Accessor and modifier functions for the %actual-notes
   * required element.
   *
   * The actual-notes element describes how many notes are played in the
   * time usually occupied by the number in the normal-notes element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::non_negative_integer actual_notes_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<actual_notes_type, char> actual_notes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const actual_notes_type &actual_notes() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  actual_notes_type &actual_notes();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void actual_notes(const actual_notes_type &x);

  //@}

  /**
   * @name normal-notes
   *
   * @brief Accessor and modifier functions for the %normal-notes
   * required element.
   *
   * The normal-notes element describes how many notes are usually played
   * in the time occupied by the number in the actual-notes element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::non_negative_integer normal_notes_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<normal_notes_type, char> normal_notes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const normal_notes_type &normal_notes() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  normal_notes_type &normal_notes();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void normal_notes(const normal_notes_type &x);

  //@}

  /**
   * @name normal-type
   *
   * @brief Accessor and modifier functions for the %normal-type
   * optional element.
   *
   * If the type associated with the number in the normal-notes element is
   * different than the current note type (e.g., a quarter note within an
   * eighth note triplet), then the normal-notes type (e.g. eighth) is
   * specified in the normal-type and normal-dot elements.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note_type_value normal_type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<normal_type_type> normal_type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<normal_type_type, char> normal_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const normal_type_optional &normal_type() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  normal_type_optional &normal_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void normal_type(const normal_type_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void normal_type(const normal_type_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void normal_type(::std::unique_ptr<normal_type_type> p);

  //@}

  /**
   * @name normal-dot
   *
   * @brief Accessor and modifier functions for the %normal-dot
   * sequence element.
   *
   * The normal-dot element is used to specify dotted normal tuplet types.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty normal_dot_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<normal_dot_type> normal_dot_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef normal_dot_sequence::iterator normal_dot_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef normal_dot_sequence::const_iterator normal_dot_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<normal_dot_type, char> normal_dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const normal_dot_sequence &normal_dot() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  normal_dot_sequence &normal_dot();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void normal_dot(const normal_dot_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  time_modification(const actual_notes_type &, const normal_notes_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  time_modification(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  time_modification(const time_modification &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual time_modification *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  time_modification &operator=(const time_modification &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~time_modification();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<actual_notes_type> actual_notes_;
  ::xsd::cxx::tree::one<normal_notes_type> normal_notes_;
  normal_type_optional normal_type_;
  normal_dot_sequence normal_dot_;

  //@endcond
};

/**
 * @brief Class corresponding to the %metronome-tuplet schema type.
 *
 * The metronome-tuplet type uses the same element structure as the
 * time-modification element along with some attributes from the tuplet
 * element.
 *
 * @nosubgrouping
 */
class metronome_tuplet : public ::musicxml::time_modification {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name bracket
   *
   * @brief Accessor and modifier functions for the %bracket
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no bracket_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bracket_type> bracket_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bracket_type, char> bracket_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bracket_optional &bracket() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bracket_optional &bracket();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bracket(const bracket_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bracket(const bracket_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bracket(::std::unique_ptr<bracket_type> p);

  //@}

  /**
   * @name show-number
   *
   * @brief Accessor and modifier functions for the %show-number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::show_tuplet show_number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<show_number_type> show_number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<show_number_type, char> show_number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const show_number_optional &show_number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  show_number_optional &show_number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void show_number(const show_number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void show_number(const show_number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void show_number(::std::unique_ptr<show_number_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  metronome_tuplet(const actual_notes_type &, const normal_notes_type &,
                   const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  metronome_tuplet(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metronome_tuplet(const metronome_tuplet &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual metronome_tuplet *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  metronome_tuplet &operator=(const metronome_tuplet &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~metronome_tuplet();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  bracket_optional bracket_;
  show_number_optional show_number_;

  //@endcond
};

/**
 * @brief Class corresponding to the %octave-shift schema type.
 *
 * The octave shift type indicates where notes are shifted up or down
 * from their true pitched values because of printing difficulty. Thus a
 * treble clef line noted with 8va will be indicated with an octave-shift
 * down from the pitch data indicated in the notes. A size of 8 indicates
 * one octave; a size of 15 indicates two octaves.
 *
 * @nosubgrouping
 */
class octave_shift : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::up_down_stop_continue type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name size
   *
   * @brief Accessor and modifier functions for the %size
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer size_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<size_type, char> size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const size_type &size() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  size_type &size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void size(const size_type &x);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static size_type size_default_value();

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  octave_shift(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  octave_shift(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  octave_shift(const octave_shift &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual octave_shift *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  octave_shift &operator=(const octave_shift &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~octave_shift();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  number_optional number_;
  ::xsd::cxx::tree::one<size_type> size_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %offset schema type.
 *
 * An offset is represented in terms of divisions, and indicates where
 * the direction will appear relative to the current musical location.
 * This affects the visual appearance of the direction. If the sound
 * attribute is "yes", then the offset affects playback too. If the sound
 * attribute is "no", then any sound associated with the direction takes
 * effect at the current location. The sound attribute is "no" by default
 * for compatibility with earlier versions of the MusicXML format. If an
 * element within a direction includes a default-x attribute, the offset
 * value will be ignored when determining the appearance of that element.
 *
 * @nosubgrouping
 */
class offset : public ::musicxml::divisions {
public:
  /**
   * @name sound
   *
   * @brief Accessor and modifier functions for the %sound
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no sound_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<sound_type> sound_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<sound_type, char> sound_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sound_optional &sound() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  sound_optional &sound();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void sound(const sound_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void sound(const sound_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void sound(::std::unique_ptr<sound_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  offset(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  offset(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  offset(const offset &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual offset *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  offset &operator=(const offset &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~offset();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  sound_optional sound_;

  //@endcond
};

/**
 * @brief Class corresponding to the %other-direction schema type.
 *
 * The other-direction type is used to define any direction symbols not
 * yet in the current version of the MusicXML format. This allows
 * extended representation, though without application interoperability.
 *
 * @nosubgrouping
 */
class other_direction : public ::xml_schema::string {
public:
  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  other_direction();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  other_direction(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  other_direction(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  other_direction(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  other_direction(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  other_direction(const other_direction &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual other_direction *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  other_direction &operator=(const other_direction &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~other_direction();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  print_object_optional print_object_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %pedal schema type.
 *
 * The pedal type represents piano pedal marks. The line attribute is yes
 * if pedal lines are used. The sign attribute is yes if Ped and * signs
 * are used. For MusicXML 2.0 compatibility, the sign attribute is yes by
 * default if the line attribute is no, and is no by default if the line
 * attribute is yes. The change and continue types are used when the line
 * attribute is yes. The change type indicates a pedal lift and retake
 * indicated with an inverted V marking. The continue type allows more
 * precise formatting across system breaks and for more complex pedaling
 * lines. The alignment attributes are ignored if the line attribute is
 * yes.
 *
 * @nosubgrouping
 */
class pedal : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_change_continue type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name line
   *
   * @brief Accessor and modifier functions for the %line
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no line_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type> line_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type, char> line_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_optional &line() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_optional &line();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line(const line_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line(const line_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line(::std::unique_ptr<line_type> p);

  //@}

  /**
   * @name sign
   *
   * @brief Accessor and modifier functions for the %sign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no sign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<sign_type> sign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<sign_type, char> sign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sign_optional &sign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  sign_optional &sign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void sign(const sign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void sign(const sign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void sign(::std::unique_ptr<sign_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  pedal(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  pedal(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  pedal(const pedal &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual pedal *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  pedal &operator=(const pedal &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~pedal();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  line_optional line_;
  sign_optional sign_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %pedal-tuning schema type.
 *
 * The pedal-tuning type specifies the tuning of a single harp pedal.
 *
 * @nosubgrouping
 */
class pedal_tuning : public ::xml_schema::type {
public:
  /**
   * @name pedal-step
   *
   * @brief Accessor and modifier functions for the %pedal-step
   * required element.
   *
   * The pedal-step element defines the pitch step for a single harp pedal.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::step pedal_step_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pedal_step_type, char> pedal_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const pedal_step_type &pedal_step() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  pedal_step_type &pedal_step();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void pedal_step(const pedal_step_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void pedal_step(::std::unique_ptr<pedal_step_type> p);

  //@}

  /**
   * @name pedal-alter
   *
   * @brief Accessor and modifier functions for the %pedal-alter
   * required element.
   *
   * The pedal-alter element defines the chromatic alteration for a single
   * harp pedal.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::semitones pedal_alter_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pedal_alter_type, char> pedal_alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const pedal_alter_type &pedal_alter() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  pedal_alter_type &pedal_alter();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void pedal_alter(const pedal_alter_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void pedal_alter(::std::unique_ptr<pedal_alter_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  pedal_tuning(const pedal_step_type &, const pedal_alter_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  pedal_tuning(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  pedal_tuning(const pedal_tuning &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual pedal_tuning *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  pedal_tuning &operator=(const pedal_tuning &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~pedal_tuning();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<pedal_step_type> pedal_step_;
  ::xsd::cxx::tree::one<pedal_alter_type> pedal_alter_;

  //@endcond
};

/**
 * @brief Class corresponding to the %per-minute schema type.
 *
 * The per-minute type can be a number, or a text description including
 * numbers. If a font is specified, it overrides the font specified for
 * the overall metronome element. This allows separate specification of a
 * music font for the beat-unit and a text font for the numeric value, in
 * cases where a single metronome font is not used.
 *
 * @nosubgrouping
 */
class per_minute : public ::xml_schema::string {
public:
  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  per_minute();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  per_minute(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  per_minute(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  per_minute(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  per_minute(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  per_minute(const per_minute &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual per_minute *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  per_minute &operator=(const per_minute &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~per_minute();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;

  //@endcond
};

/**
 * @brief Class corresponding to the %percussion schema type.
 *
 * The percussion element is used to define percussion pictogram symbols.
 * Definitions for these symbols can be found in Kurt Stone's "Music
 * Notation in the Twentieth Century" on pages 206-212 and 223. Some
 * values are added to these based on how usage has evolved in the 30
 * years since Stone's book was published.
 *
 * @nosubgrouping
 */
class percussion : public ::xml_schema::type {
public:
  /**
   * @name glass
   *
   * @brief Accessor and modifier functions for the %glass
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::glass glass_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<glass_type> glass_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<glass_type, char> glass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const glass_optional &glass() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  glass_optional &glass();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void glass(const glass_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void glass(const glass_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void glass(::std::unique_ptr<glass_type> p);

  //@}

  /**
   * @name metal
   *
   * @brief Accessor and modifier functions for the %metal
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::metal metal_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<metal_type> metal_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<metal_type, char> metal_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const metal_optional &metal() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  metal_optional &metal();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void metal(const metal_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void metal(const metal_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void metal(::std::unique_ptr<metal_type> p);

  //@}

  /**
   * @name wood
   *
   * @brief Accessor and modifier functions for the %wood
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::wood wood_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<wood_type> wood_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<wood_type, char> wood_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const wood_optional &wood() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  wood_optional &wood();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void wood(const wood_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void wood(const wood_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void wood(::std::unique_ptr<wood_type> p);

  //@}

  /**
   * @name pitched
   *
   * @brief Accessor and modifier functions for the %pitched
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::pitched pitched_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<pitched_type> pitched_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pitched_type, char> pitched_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const pitched_optional &pitched() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  pitched_optional &pitched();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void pitched(const pitched_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void pitched(const pitched_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void pitched(::std::unique_ptr<pitched_type> p);

  //@}

  /**
   * @name membrane
   *
   * @brief Accessor and modifier functions for the %membrane
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::membrane membrane_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<membrane_type> membrane_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<membrane_type, char> membrane_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const membrane_optional &membrane() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  membrane_optional &membrane();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void membrane(const membrane_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void membrane(const membrane_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void membrane(::std::unique_ptr<membrane_type> p);

  //@}

  /**
   * @name effect
   *
   * @brief Accessor and modifier functions for the %effect
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::effect effect_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<effect_type> effect_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<effect_type, char> effect_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const effect_optional &effect() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  effect_optional &effect();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void effect(const effect_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void effect(const effect_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void effect(::std::unique_ptr<effect_type> p);

  //@}

  /**
   * @name timpani
   *
   * @brief Accessor and modifier functions for the %timpani
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty timpani_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<timpani_type> timpani_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<timpani_type, char> timpani_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const timpani_optional &timpani() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  timpani_optional &timpani();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void timpani(const timpani_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void timpani(const timpani_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void timpani(::std::unique_ptr<timpani_type> p);

  //@}

  /**
   * @name beater
   *
   * @brief Accessor and modifier functions for the %beater
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::beater beater_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<beater_type> beater_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beater_type, char> beater_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const beater_optional &beater() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  beater_optional &beater();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void beater(const beater_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void beater(const beater_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void beater(::std::unique_ptr<beater_type> p);

  //@}

  /**
   * @name stick
   *
   * @brief Accessor and modifier functions for the %stick
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::stick stick_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<stick_type> stick_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<stick_type, char> stick_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const stick_optional &stick() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  stick_optional &stick();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void stick(const stick_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void stick(const stick_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void stick(::std::unique_ptr<stick_type> p);

  //@}

  /**
   * @name stick-location
   *
   * @brief Accessor and modifier functions for the %stick-location
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::stick_location stick_location_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<stick_location_type>
    stick_location_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<stick_location_type, char>
    stick_location_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const stick_location_optional &stick_location() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  stick_location_optional &stick_location();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void stick_location(const stick_location_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void stick_location(const stick_location_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void stick_location(::std::unique_ptr<stick_location_type> p);

  //@}

  /**
   * @name other-percussion
   *
   * @brief Accessor and modifier functions for the %other-percussion
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string other_percussion_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<other_percussion_type>
    other_percussion_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_percussion_type, char>
    other_percussion_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const other_percussion_optional &other_percussion() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  other_percussion_optional &other_percussion();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void other_percussion(const other_percussion_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void other_percussion(const other_percussion_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void other_percussion(::std::unique_ptr<other_percussion_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name enclosure
   *
   * @brief Accessor and modifier functions for the %enclosure
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::enclosure_shape enclosure_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<enclosure_type> enclosure_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<enclosure_type, char> enclosure_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const enclosure_optional &enclosure() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  enclosure_optional &enclosure();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void enclosure(const enclosure_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void enclosure(const enclosure_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void enclosure(::std::unique_ptr<enclosure_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  percussion();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  percussion(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  percussion(const percussion &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual percussion *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  percussion &operator=(const percussion &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~percussion();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  glass_optional glass_;
  metal_optional metal_;
  wood_optional wood_;
  pitched_optional pitched_;
  membrane_optional membrane_;
  effect_optional effect_;
  timpani_optional timpani_;
  beater_optional beater_;
  stick_optional stick_;
  stick_location_optional stick_location_;
  other_percussion_optional other_percussion_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;
  enclosure_optional enclosure_;

  //@endcond
};

/**
 * @brief Class corresponding to the %principal-voice schema type.
 *
 * The principal-voice element represents principal and secondary voices
 * in a score, either for analysis or for square bracket symbols that
 * appear in a score. The symbol attribute indicates the type of symbol
 * used at the start of the principal-voice. The content of the
 * principal-voice element is used for analysis and may be any text
 * value. When used for analysis separate from any printed score
 * markings, the symbol attribute should be set to "none".
 *
 * @nosubgrouping
 */
class principal_voice : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name symbol
   *
   * @brief Accessor and modifier functions for the %symbol
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::principal_voice_symbol symbol_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<symbol_type, char> symbol_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const symbol_type &symbol() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  symbol_type &symbol();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void symbol(const symbol_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void symbol(::std::unique_ptr<symbol_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  principal_voice(const type_type &, const symbol_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  principal_voice(const char *, const type_type &, const symbol_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  principal_voice(const ::std::string &, const type_type &,
                  const symbol_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  principal_voice(const ::xml_schema::string &, const type_type &,
                  const symbol_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  principal_voice(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  principal_voice(const principal_voice &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual principal_voice *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  principal_voice &operator=(const principal_voice &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~principal_voice();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<symbol_type> symbol_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %print schema type.
 *
 * The print type contains general printing parameters, including the
 * layout elements defined in the layout.mod file. The part-name-display
 * and part-abbreviation-display elements used in the score.mod file may
 * also be used here to change how a part name or abbreviation is
 * displayed over the course of a piece. They take effect when the
 * current measure or a succeeding measure starts a new system.
 *
 * Layout elements in a print statement only apply to the current page,
 * system, staff, or measure. Music that follows continues to take the
 * default values from the layout included in the defaults element.
 *
 * @nosubgrouping
 */
class print : public ::xml_schema::type {
public:
  /**
   * @name page-layout
   *
   * @brief Accessor and modifier functions for the %page-layout
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::page_layout page_layout_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<page_layout_type> page_layout_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<page_layout_type, char> page_layout_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const page_layout_optional &page_layout() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  page_layout_optional &page_layout();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void page_layout(const page_layout_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void page_layout(const page_layout_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void page_layout(::std::unique_ptr<page_layout_type> p);

  //@}

  /**
   * @name system-layout
   *
   * @brief Accessor and modifier functions for the %system-layout
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::system_layout system_layout_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<system_layout_type> system_layout_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<system_layout_type, char>
    system_layout_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const system_layout_optional &system_layout() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  system_layout_optional &system_layout();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void system_layout(const system_layout_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void system_layout(const system_layout_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void system_layout(::std::unique_ptr<system_layout_type> p);

  //@}

  /**
   * @name staff-layout
   *
   * @brief Accessor and modifier functions for the %staff-layout
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::staff_layout staff_layout_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<staff_layout_type> staff_layout_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef staff_layout_sequence::iterator staff_layout_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef staff_layout_sequence::const_iterator staff_layout_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_layout_type, char> staff_layout_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const staff_layout_sequence &staff_layout() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  staff_layout_sequence &staff_layout();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void staff_layout(const staff_layout_sequence &s);

  //@}

  /**
   * @name measure-layout
   *
   * @brief Accessor and modifier functions for the %measure-layout
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::measure_layout measure_layout_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<measure_layout_type>
    measure_layout_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<measure_layout_type, char>
    measure_layout_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const measure_layout_optional &measure_layout() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  measure_layout_optional &measure_layout();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void measure_layout(const measure_layout_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void measure_layout(const measure_layout_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void measure_layout(::std::unique_ptr<measure_layout_type> p);

  //@}

  /**
   * @name measure-numbering
   *
   * @brief Accessor and modifier functions for the %measure-numbering
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::measure_numbering measure_numbering_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<measure_numbering_type>
    measure_numbering_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<measure_numbering_type, char>
    measure_numbering_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const measure_numbering_optional &measure_numbering() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  measure_numbering_optional &measure_numbering();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void measure_numbering(const measure_numbering_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void measure_numbering(const measure_numbering_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void measure_numbering(::std::unique_ptr<measure_numbering_type> p);

  //@}

  /**
   * @name part-name-display
   *
   * @brief Accessor and modifier functions for the %part-name-display
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::name_display part_name_display_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<part_name_display_type>
    part_name_display_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_name_display_type, char>
    part_name_display_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const part_name_display_optional &part_name_display() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  part_name_display_optional &part_name_display();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_name_display(const part_name_display_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void part_name_display(const part_name_display_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void part_name_display(::std::unique_ptr<part_name_display_type> p);

  //@}

  /**
   * @name part-abbreviation-display
   *
   * @brief Accessor and modifier functions for the %part-abbreviation-display
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::name_display part_abbreviation_display_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<part_abbreviation_display_type>
    part_abbreviation_display_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_abbreviation_display_type, char>
    part_abbreviation_display_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const part_abbreviation_display_optional &part_abbreviation_display() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  part_abbreviation_display_optional &part_abbreviation_display();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_abbreviation_display(const part_abbreviation_display_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void part_abbreviation_display(const part_abbreviation_display_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void part_abbreviation_display(
    ::std::unique_ptr<part_abbreviation_display_type> p);

  //@}

  /**
   * @name staff-spacing
   *
   * @brief Accessor and modifier functions for the %staff-spacing
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths staff_spacing_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_spacing_type> staff_spacing_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_spacing_type, char>
    staff_spacing_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_spacing_optional &staff_spacing() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  staff_spacing_optional &staff_spacing();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void staff_spacing(const staff_spacing_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void staff_spacing(const staff_spacing_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void staff_spacing(::std::unique_ptr<staff_spacing_type> p);

  //@}

  /**
   * @name new-system
   *
   * @brief Accessor and modifier functions for the %new-system
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no new_system_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<new_system_type> new_system_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<new_system_type, char> new_system_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const new_system_optional &new_system() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  new_system_optional &new_system();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void new_system(const new_system_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void new_system(const new_system_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void new_system(::std::unique_ptr<new_system_type> p);

  //@}

  /**
   * @name new-page
   *
   * @brief Accessor and modifier functions for the %new-page
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no new_page_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<new_page_type> new_page_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<new_page_type, char> new_page_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const new_page_optional &new_page() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  new_page_optional &new_page();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void new_page(const new_page_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void new_page(const new_page_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void new_page(::std::unique_ptr<new_page_type> p);

  //@}

  /**
   * @name blank-page
   *
   * @brief Accessor and modifier functions for the %blank-page
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer blank_page_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<blank_page_type> blank_page_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<blank_page_type, char> blank_page_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const blank_page_optional &blank_page() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  blank_page_optional &blank_page();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void blank_page(const blank_page_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void blank_page(const blank_page_optional &x);

  //@}

  /**
   * @name page-number
   *
   * @brief Accessor and modifier functions for the %page-number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token page_number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<page_number_type> page_number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<page_number_type, char> page_number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const page_number_optional &page_number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  page_number_optional &page_number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void page_number(const page_number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void page_number(const page_number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void page_number(::std::unique_ptr<page_number_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  print();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  print(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  print(const print &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual print *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  print &operator=(const print &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~print();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  page_layout_optional page_layout_;
  system_layout_optional system_layout_;
  staff_layout_sequence staff_layout_;
  measure_layout_optional measure_layout_;
  measure_numbering_optional measure_numbering_;
  part_name_display_optional part_name_display_;
  part_abbreviation_display_optional part_abbreviation_display_;
  staff_spacing_optional staff_spacing_;
  new_system_optional new_system_;
  new_page_optional new_page_;
  blank_page_optional blank_page_;
  page_number_optional page_number_;

  //@endcond
};

/**
 * @brief Class corresponding to the %root schema type.
 *
 * The root type indicates a pitch like C, D, E vs. a function indication
 * like I, II, III. It is used with chord symbols in popular music. The
 * root element has a root-step and optional root-alter element similar
 * to the step and alter elements, but renamed to distinguish the
 * different musical meanings.
 *
 * @nosubgrouping
 */
class root : public ::xml_schema::type {
public:
  /**
   * @name root-step
   *
   * @brief Accessor and modifier functions for the %root-step
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::root_step root_step_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<root_step_type, char> root_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const root_step_type &root_step() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  root_step_type &root_step();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void root_step(const root_step_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void root_step(::std::unique_ptr<root_step_type> p);

  //@}

  /**
   * @name root-alter
   *
   * @brief Accessor and modifier functions for the %root-alter
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::root_alter root_alter_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<root_alter_type> root_alter_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<root_alter_type, char> root_alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const root_alter_optional &root_alter() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  root_alter_optional &root_alter();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void root_alter(const root_alter_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void root_alter(const root_alter_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void root_alter(::std::unique_ptr<root_alter_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  root(const root_step_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  root(::std::unique_ptr<root_step_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  root(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  root(const root &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual root *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  root &operator=(const root &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~root();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<root_step_type> root_step_;
  root_alter_optional root_alter_;

  //@endcond
};

/**
 * @brief Class corresponding to the %root-alter schema type.
 *
 * The root-alter type represents the chromatic alteration of the root of
 * the current chord within the harmony element. In some chord styles,
 * the text for the root-step element may include root-alter information.
 * In that case, the print-object attribute of the root-alter element can
 * be set to no. The location attribute indicates whether the alteration
 * should appear to the left or the right of the root-step; it is right
 * by default.
 *
 * @nosubgrouping
 */
class root_alter : public ::musicxml::semitones {
public:
  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name location
   *
   * @brief Accessor and modifier functions for the %location
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_right location_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<location_type> location_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<location_type, char> location_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const location_optional &location() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  location_optional &location();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void location(const location_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void location(const location_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void location(::std::unique_ptr<location_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  root_alter(const ::xml_schema::decimal &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  root_alter(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  root_alter(const root_alter &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual root_alter *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  root_alter &operator=(const root_alter &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~root_alter();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  print_object_optional print_object_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  location_optional location_;

  //@endcond
};

/**
 * @brief Class corresponding to the %root-step schema type.
 *
 * The root-step type represents the pitch step of the root of the
 * current chord within the harmony element. The text attribute indicates
 * how the root should appear in a score if not using the element
 * contents.
 *
 * @nosubgrouping
 */
class root_step : public ::musicxml::step {
public:
  /**
   * @name text
   *
   * @brief Accessor and modifier functions for the %text
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token text_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<text_type> text_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_type, char> text_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const text_optional &text() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  text_optional &text();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void text(const text_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void text(const text_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void text(::std::unique_ptr<text_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  root_step(::musicxml::step::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  root_step(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  root_step(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  root_step(const ::musicxml::step &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  root_step(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  root_step(const root_step &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual root_step *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  root_step &operator=(const root_step &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~root_step();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  text_optional text_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %scordatura schema type.
 *
 * Scordatura string tunings are represented by a series of accord
 * elements, similar to the staff-tuning elements. Strings are numbered
 * from high to low.
 *
 * @nosubgrouping
 */
class scordatura : public ::xml_schema::type {
public:
  /**
   * @name accord
   *
   * @brief Accessor and modifier functions for the %accord
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accord accord_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<accord_type> accord_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef accord_sequence::iterator accord_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef accord_sequence::const_iterator accord_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accord_type, char> accord_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const accord_sequence &accord() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  accord_sequence &accord();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void accord(const accord_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  scordatura();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  scordatura(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  scordatura(const scordatura &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual scordatura *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  scordatura &operator=(const scordatura &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~scordatura();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  accord_sequence accord_;

  //@endcond
};

/**
 * @brief Class corresponding to the %sound schema type.
 *
 * The sound element contains general playback parameters. They can stand
 * alone within a part/measure, or be a component element within a
 * direction.
 *
 * Tempo is expressed in quarter notes per minute. If 0, the
 * sound-generating program should prompt the user at the time of
 * compiling a sound (MIDI) file.
 *
 * Dynamics (or MIDI velocity) are expressed as a percentage of the
 * default forte value (90 for MIDI 1.0).
 *
 * Dacapo indicates to go back to the beginning of the movement. When
 * used it always has the value "yes".
 *
 * Segno and dalsegno are used for backwards jumps to a segno sign; coda
 * and tocoda are used for forward jumps to a coda sign. If there are
 * multiple jumps, the value of these parameters can be used to name and
 * distinguish them. If segno or coda is used, the divisions attribute
 * can also be used to indicate the number of divisions per quarter note.
 * Otherwise sound and MIDI generating programs may have to recompute
 * this.
 *
 * By default, a dalsegno or dacapo attribute indicates that the jump
 * should occur the first time through, while a tocoda attribute
 * indicates the jump should occur the second time through. The time that
 * jumps occur can be changed by using the time-only attribute.
 *
 * Forward-repeat is used when a forward repeat sign is implied, and
 * usually follows a bar line. When used it always has the value of
 * "yes".
 *
 * The fine attribute follows the final note or rest in a movement with a
 * da capo or dal segno direction. If numeric, the value represents the
 * actual duration of the final note or rest, which can be ambiguous in
 * written notation and different among parts and voices. The value may
 * also be "yes" to indicate no change to the final duration.
 *
 * If the sound element applies only particular times through a repeat,
 * the time-only attribute indicates which times to apply the sound
 * element.
 *
 * Pizzicato in a sound element effects all following notes. Yes
 * indicates pizzicato, no indicates arco.
 *
 * The pan and elevation attributes are deprecated in Version 2.0. The
 * pan and elevation elements in the midi-instrument element should be
 * used instead. The meaning of the pan and elevation attributes is the
 * same as for the pan and elevation elements. If both are present, the
 * mid-instrument elements take priority.
 *
 * The damper-pedal, soft-pedal, and sostenuto-pedal attributes effect
 * playback of the three common piano pedals and their MIDI controller
 * equivalents. The yes value indicates the pedal is depressed; no
 * indicates the pedal is released. A numeric value from 0 to 100 may
 * also be used for half pedaling. This value is the percentage that the
 * pedal is depressed. A value of 0 is equivalent to no, and a value of
 * 100 is equivalent to yes.
 *
 * MIDI devices, MIDI instruments, and playback techniques are changed
 * using the midi-device, midi-instrument, and play elements. When there
 * are multiple instances of these elements, they should be grouped
 * together by instrument using the id attribute values.
 *
 * The offset element is used to indicate that the sound takes place
 * offset from the current score position. If the sound element is a
 * child of a direction element, the sound offset element overrides the
 * direction offset element if both elements are present. Note that the
 * offset reflects the intended musical position for the change in sound.
 * It should not be used to compensate for latency issues in particular
 * hardware configurations.
 *
 * @nosubgrouping
 */
class sound : public ::xml_schema::type {
public:
  /**
   * @name midi-device
   *
   * @brief Accessor and modifier functions for the %midi-device
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::midi_device midi_device_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<midi_device_type> midi_device_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef midi_device_sequence::iterator midi_device_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef midi_device_sequence::const_iterator midi_device_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_device_type, char> midi_device_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const midi_device_sequence &midi_device() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  midi_device_sequence &midi_device();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void midi_device(const midi_device_sequence &s);

  //@}

  /**
   * @name midi-instrument
   *
   * @brief Accessor and modifier functions for the %midi-instrument
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::midi_instrument midi_instrument_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<midi_instrument_type>
    midi_instrument_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef midi_instrument_sequence::iterator midi_instrument_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef midi_instrument_sequence::const_iterator
    midi_instrument_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_instrument_type, char>
    midi_instrument_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const midi_instrument_sequence &midi_instrument() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  midi_instrument_sequence &midi_instrument();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void midi_instrument(const midi_instrument_sequence &s);

  //@}

  /**
   * @name play
   *
   * @brief Accessor and modifier functions for the %play
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::play play_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<play_type> play_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef play_sequence::iterator play_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef play_sequence::const_iterator play_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<play_type, char> play_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const play_sequence &play() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  play_sequence &play();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void play(const play_sequence &s);

  //@}

  /**
   * @name offset
   *
   * @brief Accessor and modifier functions for the %offset
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::offset offset_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<offset_type> offset_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<offset_type, char> offset_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const offset_optional &offset() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  offset_optional &offset();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void offset(const offset_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void offset(const offset_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void offset(::std::unique_ptr<offset_type> p);

  //@}

  /**
   * @name tempo
   *
   * @brief Accessor and modifier functions for the %tempo
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::non_negative_decimal tempo_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tempo_type> tempo_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<tempo_type, char> tempo_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tempo_optional &tempo() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  tempo_optional &tempo();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void tempo(const tempo_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void tempo(const tempo_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tempo(::std::unique_ptr<tempo_type> p);

  //@}

  /**
   * @name dynamics
   *
   * @brief Accessor and modifier functions for the %dynamics
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::non_negative_decimal dynamics_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dynamics_type> dynamics_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dynamics_type, char> dynamics_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dynamics_optional &dynamics() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dynamics_optional &dynamics();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dynamics(const dynamics_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dynamics(const dynamics_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dynamics(::std::unique_ptr<dynamics_type> p);

  //@}

  /**
   * @name dacapo
   *
   * @brief Accessor and modifier functions for the %dacapo
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no dacapo_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dacapo_type> dacapo_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dacapo_type, char> dacapo_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dacapo_optional &dacapo() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dacapo_optional &dacapo();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dacapo(const dacapo_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dacapo(const dacapo_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dacapo(::std::unique_ptr<dacapo_type> p);

  //@}

  /**
   * @name segno
   *
   * @brief Accessor and modifier functions for the %segno
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token segno_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<segno_type> segno_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<segno_type, char> segno_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const segno_optional &segno() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  segno_optional &segno();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void segno(const segno_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void segno(const segno_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void segno(::std::unique_ptr<segno_type> p);

  //@}

  /**
   * @name dalsegno
   *
   * @brief Accessor and modifier functions for the %dalsegno
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token dalsegno_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dalsegno_type> dalsegno_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dalsegno_type, char> dalsegno_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dalsegno_optional &dalsegno() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dalsegno_optional &dalsegno();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dalsegno(const dalsegno_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dalsegno(const dalsegno_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dalsegno(::std::unique_ptr<dalsegno_type> p);

  //@}

  /**
   * @name coda
   *
   * @brief Accessor and modifier functions for the %coda
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token coda_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<coda_type> coda_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<coda_type, char> coda_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const coda_optional &coda() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  coda_optional &coda();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void coda(const coda_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void coda(const coda_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void coda(::std::unique_ptr<coda_type> p);

  //@}

  /**
   * @name tocoda
   *
   * @brief Accessor and modifier functions for the %tocoda
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token tocoda_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tocoda_type> tocoda_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<tocoda_type, char> tocoda_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tocoda_optional &tocoda() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  tocoda_optional &tocoda();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void tocoda(const tocoda_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void tocoda(const tocoda_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tocoda(::std::unique_ptr<tocoda_type> p);

  //@}

  /**
   * @name divisions
   *
   * @brief Accessor and modifier functions for the %divisions
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions divisions_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<divisions_type> divisions_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<divisions_type, char> divisions_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const divisions_optional &divisions() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  divisions_optional &divisions();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void divisions(const divisions_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void divisions(const divisions_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void divisions(::std::unique_ptr<divisions_type> p);

  //@}

  /**
   * @name forward-repeat
   *
   * @brief Accessor and modifier functions for the %forward-repeat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no forward_repeat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<forward_repeat_type>
    forward_repeat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<forward_repeat_type, char>
    forward_repeat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const forward_repeat_optional &forward_repeat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  forward_repeat_optional &forward_repeat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void forward_repeat(const forward_repeat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void forward_repeat(const forward_repeat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void forward_repeat(::std::unique_ptr<forward_repeat_type> p);

  //@}

  /**
   * @name fine
   *
   * @brief Accessor and modifier functions for the %fine
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token fine_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<fine_type> fine_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<fine_type, char> fine_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const fine_optional &fine() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  fine_optional &fine();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void fine(const fine_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void fine(const fine_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void fine(::std::unique_ptr<fine_type> p);

  //@}

  /**
   * @name time-only
   *
   * @brief Accessor and modifier functions for the %time-only
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::time_only time_only_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<time_only_type> time_only_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<time_only_type, char> time_only_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const time_only_optional &time_only() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  time_only_optional &time_only();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void time_only(const time_only_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void time_only(const time_only_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void time_only(::std::unique_ptr<time_only_type> p);

  //@}

  /**
   * @name pizzicato
   *
   * @brief Accessor and modifier functions for the %pizzicato
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no pizzicato_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<pizzicato_type> pizzicato_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<pizzicato_type, char> pizzicato_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const pizzicato_optional &pizzicato() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  pizzicato_optional &pizzicato();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void pizzicato(const pizzicato_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void pizzicato(const pizzicato_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void pizzicato(::std::unique_ptr<pizzicato_type> p);

  //@}

  /**
   * @name pan
   *
   * @brief Accessor and modifier functions for the %pan
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::rotation_degrees pan_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<pan_type> pan_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<pan_type, char> pan_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const pan_optional &pan() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  pan_optional &pan();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void pan(const pan_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void pan(const pan_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void pan(::std::unique_ptr<pan_type> p);

  //@}

  /**
   * @name elevation
   *
   * @brief Accessor and modifier functions for the %elevation
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::rotation_degrees elevation_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<elevation_type> elevation_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<elevation_type, char> elevation_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const elevation_optional &elevation() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  elevation_optional &elevation();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void elevation(const elevation_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void elevation(const elevation_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void elevation(::std::unique_ptr<elevation_type> p);

  //@}

  /**
   * @name damper-pedal
   *
   * @brief Accessor and modifier functions for the %damper-pedal
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no_number damper_pedal_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<damper_pedal_type> damper_pedal_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<damper_pedal_type, char> damper_pedal_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const damper_pedal_optional &damper_pedal() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  damper_pedal_optional &damper_pedal();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void damper_pedal(const damper_pedal_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void damper_pedal(const damper_pedal_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void damper_pedal(::std::unique_ptr<damper_pedal_type> p);

  //@}

  /**
   * @name soft-pedal
   *
   * @brief Accessor and modifier functions for the %soft-pedal
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no_number soft_pedal_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<soft_pedal_type> soft_pedal_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<soft_pedal_type, char> soft_pedal_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const soft_pedal_optional &soft_pedal() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  soft_pedal_optional &soft_pedal();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void soft_pedal(const soft_pedal_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void soft_pedal(const soft_pedal_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void soft_pedal(::std::unique_ptr<soft_pedal_type> p);

  //@}

  /**
   * @name sostenuto-pedal
   *
   * @brief Accessor and modifier functions for the %sostenuto-pedal
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no_number sostenuto_pedal_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<sostenuto_pedal_type>
    sostenuto_pedal_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<sostenuto_pedal_type, char>
    sostenuto_pedal_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sostenuto_pedal_optional &sostenuto_pedal() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  sostenuto_pedal_optional &sostenuto_pedal();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void sostenuto_pedal(const sostenuto_pedal_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void sostenuto_pedal(const sostenuto_pedal_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void sostenuto_pedal(::std::unique_ptr<sostenuto_pedal_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  sound();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  sound(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  sound(const sound &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual sound *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  sound &operator=(const sound &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~sound();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  midi_device_sequence midi_device_;
  midi_instrument_sequence midi_instrument_;
  play_sequence play_;
  offset_optional offset_;
  tempo_optional tempo_;
  dynamics_optional dynamics_;
  dacapo_optional dacapo_;
  segno_optional segno_;
  dalsegno_optional dalsegno_;
  coda_optional coda_;
  tocoda_optional tocoda_;
  divisions_optional divisions_;
  forward_repeat_optional forward_repeat_;
  fine_optional fine_;
  time_only_optional time_only_;
  pizzicato_optional pizzicato_;
  pan_optional pan_;
  elevation_optional elevation_;
  damper_pedal_optional damper_pedal_;
  soft_pedal_optional soft_pedal_;
  sostenuto_pedal_optional sostenuto_pedal_;

  //@endcond
};

/**
 * @brief Class corresponding to the %stick schema type.
 *
 * The stick type represents pictograms where the material of the stick,
 * mallet, or beater is included.
 *
 * @nosubgrouping
 */
class stick : public ::xml_schema::type {
public:
  /**
   * @name stick-type
   *
   * @brief Accessor and modifier functions for the %stick-type
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::stick_type stick_type_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<stick_type_type, char> stick_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const stick_type_type &stick_type() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  stick_type_type &stick_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void stick_type(const stick_type_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void stick_type(::std::unique_ptr<stick_type_type> p);

  //@}

  /**
   * @name stick-material
   *
   * @brief Accessor and modifier functions for the %stick-material
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::stick_material stick_material_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<stick_material_type, char>
    stick_material_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const stick_material_type &stick_material() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  stick_material_type &stick_material();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void stick_material(const stick_material_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void stick_material(::std::unique_ptr<stick_material_type> p);

  //@}

  /**
   * @name tip
   *
   * @brief Accessor and modifier functions for the %tip
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tip_direction tip_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tip_type> tip_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<tip_type, char> tip_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tip_optional &tip() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  tip_optional &tip();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void tip(const tip_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void tip(const tip_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tip(::std::unique_ptr<tip_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  stick(const stick_type_type &, const stick_material_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stick(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  stick(const stick &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual stick *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  stick &operator=(const stick &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~stick();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<stick_type_type> stick_type_;
  ::xsd::cxx::tree::one<stick_material_type> stick_material_;
  tip_optional tip_;

  //@endcond
};

/**
 * @brief Class corresponding to the %string-mute schema type.
 *
 * The string-mute type represents string mute on and mute off symbols.
 *
 * @nosubgrouping
 */
class string_mute : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::on_off type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name halign
   *
   * @brief Accessor and modifier functions for the %halign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right halign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<halign_type> halign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<halign_type, char> halign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const halign_optional &halign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  halign_optional &halign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void halign(const halign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void halign(const halign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void halign(::std::unique_ptr<halign_type> p);

  //@}

  /**
   * @name valign
   *
   * @brief Accessor and modifier functions for the %valign
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::valign valign_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<valign_type> valign_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<valign_type, char> valign_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valign_optional &valign() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valign_optional &valign();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void valign(const valign_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void valign(const valign_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void valign(::std::unique_ptr<valign_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  string_mute(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  string_mute(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  string_mute(const string_mute &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual string_mute *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  string_mute &operator=(const string_mute &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~string_mute();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  halign_optional halign_;
  valign_optional valign_;

  //@endcond
};

/**
 * @brief Class corresponding to the %wedge schema type.
 *
 * The wedge type represents crescendo and diminuendo wedge symbols. The
 * type attribute is crescendo for the start of a wedge that is closed at
 * the left side, and diminuendo for the start of a wedge that is closed
 * on the right side. Spread values are measured in tenths; those at the
 * start of a crescendo wedge or end of a diminuendo wedge are ignored.
 * The niente attribute is yes if a circle appears at the point of the
 * wedge, indicating a crescendo from nothing or diminuendo to nothing.
 * It is no by default, and used only when the type is crescendo, or the
 * type is stop for a wedge that began with a diminuendo type. The
 * line-type is solid by default.
 *
 * @nosubgrouping
 */
class wedge : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::wedge_type type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name spread
   *
   * @brief Accessor and modifier functions for the %spread
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths spread_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<spread_type> spread_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<spread_type, char> spread_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const spread_optional &spread() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  spread_optional &spread();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void spread(const spread_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void spread(const spread_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void spread(::std::unique_ptr<spread_type> p);

  //@}

  /**
   * @name niente
   *
   * @brief Accessor and modifier functions for the %niente
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no niente_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<niente_type> niente_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<niente_type, char> niente_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const niente_optional &niente() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  niente_optional &niente();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void niente(const niente_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void niente(const niente_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void niente(::std::unique_ptr<niente_type> p);

  //@}

  /**
   * @name line-type
   *
   * @brief Accessor and modifier functions for the %line-type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_type line_type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type_type> line_type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type_type, char> line_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_type_optional &line_type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_type_optional &line_type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_type(const line_type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_type(const line_type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_type(::std::unique_ptr<line_type_type> p);

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  wedge(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  wedge(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  wedge(const wedge &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual wedge *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  wedge &operator=(const wedge &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~wedge();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  number_optional number_;
  spread_optional spread_;
  niente_optional niente_;
  line_type_optional line_type_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %encoding schema type.
 *
 * The encoding element contains information about who did the digital
 * encoding, when, with what software, and in what aspects. Standard type
 * values for the encoder element are music, words, and arrangement, but
 * other types may be used. The type attribute is only needed when there
 * are multiple encoder elements.
 *
 * @nosubgrouping
 */
class encoding : public ::xml_schema::type {
public:
  /**
   * @name encoding-date
   *
   * @brief Accessor and modifier functions for the %encoding-date
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::yyyy_mm_dd encoding_date_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<encoding_date_type> encoding_date_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef encoding_date_sequence::iterator encoding_date_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef encoding_date_sequence::const_iterator encoding_date_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<encoding_date_type, char>
    encoding_date_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const encoding_date_sequence &encoding_date() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  encoding_date_sequence &encoding_date();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void encoding_date(const encoding_date_sequence &s);

  //@}

  /**
   * @name encoder
   *
   * @brief Accessor and modifier functions for the %encoder
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::typed_text encoder_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<encoder_type> encoder_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef encoder_sequence::iterator encoder_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef encoder_sequence::const_iterator encoder_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<encoder_type, char> encoder_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const encoder_sequence &encoder() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  encoder_sequence &encoder();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void encoder(const encoder_sequence &s);

  //@}

  /**
   * @name software
   *
   * @brief Accessor and modifier functions for the %software
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string software_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<software_type> software_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef software_sequence::iterator software_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef software_sequence::const_iterator software_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<software_type, char> software_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const software_sequence &software() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  software_sequence &software();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void software(const software_sequence &s);

  //@}

  /**
   * @name encoding-description
   *
   * @brief Accessor and modifier functions for the %encoding-description
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string encoding_description_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<encoding_description_type>
    encoding_description_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef encoding_description_sequence::iterator encoding_description_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef encoding_description_sequence::const_iterator
    encoding_description_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<encoding_description_type, char>
    encoding_description_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const encoding_description_sequence &encoding_description() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  encoding_description_sequence &encoding_description();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void encoding_description(const encoding_description_sequence &s);

  //@}

  /**
   * @name supports
   *
   * @brief Accessor and modifier functions for the %supports
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::supports supports_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<supports_type> supports_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef supports_sequence::iterator supports_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef supports_sequence::const_iterator supports_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<supports_type, char> supports_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const supports_sequence &supports() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  supports_sequence &supports();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void supports(const supports_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  encoding();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  encoding(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  encoding(const encoding &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual encoding *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  encoding &operator=(const encoding &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~encoding();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  encoding_date_sequence encoding_date_;
  encoder_sequence encoder_;
  software_sequence software_;
  encoding_description_sequence encoding_description_;
  supports_sequence supports_;

  //@endcond
};

/**
 * @brief Class corresponding to the %identification schema type.
 *
 * Identification contains basic metadata about the score. It includes
 * the information in MuseData headers that may apply at a score-wide,
 * movement-wide, or part-wide level. The creator, rights, source, and
 * relation elements are based on Dublin Core.
 *
 * @nosubgrouping
 */
class identification : public ::xml_schema::type {
public:
  /**
   * @name creator
   *
   * @brief Accessor and modifier functions for the %creator
   * sequence element.
   *
   * The creator element is borrowed from Dublin Core. It is used for the
   * creators of the score. The type attribute is used to distinguish
   * different creative contributions. Thus, there can be multiple creators
   * within an identification. Standard type values are composer, lyricist,
   * and arranger. Other type values may be used for different types of
   * creative roles. The type attribute should usually be used even if
   * there is just a single creator element. The MusicXML format does not
   * use the creator / contributor distinction from Dublin Core.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::typed_text creator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<creator_type> creator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef creator_sequence::iterator creator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef creator_sequence::const_iterator creator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<creator_type, char> creator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const creator_sequence &creator() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  creator_sequence &creator();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void creator(const creator_sequence &s);

  //@}

  /**
   * @name rights
   *
   * @brief Accessor and modifier functions for the %rights
   * sequence element.
   *
   * The rights element is borrowed from Dublin Core. It contains copyright
   * and other intellectual property notices. Words, music, and derivatives
   * can have different types, so multiple rights tags with different type
   * attributes are supported. Standard type values are music, words, and
   * arrangement, but other types may be used. The type attribute is only
   * needed when there are multiple rights elements.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::typed_text rights_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<rights_type> rights_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef rights_sequence::iterator rights_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef rights_sequence::const_iterator rights_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rights_type, char> rights_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const rights_sequence &rights() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  rights_sequence &rights();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void rights(const rights_sequence &s);

  //@}

  /**
   * @name encoding
   *
   * @brief Accessor and modifier functions for the %encoding
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::encoding encoding_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<encoding_type> encoding_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<encoding_type, char> encoding_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const encoding_optional &encoding() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  encoding_optional &encoding();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void encoding(const encoding_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void encoding(const encoding_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void encoding(::std::unique_ptr<encoding_type> p);

  //@}

  /**
   * @name source
   *
   * @brief Accessor and modifier functions for the %source
   * optional element.
   *
   * The source for the music that is encoded. This is similar to the
   * Dublin Core source element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string source_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<source_type> source_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<source_type, char> source_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const source_optional &source() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  source_optional &source();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void source(const source_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void source(const source_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void source(::std::unique_ptr<source_type> p);

  //@}

  /**
   * @name relation
   *
   * @brief Accessor and modifier functions for the %relation
   * sequence element.
   *
   * A related resource for the music that is encoded. This is similar to
   * the Dublin Core relation element. Standard type values are music,
   * words, and arrangement, but other types may be used.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::typed_text relation_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<relation_type> relation_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef relation_sequence::iterator relation_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef relation_sequence::const_iterator relation_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<relation_type, char> relation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const relation_sequence &relation() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  relation_sequence &relation();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void relation(const relation_sequence &s);

  //@}

  /**
   * @name miscellaneous
   *
   * @brief Accessor and modifier functions for the %miscellaneous
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::miscellaneous miscellaneous_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<miscellaneous_type> miscellaneous_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<miscellaneous_type, char>
    miscellaneous_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const miscellaneous_optional &miscellaneous() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  miscellaneous_optional &miscellaneous();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void miscellaneous(const miscellaneous_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void miscellaneous(const miscellaneous_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void miscellaneous(::std::unique_ptr<miscellaneous_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  identification();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  identification(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  identification(const identification &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual identification *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  identification &operator=(const identification &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~identification();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  creator_sequence creator_;
  rights_sequence rights_;
  encoding_optional encoding_;
  source_optional source_;
  relation_sequence relation_;
  miscellaneous_optional miscellaneous_;

  //@endcond
};

/**
 * @brief Class corresponding to the %miscellaneous schema type.
 *
 * If a program has other metadata not yet supported in the MusicXML
 * format, it can go in the miscellaneous element. The miscellaneous type
 * puts each separate part of metadata into its own miscellaneous-field
 * type.
 *
 * @nosubgrouping
 */
class miscellaneous : public ::xml_schema::type {
public:
  /**
   * @name miscellaneous-field
   *
   * @brief Accessor and modifier functions for the %miscellaneous-field
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::miscellaneous_field miscellaneous_field_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<miscellaneous_field_type>
    miscellaneous_field_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef miscellaneous_field_sequence::iterator miscellaneous_field_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef miscellaneous_field_sequence::const_iterator
    miscellaneous_field_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<miscellaneous_field_type, char>
    miscellaneous_field_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const miscellaneous_field_sequence &miscellaneous_field() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  miscellaneous_field_sequence &miscellaneous_field();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void miscellaneous_field(const miscellaneous_field_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  miscellaneous();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  miscellaneous(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  miscellaneous(const miscellaneous &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual miscellaneous *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  miscellaneous &operator=(const miscellaneous &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~miscellaneous();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  miscellaneous_field_sequence miscellaneous_field_;

  //@endcond
};

/**
 * @brief Class corresponding to the %miscellaneous-field schema type.
 *
 * If a program has other metadata not yet supported in the MusicXML
 * format, each type of metadata can go in a miscellaneous-field element.
 * The required name attribute indicates the type of metadata the element
 * content represents.
 *
 * @nosubgrouping
 */
class miscellaneous_field : public ::xml_schema::string {
public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type &name() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  miscellaneous_field(const name_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  miscellaneous_field(const char *, const name_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  miscellaneous_field(const ::std::string &, const name_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  miscellaneous_field(const ::xml_schema::string &, const name_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  miscellaneous_field(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  miscellaneous_field(const miscellaneous_field &x, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual miscellaneous_field *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  miscellaneous_field &operator=(const miscellaneous_field &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~miscellaneous_field();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<name_type> name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %supports schema type.
 *
 * The supports type indicates if a MusicXML encoding supports a
 * particular MusicXML element. This is recommended for elements like
 * beam, stem, and accidental, where the absence of an element is
 * ambiguous if you do not know if the encoding supports that element.
 * For Version 2.0, the supports element is expanded to allow programs to
 * indicate support for particular attributes or particular values. This
 * lets applications communicate, for example, that all system and/or
 * page breaks are contained in the MusicXML file.
 *
 * @nosubgrouping
 */
class supports : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name element
   *
   * @brief Accessor and modifier functions for the %element
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::nmtoken element_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<element_type, char> element_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const element_type &element() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  element_type &element();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void element(const element_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void element(::std::unique_ptr<element_type> p);

  //@}

  /**
   * @name attribute
   *
   * @brief Accessor and modifier functions for the %attribute
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::nmtoken attribute_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<attribute_type> attribute_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<attribute_type, char> attribute_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const attribute_optional &attribute() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  attribute_optional &attribute();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void attribute(const attribute_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void attribute(const attribute_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void attribute(::std::unique_ptr<attribute_type> p);

  //@}

  /**
   * @name value
   *
   * @brief Accessor and modifier functions for the %value
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token value_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<value_type> value_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<value_type, char> value_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const value_optional &value() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  value_optional &value();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void value(const value_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void value(const value_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void value(::std::unique_ptr<value_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  supports(const type_type &, const element_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  supports(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  supports(const supports &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual supports *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  supports &operator=(const supports &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~supports();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<element_type> element_;
  attribute_optional attribute_;
  value_optional value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %appearance schema type.
 *
 * The appearance type controls general graphical settings for the
 * music's final form appearance on a printed page of display. This
 * includes support for line widths, definitions for note sizes, and
 * standard distances between notation elements, plus an extension
 * element for other aspects of appearance.
 *
 * @nosubgrouping
 */
class appearance : public ::xml_schema::type {
public:
  /**
   * @name line-width
   *
   * @brief Accessor and modifier functions for the %line-width
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::line_width line_width_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<line_width_type> line_width_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef line_width_sequence::iterator line_width_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef line_width_sequence::const_iterator line_width_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_width_type, char> line_width_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const line_width_sequence &line_width() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  line_width_sequence &line_width();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void line_width(const line_width_sequence &s);

  //@}

  /**
   * @name note-size
   *
   * @brief Accessor and modifier functions for the %note-size
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note_size note_size_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<note_size_type> note_size_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef note_size_sequence::iterator note_size_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef note_size_sequence::const_iterator note_size_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<note_size_type, char> note_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const note_size_sequence &note_size() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  note_size_sequence &note_size();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void note_size(const note_size_sequence &s);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::distance distance_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<distance_type> distance_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef distance_sequence::iterator distance_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef distance_sequence::const_iterator distance_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<distance_type, char> distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const distance_sequence &distance() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  distance_sequence &distance();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void distance(const distance_sequence &s);

  //@}

  /**
   * @name other-appearance
   *
   * @brief Accessor and modifier functions for the %other-appearance
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::other_appearance other_appearance_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<other_appearance_type>
    other_appearance_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef other_appearance_sequence::iterator other_appearance_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef other_appearance_sequence::const_iterator
    other_appearance_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_appearance_type, char>
    other_appearance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const other_appearance_sequence &other_appearance() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  other_appearance_sequence &other_appearance();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void other_appearance(const other_appearance_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  appearance();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  appearance(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  appearance(const appearance &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual appearance *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  appearance &operator=(const appearance &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~appearance();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  line_width_sequence line_width_;
  note_size_sequence note_size_;
  distance_sequence distance_;
  other_appearance_sequence other_appearance_;

  //@endcond
};

/**
 * @brief Class corresponding to the %distance schema type.
 *
 * The distance element represents standard distances between notation
 * elements in tenths. The type attribute defines what type of distance
 * is being defined. Valid values include hyphen (for hyphens in lyrics)
 * and beam.
 *
 * @nosubgrouping
 */
class distance : public ::musicxml::tenths {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::distance_type type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  distance(const ::xml_schema::decimal &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  distance(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  distance(const distance &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual distance *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  distance &operator=(const distance &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~distance();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %line-width schema type.
 *
 * The line-width type indicates the width of a line type in tenths. The
 * type attribute defines what type of line is being defined. Values
 * include beam, bracket, dashes, enclosure, ending, extend, heavy
 * barline, leger, light barline, octave shift, pedal, slur middle, slur
 * tip, staff, stem, tie middle, tie tip, tuplet bracket, and wedge. The
 * text content is expressed in tenths.
 *
 * @nosubgrouping
 */
class line_width : public ::musicxml::tenths {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_width_type type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  line_width(const ::xml_schema::decimal &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  line_width(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  line_width(const line_width &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual line_width *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  line_width &operator=(const line_width &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~line_width();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %measure-layout schema type.
 *
 * The measure-layout type includes the horizontal distance from the
 * previous measure.
 *
 * @nosubgrouping
 */
class measure_layout : public ::xml_schema::type {
public:
  /**
   * @name measure-distance
   *
   * @brief Accessor and modifier functions for the %measure-distance
   * optional element.
   *
   * The measure-distance element specifies the horizontal distance from
   * the previous measure. This value is only used for systems where there
   * is horizontal whitespace in the middle of a system, as in systems with
   * codas. To specify the measure width, use the width attribute of the
   * measure element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths measure_distance_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<measure_distance_type>
    measure_distance_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<measure_distance_type, char>
    measure_distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const measure_distance_optional &measure_distance() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  measure_distance_optional &measure_distance();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void measure_distance(const measure_distance_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void measure_distance(const measure_distance_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void measure_distance(::std::unique_ptr<measure_distance_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  measure_layout();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure_layout(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_layout(const measure_layout &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual measure_layout *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure_layout &operator=(const measure_layout &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~measure_layout();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  measure_distance_optional measure_distance_;

  //@endcond
};

/**
 * @brief Class corresponding to the %note-size schema type.
 *
 * The note-size type indicates the percentage of the regular note size
 * to use for notes with a cue and large size as defined in the type
 * element. The grace type is used for notes of cue size that that
 * include a grace element. The cue type is used for all other notes with
 * cue size, whether defined explicitly or implicitly via a cue element.
 * The large type is used for notes of large size. The text content
 * represent the numeric percentage. A value of 100 would be identical to
 * the size of a regular note as defined by the music font.
 *
 * @nosubgrouping
 */
class note_size : public ::musicxml::non_negative_decimal {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::note_size_type type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  note_size(const ::xml_schema::decimal &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note_size(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  note_size(const note_size &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual note_size *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  note_size &operator=(const note_size &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~note_size();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %other-appearance schema type.
 *
 * The other-appearance type is used to define any graphical settings not
 * yet in the current version of the MusicXML format. This allows
 * extended representation, though without application interoperability.
 *
 * @nosubgrouping
 */
class other_appearance : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  other_appearance(const type_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  other_appearance(const char *, const type_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  other_appearance(const ::std::string &, const type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  other_appearance(const ::xml_schema::string &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  other_appearance(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  other_appearance(const other_appearance &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual other_appearance *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  other_appearance &operator=(const other_appearance &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~other_appearance();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %page-layout schema type.
 *
 * Page layout can be defined both in score-wide defaults and in the
 * print element. Page margins are specified either for both even and odd
 * pages, or via separate odd and even page number values. The type is
 * not needed when used as part of a print element. If omitted when used
 * in the defaults element, "both" is the default.
 *
 * @nosubgrouping
 */
class page_layout : public ::xml_schema::type {
public:
  /**
   * @name page-height
   *
   * @brief Accessor and modifier functions for the %page-height
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths page_height_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<page_height_type> page_height_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<page_height_type, char> page_height_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const page_height_optional &page_height() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  page_height_optional &page_height();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void page_height(const page_height_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void page_height(const page_height_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void page_height(::std::unique_ptr<page_height_type> p);

  //@}

  /**
   * @name page-width
   *
   * @brief Accessor and modifier functions for the %page-width
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths page_width_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<page_width_type> page_width_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<page_width_type, char> page_width_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const page_width_optional &page_width() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  page_width_optional &page_width();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void page_width(const page_width_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void page_width(const page_width_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void page_width(::std::unique_ptr<page_width_type> p);

  //@}

  /**
   * @name page-margins
   *
   * @brief Accessor and modifier functions for the %page-margins
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::page_margins page_margins_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<page_margins_type> page_margins_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef page_margins_sequence::iterator page_margins_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef page_margins_sequence::const_iterator page_margins_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<page_margins_type, char> page_margins_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const page_margins_sequence &page_margins() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  page_margins_sequence &page_margins();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void page_margins(const page_margins_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  page_layout();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  page_layout(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  page_layout(const page_layout &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual page_layout *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  page_layout &operator=(const page_layout &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~page_layout();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  page_height_optional page_height_;
  page_width_optional page_width_;
  page_margins_sequence page_margins_;

  //@endcond
};

/**
 * @brief Class corresponding to the %page-margins schema type.
 *
 * Page margins are specified either for both even and odd pages, or via
 * separate odd and even page number values. The type attribute is not
 * needed when used as part of a print element. If omitted when the
 * page-margins type is used in the defaults element, "both" is the
 * default value.
 *
 * @nosubgrouping
 */
class page_margins : public ::xml_schema::type {
public:
  /**
   * @name left-margin
   *
   * @brief Accessor and modifier functions for the %left-margin
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths left_margin_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<left_margin_type, char> left_margin_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const left_margin_type &left_margin() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  left_margin_type &left_margin();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void left_margin(const left_margin_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void left_margin(::std::unique_ptr<left_margin_type> p);

  //@}

  /**
   * @name right-margin
   *
   * @brief Accessor and modifier functions for the %right-margin
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths right_margin_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<right_margin_type, char> right_margin_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const right_margin_type &right_margin() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  right_margin_type &right_margin();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void right_margin(const right_margin_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void right_margin(::std::unique_ptr<right_margin_type> p);

  //@}

  /**
   * @name top-margin
   *
   * @brief Accessor and modifier functions for the %top-margin
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths top_margin_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<top_margin_type, char> top_margin_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const top_margin_type &top_margin() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  top_margin_type &top_margin();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void top_margin(const top_margin_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void top_margin(::std::unique_ptr<top_margin_type> p);

  //@}

  /**
   * @name bottom-margin
   *
   * @brief Accessor and modifier functions for the %bottom-margin
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths bottom_margin_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bottom_margin_type, char>
    bottom_margin_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const bottom_margin_type &bottom_margin() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  bottom_margin_type &bottom_margin();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void bottom_margin(const bottom_margin_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void bottom_margin(::std::unique_ptr<bottom_margin_type> p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::margin_type type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<type_type> type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional &type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  type_optional &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void type(const type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  page_margins(const left_margin_type &, const right_margin_type &,
               const top_margin_type &, const bottom_margin_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  page_margins(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  page_margins(const page_margins &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual page_margins *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  page_margins &operator=(const page_margins &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~page_margins();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<left_margin_type> left_margin_;
  ::xsd::cxx::tree::one<right_margin_type> right_margin_;
  ::xsd::cxx::tree::one<top_margin_type> top_margin_;
  ::xsd::cxx::tree::one<bottom_margin_type> bottom_margin_;
  type_optional type_;

  //@endcond
};

/**
 * @brief Class corresponding to the %scaling schema type.
 *
 * Margins, page sizes, and distances are all measured in tenths to keep
 * MusicXML data in a consistent coordinate system as much as possible.
 * The translation to absolute units is done with the scaling type, which
 * specifies how many millimeters are equal to how many tenths. For a
 * staff height of 7 mm, millimeters would be set to 7 while tenths is
 * set to 40. The ability to set a formula rather than a single scaling
 * factor helps avoid roundoff errors.
 *
 * @nosubgrouping
 */
class scaling : public ::xml_schema::type {
public:
  /**
   * @name millimeters
   *
   * @brief Accessor and modifier functions for the %millimeters
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::millimeters millimeters_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<millimeters_type, char> millimeters_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const millimeters_type &millimeters() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  millimeters_type &millimeters();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void millimeters(const millimeters_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void millimeters(::std::unique_ptr<millimeters_type> p);

  //@}

  /**
   * @name tenths
   *
   * @brief Accessor and modifier functions for the %tenths
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths tenths_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tenths_type, char> tenths_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const tenths_type &tenths() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  tenths_type &tenths();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tenths(const tenths_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void tenths(::std::unique_ptr<tenths_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  scaling(const millimeters_type &, const tenths_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  scaling(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  scaling(const scaling &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual scaling *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  scaling &operator=(const scaling &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~scaling();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<millimeters_type> millimeters_;
  ::xsd::cxx::tree::one<tenths_type> tenths_;

  //@endcond
};

/**
 * @brief Class corresponding to the %staff-layout schema type.
 *
 * Staff layout includes the vertical distance from the bottom line of
 * the previous staff in this system to the top line of the staff
 * specified by the number attribute. The optional number attribute
 * refers to staff numbers within the part, from top to bottom on the
 * system. A value of 1 is assumed if not present. When used in the
 * defaults element, the values apply to all parts. This value is ignored
 * for the first staff in a system.
 *
 * @nosubgrouping
 */
class staff_layout : public ::xml_schema::type {
public:
  /**
   * @name staff-distance
   *
   * @brief Accessor and modifier functions for the %staff-distance
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths staff_distance_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_distance_type>
    staff_distance_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_distance_type, char>
    staff_distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_distance_optional &staff_distance() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staff_distance_optional &staff_distance();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staff_distance(const staff_distance_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staff_distance(const staff_distance_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void staff_distance(::std::unique_ptr<staff_distance_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::staff_number number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  staff_layout();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  staff_layout(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_layout(const staff_layout &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual staff_layout *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  staff_layout &operator=(const staff_layout &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~staff_layout();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  staff_distance_optional staff_distance_;
  number_optional number_;

  //@endcond
};

/**
 * @brief Class corresponding to the %system-dividers schema type.
 *
 * The system-dividers element indicates the presence or absence of
 * system dividers (also known as system separation marks) between
 * systems displayed on the same page. Dividers on the left and right
 * side of the page are controlled by the left-divider and right-divider
 * elements respectively. The default vertical position is half the
 * system-distance value from the top of the system that is below the
 * divider. The default horizontal position is the left and right system
 * margin, respectively.
 *
 * When used in the print element, the system-dividers element affects
 * the dividers that would appear between the current system and the
 * previous system.
 *
 * @nosubgrouping
 */
class system_dividers : public ::xml_schema::type {
public:
  /**
   * @name left-divider
   *
   * @brief Accessor and modifier functions for the %left-divider
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_object_style_align left_divider_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<left_divider_type, char> left_divider_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const left_divider_type &left_divider() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  left_divider_type &left_divider();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void left_divider(const left_divider_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void left_divider(::std::unique_ptr<left_divider_type> p);

  //@}

  /**
   * @name right-divider
   *
   * @brief Accessor and modifier functions for the %right-divider
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_print_object_style_align right_divider_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<right_divider_type, char>
    right_divider_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const right_divider_type &right_divider() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  right_divider_type &right_divider();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void right_divider(const right_divider_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void right_divider(::std::unique_ptr<right_divider_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  system_dividers(const left_divider_type &, const right_divider_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  system_dividers(::std::unique_ptr<left_divider_type>,
                  ::std::unique_ptr<right_divider_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  system_dividers(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  system_dividers(const system_dividers &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual system_dividers *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  system_dividers &operator=(const system_dividers &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~system_dividers();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<left_divider_type> left_divider_;
  ::xsd::cxx::tree::one<right_divider_type> right_divider_;

  //@endcond
};

/**
 * @brief Class corresponding to the %system-layout schema type.
 *
 * A system is a group of staves that are read and played simultaneously.
 * System layout includes left and right margins and the vertical
 * distance from the previous system. The system distance is measured
 * from the bottom line of the previous system to the top line of the
 * current system. It is ignored for the first system on a page. The top
 * system distance is measured from the page's top margin to the top line
 * of the first system. It is ignored for all but the first system on a
 * page.
 *
 * Sometimes the sum of measure widths in a system may not equal the
 * system width specified by the layout elements due to roundoff or other
 * errors. The behavior when reading MusicXML files in these cases is
 * application-dependent. For instance, applications may find that the
 * system layout data is more reliable than the sum of the measure
 * widths, and adjust the measure widths accordingly.
 *
 * @nosubgrouping
 */
class system_layout : public ::xml_schema::type {
public:
  /**
   * @name system-margins
   *
   * @brief Accessor and modifier functions for the %system-margins
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::system_margins system_margins_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<system_margins_type>
    system_margins_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<system_margins_type, char>
    system_margins_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const system_margins_optional &system_margins() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  system_margins_optional &system_margins();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void system_margins(const system_margins_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void system_margins(const system_margins_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void system_margins(::std::unique_ptr<system_margins_type> p);

  //@}

  /**
   * @name system-distance
   *
   * @brief Accessor and modifier functions for the %system-distance
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths system_distance_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<system_distance_type>
    system_distance_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<system_distance_type, char>
    system_distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const system_distance_optional &system_distance() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  system_distance_optional &system_distance();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void system_distance(const system_distance_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void system_distance(const system_distance_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void system_distance(::std::unique_ptr<system_distance_type> p);

  //@}

  /**
   * @name top-system-distance
   *
   * @brief Accessor and modifier functions for the %top-system-distance
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths top_system_distance_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<top_system_distance_type>
    top_system_distance_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<top_system_distance_type, char>
    top_system_distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const top_system_distance_optional &top_system_distance() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  top_system_distance_optional &top_system_distance();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void top_system_distance(const top_system_distance_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void top_system_distance(const top_system_distance_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void top_system_distance(::std::unique_ptr<top_system_distance_type> p);

  //@}

  /**
   * @name system-dividers
   *
   * @brief Accessor and modifier functions for the %system-dividers
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::system_dividers system_dividers_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<system_dividers_type>
    system_dividers_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<system_dividers_type, char>
    system_dividers_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const system_dividers_optional &system_dividers() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  system_dividers_optional &system_dividers();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void system_dividers(const system_dividers_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void system_dividers(const system_dividers_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void system_dividers(::std::unique_ptr<system_dividers_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  system_layout();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  system_layout(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  system_layout(const system_layout &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual system_layout *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  system_layout &operator=(const system_layout &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~system_layout();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  system_margins_optional system_margins_;
  system_distance_optional system_distance_;
  top_system_distance_optional top_system_distance_;
  system_dividers_optional system_dividers_;

  //@endcond
};

/**
 * @brief Class corresponding to the %system-margins schema type.
 *
 * System margins are relative to the page margins. Positive values
 * indent and negative values reduce the margin size.
 *
 * @nosubgrouping
 */
class system_margins : public ::xml_schema::type {
public:
  /**
   * @name left-margin
   *
   * @brief Accessor and modifier functions for the %left-margin
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths left_margin_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<left_margin_type, char> left_margin_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const left_margin_type &left_margin() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  left_margin_type &left_margin();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void left_margin(const left_margin_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void left_margin(::std::unique_ptr<left_margin_type> p);

  //@}

  /**
   * @name right-margin
   *
   * @brief Accessor and modifier functions for the %right-margin
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tenths right_margin_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<right_margin_type, char> right_margin_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const right_margin_type &right_margin() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  right_margin_type &right_margin();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void right_margin(const right_margin_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void right_margin(::std::unique_ptr<right_margin_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  system_margins(const left_margin_type &, const right_margin_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  system_margins(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  system_margins(const system_margins &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual system_margins *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  system_margins &operator=(const system_margins &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~system_margins();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<left_margin_type> left_margin_;
  ::xsd::cxx::tree::one<right_margin_type> right_margin_;

  //@endcond
};

/**
 * @brief Class corresponding to the %bookmark schema type.
 *
 * The bookmark type serves as a well-defined target for an incoming
 * simple XLink.
 *
 * @nosubgrouping
 */
class bookmark : public ::xml_schema::type {
public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::id id_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const id_type &id() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  id_type &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token name_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<name_type> name_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const name_optional &name() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  name_optional &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void name(const name_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name element
   *
   * @brief Accessor and modifier functions for the %element
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::nmtoken element_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<element_type> element_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<element_type, char> element_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const element_optional &element() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  element_optional &element();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void element(const element_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void element(const element_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void element(::std::unique_ptr<element_type> p);

  //@}

  /**
   * @name position
   *
   * @brief Accessor and modifier functions for the %position
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer position_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<position_type> position_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<position_type, char> position_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const position_optional &position() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  position_optional &position();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void position(const position_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void position(const position_optional &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  bookmark(const id_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bookmark(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bookmark(const bookmark &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bookmark *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bookmark &operator=(const bookmark &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~bookmark();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<id_type> id_;
  name_optional name_;
  element_optional element_;
  position_optional position_;

  //@endcond
};

/**
 * @brief Class corresponding to the %link schema type.
 *
 * The link type serves as an outgoing simple XLink. It is also used to
 * connect a MusicXML score with a MusicXML opus. If a relative link is
 * used within a document that is part of a compressed MusicXML file, the
 * link is relative to the  root folder of the zip file.
 *
 * @nosubgrouping
 */
class link : public ::xml_schema::type {
public:
  /**
   * @name href
   *
   * @brief Accessor and modifier functions for the %href
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::uri href_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<href_type, char> href_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const href_type &href() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  href_type &href();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void href(const href_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void href(::std::unique_ptr<href_type> p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xlink::type type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const type_type &type_default_value();

  //@}

  /**
   * @name role
   *
   * @brief Accessor and modifier functions for the %role
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token role_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<role_type> role_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<role_type, char> role_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const role_optional &role() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  role_optional &role();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void role(const role_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void role(const role_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void role(::std::unique_ptr<role_type> p);

  //@}

  /**
   * @name title
   *
   * @brief Accessor and modifier functions for the %title
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token title_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<title_type> title_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<title_type, char> title_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const title_optional &title() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  title_optional &title();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void title(const title_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void title(const title_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void title(::std::unique_ptr<title_type> p);

  //@}

  /**
   * @name show
   *
   * @brief Accessor and modifier functions for the %show
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xlink::show show_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<show_type, char> show_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const show_type &show() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  show_type &show();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void show(const show_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void show(::std::unique_ptr<show_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const show_type &show_default_value();

  //@}

  /**
   * @name actuate
   *
   * @brief Accessor and modifier functions for the %actuate
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xlink::actuate actuate_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<actuate_type, char> actuate_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const actuate_type &actuate() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  actuate_type &actuate();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void actuate(const actuate_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void actuate(::std::unique_ptr<actuate_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const actuate_type &actuate_default_value();

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token name_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<name_type> name_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const name_optional &name() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  name_optional &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void name(const name_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name element
   *
   * @brief Accessor and modifier functions for the %element
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::nmtoken element_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<element_type> element_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<element_type, char> element_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const element_optional &element() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  element_optional &element();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void element(const element_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void element(const element_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void element(::std::unique_ptr<element_type> p);

  //@}

  /**
   * @name position
   *
   * @brief Accessor and modifier functions for the %position
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer position_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<position_type> position_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<position_type, char> position_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const position_optional &position() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  position_optional &position();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void position(const position_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void position(const position_optional &x);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  link(const href_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  link(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  link(const link &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual link *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  link &operator=(const link &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~link();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<href_type> href_;
  ::xsd::cxx::tree::one<type_type> type_;
  static const type_type type_default_value_;
  role_optional role_;
  title_optional title_;
  ::xsd::cxx::tree::one<show_type> show_;
  static const show_type show_default_value_;
  ::xsd::cxx::tree::one<actuate_type> actuate_;
  static const actuate_type actuate_default_value_;
  name_optional name_;
  element_optional element_;
  position_optional position_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;

  //@endcond
};

/**
 * @brief Class corresponding to the %accidental schema type.
 *
 * The accidental type represents actual notated accidentals. Editorial
 * and cautionary indications are indicated by attributes. Values for
 * these attributes are "no" if not present. Specific graphic display
 * such as parentheses, brackets, and size are controlled by the
 * level-display attribute group.
 *
 * @nosubgrouping
 */
class accidental : public ::musicxml::accidental_value {
public:
  /**
   * @name cautionary
   *
   * @brief Accessor and modifier functions for the %cautionary
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no cautionary_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<cautionary_type> cautionary_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<cautionary_type, char> cautionary_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const cautionary_optional &cautionary() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  cautionary_optional &cautionary();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void cautionary(const cautionary_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void cautionary(const cautionary_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void cautionary(::std::unique_ptr<cautionary_type> p);

  //@}

  /**
   * @name editorial
   *
   * @brief Accessor and modifier functions for the %editorial
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no editorial_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<editorial_type> editorial_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<editorial_type, char> editorial_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const editorial_optional &editorial() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  editorial_optional &editorial();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void editorial(const editorial_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void editorial(const editorial_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void editorial(::std::unique_ptr<editorial_type> p);

  //@}

  /**
   * @name parentheses
   *
   * @brief Accessor and modifier functions for the %parentheses
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no parentheses_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<parentheses_type> parentheses_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<parentheses_type, char> parentheses_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const parentheses_optional &parentheses() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  parentheses_optional &parentheses();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void parentheses(const parentheses_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void parentheses(const parentheses_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void parentheses(::std::unique_ptr<parentheses_type> p);

  //@}

  /**
   * @name bracket
   *
   * @brief Accessor and modifier functions for the %bracket
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no bracket_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bracket_type> bracket_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bracket_type, char> bracket_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bracket_optional &bracket() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bracket_optional &bracket();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bracket(const bracket_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bracket(const bracket_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bracket(::std::unique_ptr<bracket_type> p);

  //@}

  /**
   * @name size
   *
   * @brief Accessor and modifier functions for the %size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::symbol_size size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<size_type> size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<size_type, char> size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const size_optional &size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  size_optional &size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void size(const size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void size(const size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void size(::std::unique_ptr<size_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  accidental(::musicxml::accidental_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  accidental(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  accidental(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  accidental(const ::musicxml::accidental_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accidental(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accidental(const accidental &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual accidental *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accidental &operator=(const accidental &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~accidental();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  cautionary_optional cautionary_;
  editorial_optional editorial_;
  parentheses_optional parentheses_;
  bracket_optional bracket_;
  size_optional size_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %accidental-mark schema type.
 *
 * An accidental-mark can be used as a separate notation or as part of an
 * ornament. When used in an ornament, position and placement are
 * relative to the ornament, not relative to the note.
 *
 * @nosubgrouping
 */
class accidental_mark : public ::musicxml::accidental_value {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  accidental_mark(::musicxml::accidental_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  accidental_mark(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  accidental_mark(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  accidental_mark(const ::musicxml::accidental_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accidental_mark(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accidental_mark(const accidental_mark &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual accidental_mark *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accidental_mark &operator=(const accidental_mark &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~accidental_mark();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %arpeggiate schema type.
 *
 * The arpeggiate type indicates that this note is part of an arpeggiated
 * chord. The number attribute can be used to distinguish between two
 * simultaneous chords arpeggiated separately (different numbers) or
 * together (same number). The up-down attribute is used if there is an
 * arrow on the arpeggio sign. By default, arpeggios go from the lowest
 * to highest note.
 *
 * @nosubgrouping
 */
class arpeggiate : public ::xml_schema::type {
public:
  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name direction
   *
   * @brief Accessor and modifier functions for the %direction
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::up_down direction_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<direction_type> direction_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<direction_type, char> direction_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const direction_optional &direction() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  direction_optional &direction();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void direction(const direction_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void direction(const direction_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void direction(::std::unique_ptr<direction_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  arpeggiate();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  arpeggiate(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  arpeggiate(const arpeggiate &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual arpeggiate *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  arpeggiate &operator=(const arpeggiate &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~arpeggiate();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  number_optional number_;
  direction_optional direction_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  placement_optional placement_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %articulations schema type.
 *
 * Articulations and accents are grouped together here.
 *
 * @nosubgrouping
 */
class articulations : public ::xml_schema::type {
public:
  /**
   * @name accent
   *
   * @brief Accessor and modifier functions for the %accent
   * sequence element.
   *
   * The accent element indicates a regular horizontal accent mark.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement accent_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<accent_type> accent_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef accent_sequence::iterator accent_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef accent_sequence::const_iterator accent_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accent_type, char> accent_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const accent_sequence &accent() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  accent_sequence &accent();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void accent(const accent_sequence &s);

  //@}

  /**
   * @name strong-accent
   *
   * @brief Accessor and modifier functions for the %strong-accent
   * sequence element.
   *
   * The strong-accent element indicates a vertical accent mark.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::strong_accent strong_accent_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<strong_accent_type> strong_accent_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef strong_accent_sequence::iterator strong_accent_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef strong_accent_sequence::const_iterator strong_accent_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<strong_accent_type, char>
    strong_accent_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const strong_accent_sequence &strong_accent() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  strong_accent_sequence &strong_accent();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void strong_accent(const strong_accent_sequence &s);

  //@}

  /**
   * @name staccato
   *
   * @brief Accessor and modifier functions for the %staccato
   * sequence element.
   *
   * The staccato element is used for a dot articulation, as opposed to a
   * stroke or a wedge.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement staccato_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<staccato_type> staccato_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef staccato_sequence::iterator staccato_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef staccato_sequence::const_iterator staccato_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staccato_type, char> staccato_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const staccato_sequence &staccato() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  staccato_sequence &staccato();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void staccato(const staccato_sequence &s);

  //@}

  /**
   * @name tenuto
   *
   * @brief Accessor and modifier functions for the %tenuto
   * sequence element.
   *
   * The tenuto element indicates a tenuto line symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement tenuto_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<tenuto_type> tenuto_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef tenuto_sequence::iterator tenuto_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef tenuto_sequence::const_iterator tenuto_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tenuto_type, char> tenuto_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const tenuto_sequence &tenuto() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  tenuto_sequence &tenuto();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void tenuto(const tenuto_sequence &s);

  //@}

  /**
   * @name detached-legato
   *
   * @brief Accessor and modifier functions for the %detached-legato
   * sequence element.
   *
   * The detached-legato element indicates the combination of a tenuto line
   * and staccato dot symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement detached_legato_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<detached_legato_type>
    detached_legato_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef detached_legato_sequence::iterator detached_legato_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef detached_legato_sequence::const_iterator
    detached_legato_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<detached_legato_type, char>
    detached_legato_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const detached_legato_sequence &detached_legato() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  detached_legato_sequence &detached_legato();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void detached_legato(const detached_legato_sequence &s);

  //@}

  /**
   * @name staccatissimo
   *
   * @brief Accessor and modifier functions for the %staccatissimo
   * sequence element.
   *
   * The staccatissimo element is used for a wedge articulation, as opposed
   * to a dot or a stroke.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement staccatissimo_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<staccatissimo_type> staccatissimo_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef staccatissimo_sequence::iterator staccatissimo_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef staccatissimo_sequence::const_iterator staccatissimo_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staccatissimo_type, char>
    staccatissimo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const staccatissimo_sequence &staccatissimo() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  staccatissimo_sequence &staccatissimo();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void staccatissimo(const staccatissimo_sequence &s);

  //@}

  /**
   * @name spiccato
   *
   * @brief Accessor and modifier functions for the %spiccato
   * sequence element.
   *
   * The spiccato element is used for a stroke articulation, as opposed to
   * a dot or a wedge.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement spiccato_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<spiccato_type> spiccato_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef spiccato_sequence::iterator spiccato_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef spiccato_sequence::const_iterator spiccato_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<spiccato_type, char> spiccato_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const spiccato_sequence &spiccato() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  spiccato_sequence &spiccato();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void spiccato(const spiccato_sequence &s);

  //@}

  /**
   * @name scoop
   *
   * @brief Accessor and modifier functions for the %scoop
   * sequence element.
   *
   * The scoop element is an indeterminate slide attached to a single note.
   * The scoop element appears before the main note and comes from below
   * the main pitch.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_line scoop_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<scoop_type> scoop_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef scoop_sequence::iterator scoop_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef scoop_sequence::const_iterator scoop_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<scoop_type, char> scoop_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const scoop_sequence &scoop() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  scoop_sequence &scoop();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void scoop(const scoop_sequence &s);

  //@}

  /**
   * @name plop
   *
   * @brief Accessor and modifier functions for the %plop
   * sequence element.
   *
   * The plop element is an indeterminate slide attached to a single note.
   * The plop element appears before the main note and comes from above the
   * main pitch.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_line plop_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<plop_type> plop_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef plop_sequence::iterator plop_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef plop_sequence::const_iterator plop_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<plop_type, char> plop_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const plop_sequence &plop() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  plop_sequence &plop();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void plop(const plop_sequence &s);

  //@}

  /**
   * @name doit
   *
   * @brief Accessor and modifier functions for the %doit
   * sequence element.
   *
   * The doit element is an indeterminate slide attached to a single note.
   * The doit element appears after the main note and goes above the main
   * pitch.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_line doit_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<doit_type> doit_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef doit_sequence::iterator doit_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef doit_sequence::const_iterator doit_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<doit_type, char> doit_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const doit_sequence &doit() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  doit_sequence &doit();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void doit(const doit_sequence &s);

  //@}

  /**
   * @name falloff
   *
   * @brief Accessor and modifier functions for the %falloff
   * sequence element.
   *
   * The falloff element is an indeterminate slide attached to a single
   * note. The falloff element appears before the main note and goes below
   * the main pitch.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_line falloff_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<falloff_type> falloff_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef falloff_sequence::iterator falloff_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef falloff_sequence::const_iterator falloff_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<falloff_type, char> falloff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const falloff_sequence &falloff() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  falloff_sequence &falloff();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void falloff(const falloff_sequence &s);

  //@}

  /**
   * @name breath-mark
   *
   * @brief Accessor and modifier functions for the %breath-mark
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::breath_mark breath_mark_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<breath_mark_type> breath_mark_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef breath_mark_sequence::iterator breath_mark_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef breath_mark_sequence::const_iterator breath_mark_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<breath_mark_type, char> breath_mark_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const breath_mark_sequence &breath_mark() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  breath_mark_sequence &breath_mark();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void breath_mark(const breath_mark_sequence &s);

  //@}

  /**
   * @name caesura
   *
   * @brief Accessor and modifier functions for the %caesura
   * sequence element.
   *
   * The caesura element indicates a slight pause. It is notated using a
   * "railroad tracks" symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement caesura_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<caesura_type> caesura_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef caesura_sequence::iterator caesura_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef caesura_sequence::const_iterator caesura_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<caesura_type, char> caesura_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const caesura_sequence &caesura() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  caesura_sequence &caesura();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void caesura(const caesura_sequence &s);

  //@}

  /**
   * @name stress
   *
   * @brief Accessor and modifier functions for the %stress
   * sequence element.
   *
   * The stress element indicates a stressed note.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement stress_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<stress_type> stress_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef stress_sequence::iterator stress_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef stress_sequence::const_iterator stress_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<stress_type, char> stress_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const stress_sequence &stress() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  stress_sequence &stress();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void stress(const stress_sequence &s);

  //@}

  /**
   * @name unstress
   *
   * @brief Accessor and modifier functions for the %unstress
   * sequence element.
   *
   * The unstress element indicates an unstressed note. It is often notated
   * using a u-shaped symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement unstress_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<unstress_type> unstress_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef unstress_sequence::iterator unstress_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef unstress_sequence::const_iterator unstress_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<unstress_type, char> unstress_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const unstress_sequence &unstress() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  unstress_sequence &unstress();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void unstress(const unstress_sequence &s);

  //@}

  /**
   * @name other-articulation
   *
   * @brief Accessor and modifier functions for the %other-articulation
   * sequence element.
   *
   * The other-articulation element is used to define any articulations not
   * yet in the MusicXML format. This allows extended representation,
   * though without application interoperability.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::placement_text other_articulation_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<other_articulation_type>
    other_articulation_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef other_articulation_sequence::iterator other_articulation_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef other_articulation_sequence::const_iterator
    other_articulation_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_articulation_type, char>
    other_articulation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const other_articulation_sequence &other_articulation() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  other_articulation_sequence &other_articulation();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void other_articulation(const other_articulation_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  articulations();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  articulations(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  articulations(const articulations &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual articulations *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  articulations &operator=(const articulations &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~articulations();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  accent_sequence accent_;
  strong_accent_sequence strong_accent_;
  staccato_sequence staccato_;
  tenuto_sequence tenuto_;
  detached_legato_sequence detached_legato_;
  staccatissimo_sequence staccatissimo_;
  spiccato_sequence spiccato_;
  scoop_sequence scoop_;
  plop_sequence plop_;
  doit_sequence doit_;
  falloff_sequence falloff_;
  breath_mark_sequence breath_mark_;
  caesura_sequence caesura_;
  stress_sequence stress_;
  unstress_sequence unstress_;
  other_articulation_sequence other_articulation_;

  //@endcond
};

/**
 * @brief Class corresponding to the %arrow schema type.
 *
 * The arrow element represents an arrow used for a musical technical
 * indication..
 *
 * @nosubgrouping
 */
class arrow : public ::xml_schema::type {
public:
  /**
   * @name arrow-direction
   *
   * @brief Accessor and modifier functions for the %arrow-direction
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::arrow_direction arrow_direction_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<arrow_direction_type>
    arrow_direction_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<arrow_direction_type, char>
    arrow_direction_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const arrow_direction_optional &arrow_direction() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  arrow_direction_optional &arrow_direction();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void arrow_direction(const arrow_direction_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void arrow_direction(const arrow_direction_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void arrow_direction(::std::unique_ptr<arrow_direction_type> p);

  //@}

  /**
   * @name arrow-style
   *
   * @brief Accessor and modifier functions for the %arrow-style
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::arrow_style arrow_style_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<arrow_style_type> arrow_style_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<arrow_style_type, char> arrow_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const arrow_style_optional &arrow_style() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  arrow_style_optional &arrow_style();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void arrow_style(const arrow_style_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void arrow_style(const arrow_style_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void arrow_style(::std::unique_ptr<arrow_style_type> p);

  //@}

  /**
   * @name circular-arrow
   *
   * @brief Accessor and modifier functions for the %circular-arrow
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::circular_arrow circular_arrow_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<circular_arrow_type>
    circular_arrow_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<circular_arrow_type, char>
    circular_arrow_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const circular_arrow_optional &circular_arrow() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  circular_arrow_optional &circular_arrow();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void circular_arrow(const circular_arrow_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void circular_arrow(const circular_arrow_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void circular_arrow(::std::unique_ptr<circular_arrow_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  arrow();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  arrow(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  arrow(const arrow &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual arrow *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  arrow &operator=(const arrow &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~arrow();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  arrow_direction_optional arrow_direction_;
  arrow_style_optional arrow_style_;
  circular_arrow_optional circular_arrow_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %backup schema type.
 *
 * The backup and forward elements are required to coordinate multiple
 * voices in one part, including music on multiple staves. The backup
 * type is generally used to move between voices and staves. Thus the
 * backup element does not include voice or staff elements. Duration
 * values should always be positive, and should not cross measure
 * boundaries or mid-measure changes in the divisions value.
 *
 * @nosubgrouping
 */
class backup : public ::xml_schema::type {
public:
  /**
   * @name duration
   *
   * @brief Accessor and modifier functions for the %duration
   * required element.
   *
   * Duration is a positive number specified in division units. This is the
   * intended duration vs. notated duration (for instance, swing eighths
   * vs. even eighths, or differences in dotted notes in Baroque-era
   * music). Differences in duration specific to an interpretation or
   * performance should use the note element's attack and release
   * attributes.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::positive_divisions duration_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<duration_type, char> duration_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const duration_type &duration() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  duration_type &duration();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void duration(const duration_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void duration(::std::unique_ptr<duration_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  backup(const duration_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  backup(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  backup(const backup &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual backup *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  backup &operator=(const backup &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~backup();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<duration_type> duration_;
  footnote_optional footnote_;
  level_optional level_;

  //@endcond
};

/**
 * @brief Class corresponding to the %beam schema type.
 *
 * Beam values include begin, continue, end, forward hook, and backward
 * hook. Up to eight concurrent beams are available to cover up to 1024th
 * notes. Each beam in a note is represented with a separate beam
 * element, starting with the eighth note beam using a number attribute
 * of 1.
 *
 * Note that the beam number does not distinguish sets of beams that
 * overlap, as it does for slur and other elements. Beaming groups are
 * distinguished by being in different voices and/or the presence or
 * absence of grace and cue elements.
 *
 * Beams that have a begin value can also have a fan attribute to
 * indicate accelerandos and ritardandos using fanned beams. The fan
 * attribute may also be used with a continue value if the fanning
 * direction changes on that note. The value is "none" if not specified.
 *
 * The repeater attribute has been deprecated in MusicXML 3.0. Formerly
 * used for tremolos, it needs to be specified with a "yes" value for
 * each beam using it.
 *
 * @nosubgrouping
 */
class beam : public ::musicxml::beam_value {
public:
  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::beam_level number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static number_type number_default_value();

  //@}

  /**
   * @name repeater
   *
   * @brief Accessor and modifier functions for the %repeater
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no repeater_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<repeater_type> repeater_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<repeater_type, char> repeater_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const repeater_optional &repeater() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  repeater_optional &repeater();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void repeater(const repeater_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void repeater(const repeater_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void repeater(::std::unique_ptr<repeater_type> p);

  //@}

  /**
   * @name fan
   *
   * @brief Accessor and modifier functions for the %fan
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::fan fan_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<fan_type> fan_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<fan_type, char> fan_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const fan_optional &fan() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  fan_optional &fan();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void fan(const fan_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void fan(const fan_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void fan(::std::unique_ptr<fan_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  beam(::musicxml::beam_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  beam(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  beam(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  beam(const ::musicxml::beam_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  beam(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beam(const beam &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual beam *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  beam &operator=(const beam &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~beam();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<number_type> number_;
  repeater_optional repeater_;
  fan_optional fan_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %bend schema type.
 *
 * The bend type is used in guitar and tablature. The bend-alter element
 * indicates the number of steps in the bend, similar to the alter
 * element. As with the alter element, numbers like 0.5 can be used to
 * indicate microtones. Negative numbers indicate pre-bends or releases;
 * the pre-bend and release elements are used to distinguish what is
 * intended. A with-bar element indicates that the bend is to be done at
 * the bridge with a whammy or vibrato bar. The content of the element
 * indicates how this should be notated.
 *
 * @nosubgrouping
 */
class bend : public ::xml_schema::type {
public:
  /**
   * @name bend-alter
   *
   * @brief Accessor and modifier functions for the %bend-alter
   * required element.
   *
   * The bend-alter element indicates the number of steps in the bend,
   * similar to the alter element. As with the alter element, numbers like
   * 0.5 can be used to indicate microtones. Negative numbers indicate
   * pre-bends or releases; the pre-bend and release elements are used to
   * distinguish what is intended.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::semitones bend_alter_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bend_alter_type, char> bend_alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const bend_alter_type &bend_alter() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  bend_alter_type &bend_alter();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void bend_alter(const bend_alter_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void bend_alter(::std::unique_ptr<bend_alter_type> p);

  //@}

  /**
   * @name pre-bend
   *
   * @brief Accessor and modifier functions for the %pre-bend
   * optional element.
   *
   * The pre-bend element indicates that this is a pre-bend rather than a
   * normal bend or a release.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty pre_bend_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<pre_bend_type> pre_bend_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pre_bend_type, char> pre_bend_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const pre_bend_optional &pre_bend() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  pre_bend_optional &pre_bend();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void pre_bend(const pre_bend_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void pre_bend(const pre_bend_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void pre_bend(::std::unique_ptr<pre_bend_type> p);

  //@}

  /**
   * @name release
   *
   * @brief Accessor and modifier functions for the %release
   * optional element.
   *
   * The release element indicates that this is a release rather than a
   * normal bend or pre-bend.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty release_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<release_type> release_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<release_type, char> release_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const release_optional &release() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  release_optional &release();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void release(const release_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void release(const release_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void release(::std::unique_ptr<release_type> p);

  //@}

  /**
   * @name with-bar
   *
   * @brief Accessor and modifier functions for the %with-bar
   * optional element.
   *
   * The with-bar element indicates that the bend is to be done at the
   * bridge with a whammy or vibrato bar. The content of the element
   * indicates how this should be notated.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::placement_text with_bar_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<with_bar_type> with_bar_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<with_bar_type, char> with_bar_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const with_bar_optional &with_bar() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  with_bar_optional &with_bar();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void with_bar(const with_bar_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void with_bar(const with_bar_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void with_bar(::std::unique_ptr<with_bar_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name accelerate
   *
   * @brief Accessor and modifier functions for the %accelerate
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no accelerate_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accelerate_type> accelerate_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<accelerate_type, char> accelerate_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accelerate_optional &accelerate() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  accelerate_optional &accelerate();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void accelerate(const accelerate_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void accelerate(const accelerate_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accelerate(::std::unique_ptr<accelerate_type> p);

  //@}

  /**
   * @name beats
   *
   * @brief Accessor and modifier functions for the %beats
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::trill_beats beats_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<beats_type> beats_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<beats_type, char> beats_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const beats_optional &beats() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  beats_optional &beats();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void beats(const beats_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void beats(const beats_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void beats(::std::unique_ptr<beats_type> p);

  //@}

  /**
   * @name first-beat
   *
   * @brief Accessor and modifier functions for the %first-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent first_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<first_beat_type> first_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<first_beat_type, char> first_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const first_beat_optional &first_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  first_beat_optional &first_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void first_beat(const first_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void first_beat(const first_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void first_beat(::std::unique_ptr<first_beat_type> p);

  //@}

  /**
   * @name last-beat
   *
   * @brief Accessor and modifier functions for the %last-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent last_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<last_beat_type> last_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<last_beat_type, char> last_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const last_beat_optional &last_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  last_beat_optional &last_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void last_beat(const last_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void last_beat(const last_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void last_beat(::std::unique_ptr<last_beat_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  bend(const bend_alter_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bend(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bend(const bend &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bend *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bend &operator=(const bend &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~bend();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<bend_alter_type> bend_alter_;
  pre_bend_optional pre_bend_;
  release_optional release_;
  with_bar_optional with_bar_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  accelerate_optional accelerate_;
  beats_optional beats_;
  first_beat_optional first_beat_;
  last_beat_optional last_beat_;

  //@endcond
};

/**
 * @brief Class corresponding to the %breath-mark schema type.
 *
 * The breath-mark element indicates a place to take a breath.
 *
 * @nosubgrouping
 */
class breath_mark : public ::musicxml::breath_mark_value {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  breath_mark(::musicxml::breath_mark_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  breath_mark(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  breath_mark(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  breath_mark(const ::musicxml::breath_mark_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  breath_mark(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  breath_mark(const breath_mark &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual breath_mark *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  breath_mark &operator=(const breath_mark &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~breath_mark();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %empty-line schema type.
 *
 * The empty-line type represents an empty element with line-shape,
 * line-type, dashed-formatting, print-style and placement attributes.
 *
 * @nosubgrouping
 */
class empty_line : public ::xml_schema::type {
public:
  /**
   * @name line-shape
   *
   * @brief Accessor and modifier functions for the %line-shape
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_shape line_shape_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_shape_type> line_shape_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_shape_type, char> line_shape_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_shape_optional &line_shape() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_shape_optional &line_shape();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_shape(const line_shape_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_shape(const line_shape_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_shape(::std::unique_ptr<line_shape_type> p);

  //@}

  /**
   * @name line-type
   *
   * @brief Accessor and modifier functions for the %line-type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_type line_type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type_type> line_type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type_type, char> line_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_type_optional &line_type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_type_optional &line_type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_type(const line_type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_type(const line_type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_type(::std::unique_ptr<line_type_type> p);

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  empty_line();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty_line(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_line(const empty_line &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual empty_line *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_line &operator=(const empty_line &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~empty_line();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  line_shape_optional line_shape_;
  line_type_optional line_type_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %extend schema type.
 *
 * The extend type represents lyric word extension / melisma lines as
 * well as figured bass extensions. The optional type and position
 * attributes are added in Version 3.0 to provide better formatting
 * control.
 *
 * @nosubgrouping
 */
class extend : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_continue type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<type_type> type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional &type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  type_optional &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void type(const type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  extend();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  extend(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  extend(const extend &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual extend *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  extend &operator=(const extend &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~extend();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  type_optional type_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %figure schema type.
 *
 * The figure type represents a single figure within a figured-bass
 * element.
 *
 * @nosubgrouping
 */
class figure : public ::xml_schema::type {
public:
  /**
   * @name prefix
   *
   * @brief Accessor and modifier functions for the %prefix
   * optional element.
   *
   * Values for the prefix element include the accidental values sharp,
   * flat, natural, double-sharp, flat-flat, and sharp-sharp. The prefix
   * element may contain additional values for symbols specific to
   * particular figured bass styles.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::style_text prefix_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<prefix_type> prefix_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<prefix_type, char> prefix_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const prefix_optional &prefix() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  prefix_optional &prefix();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void prefix(const prefix_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void prefix(const prefix_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void prefix(::std::unique_ptr<prefix_type> p);

  //@}

  /**
   * @name figure-number
   *
   * @brief Accessor and modifier functions for the %figure-number
   * optional element.
   *
   * A figure-number is a number. Overstrikes of the figure number are
   * represented in the suffix element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::style_text figure_number_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<figure_number_type> figure_number_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<figure_number_type, char>
    figure_number_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const figure_number_optional &figure_number() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  figure_number_optional &figure_number();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void figure_number(const figure_number_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void figure_number(const figure_number_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void figure_number(::std::unique_ptr<figure_number_type> p);

  //@}

  /**
   * @name suffix
   *
   * @brief Accessor and modifier functions for the %suffix
   * optional element.
   *
   * Values for the suffix element include the accidental values sharp,
   * flat, natural, double-sharp, flat-flat, and sharp-sharp. Suffixes
   * include both symbols that come after the figure number and those that
   * overstrike the figure number. The suffix value slash is used for
   * slashed numbers indicating chromatic alteration. The orientation and
   * display of the slash usually depends on the figure number. The suffix
   * element may contain additional values for symbols specific to
   * particular figured bass styles.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::style_text suffix_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<suffix_type> suffix_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<suffix_type, char> suffix_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const suffix_optional &suffix() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  suffix_optional &suffix();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void suffix(const suffix_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void suffix(const suffix_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void suffix(::std::unique_ptr<suffix_type> p);

  //@}

  /**
   * @name extend
   *
   * @brief Accessor and modifier functions for the %extend
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::extend extend_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<extend_type> extend_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<extend_type, char> extend_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const extend_optional &extend() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  extend_optional &extend();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void extend(const extend_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void extend(const extend_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void extend(::std::unique_ptr<extend_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  figure();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  figure(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  figure(const figure &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual figure *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  figure &operator=(const figure &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~figure();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  prefix_optional prefix_;
  figure_number_optional figure_number_;
  suffix_optional suffix_;
  extend_optional extend_;

  //@endcond
};

/**
 * @brief Class corresponding to the %figured-bass schema type.
 *
 * The figured-bass element represents figured bass notation. Figured
 * bass elements take their position from the first regular note (not a
 * grace note or chord note) that follows in score order. The optional
 * duration element is used to indicate changes of figures under a note.
 *
 * Figures are ordered from top to bottom. The value of parentheses is
 * "no" if not present.
 *
 * @nosubgrouping
 */
class figured_bass : public ::xml_schema::type {
public:
  /**
   * @name figure
   *
   * @brief Accessor and modifier functions for the %figure
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::figure figure_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<figure_type> figure_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef figure_sequence::iterator figure_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef figure_sequence::const_iterator figure_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<figure_type, char> figure_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const figure_sequence &figure() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  figure_sequence &figure();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void figure(const figure_sequence &s);

  //@}

  /**
   * @name duration
   *
   * @brief Accessor and modifier functions for the %duration
   * optional element.
   *
   * Duration is a positive number specified in division units. This is the
   * intended duration vs. notated duration (for instance, swing eighths
   * vs. even eighths, or differences in dotted notes in Baroque-era
   * music). Differences in duration specific to an interpretation or
   * performance should use the note element's attack and release
   * attributes.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::positive_divisions duration_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<duration_type> duration_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<duration_type, char> duration_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const duration_optional &duration() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  duration_optional &duration();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void duration(const duration_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void duration(const duration_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void duration(::std::unique_ptr<duration_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name print-dot
   *
   * @brief Accessor and modifier functions for the %print-dot
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_dot_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_dot_type> print_dot_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_dot_type, char> print_dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_dot_optional &print_dot() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_dot_optional &print_dot();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_dot(const print_dot_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_dot(const print_dot_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_dot(::std::unique_ptr<print_dot_type> p);

  //@}

  /**
   * @name print-spacing
   *
   * @brief Accessor and modifier functions for the %print-spacing
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_spacing_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_spacing_type> print_spacing_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_spacing_type, char>
    print_spacing_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_spacing_optional &print_spacing() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_spacing_optional &print_spacing();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_spacing(const print_spacing_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_spacing(const print_spacing_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_spacing(::std::unique_ptr<print_spacing_type> p);

  //@}

  /**
   * @name print-lyric
   *
   * @brief Accessor and modifier functions for the %print-lyric
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_lyric_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_lyric_type> print_lyric_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_lyric_type, char> print_lyric_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_lyric_optional &print_lyric() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_lyric_optional &print_lyric();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_lyric(const print_lyric_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_lyric(const print_lyric_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_lyric(::std::unique_ptr<print_lyric_type> p);

  //@}

  /**
   * @name parentheses
   *
   * @brief Accessor and modifier functions for the %parentheses
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no parentheses_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<parentheses_type> parentheses_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<parentheses_type, char> parentheses_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const parentheses_optional &parentheses() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  parentheses_optional &parentheses();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void parentheses(const parentheses_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void parentheses(const parentheses_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void parentheses(::std::unique_ptr<parentheses_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  figured_bass();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  figured_bass(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  figured_bass(const figured_bass &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual figured_bass *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  figured_bass &operator=(const figured_bass &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~figured_bass();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  figure_sequence figure_;
  duration_optional duration_;
  footnote_optional footnote_;
  level_optional level_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  print_object_optional print_object_;
  print_dot_optional print_dot_;
  print_spacing_optional print_spacing_;
  print_lyric_optional print_lyric_;
  parentheses_optional parentheses_;

  //@endcond
};

/**
 * @brief Class corresponding to the %forward schema type.
 *
 * The backup and forward elements are required to coordinate multiple
 * voices in one part, including music on multiple staves. The forward
 * element is generally used within voices and staves. Duration values
 * should always be positive, and should not cross measure boundaries or
 * mid-measure changes in the divisions value.
 *
 * @nosubgrouping
 */
class forward : public ::xml_schema::type {
public:
  /**
   * @name duration
   *
   * @brief Accessor and modifier functions for the %duration
   * required element.
   *
   * Duration is a positive number specified in division units. This is the
   * intended duration vs. notated duration (for instance, swing eighths
   * vs. even eighths, or differences in dotted notes in Baroque-era
   * music). Differences in duration specific to an interpretation or
   * performance should use the note element's attack and release
   * attributes.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::positive_divisions duration_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<duration_type, char> duration_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const duration_type &duration() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  duration_type &duration();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void duration(const duration_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void duration(::std::unique_ptr<duration_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name voice
   *
   * @brief Accessor and modifier functions for the %voice
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string voice_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<voice_type> voice_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<voice_type, char> voice_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const voice_optional &voice() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  voice_optional &voice();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void voice(const voice_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void voice(const voice_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void voice(::std::unique_ptr<voice_type> p);

  //@}

  /**
   * @name staff
   *
   * @brief Accessor and modifier functions for the %staff
   * optional element.
   *
   * Staff assignment is only needed for music notated on multiple staves.
   * Used by both notes and directions. Staff values are numbers, with 1
   * referring to the top-most staff in a part.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::positive_integer staff_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_type> staff_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_type, char> staff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_optional &staff() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staff_optional &staff();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staff(const staff_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staff(const staff_optional &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  forward(const duration_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  forward(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  forward(const forward &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual forward *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  forward &operator=(const forward &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~forward();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<duration_type> duration_;
  footnote_optional footnote_;
  level_optional level_;
  voice_optional voice_;
  staff_optional staff_;

  //@endcond
};

/**
 * @brief Class corresponding to the %glissando schema type.
 *
 * Glissando and slide types both indicate rapidly moving from one pitch
 * to the other so that individual notes are not discerned. The
 * distinction is similar to that between NIFF's glissando and portamento
 * elements. A glissando sounds the half notes in between the slide and
 * defaults to a wavy line. The optional text is printed alongside the
 * line.
 *
 * @nosubgrouping
 */
class glissando : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static number_type number_default_value();

  //@}

  /**
   * @name line-type
   *
   * @brief Accessor and modifier functions for the %line-type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_type line_type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type_type> line_type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type_type, char> line_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_type_optional &line_type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_type_optional &line_type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_type(const line_type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_type(const line_type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_type(::std::unique_ptr<line_type_type> p);

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  glissando(const type_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  glissando(const char *, const type_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  glissando(const ::std::string &, const type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  glissando(const ::xml_schema::string &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  glissando(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  glissando(const glissando &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual glissando *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  glissando &operator=(const glissando &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~glissando();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<number_type> number_;
  line_type_optional line_type_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %grace schema type.
 *
 * The grace type indicates the presence of a grace note. The slash
 * attribute for a grace note is yes for slashed eighth notes. The other
 * grace note attributes come from MuseData sound suggestions. The
 * steal-time-previous attribute indicates the percentage of time to
 * steal from the previous note for the grace note. The
 * steal-time-following attribute indicates the percentage of time to
 * steal from the following note for the grace note, as for
 * appoggiaturas. The make-time attribute indicates to make time, not
 * steal time; the units are in real-time divisions for the grace note.
 *
 * @nosubgrouping
 */
class grace : public ::xml_schema::type {
public:
  /**
   * @name steal-time-previous
   *
   * @brief Accessor and modifier functions for the %steal-time-previous
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent steal_time_previous_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<steal_time_previous_type>
    steal_time_previous_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<steal_time_previous_type, char>
    steal_time_previous_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const steal_time_previous_optional &steal_time_previous() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  steal_time_previous_optional &steal_time_previous();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void steal_time_previous(const steal_time_previous_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void steal_time_previous(const steal_time_previous_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void steal_time_previous(::std::unique_ptr<steal_time_previous_type> p);

  //@}

  /**
   * @name steal-time-following
   *
   * @brief Accessor and modifier functions for the %steal-time-following
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent steal_time_following_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<steal_time_following_type>
    steal_time_following_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<steal_time_following_type, char>
    steal_time_following_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const steal_time_following_optional &steal_time_following() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  steal_time_following_optional &steal_time_following();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void steal_time_following(const steal_time_following_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void steal_time_following(const steal_time_following_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void steal_time_following(::std::unique_ptr<steal_time_following_type> p);

  //@}

  /**
   * @name make-time
   *
   * @brief Accessor and modifier functions for the %make-time
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions make_time_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<make_time_type> make_time_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<make_time_type, char> make_time_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const make_time_optional &make_time() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  make_time_optional &make_time();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void make_time(const make_time_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void make_time(const make_time_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void make_time(::std::unique_ptr<make_time_type> p);

  //@}

  /**
   * @name slash
   *
   * @brief Accessor and modifier functions for the %slash
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no slash_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<slash_type> slash_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<slash_type, char> slash_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const slash_optional &slash() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  slash_optional &slash();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void slash(const slash_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void slash(const slash_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void slash(::std::unique_ptr<slash_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  grace();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  grace(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  grace(const grace &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual grace *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  grace &operator=(const grace &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~grace();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  steal_time_previous_optional steal_time_previous_;
  steal_time_following_optional steal_time_following_;
  make_time_optional make_time_;
  slash_optional slash_;

  //@endcond
};

/**
 * @brief Class corresponding to the %hammer-on-pull-off schema type.
 *
 * The hammer-on and pull-off elements are used in guitar and fretted
 * instrument notation. Since a single slur can be marked over many
 * notes, the hammer-on and pull-off elements are separate so the
 * individual pair of notes can be specified. The element content can be
 * used to specify how the hammer-on or pull-off should be notated. An
 * empty element leaves this choice up to the application.
 *
 * @nosubgrouping
 */
class hammer_on_pull_off : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static number_type number_default_value();

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  hammer_on_pull_off(const type_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  hammer_on_pull_off(const char *, const type_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  hammer_on_pull_off(const ::std::string &, const type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  hammer_on_pull_off(const ::xml_schema::string &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hammer_on_pull_off(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hammer_on_pull_off(const hammer_on_pull_off &x, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual hammer_on_pull_off *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hammer_on_pull_off &operator=(const hammer_on_pull_off &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~hammer_on_pull_off();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<number_type> number_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %handbell schema type.
 *
 * The handbell element represents notation for various techniques used
 * in handbell and handchime music.
 *
 * @nosubgrouping
 */
class handbell : public ::musicxml::handbell_value {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  handbell(::musicxml::handbell_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  handbell(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  handbell(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  handbell(const ::musicxml::handbell_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  handbell(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  handbell(const handbell &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual handbell *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  handbell &operator=(const handbell &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~handbell();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %harmonic schema type.
 *
 * The harmonic type indicates natural and artificial harmonics. Allowing
 * the type of pitch to be specified, combined with controls for
 * appearance/playback differences, allows both the notation and the
 * sound to be represented. Artificial harmonics can add a notated
 * touching-pitch; artificial pinch harmonics will usually not notate a
 * touching pitch. The attributes for the harmonic element refer to the
 * use of the circular harmonic symbol, typically but not always used
 * with natural harmonics.
 *
 * @nosubgrouping
 */
class harmonic : public ::xml_schema::type {
public:
  /**
   * @name natural
   *
   * @brief Accessor and modifier functions for the %natural
   * optional element.
   *
   * The natural element indicates that this is a natural harmonic. These
   * are usually notated at base pitch rather than sounding pitch.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty natural_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<natural_type> natural_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<natural_type, char> natural_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const natural_optional &natural() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  natural_optional &natural();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void natural(const natural_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void natural(const natural_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void natural(::std::unique_ptr<natural_type> p);

  //@}

  /**
   * @name artificial
   *
   * @brief Accessor and modifier functions for the %artificial
   * optional element.
   *
   * The artificial element indicates that this is an artificial harmonic.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty artificial_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<artificial_type> artificial_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<artificial_type, char> artificial_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const artificial_optional &artificial() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  artificial_optional &artificial();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void artificial(const artificial_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void artificial(const artificial_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void artificial(::std::unique_ptr<artificial_type> p);

  //@}

  /**
   * @name base-pitch
   *
   * @brief Accessor and modifier functions for the %base-pitch
   * optional element.
   *
   * The base pitch is the pitch at which the string is played before
   * touching to create the harmonic.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty base_pitch_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<base_pitch_type> base_pitch_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<base_pitch_type, char> base_pitch_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const base_pitch_optional &base_pitch() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  base_pitch_optional &base_pitch();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void base_pitch(const base_pitch_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void base_pitch(const base_pitch_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void base_pitch(::std::unique_ptr<base_pitch_type> p);

  //@}

  /**
   * @name touching-pitch
   *
   * @brief Accessor and modifier functions for the %touching-pitch
   * optional element.
   *
   * The touching-pitch is the pitch at which the string is touched lightly
   * to produce the harmonic.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty touching_pitch_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<touching_pitch_type>
    touching_pitch_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<touching_pitch_type, char>
    touching_pitch_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const touching_pitch_optional &touching_pitch() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  touching_pitch_optional &touching_pitch();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void touching_pitch(const touching_pitch_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void touching_pitch(const touching_pitch_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void touching_pitch(::std::unique_ptr<touching_pitch_type> p);

  //@}

  /**
   * @name sounding-pitch
   *
   * @brief Accessor and modifier functions for the %sounding-pitch
   * optional element.
   *
   * The sounding-pitch is the pitch which is heard when playing the
   * harmonic.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty sounding_pitch_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<sounding_pitch_type>
    sounding_pitch_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sounding_pitch_type, char>
    sounding_pitch_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sounding_pitch_optional &sounding_pitch() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sounding_pitch_optional &sounding_pitch();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void sounding_pitch(const sounding_pitch_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void sounding_pitch(const sounding_pitch_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void sounding_pitch(::std::unique_ptr<sounding_pitch_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  harmonic();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  harmonic(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  harmonic(const harmonic &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual harmonic *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  harmonic &operator=(const harmonic &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~harmonic();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  natural_optional natural_;
  artificial_optional artificial_;
  base_pitch_optional base_pitch_;
  touching_pitch_optional touching_pitch_;
  sounding_pitch_optional sounding_pitch_;
  print_object_optional print_object_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %heel-toe schema type.
 *
 * The heel and toe elements are used with organ pedals. The substitution
 * value is "no" if the attribute is not present.
 *
 * @nosubgrouping
 */
class heel_toe : public ::musicxml::empty_placement {
public:
  /**
   * @name substitution
   *
   * @brief Accessor and modifier functions for the %substitution
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no substitution_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<substitution_type> substitution_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<substitution_type, char> substitution_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const substitution_optional &substitution() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  substitution_optional &substitution();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void substitution(const substitution_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void substitution(const substitution_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void substitution(::std::unique_ptr<substitution_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  heel_toe();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  heel_toe(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  heel_toe(const heel_toe &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual heel_toe *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  heel_toe &operator=(const heel_toe &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~heel_toe();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  substitution_optional substitution_;

  //@endcond
};

/**
 * @brief Class corresponding to the %hole schema type.
 *
 * The hole type represents the symbols used for woodwind and brass
 * fingerings as well as other notations.
 *
 * @nosubgrouping
 */
class hole : public ::xml_schema::type {
public:
  /**
   * @name hole-type
   *
   * @brief Accessor and modifier functions for the %hole-type
   * optional element.
   *
   * The content of the optional hole-type element indicates what the hole
   * symbol represents in terms of instrument fingering or other
  techniques. */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string hole_type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<hole_type_type> hole_type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<hole_type_type, char> hole_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const hole_type_optional &hole_type() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  hole_type_optional &hole_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void hole_type(const hole_type_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void hole_type(const hole_type_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void hole_type(::std::unique_ptr<hole_type_type> p);

  //@}

  /**
   * @name hole-closed
   *
   * @brief Accessor and modifier functions for the %hole-closed
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::hole_closed hole_closed_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<hole_closed_type, char> hole_closed_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const hole_closed_type &hole_closed() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  hole_closed_type &hole_closed();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void hole_closed(const hole_closed_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void hole_closed(::std::unique_ptr<hole_closed_type> p);

  //@}

  /**
   * @name hole-shape
   *
   * @brief Accessor and modifier functions for the %hole-shape
   * optional element.
   *
   * The optional hole-shape element indicates the shape of the hole
   * symbol; the default is a circle.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string hole_shape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<hole_shape_type> hole_shape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<hole_shape_type, char> hole_shape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const hole_shape_optional &hole_shape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  hole_shape_optional &hole_shape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void hole_shape(const hole_shape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void hole_shape(const hole_shape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void hole_shape(::std::unique_ptr<hole_shape_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  hole(const hole_closed_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  hole(::std::unique_ptr<hole_closed_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hole(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hole(const hole &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual hole *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hole &operator=(const hole &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~hole();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  hole_type_optional hole_type_;
  ::xsd::cxx::tree::one<hole_closed_type> hole_closed_;
  hole_shape_optional hole_shape_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %hole-closed schema type.
 *
 * The hole-closed type represents whether the hole is closed, open, or
 * half-open. The optional location attribute indicates which portion of
 * the hole is filled in when the element value is half.
 *
 * @nosubgrouping
 */
class hole_closed : public ::musicxml::hole_closed_value {
public:
  /**
   * @name location
   *
   * @brief Accessor and modifier functions for the %location
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::hole_closed_location location_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<location_type> location_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<location_type, char> location_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const location_optional &location() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  location_optional &location();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void location(const location_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void location(const location_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void location(::std::unique_ptr<location_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  hole_closed(::musicxml::hole_closed_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  hole_closed(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  hole_closed(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  hole_closed(const ::musicxml::hole_closed_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hole_closed(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hole_closed(const hole_closed &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual hole_closed *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hole_closed &operator=(const hole_closed &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~hole_closed();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  location_optional location_;

  //@endcond
};

/**
 * @brief Class corresponding to the %instrument schema type.
 *
 * The instrument type distinguishes between score-instrument elements in
 * a score-part. The id attribute is an IDREF back to the
 * score-instrument ID. If multiple score-instruments are specified on a
 * score-part, there should be an instrument element for each note in the
 * part.
 *
 * @nosubgrouping
 */
class instrument : public ::xml_schema::type {
public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::idref id_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const id_type &id() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  id_type &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  instrument(const id_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  instrument(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  instrument(const instrument &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual instrument *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  instrument &operator=(const instrument &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~instrument();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<id_type> id_;

  //@endcond
};

/**
 * @brief Class corresponding to the %lyric schema type.
 *
 * The lyric type represents text underlays for lyrics, based on Humdrum
 * with support for other formats. Two text elements that are not
 * separated by an elision element are part of the same syllable, but may
 * have different text formatting. The MusicXML 2.0 XSD is more strict
 * than the 2.0 DTD in enforcing this by disallowing a second syllabic
 * element unless preceded by an elision element. The lyric number
 * indicates multiple lines, though a name can be used as well (as in
 * Finale's verse / chorus / section specification). Justification is
 * center by default; placement is below by default. The content of the
 * elision type is used to specify the symbol used to display the
 * elision. Common values are a no-break space (Unicode 00A0), an
 * underscore (Unicode 005F), or an undertie (Unicode 203F).
 *
 * @nosubgrouping
 */
class lyric : public ::xml_schema::type {
public:
  /**
   * @name syllabic
   *
   * @brief Accessor and modifier functions for the %syllabic
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::syllabic syllabic_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<syllabic_type> syllabic_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef syllabic_sequence::iterator syllabic_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef syllabic_sequence::const_iterator syllabic_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<syllabic_type, char> syllabic_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const syllabic_sequence &syllabic() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  syllabic_sequence &syllabic();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void syllabic(const syllabic_sequence &s);

  //@}

  /**
   * @name text
   *
   * @brief Accessor and modifier functions for the %text
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::text_element_data text_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<text_type> text_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef text_sequence::iterator text_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef text_sequence::const_iterator text_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<text_type, char> text_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const text_sequence &text() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  text_sequence &text();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void text(const text_sequence &s);

  //@}

  /**
   * @name elision
   *
   * @brief Accessor and modifier functions for the %elision
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::text_font_color elision_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<elision_type> elision_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef elision_sequence::iterator elision_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef elision_sequence::const_iterator elision_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<elision_type, char> elision_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const elision_sequence &elision() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  elision_sequence &elision();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void elision(const elision_sequence &s);

  //@}

  /**
   * @name extend
   *
   * @brief Accessor and modifier functions for the %extend
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::extend extend_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<extend_type> extend_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<extend_type, char> extend_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const extend_optional &extend() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  extend_optional &extend();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void extend(const extend_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void extend(const extend_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void extend(::std::unique_ptr<extend_type> p);

  //@}

  /**
   * @name laughing
   *
   * @brief Accessor and modifier functions for the %laughing
   * optional element.
   *
   * The laughing element is taken from Humdrum.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty laughing_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<laughing_type> laughing_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<laughing_type, char> laughing_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const laughing_optional &laughing() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  laughing_optional &laughing();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void laughing(const laughing_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void laughing(const laughing_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void laughing(::std::unique_ptr<laughing_type> p);

  //@}

  /**
   * @name humming
   *
   * @brief Accessor and modifier functions for the %humming
   * optional element.
   *
   * The humming element is taken from Humdrum.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty humming_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<humming_type> humming_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<humming_type, char> humming_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const humming_optional &humming() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  humming_optional &humming();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void humming(const humming_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void humming(const humming_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void humming(::std::unique_ptr<humming_type> p);

  //@}

  /**
   * @name end-line
   *
   * @brief Accessor and modifier functions for the %end-line
   * optional element.
   *
   * The end-line element comes from RP-017 for Standard MIDI File Lyric
   * meta-events. It facilitates lyric display for Karaoke and similar
   * applications.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty end_line_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<end_line_type> end_line_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<end_line_type, char> end_line_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const end_line_optional &end_line() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  end_line_optional &end_line();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void end_line(const end_line_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void end_line(const end_line_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void end_line(::std::unique_ptr<end_line_type> p);

  //@}

  /**
   * @name end-paragraph
   *
   * @brief Accessor and modifier functions for the %end-paragraph
   * optional element.
   *
   * The end-paragraph element comes from RP-017 for Standard MIDI File
   * Lyric meta-events. It facilitates lyric display for Karaoke and
   * similar applications.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty end_paragraph_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<end_paragraph_type> end_paragraph_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<end_paragraph_type, char>
    end_paragraph_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const end_paragraph_optional &end_paragraph() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  end_paragraph_optional &end_paragraph();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void end_paragraph(const end_paragraph_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void end_paragraph(const end_paragraph_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void end_paragraph(::std::unique_ptr<end_paragraph_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::nmtoken number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token name_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<name_type> name_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const name_optional &name() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  name_optional &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void name(const name_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name justify
   *
   * @brief Accessor and modifier functions for the %justify
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right justify_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<justify_type> justify_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<justify_type, char> justify_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const justify_optional &justify() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  justify_optional &justify();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void justify(const justify_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void justify(const justify_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void justify(::std::unique_ptr<justify_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  lyric();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  lyric(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  lyric(const lyric &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual lyric *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  lyric &operator=(const lyric &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~lyric();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  syllabic_sequence syllabic_;
  text_sequence text_;
  elision_sequence elision_;
  extend_optional extend_;
  laughing_optional laughing_;
  humming_optional humming_;
  end_line_optional end_line_;
  end_paragraph_optional end_paragraph_;
  footnote_optional footnote_;
  level_optional level_;
  number_optional number_;
  name_optional name_;
  justify_optional justify_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  placement_optional placement_;
  color_optional color_;
  print_object_optional print_object_;

  //@endcond
};

/**
 * @brief Class corresponding to the %mordent schema type.
 *
 * The mordent type is used for both represents the mordent sign with the
 * vertical line and the inverted-mordent sign without the line. The long
 * attribute is "no" by default. The approach and departure attributes
 * are used for compound ornaments, indicating how the beginning and
 * ending of the ornament look relative to the main part of the mordent.
 *
 * @nosubgrouping
 */
class mordent : public ::musicxml::empty_trill_sound {
public:
  /**
   * @name long
   *
   * @brief Accessor and modifier functions for the %long
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no long_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<long_type> long_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<long_type, char> long_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const long_optional &long_() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  long_optional &long_();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void long_(const long_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void long_(const long_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void long_(::std::unique_ptr<long_type> p);

  //@}

  /**
   * @name approach
   *
   * @brief Accessor and modifier functions for the %approach
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below approach_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<approach_type> approach_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<approach_type, char> approach_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const approach_optional &approach() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  approach_optional &approach();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void approach(const approach_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void approach(const approach_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void approach(::std::unique_ptr<approach_type> p);

  //@}

  /**
   * @name departure
   *
   * @brief Accessor and modifier functions for the %departure
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below departure_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<departure_type> departure_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<departure_type, char> departure_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const departure_optional &departure() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  departure_optional &departure();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void departure(const departure_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void departure(const departure_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void departure(::std::unique_ptr<departure_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  mordent();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  mordent(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  mordent(const mordent &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual mordent *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  mordent &operator=(const mordent &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~mordent();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  long_optional long__;
  approach_optional approach_;
  departure_optional departure_;

  //@endcond
};

/**
 * @brief Class corresponding to the %non-arpeggiate schema type.
 *
 * The non-arpeggiate type indicates that this note is at the top or
 * bottom of a bracket indicating to not arpeggiate these notes. Since
 * this does not involve playback, it is only used on the top or bottom
 * notes, not on each note as for the arpeggiate type.
 *
 * @nosubgrouping
 */
class non_arpeggiate : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::top_bottom type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  non_arpeggiate(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  non_arpeggiate(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  non_arpeggiate(const non_arpeggiate &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual non_arpeggiate *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  non_arpeggiate &operator=(const non_arpeggiate &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~non_arpeggiate();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  number_optional number_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  placement_optional placement_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %notations schema type.
 *
 * Notations refer to musical notations, not XML notations. Multiple
 * notations are allowed in order to represent multiple editorial levels.
 * The print-object attribute, added in Version 3.0, allows notations to
 * represent details of performance technique, such as fingerings,
 * without having them appear in the score.
 *
 * @nosubgrouping
 */
class notations : public ::xml_schema::type {
public:
  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name tied
   *
   * @brief Accessor and modifier functions for the %tied
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tied tied_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<tied_type> tied_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef tied_sequence::iterator tied_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef tied_sequence::const_iterator tied_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tied_type, char> tied_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const tied_sequence &tied() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  tied_sequence &tied();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void tied(const tied_sequence &s);

  //@}

  /**
   * @name slur
   *
   * @brief Accessor and modifier functions for the %slur
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::slur slur_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<slur_type> slur_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef slur_sequence::iterator slur_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef slur_sequence::const_iterator slur_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<slur_type, char> slur_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const slur_sequence &slur() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  slur_sequence &slur();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void slur(const slur_sequence &s);

  //@}

  /**
   * @name tuplet
   *
   * @brief Accessor and modifier functions for the %tuplet
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tuplet tuplet_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<tuplet_type> tuplet_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef tuplet_sequence::iterator tuplet_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef tuplet_sequence::const_iterator tuplet_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuplet_type, char> tuplet_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const tuplet_sequence &tuplet() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  tuplet_sequence &tuplet();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void tuplet(const tuplet_sequence &s);

  //@}

  /**
   * @name glissando
   *
   * @brief Accessor and modifier functions for the %glissando
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::glissando glissando_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<glissando_type> glissando_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef glissando_sequence::iterator glissando_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef glissando_sequence::const_iterator glissando_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<glissando_type, char> glissando_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const glissando_sequence &glissando() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  glissando_sequence &glissando();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void glissando(const glissando_sequence &s);

  //@}

  /**
   * @name slide
   *
   * @brief Accessor and modifier functions for the %slide
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::slide slide_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<slide_type> slide_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef slide_sequence::iterator slide_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef slide_sequence::const_iterator slide_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<slide_type, char> slide_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const slide_sequence &slide() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  slide_sequence &slide();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void slide(const slide_sequence &s);

  //@}

  /**
   * @name ornaments
   *
   * @brief Accessor and modifier functions for the %ornaments
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::ornaments ornaments_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<ornaments_type> ornaments_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ornaments_sequence::iterator ornaments_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ornaments_sequence::const_iterator ornaments_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ornaments_type, char> ornaments_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ornaments_sequence &ornaments() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ornaments_sequence &ornaments();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void ornaments(const ornaments_sequence &s);

  //@}

  /**
   * @name technical
   *
   * @brief Accessor and modifier functions for the %technical
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::technical technical_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<technical_type> technical_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef technical_sequence::iterator technical_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef technical_sequence::const_iterator technical_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<technical_type, char> technical_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const technical_sequence &technical() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  technical_sequence &technical();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void technical(const technical_sequence &s);

  //@}

  /**
   * @name articulations
   *
   * @brief Accessor and modifier functions for the %articulations
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::articulations articulations_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<articulations_type> articulations_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef articulations_sequence::iterator articulations_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef articulations_sequence::const_iterator articulations_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<articulations_type, char>
    articulations_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const articulations_sequence &articulations() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  articulations_sequence &articulations();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void articulations(const articulations_sequence &s);

  //@}

  /**
   * @name dynamics
   *
   * @brief Accessor and modifier functions for the %dynamics
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::dynamics dynamics_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<dynamics_type> dynamics_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef dynamics_sequence::iterator dynamics_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef dynamics_sequence::const_iterator dynamics_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<dynamics_type, char> dynamics_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const dynamics_sequence &dynamics() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  dynamics_sequence &dynamics();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void dynamics(const dynamics_sequence &s);

  //@}

  /**
   * @name fermata
   *
   * @brief Accessor and modifier functions for the %fermata
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::fermata fermata_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fermata_type> fermata_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fermata_sequence::iterator fermata_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fermata_sequence::const_iterator fermata_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fermata_type, char> fermata_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fermata_sequence &fermata() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fermata_sequence &fermata();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fermata(const fermata_sequence &s);

  //@}

  /**
   * @name arpeggiate
   *
   * @brief Accessor and modifier functions for the %arpeggiate
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::arpeggiate arpeggiate_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<arpeggiate_type> arpeggiate_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef arpeggiate_sequence::iterator arpeggiate_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef arpeggiate_sequence::const_iterator arpeggiate_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<arpeggiate_type, char> arpeggiate_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const arpeggiate_sequence &arpeggiate() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  arpeggiate_sequence &arpeggiate();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void arpeggiate(const arpeggiate_sequence &s);

  //@}

  /**
   * @name non-arpeggiate
   *
   * @brief Accessor and modifier functions for the %non-arpeggiate
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::non_arpeggiate non_arpeggiate_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<non_arpeggiate_type>
    non_arpeggiate_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef non_arpeggiate_sequence::iterator non_arpeggiate_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef non_arpeggiate_sequence::const_iterator non_arpeggiate_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<non_arpeggiate_type, char>
    non_arpeggiate_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const non_arpeggiate_sequence &non_arpeggiate() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  non_arpeggiate_sequence &non_arpeggiate();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void non_arpeggiate(const non_arpeggiate_sequence &s);

  //@}

  /**
   * @name accidental-mark
   *
   * @brief Accessor and modifier functions for the %accidental-mark
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accidental_mark accidental_mark_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<accidental_mark_type>
    accidental_mark_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef accidental_mark_sequence::iterator accidental_mark_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef accidental_mark_sequence::const_iterator
    accidental_mark_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accidental_mark_type, char>
    accidental_mark_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const accidental_mark_sequence &accidental_mark() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  accidental_mark_sequence &accidental_mark();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void accidental_mark(const accidental_mark_sequence &s);

  //@}

  /**
   * @name other-notation
   *
   * @brief Accessor and modifier functions for the %other-notation
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::other_notation other_notation_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<other_notation_type>
    other_notation_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef other_notation_sequence::iterator other_notation_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef other_notation_sequence::const_iterator other_notation_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_notation_type, char>
    other_notation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const other_notation_sequence &other_notation() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  other_notation_sequence &other_notation();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void other_notation(const other_notation_sequence &s);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  notations();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  notations(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  notations(const notations &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual notations *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  notations &operator=(const notations &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~notations();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  footnote_optional footnote_;
  level_optional level_;
  tied_sequence tied_;
  slur_sequence slur_;
  tuplet_sequence tuplet_;
  glissando_sequence glissando_;
  slide_sequence slide_;
  ornaments_sequence ornaments_;
  technical_sequence technical_;
  articulations_sequence articulations_;
  dynamics_sequence dynamics_;
  fermata_sequence fermata_;
  arpeggiate_sequence arpeggiate_;
  non_arpeggiate_sequence non_arpeggiate_;
  accidental_mark_sequence accidental_mark_;
  other_notation_sequence other_notation_;
  print_object_optional print_object_;

  //@endcond
};

/**
 * @brief Class corresponding to the %note schema type.
 *
 * Notes are the most common type of MusicXML data. The MusicXML format
 * keeps the MuseData distinction between elements used for sound
 * information and elements used for notation information (e.g., tie is
 * used for sound, tied for notation). Thus grace notes do not have a
 * duration element. Cue notes have a duration element, as do forward
 * elements, but no tie elements. Having these two types of information
 * available can make interchange considerably easier, as some programs
 * handle one type of information much more readily than the other.
 *
 * The dynamics and end-dynamics attributes correspond to MIDI 1.0's Note
 * On and Note Off velocities, respectively. They are expressed in terms
 * of percentages of the default forte value (90 for MIDI 1.0). The
 * attack and release attributes are used to alter the starting and
 * stopping time of the note from when it would otherwise occur based on
 * the flow of durations - information that is specific to a performance.
 * They are expressed in terms of divisions, either positive or negative.
 * A note that starts a tie should not have a release attribute, and a
 * note that stops a tie should not have an attack attribute. If a note
 * is played only particular times through a repeat, the time-only
 * attribute shows which times to play the note. The pizzicato attribute
 * is used when just this note is sounded pizzicato, vs. the pizzicato
 * element which changes overall playback between pizzicato and arco.
 *
 * @nosubgrouping
 */
class note : public ::xml_schema::type {
public:
  /**
   * @name grace
   *
   * @brief Accessor and modifier functions for the %grace
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::grace grace_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<grace_type> grace_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<grace_type, char> grace_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const grace_optional &grace() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  grace_optional &grace();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void grace(const grace_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void grace(const grace_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void grace(::std::unique_ptr<grace_type> p);

  //@}

  /**
   * @name chord
   *
   * @brief Accessor and modifier functions for the %chord
   * optional element.
   *
   * The chord element indicates that this note is an additional chord tone
   * with the preceding note. The duration of this note can be no longer
   * than the preceding note. In MuseData, a missing duration indicates the
   * same length as the previous note, but the MusicXML format requires a
   * duration for chord notes too.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty chord_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<chord_type> chord_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<chord_type, char> chord_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const chord_optional &chord() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  chord_optional &chord();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void chord(const chord_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void chord(const chord_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void chord(::std::unique_ptr<chord_type> p);

  //@}

  /**
   * @name pitch
   *
   * @brief Accessor and modifier functions for the %pitch
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::pitch pitch_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<pitch_type> pitch_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pitch_type, char> pitch_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const pitch_optional &pitch() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  pitch_optional &pitch();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void pitch(const pitch_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void pitch(const pitch_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void pitch(::std::unique_ptr<pitch_type> p);

  //@}

  /**
   * @name unpitched
   *
   * @brief Accessor and modifier functions for the %unpitched
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::unpitched unpitched_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<unpitched_type> unpitched_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<unpitched_type, char> unpitched_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const unpitched_optional &unpitched() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  unpitched_optional &unpitched();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void unpitched(const unpitched_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void unpitched(const unpitched_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void unpitched(::std::unique_ptr<unpitched_type> p);

  //@}

  /**
   * @name rest
   *
   * @brief Accessor and modifier functions for the %rest
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::rest rest_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<rest_type> rest_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rest_type, char> rest_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rest_optional &rest() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  rest_optional &rest();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void rest(const rest_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void rest(const rest_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void rest(::std::unique_ptr<rest_type> p);

  //@}

  /**
   * @name tie
   *
   * @brief Accessor and modifier functions for the %tie
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tie tie_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<tie_type> tie_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef tie_sequence::iterator tie_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef tie_sequence::const_iterator tie_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tie_type, char> tie_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const tie_sequence &tie() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  tie_sequence &tie();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void tie(const tie_sequence &s);

  //@}

  /**
   * @name cue
   *
   * @brief Accessor and modifier functions for the %cue
   * optional element.
   *
   * The cue element indicates the presence of a cue note.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty cue_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<cue_type> cue_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<cue_type, char> cue_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const cue_optional &cue() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  cue_optional &cue();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void cue(const cue_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void cue(const cue_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void cue(::std::unique_ptr<cue_type> p);

  //@}

  /**
   * @name duration
   *
   * @brief Accessor and modifier functions for the %duration
   * optional element.
   *
   * Duration is a positive number specified in division units. This is the
   * intended duration vs. notated duration (for instance, swing eighths
   * vs. even eighths, or differences in dotted notes in Baroque-era
   * music). Differences in duration specific to an interpretation or
   * performance should use the note element's attack and release
   * attributes.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::positive_divisions duration_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<duration_type> duration_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<duration_type, char> duration_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const duration_optional &duration() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  duration_optional &duration();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void duration(const duration_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void duration(const duration_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void duration(::std::unique_ptr<duration_type> p);

  //@}

  /**
   * @name instrument
   *
   * @brief Accessor and modifier functions for the %instrument
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::instrument instrument_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<instrument_type> instrument_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<instrument_type, char> instrument_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const instrument_optional &instrument() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  instrument_optional &instrument();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void instrument(const instrument_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void instrument(const instrument_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void instrument(::std::unique_ptr<instrument_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name voice
   *
   * @brief Accessor and modifier functions for the %voice
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string voice_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<voice_type> voice_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<voice_type, char> voice_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const voice_optional &voice() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  voice_optional &voice();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void voice(const voice_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void voice(const voice_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void voice(::std::unique_ptr<voice_type> p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note_type type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<type_type> type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional &type() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  type_optional &type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void type(const type_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void type(const type_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name dot
   *
   * @brief Accessor and modifier functions for the %dot
   * sequence element.
   *
   * One dot element is used for each dot of prolongation. The placement
   * element is used to specify whether the dot should appear above or
   * below the staff line. It is ignored for notes that appear on a staff
   * space.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement dot_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<dot_type> dot_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef dot_sequence::iterator dot_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef dot_sequence::const_iterator dot_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<dot_type, char> dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const dot_sequence &dot() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  dot_sequence &dot();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void dot(const dot_sequence &s);

  //@}

  /**
   * @name accidental
   *
   * @brief Accessor and modifier functions for the %accidental
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accidental accidental_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accidental_type> accidental_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accidental_type, char> accidental_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accidental_optional &accidental() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  accidental_optional &accidental();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void accidental(const accidental_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void accidental(const accidental_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accidental(::std::unique_ptr<accidental_type> p);

  //@}

  /**
   * @name time-modification
   *
   * @brief Accessor and modifier functions for the %time-modification
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::time_modification time_modification_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<time_modification_type>
    time_modification_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<time_modification_type, char>
    time_modification_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const time_modification_optional &time_modification() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  time_modification_optional &time_modification();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void time_modification(const time_modification_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void time_modification(const time_modification_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void time_modification(::std::unique_ptr<time_modification_type> p);

  //@}

  /**
   * @name stem
   *
   * @brief Accessor and modifier functions for the %stem
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::stem stem_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<stem_type> stem_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<stem_type, char> stem_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const stem_optional &stem() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  stem_optional &stem();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void stem(const stem_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void stem(const stem_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void stem(::std::unique_ptr<stem_type> p);

  //@}

  /**
   * @name notehead
   *
   * @brief Accessor and modifier functions for the %notehead
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::notehead notehead_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<notehead_type> notehead_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<notehead_type, char> notehead_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const notehead_optional &notehead() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  notehead_optional &notehead();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void notehead(const notehead_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void notehead(const notehead_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void notehead(::std::unique_ptr<notehead_type> p);

  //@}

  /**
   * @name notehead-text
   *
   * @brief Accessor and modifier functions for the %notehead-text
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::notehead_text notehead_text_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<notehead_text_type> notehead_text_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<notehead_text_type, char>
    notehead_text_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const notehead_text_optional &notehead_text() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  notehead_text_optional &notehead_text();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void notehead_text(const notehead_text_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void notehead_text(const notehead_text_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void notehead_text(::std::unique_ptr<notehead_text_type> p);

  //@}

  /**
   * @name staff
   *
   * @brief Accessor and modifier functions for the %staff
   * optional element.
   *
   * Staff assignment is only needed for music notated on multiple staves.
   * Used by both notes and directions. Staff values are numbers, with 1
   * referring to the top-most staff in a part.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::positive_integer staff_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<staff_type> staff_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_type, char> staff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const staff_optional &staff() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  staff_optional &staff();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void staff(const staff_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void staff(const staff_optional &x);

  //@}

  /**
   * @name beam
   *
   * @brief Accessor and modifier functions for the %beam
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::beam beam_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<beam_type> beam_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef beam_sequence::iterator beam_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef beam_sequence::const_iterator beam_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<beam_type, char> beam_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const beam_sequence &beam() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  beam_sequence &beam();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void beam(const beam_sequence &s);

  //@}

  /**
   * @name notations
   *
   * @brief Accessor and modifier functions for the %notations
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::notations notations_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<notations_type> notations_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef notations_sequence::iterator notations_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef notations_sequence::const_iterator notations_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<notations_type, char> notations_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const notations_sequence &notations() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  notations_sequence &notations();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void notations(const notations_sequence &s);

  //@}

  /**
   * @name lyric
   *
   * @brief Accessor and modifier functions for the %lyric
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::lyric lyric_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<lyric_type> lyric_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef lyric_sequence::iterator lyric_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef lyric_sequence::const_iterator lyric_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<lyric_type, char> lyric_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const lyric_sequence &lyric() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  lyric_sequence &lyric();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void lyric(const lyric_sequence &s);

  //@}

  /**
   * @name play
   *
   * @brief Accessor and modifier functions for the %play
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::play play_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<play_type> play_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<play_type, char> play_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const play_optional &play() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  play_optional &play();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void play(const play_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void play(const play_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void play(::std::unique_ptr<play_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name print-dot
   *
   * @brief Accessor and modifier functions for the %print-dot
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_dot_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_dot_type> print_dot_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_dot_type, char> print_dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_dot_optional &print_dot() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_dot_optional &print_dot();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_dot(const print_dot_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_dot(const print_dot_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_dot(::std::unique_ptr<print_dot_type> p);

  //@}

  /**
   * @name print-spacing
   *
   * @brief Accessor and modifier functions for the %print-spacing
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_spacing_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_spacing_type> print_spacing_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_spacing_type, char>
    print_spacing_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_spacing_optional &print_spacing() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_spacing_optional &print_spacing();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_spacing(const print_spacing_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_spacing(const print_spacing_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_spacing(::std::unique_ptr<print_spacing_type> p);

  //@}

  /**
   * @name print-lyric
   *
   * @brief Accessor and modifier functions for the %print-lyric
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_lyric_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_lyric_type> print_lyric_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_lyric_type, char> print_lyric_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_lyric_optional &print_lyric() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_lyric_optional &print_lyric();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_lyric(const print_lyric_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_lyric(const print_lyric_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_lyric(::std::unique_ptr<print_lyric_type> p);

  //@}

  /**
   * @name dynamics
   *
   * @brief Accessor and modifier functions for the %dynamics
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::non_negative_decimal dynamics_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dynamics_type> dynamics_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dynamics_type, char> dynamics_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dynamics_optional &dynamics() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dynamics_optional &dynamics();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dynamics(const dynamics_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dynamics(const dynamics_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dynamics(::std::unique_ptr<dynamics_type> p);

  //@}

  /**
   * @name end-dynamics
   *
   * @brief Accessor and modifier functions for the %end-dynamics
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::non_negative_decimal end_dynamics_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<end_dynamics_type> end_dynamics_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<end_dynamics_type, char> end_dynamics_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const end_dynamics_optional &end_dynamics() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  end_dynamics_optional &end_dynamics();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void end_dynamics(const end_dynamics_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void end_dynamics(const end_dynamics_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void end_dynamics(::std::unique_ptr<end_dynamics_type> p);

  //@}

  /**
   * @name attack
   *
   * @brief Accessor and modifier functions for the %attack
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions attack_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<attack_type> attack_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<attack_type, char> attack_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const attack_optional &attack() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  attack_optional &attack();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void attack(const attack_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void attack(const attack_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void attack(::std::unique_ptr<attack_type> p);

  //@}

  /**
   * @name release
   *
   * @brief Accessor and modifier functions for the %release
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions release_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<release_type> release_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<release_type, char> release_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const release_optional &release() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  release_optional &release();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void release(const release_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void release(const release_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void release(::std::unique_ptr<release_type> p);

  //@}

  /**
   * @name time-only
   *
   * @brief Accessor and modifier functions for the %time-only
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::time_only time_only_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<time_only_type> time_only_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<time_only_type, char> time_only_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const time_only_optional &time_only() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  time_only_optional &time_only();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void time_only(const time_only_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void time_only(const time_only_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void time_only(::std::unique_ptr<time_only_type> p);

  //@}

  /**
   * @name pizzicato
   *
   * @brief Accessor and modifier functions for the %pizzicato
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no pizzicato_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<pizzicato_type> pizzicato_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<pizzicato_type, char> pizzicato_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const pizzicato_optional &pizzicato() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  pizzicato_optional &pizzicato();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void pizzicato(const pizzicato_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void pizzicato(const pizzicato_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void pizzicato(::std::unique_ptr<pizzicato_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  note();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  note(const note &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual note *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  note &operator=(const note &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~note();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  grace_optional grace_;
  chord_optional chord_;
  pitch_optional pitch_;
  unpitched_optional unpitched_;
  rest_optional rest_;
  tie_sequence tie_;
  cue_optional cue_;
  duration_optional duration_;
  instrument_optional instrument_;
  footnote_optional footnote_;
  level_optional level_;
  voice_optional voice_;
  type_optional type_;
  dot_sequence dot_;
  accidental_optional accidental_;
  time_modification_optional time_modification_;
  stem_optional stem_;
  notehead_optional notehead_;
  notehead_text_optional notehead_text_;
  staff_optional staff_;
  beam_sequence beam_;
  notations_sequence notations_;
  lyric_sequence lyric_;
  play_optional play_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  print_object_optional print_object_;
  print_dot_optional print_dot_;
  print_spacing_optional print_spacing_;
  print_lyric_optional print_lyric_;
  dynamics_optional dynamics_;
  end_dynamics_optional end_dynamics_;
  attack_optional attack_;
  release_optional release_;
  time_only_optional time_only_;
  pizzicato_optional pizzicato_;

  //@endcond
};

/**
 * @brief Class corresponding to the %note-type schema type.
 *
 * The note-type type indicates the graphic note type. Values range from
 * 256th to long. The size attribute indicates full, cue, or large size,
 * with full the default for regular notes and cue the default for cue
 * and grace notes.
 *
 * @nosubgrouping
 */
class note_type : public ::musicxml::note_type_value {
public:
  /**
   * @name size
   *
   * @brief Accessor and modifier functions for the %size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::symbol_size size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<size_type> size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<size_type, char> size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const size_optional &size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  size_optional &size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void size(const size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void size(const size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void size(::std::unique_ptr<size_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  note_type(::musicxml::note_type_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  note_type(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  note_type(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  note_type(const ::musicxml::note_type_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  note_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  note_type(const note_type &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual note_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  note_type &operator=(const note_type &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~note_type();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  size_optional size_;

  //@endcond
};

/**
 * @brief Class corresponding to the %notehead schema type.
 *
 * The notehead element indicates shapes other than the open and closed
 * ovals associated with note durations.
 *
 * For the enclosed shapes, the default is to be hollow for half notes
 * and longer, and filled otherwise. The filled attribute can be set to
 * change this if needed.
 *
 * If the parentheses attribute is set to yes, the notehead is
 * parenthesized. It is no by default.
 *
 * @nosubgrouping
 */
class notehead : public ::musicxml::notehead_value {
public:
  /**
   * @name filled
   *
   * @brief Accessor and modifier functions for the %filled
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no filled_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<filled_type> filled_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<filled_type, char> filled_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const filled_optional &filled() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  filled_optional &filled();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void filled(const filled_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void filled(const filled_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void filled(::std::unique_ptr<filled_type> p);

  //@}

  /**
   * @name parentheses
   *
   * @brief Accessor and modifier functions for the %parentheses
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no parentheses_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<parentheses_type> parentheses_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<parentheses_type, char> parentheses_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const parentheses_optional &parentheses() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  parentheses_optional &parentheses();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void parentheses(const parentheses_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void parentheses(const parentheses_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void parentheses(::std::unique_ptr<parentheses_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  notehead(::musicxml::notehead_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  notehead(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  notehead(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  notehead(const ::musicxml::notehead_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  notehead(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  notehead(const notehead &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual notehead *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  notehead &operator=(const notehead &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~notehead();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  filled_optional filled_;
  parentheses_optional parentheses_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %notehead-text schema type.
 *
 * The notehead-text type represents text that is displayed inside a
 * notehead, as is done in some educational music. It is not needed for
 * the numbers used in tablature or jianpu notation. The presence of a
 * TAB or jianpu clefs is sufficient to indicate that numbers are used.
 * The display-text and accidental-text elements allow display of fully
 * formatted text and accidentals.
 *
 * @nosubgrouping
 */
class notehead_text : public ::xml_schema::type {
public:
  /**
   * @name display-text
   *
   * @brief Accessor and modifier functions for the %display-text
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text display_text_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<display_text_type> display_text_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef display_text_sequence::iterator display_text_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef display_text_sequence::const_iterator display_text_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<display_text_type, char> display_text_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const display_text_sequence &display_text() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  display_text_sequence &display_text();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void display_text(const display_text_sequence &s);

  //@}

  /**
   * @name accidental-text
   *
   * @brief Accessor and modifier functions for the %accidental-text
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accidental_text accidental_text_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<accidental_text_type>
    accidental_text_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef accidental_text_sequence::iterator accidental_text_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef accidental_text_sequence::const_iterator
    accidental_text_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accidental_text_type, char>
    accidental_text_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const accidental_text_sequence &accidental_text() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  accidental_text_sequence &accidental_text();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void accidental_text(const accidental_text_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  notehead_text();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  notehead_text(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  notehead_text(const notehead_text &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual notehead_text *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  notehead_text &operator=(const notehead_text &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~notehead_text();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  display_text_sequence display_text_;
  accidental_text_sequence accidental_text_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ornaments schema type.
 *
 * Ornaments can be any of several types, followed optionally by
 * accidentals. The accidental-mark element's content is represented the
 * same as an accidental element, but with a different name to reflect
 * the different musical meaning.
 *
 * @nosubgrouping
 */
class ornaments : public ::xml_schema::type {
public:
  /**
   * @name trill-mark
   *
   * @brief Accessor and modifier functions for the %trill-mark
   * sequence element.
   *
   * The trill-mark element represents the trill-mark symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_trill_sound trill_mark_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<trill_mark_type> trill_mark_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef trill_mark_sequence::iterator trill_mark_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef trill_mark_sequence::const_iterator trill_mark_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<trill_mark_type, char> trill_mark_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const trill_mark_sequence &trill_mark() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  trill_mark_sequence &trill_mark();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void trill_mark(const trill_mark_sequence &s);

  //@}

  /**
   * @name turn
   *
   * @brief Accessor and modifier functions for the %turn
   * sequence element.
   *
   * The turn element is the normal turn shape which goes up then down.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::horizontal_turn turn_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<turn_type> turn_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef turn_sequence::iterator turn_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef turn_sequence::const_iterator turn_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<turn_type, char> turn_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const turn_sequence &turn() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  turn_sequence &turn();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void turn(const turn_sequence &s);

  //@}

  /**
   * @name delayed-turn
   *
   * @brief Accessor and modifier functions for the %delayed-turn
   * sequence element.
   *
   * The delayed-turn element indicates a normal turn that is delayed until
   * the end of the current note.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::horizontal_turn delayed_turn_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<delayed_turn_type> delayed_turn_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef delayed_turn_sequence::iterator delayed_turn_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef delayed_turn_sequence::const_iterator delayed_turn_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<delayed_turn_type, char> delayed_turn_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const delayed_turn_sequence &delayed_turn() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  delayed_turn_sequence &delayed_turn();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void delayed_turn(const delayed_turn_sequence &s);

  //@}

  /**
   * @name inverted-turn
   *
   * @brief Accessor and modifier functions for the %inverted-turn
   * sequence element.
   *
   * The inverted-turn element has the shape which goes down and then up.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::horizontal_turn inverted_turn_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<inverted_turn_type> inverted_turn_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef inverted_turn_sequence::iterator inverted_turn_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef inverted_turn_sequence::const_iterator inverted_turn_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<inverted_turn_type, char>
    inverted_turn_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const inverted_turn_sequence &inverted_turn() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  inverted_turn_sequence &inverted_turn();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void inverted_turn(const inverted_turn_sequence &s);

  //@}

  /**
   * @name delayed-inverted-turn
   *
   * @brief Accessor and modifier functions for the %delayed-inverted-turn
   * sequence element.
   *
   * The delayed-inverted-turn element indicates an inverted turn that is
   * delayed until the end of the current note.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::horizontal_turn delayed_inverted_turn_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<delayed_inverted_turn_type>
    delayed_inverted_turn_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef delayed_inverted_turn_sequence::iterator
    delayed_inverted_turn_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef delayed_inverted_turn_sequence::const_iterator
    delayed_inverted_turn_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<delayed_inverted_turn_type, char>
    delayed_inverted_turn_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const delayed_inverted_turn_sequence &delayed_inverted_turn() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  delayed_inverted_turn_sequence &delayed_inverted_turn();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void delayed_inverted_turn(const delayed_inverted_turn_sequence &s);

  //@}

  /**
   * @name vertical-turn
   *
   * @brief Accessor and modifier functions for the %vertical-turn
   * sequence element.
   *
   * The vertical-turn element has the turn symbol shape arranged
   * vertically going from upper left to lower right.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_trill_sound vertical_turn_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<vertical_turn_type> vertical_turn_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef vertical_turn_sequence::iterator vertical_turn_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef vertical_turn_sequence::const_iterator vertical_turn_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<vertical_turn_type, char>
    vertical_turn_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const vertical_turn_sequence &vertical_turn() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  vertical_turn_sequence &vertical_turn();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void vertical_turn(const vertical_turn_sequence &s);

  //@}

  /**
   * @name shake
   *
   * @brief Accessor and modifier functions for the %shake
   * sequence element.
   *
   * The shake element has a similar appearance to an inverted-mordent
   * element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_trill_sound shake_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<shake_type> shake_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef shake_sequence::iterator shake_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef shake_sequence::const_iterator shake_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<shake_type, char> shake_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const shake_sequence &shake() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  shake_sequence &shake();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void shake(const shake_sequence &s);

  //@}

  /**
   * @name wavy-line
   *
   * @brief Accessor and modifier functions for the %wavy-line
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::wavy_line wavy_line_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<wavy_line_type> wavy_line_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef wavy_line_sequence::iterator wavy_line_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef wavy_line_sequence::const_iterator wavy_line_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<wavy_line_type, char> wavy_line_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const wavy_line_sequence &wavy_line() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  wavy_line_sequence &wavy_line();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void wavy_line(const wavy_line_sequence &s);

  //@}

  /**
   * @name mordent
   *
   * @brief Accessor and modifier functions for the %mordent
   * sequence element.
   *
   * The mordent element represents the sign with the vertical line. The
   * long attribute is "no" by default.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::mordent mordent_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<mordent_type> mordent_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef mordent_sequence::iterator mordent_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef mordent_sequence::const_iterator mordent_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<mordent_type, char> mordent_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const mordent_sequence &mordent() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  mordent_sequence &mordent();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void mordent(const mordent_sequence &s);

  //@}

  /**
   * @name inverted-mordent
   *
   * @brief Accessor and modifier functions for the %inverted-mordent
   * sequence element.
   *
   * The inverted-mordent element represents the sign without the vertical
   * line. The long attribute is "no" by default.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::mordent inverted_mordent_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<inverted_mordent_type>
    inverted_mordent_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef inverted_mordent_sequence::iterator inverted_mordent_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef inverted_mordent_sequence::const_iterator
    inverted_mordent_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<inverted_mordent_type, char>
    inverted_mordent_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const inverted_mordent_sequence &inverted_mordent() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  inverted_mordent_sequence &inverted_mordent();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void inverted_mordent(const inverted_mordent_sequence &s);

  //@}

  /**
   * @name schleifer
   *
   * @brief Accessor and modifier functions for the %schleifer
   * sequence element.
   *
   * The name for this ornament is based on the German, to avoid confusion
   * with the more common slide element defined earlier.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement schleifer_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<schleifer_type> schleifer_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef schleifer_sequence::iterator schleifer_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef schleifer_sequence::const_iterator schleifer_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<schleifer_type, char> schleifer_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const schleifer_sequence &schleifer() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  schleifer_sequence &schleifer();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void schleifer(const schleifer_sequence &s);

  //@}

  /**
   * @name tremolo
   *
   * @brief Accessor and modifier functions for the %tremolo
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tremolo tremolo_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<tremolo_type> tremolo_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef tremolo_sequence::iterator tremolo_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef tremolo_sequence::const_iterator tremolo_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tremolo_type, char> tremolo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const tremolo_sequence &tremolo() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  tremolo_sequence &tremolo();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void tremolo(const tremolo_sequence &s);

  //@}

  /**
   * @name other-ornament
   *
   * @brief Accessor and modifier functions for the %other-ornament
   * sequence element.
   *
   * The other-ornament element is used to define any ornaments not yet in
   * the MusicXML format. This allows extended representation, though
   * without application interoperability.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::placement_text other_ornament_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<other_ornament_type>
    other_ornament_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef other_ornament_sequence::iterator other_ornament_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef other_ornament_sequence::const_iterator other_ornament_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_ornament_type, char>
    other_ornament_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const other_ornament_sequence &other_ornament() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  other_ornament_sequence &other_ornament();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void other_ornament(const other_ornament_sequence &s);

  //@}

  /**
   * @name accidental-mark
   *
   * @brief Accessor and modifier functions for the %accidental-mark
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::accidental_mark accidental_mark_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<accidental_mark_type>
    accidental_mark_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef accidental_mark_sequence::iterator accidental_mark_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef accidental_mark_sequence::const_iterator
    accidental_mark_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<accidental_mark_type, char>
    accidental_mark_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const accidental_mark_sequence &accidental_mark() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  accidental_mark_sequence &accidental_mark();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void accidental_mark(const accidental_mark_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ornaments();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ornaments(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ornaments(const ornaments &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ornaments *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ornaments &operator=(const ornaments &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~ornaments();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  trill_mark_sequence trill_mark_;
  turn_sequence turn_;
  delayed_turn_sequence delayed_turn_;
  inverted_turn_sequence inverted_turn_;
  delayed_inverted_turn_sequence delayed_inverted_turn_;
  vertical_turn_sequence vertical_turn_;
  shake_sequence shake_;
  wavy_line_sequence wavy_line_;
  mordent_sequence mordent_;
  inverted_mordent_sequence inverted_mordent_;
  schleifer_sequence schleifer_;
  tremolo_sequence tremolo_;
  other_ornament_sequence other_ornament_;
  accidental_mark_sequence accidental_mark_;

  //@endcond
};

/**
 * @brief Class corresponding to the %other-notation schema type.
 *
 * The other-notation type is used to define any notations not yet in the
 * MusicXML format. This allows extended representation, though without
 * application interoperability. It handles notations where more specific
 * extension elements such as other-dynamics and other-technical are not
 * appropriate.
 *
 * @nosubgrouping
 */
class other_notation : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_single type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static number_type number_default_value();

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  other_notation(const type_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  other_notation(const char *, const type_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  other_notation(const ::std::string &, const type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  other_notation(const ::xml_schema::string &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  other_notation(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  other_notation(const other_notation &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual other_notation *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  other_notation &operator=(const other_notation &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~other_notation();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<number_type> number_;
  print_object_optional print_object_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %pitch schema type.
 *
 * Pitch is represented as a combination of the step of the diatonic
 * scale, the chromatic alteration, and the octave.
 *
 * @nosubgrouping
 */
class pitch : public ::xml_schema::type {
public:
  /**
   * @name step
   *
   * @brief Accessor and modifier functions for the %step
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::step step_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<step_type, char> step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const step_type &step() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  step_type &step();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void step(const step_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void step(::std::unique_ptr<step_type> p);

  //@}

  /**
   * @name alter
   *
   * @brief Accessor and modifier functions for the %alter
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::semitones alter_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<alter_type> alter_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<alter_type, char> alter_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const alter_optional &alter() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  alter_optional &alter();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void alter(const alter_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void alter(const alter_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void alter(::std::unique_ptr<alter_type> p);

  //@}

  /**
   * @name octave
   *
   * @brief Accessor and modifier functions for the %octave
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::octave octave_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<octave_type, char> octave_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const octave_type &octave() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  octave_type &octave();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void octave(const octave_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void octave(::std::unique_ptr<octave_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  pitch(const step_type &, const octave_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  pitch(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  pitch(const pitch &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual pitch *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  pitch &operator=(const pitch &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~pitch();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<step_type> step_;
  alter_optional alter_;
  ::xsd::cxx::tree::one<octave_type> octave_;

  //@endcond
};

/**
 * @brief Class corresponding to the %placement-text schema type.
 *
 * The placement-text type represents a text element with print-style and
 * placement attribute groups.
 *
 * @nosubgrouping
 */
class placement_text : public ::xml_schema::string {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  placement_text();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  placement_text(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  placement_text(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  placement_text(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  placement_text(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  placement_text(const placement_text &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual placement_text *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  placement_text &operator=(const placement_text &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~placement_text();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %rest schema type.
 *
 * The rest element indicates notated rests or silences. Rest elements
 * are usually empty, but placement on the staff can be specified using
 * display-step and display-octave elements. If the measure attribute is
 * set to yes, this indicates this is a complete measure rest.
 *
 * @nosubgrouping
 */
class rest : public ::xml_schema::type {
public:
  /**
   * @name display-step
   *
   * @brief Accessor and modifier functions for the %display-step
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::step display_step_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<display_step_type> display_step_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<display_step_type, char> display_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const display_step_optional &display_step() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  display_step_optional &display_step();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void display_step(const display_step_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void display_step(const display_step_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void display_step(::std::unique_ptr<display_step_type> p);

  //@}

  /**
   * @name display-octave
   *
   * @brief Accessor and modifier functions for the %display-octave
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::octave display_octave_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<display_octave_type>
    display_octave_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<display_octave_type, char>
    display_octave_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const display_octave_optional &display_octave() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  display_octave_optional &display_octave();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void display_octave(const display_octave_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void display_octave(const display_octave_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void display_octave(::std::unique_ptr<display_octave_type> p);

  //@}

  /**
   * @name measure
   *
   * @brief Accessor and modifier functions for the %measure
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no measure_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<measure_type> measure_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<measure_type, char> measure_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const measure_optional &measure() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  measure_optional &measure();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void measure(const measure_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void measure(const measure_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void measure(::std::unique_ptr<measure_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  rest();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  rest(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  rest(const rest &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual rest *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  rest &operator=(const rest &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~rest();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  display_step_optional display_step_;
  display_octave_optional display_octave_;
  measure_optional measure_;

  //@endcond
};

/**
 * @brief Class corresponding to the %slide schema type.
 *
 * Glissando and slide types both indicate rapidly moving from one pitch
 * to the other so that individual notes are not discerned. The
 * distinction is similar to that between NIFF's glissando and portamento
 * elements. A slide is continuous between two notes and defaults to a
 * solid line. The optional text for a is printed alongside the line.
 *
 * @nosubgrouping
 */
class slide : public ::xml_schema::string {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static number_type number_default_value();

  //@}

  /**
   * @name line-type
   *
   * @brief Accessor and modifier functions for the %line-type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_type line_type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type_type> line_type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type_type, char> line_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_type_optional &line_type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_type_optional &line_type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_type(const line_type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_type(const line_type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_type(::std::unique_ptr<line_type_type> p);

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name accelerate
   *
   * @brief Accessor and modifier functions for the %accelerate
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no accelerate_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<accelerate_type> accelerate_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<accelerate_type, char> accelerate_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const accelerate_optional &accelerate() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  accelerate_optional &accelerate();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void accelerate(const accelerate_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void accelerate(const accelerate_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void accelerate(::std::unique_ptr<accelerate_type> p);

  //@}

  /**
   * @name beats
   *
   * @brief Accessor and modifier functions for the %beats
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::trill_beats beats_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<beats_type> beats_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<beats_type, char> beats_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const beats_optional &beats() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  beats_optional &beats();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void beats(const beats_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void beats(const beats_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void beats(::std::unique_ptr<beats_type> p);

  //@}

  /**
   * @name first-beat
   *
   * @brief Accessor and modifier functions for the %first-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent first_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<first_beat_type> first_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<first_beat_type, char> first_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const first_beat_optional &first_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  first_beat_optional &first_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void first_beat(const first_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void first_beat(const first_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void first_beat(::std::unique_ptr<first_beat_type> p);

  //@}

  /**
   * @name last-beat
   *
   * @brief Accessor and modifier functions for the %last-beat
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::percent last_beat_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<last_beat_type> last_beat_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<last_beat_type, char> last_beat_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const last_beat_optional &last_beat() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  last_beat_optional &last_beat();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void last_beat(const last_beat_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void last_beat(const last_beat_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void last_beat(::std::unique_ptr<last_beat_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  slide(const type_type &);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  slide(const char *, const type_type &);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  slide(const ::std::string &, const type_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  slide(const ::xml_schema::string &, const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  slide(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  slide(const slide &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual slide *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  slide &operator=(const slide &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~slide();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<number_type> number_;
  line_type_optional line_type_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  accelerate_optional accelerate_;
  beats_optional beats_;
  first_beat_optional first_beat_;
  last_beat_optional last_beat_;

  //@endcond
};

/**
 * @brief Class corresponding to the %slur schema type.
 *
 * Slur types are empty. Most slurs are represented with two elements:
 * one with a start type, and one with a stop type. Slurs can add more
 * elements using a continue type. This is typically used to specify the
 * formatting of cross-system slurs, or to specify the shape of very
 * complex slurs.
 *
 * @nosubgrouping
 */
class slur : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_continue type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static number_type number_default_value();

  //@}

  /**
   * @name line-type
   *
   * @brief Accessor and modifier functions for the %line-type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_type line_type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type_type> line_type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type_type, char> line_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_type_optional &line_type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_type_optional &line_type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_type(const line_type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_type(const line_type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_type(::std::unique_ptr<line_type_type> p);

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name orientation
   *
   * @brief Accessor and modifier functions for the %orientation
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::over_under orientation_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<orientation_type> orientation_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<orientation_type, char> orientation_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const orientation_optional &orientation() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  orientation_optional &orientation();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void orientation(const orientation_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void orientation(const orientation_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void orientation(::std::unique_ptr<orientation_type> p);

  //@}

  /**
   * @name bezier-offset
   *
   * @brief Accessor and modifier functions for the %bezier-offset
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions bezier_offset_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_offset_type> bezier_offset_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_offset_type, char>
    bezier_offset_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_offset_optional &bezier_offset() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_offset_optional &bezier_offset();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_offset(const bezier_offset_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_offset(const bezier_offset_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_offset(::std::unique_ptr<bezier_offset_type> p);

  //@}

  /**
   * @name bezier-offset2
   *
   * @brief Accessor and modifier functions for the %bezier-offset2
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions bezier_offset2_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_offset2_type>
    bezier_offset2_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_offset2_type, char>
    bezier_offset2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_offset2_optional &bezier_offset2() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_offset2_optional &bezier_offset2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_offset2(const bezier_offset2_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_offset2(const bezier_offset2_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_offset2(::std::unique_ptr<bezier_offset2_type> p);

  //@}

  /**
   * @name bezier-x
   *
   * @brief Accessor and modifier functions for the %bezier-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths bezier_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_x_type> bezier_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_x_type, char> bezier_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_x_optional &bezier_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_x_optional &bezier_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_x(const bezier_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_x(const bezier_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_x(::std::unique_ptr<bezier_x_type> p);

  //@}

  /**
   * @name bezier-y
   *
   * @brief Accessor and modifier functions for the %bezier-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths bezier_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_y_type> bezier_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_y_type, char> bezier_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_y_optional &bezier_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_y_optional &bezier_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_y(const bezier_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_y(const bezier_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_y(::std::unique_ptr<bezier_y_type> p);

  //@}

  /**
   * @name bezier-x2
   *
   * @brief Accessor and modifier functions for the %bezier-x2
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths bezier_x2_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_x2_type> bezier_x2_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_x2_type, char> bezier_x2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_x2_optional &bezier_x2() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_x2_optional &bezier_x2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_x2(const bezier_x2_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_x2(const bezier_x2_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_x2(::std::unique_ptr<bezier_x2_type> p);

  //@}

  /**
   * @name bezier-y2
   *
   * @brief Accessor and modifier functions for the %bezier-y2
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths bezier_y2_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_y2_type> bezier_y2_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_y2_type, char> bezier_y2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_y2_optional &bezier_y2() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_y2_optional &bezier_y2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_y2(const bezier_y2_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_y2(const bezier_y2_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_y2(::std::unique_ptr<bezier_y2_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  slur(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  slur(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  slur(const slur &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual slur *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  slur &operator=(const slur &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~slur();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<number_type> number_;
  line_type_optional line_type_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  placement_optional placement_;
  orientation_optional orientation_;
  bezier_offset_optional bezier_offset_;
  bezier_offset2_optional bezier_offset2_;
  bezier_x_optional bezier_x_;
  bezier_y_optional bezier_y_;
  bezier_x2_optional bezier_x2_;
  bezier_y2_optional bezier_y2_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %stem schema type.
 *
 * Stems can be down, up, none, or double. For down and up stems, the
 * position attributes can be used to specify stem length. The relative
 * values specify the end of the stem relative to the program default.
 * Default values specify an absolute end stem position. Negative values
 * of relative-y that would flip a stem instead of shortening it are
 * ignored. A stem element associated with a rest refers to a stemlet.
 *
 * @nosubgrouping
 */
class stem : public ::musicxml::stem_value {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  stem(::musicxml::stem_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  stem(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  stem(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  stem(const ::musicxml::stem_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  stem(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  stem(const stem &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual stem *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  stem &operator=(const stem &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~stem();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %strong-accent schema type.
 *
 * The strong-accent type indicates a vertical accent mark. The type
 * attribute indicates if the point of the accent is down or up.
 *
 * @nosubgrouping
 */
class strong_accent : public ::musicxml::empty_placement {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::up_down type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const type_type &type_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  strong_accent();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  strong_accent(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  strong_accent(const strong_accent &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual strong_accent *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  strong_accent &operator=(const strong_accent &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~strong_accent();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  static const type_type type_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %style-text schema type.
 *
 * The style-text type represents a text element with a print-style
 * attribute group.
 *
 * @nosubgrouping
 */
class style_text : public ::xml_schema::string {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  style_text();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  style_text(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  style_text(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  style_text(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  style_text(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  style_text(const style_text &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual style_text *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  style_text &operator=(const style_text &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~style_text();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %technical schema type.
 *
 * Technical indications give performance information for individual
 * instruments.
 *
 * @nosubgrouping
 */
class technical : public ::xml_schema::type {
public:
  /**
   * @name up-bow
   *
   * @brief Accessor and modifier functions for the %up-bow
   * sequence element.
   *
   * The up-bow element represents the symbol that is used both for
   * up-bowing on bowed instruments, and up-stroke on plucked instruments.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement up_bow_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<up_bow_type> up_bow_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef up_bow_sequence::iterator up_bow_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef up_bow_sequence::const_iterator up_bow_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<up_bow_type, char> up_bow_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const up_bow_sequence &up_bow() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  up_bow_sequence &up_bow();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void up_bow(const up_bow_sequence &s);

  //@}

  /**
   * @name down-bow
   *
   * @brief Accessor and modifier functions for the %down-bow
   * sequence element.
   *
   * The down-bow element represents the symbol that is used both for
   * down-bowing on bowed instruments, and down-stroke on plucked
   * instruments.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement down_bow_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<down_bow_type> down_bow_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef down_bow_sequence::iterator down_bow_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef down_bow_sequence::const_iterator down_bow_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<down_bow_type, char> down_bow_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const down_bow_sequence &down_bow() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  down_bow_sequence &down_bow();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void down_bow(const down_bow_sequence &s);

  //@}

  /**
   * @name harmonic
   *
   * @brief Accessor and modifier functions for the %harmonic
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::harmonic harmonic_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<harmonic_type> harmonic_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef harmonic_sequence::iterator harmonic_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef harmonic_sequence::const_iterator harmonic_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<harmonic_type, char> harmonic_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const harmonic_sequence &harmonic() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  harmonic_sequence &harmonic();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void harmonic(const harmonic_sequence &s);

  //@}

  /**
   * @name open-string
   *
   * @brief Accessor and modifier functions for the %open-string
   * sequence element.
   *
   * The open-string element represents the zero-shaped open string symbol.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement open_string_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<open_string_type> open_string_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef open_string_sequence::iterator open_string_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef open_string_sequence::const_iterator open_string_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<open_string_type, char> open_string_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const open_string_sequence &open_string() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  open_string_sequence &open_string();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void open_string(const open_string_sequence &s);

  //@}

  /**
   * @name thumb-position
   *
   * @brief Accessor and modifier functions for the %thumb-position
   * sequence element.
   *
   * The thumb-position element represents the thumb position symbol. This
   * is a circle with a line, where the line does not come within the
   * circle. It is distinct from the snap pizzicato symbol, where the line
   * comes inside the circle.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement thumb_position_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<thumb_position_type>
    thumb_position_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef thumb_position_sequence::iterator thumb_position_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef thumb_position_sequence::const_iterator thumb_position_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<thumb_position_type, char>
    thumb_position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const thumb_position_sequence &thumb_position() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  thumb_position_sequence &thumb_position();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void thumb_position(const thumb_position_sequence &s);

  //@}

  /**
   * @name fingering
   *
   * @brief Accessor and modifier functions for the %fingering
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::fingering fingering_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fingering_type> fingering_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fingering_sequence::iterator fingering_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fingering_sequence::const_iterator fingering_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fingering_type, char> fingering_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fingering_sequence &fingering() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fingering_sequence &fingering();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fingering(const fingering_sequence &s);

  //@}

  /**
   * @name pluck
   *
   * @brief Accessor and modifier functions for the %pluck
   * sequence element.
   *
   * The pluck element is used to specify the plucking fingering on a
   * fretted instrument, where the fingering element refers to the fretting
   * fingering. Typical values are p, i, m, a for pulgar/thumb,
   * indicio/index, medio/middle, and anular/ring fingers.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::placement_text pluck_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<pluck_type> pluck_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef pluck_sequence::iterator pluck_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef pluck_sequence::const_iterator pluck_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pluck_type, char> pluck_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const pluck_sequence &pluck() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  pluck_sequence &pluck();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void pluck(const pluck_sequence &s);

  //@}

  /**
   * @name double-tongue
   *
   * @brief Accessor and modifier functions for the %double-tongue
   * sequence element.
   *
   * The double-tongue element represents the double tongue symbol (two
   * dots arranged horizontally).
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement double_tongue_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<double_tongue_type> double_tongue_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef double_tongue_sequence::iterator double_tongue_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef double_tongue_sequence::const_iterator double_tongue_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<double_tongue_type, char>
    double_tongue_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const double_tongue_sequence &double_tongue() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  double_tongue_sequence &double_tongue();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void double_tongue(const double_tongue_sequence &s);

  //@}

  /**
   * @name triple-tongue
   *
   * @brief Accessor and modifier functions for the %triple-tongue
   * sequence element.
   *
   * The triple-tongue element represents the triple tongue symbol (three
   * dots arranged horizontally).
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement triple_tongue_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<triple_tongue_type> triple_tongue_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef triple_tongue_sequence::iterator triple_tongue_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef triple_tongue_sequence::const_iterator triple_tongue_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<triple_tongue_type, char>
    triple_tongue_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const triple_tongue_sequence &triple_tongue() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  triple_tongue_sequence &triple_tongue();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void triple_tongue(const triple_tongue_sequence &s);

  //@}

  /**
   * @name stopped
   *
   * @brief Accessor and modifier functions for the %stopped
   * sequence element.
   *
   * The stopped element represents the stopped symbol, which looks like a
   * plus sign.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement stopped_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<stopped_type> stopped_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef stopped_sequence::iterator stopped_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef stopped_sequence::const_iterator stopped_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<stopped_type, char> stopped_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const stopped_sequence &stopped() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  stopped_sequence &stopped();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void stopped(const stopped_sequence &s);

  //@}

  /**
   * @name snap-pizzicato
   *
   * @brief Accessor and modifier functions for the %snap-pizzicato
   * sequence element.
   *
   * The snap-pizzicato element represents the snap pizzicato symbol. This
   * is a circle with a line, where the line comes inside the circle. It is
   * distinct from the thumb-position symbol, where the line does not come
   * inside the circle.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement snap_pizzicato_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<snap_pizzicato_type>
    snap_pizzicato_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef snap_pizzicato_sequence::iterator snap_pizzicato_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef snap_pizzicato_sequence::const_iterator snap_pizzicato_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<snap_pizzicato_type, char>
    snap_pizzicato_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const snap_pizzicato_sequence &snap_pizzicato() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  snap_pizzicato_sequence &snap_pizzicato();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void snap_pizzicato(const snap_pizzicato_sequence &s);

  //@}

  /**
   * @name fret
   *
   * @brief Accessor and modifier functions for the %fret
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::fret fret_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fret_type> fret_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fret_sequence::iterator fret_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fret_sequence::const_iterator fret_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fret_type, char> fret_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fret_sequence &fret() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fret_sequence &fret();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fret(const fret_sequence &s);

  //@}

  /**
   * @name string
   *
   * @brief Accessor and modifier functions for the %string
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::string string_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<string_type> string_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef string_sequence::iterator string_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef string_sequence::const_iterator string_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<string_type, char> string_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const string_sequence &string() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  string_sequence &string();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void string(const string_sequence &s);

  //@}

  /**
   * @name hammer-on
   *
   * @brief Accessor and modifier functions for the %hammer-on
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::hammer_on_pull_off hammer_on_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<hammer_on_type> hammer_on_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef hammer_on_sequence::iterator hammer_on_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef hammer_on_sequence::const_iterator hammer_on_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<hammer_on_type, char> hammer_on_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const hammer_on_sequence &hammer_on() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  hammer_on_sequence &hammer_on();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void hammer_on(const hammer_on_sequence &s);

  //@}

  /**
   * @name pull-off
   *
   * @brief Accessor and modifier functions for the %pull-off
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::hammer_on_pull_off pull_off_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<pull_off_type> pull_off_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef pull_off_sequence::iterator pull_off_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef pull_off_sequence::const_iterator pull_off_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<pull_off_type, char> pull_off_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const pull_off_sequence &pull_off() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  pull_off_sequence &pull_off();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void pull_off(const pull_off_sequence &s);

  //@}

  /**
   * @name bend
   *
   * @brief Accessor and modifier functions for the %bend
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bend bend_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<bend_type> bend_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef bend_sequence::iterator bend_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef bend_sequence::const_iterator bend_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bend_type, char> bend_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const bend_sequence &bend() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  bend_sequence &bend();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void bend(const bend_sequence &s);

  //@}

  /**
   * @name tap
   *
   * @brief Accessor and modifier functions for the %tap
   * sequence element.
   *
   * The tap element indicates a tap on the fretboard. The element content
   * allows specification of the notation; + and T are common choices. If
   * empty, the display is application-specific.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::placement_text tap_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<tap_type> tap_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef tap_sequence::iterator tap_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef tap_sequence::const_iterator tap_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tap_type, char> tap_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const tap_sequence &tap() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  tap_sequence &tap();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void tap(const tap_sequence &s);

  //@}

  /**
   * @name heel
   *
   * @brief Accessor and modifier functions for the %heel
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::heel_toe heel_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<heel_type> heel_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef heel_sequence::iterator heel_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef heel_sequence::const_iterator heel_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<heel_type, char> heel_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const heel_sequence &heel() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  heel_sequence &heel();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void heel(const heel_sequence &s);

  //@}

  /**
   * @name toe
   *
   * @brief Accessor and modifier functions for the %toe
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::heel_toe toe_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<toe_type> toe_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef toe_sequence::iterator toe_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef toe_sequence::const_iterator toe_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<toe_type, char> toe_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const toe_sequence &toe() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  toe_sequence &toe();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void toe(const toe_sequence &s);

  //@}

  /**
   * @name fingernails
   *
   * @brief Accessor and modifier functions for the %fingernails
   * sequence element.
   *
   * The fingernails element is used in notation for harp and other plucked
   * string instruments.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_placement fingernails_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fingernails_type> fingernails_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fingernails_sequence::iterator fingernails_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fingernails_sequence::const_iterator fingernails_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fingernails_type, char> fingernails_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fingernails_sequence &fingernails() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fingernails_sequence &fingernails();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fingernails(const fingernails_sequence &s);

  //@}

  /**
   * @name hole
   *
   * @brief Accessor and modifier functions for the %hole
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::hole hole_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<hole_type> hole_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef hole_sequence::iterator hole_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef hole_sequence::const_iterator hole_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<hole_type, char> hole_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const hole_sequence &hole() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  hole_sequence &hole();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void hole(const hole_sequence &s);

  //@}

  /**
   * @name arrow
   *
   * @brief Accessor and modifier functions for the %arrow
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::arrow arrow_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<arrow_type> arrow_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef arrow_sequence::iterator arrow_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef arrow_sequence::const_iterator arrow_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<arrow_type, char> arrow_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const arrow_sequence &arrow() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  arrow_sequence &arrow();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void arrow(const arrow_sequence &s);

  //@}

  /**
   * @name handbell
   *
   * @brief Accessor and modifier functions for the %handbell
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::handbell handbell_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<handbell_type> handbell_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef handbell_sequence::iterator handbell_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef handbell_sequence::const_iterator handbell_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<handbell_type, char> handbell_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const handbell_sequence &handbell() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  handbell_sequence &handbell();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void handbell(const handbell_sequence &s);

  //@}

  /**
   * @name other-technical
   *
   * @brief Accessor and modifier functions for the %other-technical
   * sequence element.
   *
   * The other-technical element is used to define any technical
   * indications not yet in the MusicXML format. This allows extended
   * representation, though without application interoperability.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::placement_text other_technical_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<other_technical_type>
    other_technical_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef other_technical_sequence::iterator other_technical_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef other_technical_sequence::const_iterator
    other_technical_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<other_technical_type, char>
    other_technical_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const other_technical_sequence &other_technical() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  other_technical_sequence &other_technical();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void other_technical(const other_technical_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  technical();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  technical(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  technical(const technical &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual technical *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  technical &operator=(const technical &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~technical();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  up_bow_sequence up_bow_;
  down_bow_sequence down_bow_;
  harmonic_sequence harmonic_;
  open_string_sequence open_string_;
  thumb_position_sequence thumb_position_;
  fingering_sequence fingering_;
  pluck_sequence pluck_;
  double_tongue_sequence double_tongue_;
  triple_tongue_sequence triple_tongue_;
  stopped_sequence stopped_;
  snap_pizzicato_sequence snap_pizzicato_;
  fret_sequence fret_;
  string_sequence string_;
  hammer_on_sequence hammer_on_;
  pull_off_sequence pull_off_;
  bend_sequence bend_;
  tap_sequence tap_;
  heel_sequence heel_;
  toe_sequence toe_;
  fingernails_sequence fingernails_;
  hole_sequence hole_;
  arrow_sequence arrow_;
  handbell_sequence handbell_;
  other_technical_sequence other_technical_;

  //@endcond
};

/**
 * @brief Class corresponding to the %text-element-data schema type.
 *
 * The text-element-data type represents a syllable or portion of a
 * syllable for lyric text underlay. A hyphen in the string content
 * should only be used for an actual hyphenated word. Language names for
 * text elements come from ISO 639, with optional country subcodes from
 * ISO 3166.
 *
 * @nosubgrouping
 */
class text_element_data : public ::xml_schema::string {
public:
  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name underline
   *
   * @brief Accessor and modifier functions for the %underline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines underline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<underline_type> underline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<underline_type, char> underline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const underline_optional &underline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  underline_optional &underline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void underline(const underline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void underline(const underline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void underline(::std::unique_ptr<underline_type> p);

  //@}

  /**
   * @name overline
   *
   * @brief Accessor and modifier functions for the %overline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines overline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<overline_type> overline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<overline_type, char> overline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const overline_optional &overline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  overline_optional &overline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void overline(const overline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void overline(const overline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void overline(::std::unique_ptr<overline_type> p);

  //@}

  /**
   * @name line-through
   *
   * @brief Accessor and modifier functions for the %line-through
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines line_through_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_through_type> line_through_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_through_type, char> line_through_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_through_optional &line_through() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_through_optional &line_through();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_through(const line_through_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_through(const line_through_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_through(::std::unique_ptr<line_through_type> p);

  //@}

  /**
   * @name rotation
   *
   * @brief Accessor and modifier functions for the %rotation
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::rotation_degrees rotation_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<rotation_type> rotation_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<rotation_type, char> rotation_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rotation_optional &rotation() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  rotation_optional &rotation();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void rotation(const rotation_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void rotation(const rotation_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void rotation(::std::unique_ptr<rotation_type> p);

  //@}

  /**
   * @name letter-spacing
   *
   * @brief Accessor and modifier functions for the %letter-spacing
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_or_normal letter_spacing_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<letter_spacing_type>
    letter_spacing_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<letter_spacing_type, char>
    letter_spacing_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const letter_spacing_optional &letter_spacing() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  letter_spacing_optional &letter_spacing();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void letter_spacing(const letter_spacing_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void letter_spacing(const letter_spacing_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void letter_spacing(::std::unique_ptr<letter_spacing_type> p);

  //@}

  /**
   * @name lang
   *
   * @brief Accessor and modifier functions for the %lang
   * optional attribute.
   *
   * Attempting to install the relevant ISO 2- and 3-letter
   * codes as the enumerated possible values is probably never
   * going to be a realistic possibility.  See
   * RFC 3066 at http://www.ietf.org/rfc/rfc3066.txt and the IANA registry
   * at http://www.iana.org/assignments/lang-tag-apps.htm for
   * further information.
   *
   * The union allows for the 'un-declaration' of xml:lang with
   * the empty string.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::namespace_::lang lang_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<lang_type> lang_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<lang_type, char> lang_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const lang_optional &lang() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  lang_optional &lang();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void lang(const lang_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void lang(const lang_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void lang(::std::unique_ptr<lang_type> p);

  //@}

  /**
   * @name dir
   *
   * @brief Accessor and modifier functions for the %dir
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::text_direction dir_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dir_type> dir_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dir_type, char> dir_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dir_optional &dir() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dir_optional &dir();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dir(const dir_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dir(const dir_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dir(::std::unique_ptr<dir_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  text_element_data();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  text_element_data(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  text_element_data(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  text_element_data(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  text_element_data(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  text_element_data(const text_element_data &x, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual text_element_data *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  text_element_data &operator=(const text_element_data &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~text_element_data();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  underline_optional underline_;
  overline_optional overline_;
  line_through_optional line_through_;
  rotation_optional rotation_;
  letter_spacing_optional letter_spacing_;
  lang_optional lang_;
  dir_optional dir_;

  //@endcond
};

/**
 * @brief Class corresponding to the %text-font-color schema type.
 *
 * The text-font-color type represents text with optional font and color
 * information. It is used for the elision element.
 *
 * @nosubgrouping
 */
class text_font_color : public ::xml_schema::string {
public:
  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name underline
   *
   * @brief Accessor and modifier functions for the %underline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines underline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<underline_type> underline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<underline_type, char> underline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const underline_optional &underline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  underline_optional &underline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void underline(const underline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void underline(const underline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void underline(::std::unique_ptr<underline_type> p);

  //@}

  /**
   * @name overline
   *
   * @brief Accessor and modifier functions for the %overline
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines overline_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<overline_type> overline_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<overline_type, char> overline_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const overline_optional &overline() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  overline_optional &overline();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void overline(const overline_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void overline(const overline_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void overline(::std::unique_ptr<overline_type> p);

  //@}

  /**
   * @name line-through
   *
   * @brief Accessor and modifier functions for the %line-through
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_of_lines line_through_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_through_type> line_through_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_through_type, char> line_through_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_through_optional &line_through() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_through_optional &line_through();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_through(const line_through_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_through(const line_through_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_through(::std::unique_ptr<line_through_type> p);

  //@}

  /**
   * @name rotation
   *
   * @brief Accessor and modifier functions for the %rotation
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::rotation_degrees rotation_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<rotation_type> rotation_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<rotation_type, char> rotation_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rotation_optional &rotation() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  rotation_optional &rotation();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void rotation(const rotation_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void rotation(const rotation_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void rotation(::std::unique_ptr<rotation_type> p);

  //@}

  /**
   * @name letter-spacing
   *
   * @brief Accessor and modifier functions for the %letter-spacing
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_or_normal letter_spacing_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<letter_spacing_type>
    letter_spacing_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<letter_spacing_type, char>
    letter_spacing_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const letter_spacing_optional &letter_spacing() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  letter_spacing_optional &letter_spacing();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void letter_spacing(const letter_spacing_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void letter_spacing(const letter_spacing_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void letter_spacing(::std::unique_ptr<letter_spacing_type> p);

  //@}

  /**
   * @name lang
   *
   * @brief Accessor and modifier functions for the %lang
   * optional attribute.
   *
   * Attempting to install the relevant ISO 2- and 3-letter
   * codes as the enumerated possible values is probably never
   * going to be a realistic possibility.  See
   * RFC 3066 at http://www.ietf.org/rfc/rfc3066.txt and the IANA registry
   * at http://www.iana.org/assignments/lang-tag-apps.htm for
   * further information.
   *
   * The union allows for the 'un-declaration' of xml:lang with
   * the empty string.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::namespace_::lang lang_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<lang_type> lang_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<lang_type, char> lang_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const lang_optional &lang() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  lang_optional &lang();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void lang(const lang_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void lang(const lang_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void lang(::std::unique_ptr<lang_type> p);

  //@}

  /**
   * @name dir
   *
   * @brief Accessor and modifier functions for the %dir
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::text_direction dir_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dir_type> dir_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dir_type, char> dir_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dir_optional &dir() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dir_optional &dir();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dir(const dir_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dir(const dir_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dir(::std::unique_ptr<dir_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  text_font_color();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  text_font_color(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  text_font_color(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  text_font_color(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  text_font_color(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  text_font_color(const text_font_color &x, ::xml_schema::flags f = 0,
                  ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual text_font_color *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  text_font_color &operator=(const text_font_color &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~text_font_color();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  underline_optional underline_;
  overline_optional overline_;
  line_through_optional line_through_;
  rotation_optional rotation_;
  letter_spacing_optional letter_spacing_;
  lang_optional lang_;
  dir_optional dir_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tie schema type.
 *
 * The tie element indicates that a tie begins or ends with this note. If
 * the tie element applies only particular times through a repeat, the
 * time-only attribute indicates which times to apply it. The tie element
 * indicates sound; the tied element indicates notation.
 *
 * @nosubgrouping
 */
class tie : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name time-only
   *
   * @brief Accessor and modifier functions for the %time-only
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::time_only time_only_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<time_only_type> time_only_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<time_only_type, char> time_only_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const time_only_optional &time_only() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  time_only_optional &time_only();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void time_only(const time_only_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void time_only(const time_only_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void time_only(::std::unique_ptr<time_only_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tie(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tie(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tie(const tie &x, ::xml_schema::flags f = 0,
      ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tie *_clone(::xml_schema::flags f = 0,
                      ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tie &operator=(const tie &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tie();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  time_only_optional time_only_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tied schema type.
 *
 * The tied type represents the notated tie. The tie element represents
 * the tie sound.
 *
 * The number attribute is rarely needed to disambiguate ties, since note
 * pitches will usually suffice. The attribute is implied rather than
 * defaulting to 1 as with most elements. It is available for use in more
 * complex tied notation situations.
 *
 * @nosubgrouping
 */
class tied : public ::xml_schema::type {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_continue type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name line-type
   *
   * @brief Accessor and modifier functions for the %line-type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_type line_type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_type_type> line_type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_type_type, char> line_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_type_optional &line_type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_type_optional &line_type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_type(const line_type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_type(const line_type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_type(::std::unique_ptr<line_type_type> p);

  //@}

  /**
   * @name dash-length
   *
   * @brief Accessor and modifier functions for the %dash-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths dash_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<dash_length_type> dash_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<dash_length_type, char> dash_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dash_length_optional &dash_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  dash_length_optional &dash_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void dash_length(const dash_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void dash_length(const dash_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void dash_length(::std::unique_ptr<dash_length_type> p);

  //@}

  /**
   * @name space-length
   *
   * @brief Accessor and modifier functions for the %space-length
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths space_length_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<space_length_type> space_length_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<space_length_type, char> space_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const space_length_optional &space_length() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  space_length_optional &space_length();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void space_length(const space_length_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void space_length(const space_length_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void space_length(::std::unique_ptr<space_length_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name orientation
   *
   * @brief Accessor and modifier functions for the %orientation
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::over_under orientation_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<orientation_type> orientation_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<orientation_type, char> orientation_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const orientation_optional &orientation() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  orientation_optional &orientation();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void orientation(const orientation_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void orientation(const orientation_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void orientation(::std::unique_ptr<orientation_type> p);

  //@}

  /**
   * @name bezier-offset
   *
   * @brief Accessor and modifier functions for the %bezier-offset
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions bezier_offset_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_offset_type> bezier_offset_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_offset_type, char>
    bezier_offset_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_offset_optional &bezier_offset() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_offset_optional &bezier_offset();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_offset(const bezier_offset_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_offset(const bezier_offset_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_offset(::std::unique_ptr<bezier_offset_type> p);

  //@}

  /**
   * @name bezier-offset2
   *
   * @brief Accessor and modifier functions for the %bezier-offset2
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::divisions bezier_offset2_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_offset2_type>
    bezier_offset2_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_offset2_type, char>
    bezier_offset2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_offset2_optional &bezier_offset2() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_offset2_optional &bezier_offset2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_offset2(const bezier_offset2_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_offset2(const bezier_offset2_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_offset2(::std::unique_ptr<bezier_offset2_type> p);

  //@}

  /**
   * @name bezier-x
   *
   * @brief Accessor and modifier functions for the %bezier-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths bezier_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_x_type> bezier_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_x_type, char> bezier_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_x_optional &bezier_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_x_optional &bezier_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_x(const bezier_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_x(const bezier_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_x(::std::unique_ptr<bezier_x_type> p);

  //@}

  /**
   * @name bezier-y
   *
   * @brief Accessor and modifier functions for the %bezier-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths bezier_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_y_type> bezier_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_y_type, char> bezier_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_y_optional &bezier_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_y_optional &bezier_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_y(const bezier_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_y(const bezier_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_y(::std::unique_ptr<bezier_y_type> p);

  //@}

  /**
   * @name bezier-x2
   *
   * @brief Accessor and modifier functions for the %bezier-x2
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths bezier_x2_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_x2_type> bezier_x2_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_x2_type, char> bezier_x2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_x2_optional &bezier_x2() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_x2_optional &bezier_x2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_x2(const bezier_x2_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_x2(const bezier_x2_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_x2(::std::unique_ptr<bezier_x2_type> p);

  //@}

  /**
   * @name bezier-y2
   *
   * @brief Accessor and modifier functions for the %bezier-y2
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths bezier_y2_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bezier_y2_type> bezier_y2_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bezier_y2_type, char> bezier_y2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bezier_y2_optional &bezier_y2() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bezier_y2_optional &bezier_y2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bezier_y2(const bezier_y2_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bezier_y2(const bezier_y2_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bezier_y2(::std::unique_ptr<bezier_y2_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tied(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tied(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tied(const tied &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tied *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tied &operator=(const tied &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tied();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  number_optional number_;
  line_type_optional line_type_;
  dash_length_optional dash_length_;
  space_length_optional space_length_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  placement_optional placement_;
  orientation_optional orientation_;
  bezier_offset_optional bezier_offset_;
  bezier_offset2_optional bezier_offset2_;
  bezier_x_optional bezier_x_;
  bezier_y_optional bezier_y_;
  bezier_x2_optional bezier_x2_;
  bezier_y2_optional bezier_y2_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tremolo schema type.
 *
 * The tremolo ornament can be used to indicate either single-note or
 * double-note tremolos. Single-note tremolos use the single type, while
 * double-note tremolos use the start and stop types. The default is
 * "single" for compatibility with Version 1.1. The text of the element
 * indicates the number of tremolo marks and is an integer from 0 to 8.
 * Note that the number of attached beams is not included in this value,
 * but is represented separately using the beam element.
 *
 * When using double-note tremolos, the duration of each note in the
 * tremolo should correspond to half of the notated type value. A
 * time-modification element should also be added with an actual-notes
 * value of 2 and a normal-notes value of 1. If used within a tuplet,
 * this 2/1 ratio should be multiplied by the existing tuplet ratio.
 *
 * Using repeater beams for indicating tremolos is deprecated as of
 * MusicXML 3.0.
 *
 * @nosubgrouping
 */
class tremolo : public ::musicxml::tremolo_marks {
public:
  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop_single type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const type_type &type_default_value();

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tremolo(const ::xml_schema::integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tremolo(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tremolo(const tremolo &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tremolo *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tremolo &operator=(const tremolo &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tremolo();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<type_type> type_;
  static const type_type type_default_value_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tuplet schema type.
 *
 * A tuplet element is present when a tuplet is to be displayed
 * graphically, in addition to the sound data provided by the
 * time-modification elements. The number attribute is used to
 * distinguish nested tuplets. The bracket attribute is used to indicate
 * the presence of a bracket. If unspecified, the results are
 * implementation-dependent. The line-shape attribute is used to specify
 * whether the bracket is straight or in the older curved or slurred
 * style. It is straight by default.
 *
 * Whereas a time-modification element shows how the cumulative, sounding
 * effect of tuplets and double-note tremolos compare to the written note
 * type, the tuplet element describes how this is displayed. The tuplet
 * element also provides more detailed representation information than
 * the time-modification element, and is needed to represent nested
 * tuplets and other complex tuplets accurately.
 *
 * The show-number attribute is used to display either the number of
 * actual notes, the number of both actual and normal notes, or neither.
 * It is actual by default. The show-type attribute is used to display
 * either the actual type, both the actual and normal types, or neither.
 * It is none by default.
 *
 * @nosubgrouping
 */
class tuplet : public ::xml_schema::type {
public:
  /**
   * @name tuplet-actual
   *
   * @brief Accessor and modifier functions for the %tuplet-actual
   * optional element.
   *
   * The tuplet-actual element provide optional full control over how the
   * actual part of the tuplet is displayed, including number and note type
   * (with dots). If any of these elements are absent, their values are
   * based on the time-modification element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tuplet_portion tuplet_actual_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tuplet_actual_type> tuplet_actual_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuplet_actual_type, char>
    tuplet_actual_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tuplet_actual_optional &tuplet_actual() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tuplet_actual_optional &tuplet_actual();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuplet_actual(const tuplet_actual_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void tuplet_actual(const tuplet_actual_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tuplet_actual(::std::unique_ptr<tuplet_actual_type> p);

  //@}

  /**
   * @name tuplet-normal
   *
   * @brief Accessor and modifier functions for the %tuplet-normal
   * optional element.
   *
   * The tuplet-normal element provide optional full control over how the
   * normal part of the tuplet is displayed, including number and note type
   * (with dots). If any of these elements are absent, their values are
   * based on the time-modification element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tuplet_portion tuplet_normal_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tuplet_normal_type> tuplet_normal_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuplet_normal_type, char>
    tuplet_normal_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tuplet_normal_optional &tuplet_normal() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tuplet_normal_optional &tuplet_normal();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuplet_normal(const tuplet_normal_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void tuplet_normal(const tuplet_normal_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tuplet_normal(::std::unique_ptr<tuplet_normal_type> p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::number_level number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name bracket
   *
   * @brief Accessor and modifier functions for the %bracket
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no bracket_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<bracket_type> bracket_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<bracket_type, char> bracket_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const bracket_optional &bracket() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  bracket_optional &bracket();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void bracket(const bracket_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void bracket(const bracket_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void bracket(::std::unique_ptr<bracket_type> p);

  //@}

  /**
   * @name show-number
   *
   * @brief Accessor and modifier functions for the %show-number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::show_tuplet show_number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<show_number_type> show_number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<show_number_type, char> show_number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const show_number_optional &show_number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  show_number_optional &show_number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void show_number(const show_number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void show_number(const show_number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void show_number(::std::unique_ptr<show_number_type> p);

  //@}

  /**
   * @name show-type
   *
   * @brief Accessor and modifier functions for the %show-type
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::show_tuplet show_type_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<show_type_type> show_type_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<show_type_type, char> show_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const show_type_optional &show_type() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  show_type_optional &show_type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void show_type(const show_type_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void show_type(const show_type_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void show_type(::std::unique_ptr<show_type_type> p);

  //@}

  /**
   * @name line-shape
   *
   * @brief Accessor and modifier functions for the %line-shape
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::line_shape line_shape_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<line_shape_type> line_shape_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<line_shape_type, char> line_shape_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const line_shape_optional &line_shape() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  line_shape_optional &line_shape();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void line_shape(const line_shape_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void line_shape(const line_shape_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void line_shape(::std::unique_ptr<line_shape_type> p);

  //@}

  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name placement
   *
   * @brief Accessor and modifier functions for the %placement
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::above_below placement_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<placement_type> placement_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<placement_type, char> placement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const placement_optional &placement() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  placement_optional &placement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void placement(const placement_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void placement(const placement_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void placement(::std::unique_ptr<placement_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tuplet(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tuplet(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet(const tuplet &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tuplet *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet &operator=(const tuplet &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tuplet();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  tuplet_actual_optional tuplet_actual_;
  tuplet_normal_optional tuplet_normal_;
  ::xsd::cxx::tree::one<type_type> type_;
  number_optional number_;
  bracket_optional bracket_;
  show_number_optional show_number_;
  show_type_optional show_type_;
  line_shape_optional line_shape_;
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  placement_optional placement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tuplet-dot schema type.
 *
 * The tuplet-dot type is used to specify dotted normal tuplet types.
 *
 * @nosubgrouping
 */
class tuplet_dot : public ::xml_schema::type {
public:
  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tuplet_dot();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tuplet_dot(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet_dot(const tuplet_dot &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tuplet_dot *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet_dot &operator=(const tuplet_dot &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tuplet_dot();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tuplet-number schema type.
 *
 * The tuplet-number type indicates the number of notes for this portion
 * of the tuplet.
 *
 * @nosubgrouping
 */
class tuplet_number
  : public ::xsd::cxx::tree::fundamental_base<
      ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> {
public:
  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tuplet_number(const ::xml_schema::non_negative_integer &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tuplet_number(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet_number(const tuplet_number &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tuplet_number *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet_number &operator=(const tuplet_number &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tuplet_number();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tuplet-portion schema type.
 *
 * The tuplet-portion type provides optional full control over tuplet
 * specifications. It allows the number and note type (including dots) to
 * be set for the actual and normal portions of a single tuplet. If any
 * of these elements are absent, their values are based on the
 * time-modification element.
 *
 * @nosubgrouping
 */
class tuplet_portion : public ::xml_schema::type {
public:
  /**
   * @name tuplet-number
   *
   * @brief Accessor and modifier functions for the %tuplet-number
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tuplet_number tuplet_number_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tuplet_number_type> tuplet_number_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuplet_number_type, char>
    tuplet_number_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tuplet_number_optional &tuplet_number() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tuplet_number_optional &tuplet_number();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuplet_number(const tuplet_number_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void tuplet_number(const tuplet_number_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tuplet_number(::std::unique_ptr<tuplet_number_type> p);

  //@}

  /**
   * @name tuplet-type
   *
   * @brief Accessor and modifier functions for the %tuplet-type
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tuplet_type tuplet_type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<tuplet_type_type> tuplet_type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuplet_type_type, char> tuplet_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tuplet_type_optional &tuplet_type() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tuplet_type_optional &tuplet_type();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void tuplet_type(const tuplet_type_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void tuplet_type(const tuplet_type_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void tuplet_type(::std::unique_ptr<tuplet_type_type> p);

  //@}

  /**
   * @name tuplet-dot
   *
   * @brief Accessor and modifier functions for the %tuplet-dot
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::tuplet_dot tuplet_dot_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<tuplet_dot_type> tuplet_dot_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef tuplet_dot_sequence::iterator tuplet_dot_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef tuplet_dot_sequence::const_iterator tuplet_dot_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<tuplet_dot_type, char> tuplet_dot_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const tuplet_dot_sequence &tuplet_dot() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  tuplet_dot_sequence &tuplet_dot();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void tuplet_dot(const tuplet_dot_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tuplet_portion();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tuplet_portion(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet_portion(const tuplet_portion &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tuplet_portion *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet_portion &operator=(const tuplet_portion &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tuplet_portion();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  tuplet_number_optional tuplet_number_;
  tuplet_type_optional tuplet_type_;
  tuplet_dot_sequence tuplet_dot_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tuplet-type schema type.
 *
 * The tuplet-type type indicates the graphical note type of the notes
 * for this portion of the tuplet.
 *
 * @nosubgrouping
 */
class tuplet_type : public ::musicxml::note_type_value {
public:
  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  tuplet_type(::musicxml::note_type_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  tuplet_type(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  tuplet_type(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tuplet_type(const ::musicxml::note_type_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tuplet_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet_type(const tuplet_type &x, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tuplet_type *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tuplet_type &operator=(const tuplet_type &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~tuplet_type();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %unpitched schema type.
 *
 * The unpitched type represents musical elements that are notated on the
 * staff but lack definite pitch, such as unpitched percussion and
 * speaking voice.
 *
 * @nosubgrouping
 */
class unpitched : public ::xml_schema::type {
public:
  /**
   * @name display-step
   *
   * @brief Accessor and modifier functions for the %display-step
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::step display_step_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<display_step_type> display_step_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<display_step_type, char> display_step_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const display_step_optional &display_step() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  display_step_optional &display_step();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void display_step(const display_step_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void display_step(const display_step_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void display_step(::std::unique_ptr<display_step_type> p);

  //@}

  /**
   * @name display-octave
   *
   * @brief Accessor and modifier functions for the %display-octave
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::octave display_octave_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<display_octave_type>
    display_octave_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<display_octave_type, char>
    display_octave_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const display_octave_optional &display_octave() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  display_octave_optional &display_octave();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void display_octave(const display_octave_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void display_octave(const display_octave_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void display_octave(::std::unique_ptr<display_octave_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  unpitched();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  unpitched(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  unpitched(const unpitched &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual unpitched *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  unpitched &operator=(const unpitched &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~unpitched();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  display_step_optional display_step_;
  display_octave_optional display_octave_;

  //@endcond
};

/**
 * @brief Class corresponding to the %credit schema type.
 *
 * The credit type represents the appearance of the title, composer,
 * arranger, lyricist, copyright, dedication, and other text and graphics
 * that commonly appears on the first page of a score. The credit-words
 * and credit-image elements are similar to the words and image elements
 * for directions. However, since the credit is not part of a measure,
 * the default-x and default-y attributes adjust the origin relative to
 * the bottom left-hand corner of the first page. The enclosure for
 * credit-words is none by default.
 *
 * By default, a series of credit-words elements within a single credit
 * element follow one another in sequence visually. Non-positional
 * formatting attributes are carried over from the previous element by
 * default.
 *
 * The page attribute for the credit element, new in Version 2.0,
 * specifies the page number where the credit should appear. This is an
 * integer value that starts with 1 for the first page. Its value is 1 by
 * default. Since credits occur before the music, these page numbers do
 * not refer to the page numbering specified by the print element's
 * page-number attribute.
 *
 * The credit-type element, new in Version 3.0, indicates the purpose
 * behind a credit. Multiple types of data may be combined in a single
 * credit, so multiple elements may be used. Standard values include page
 * number, title, subtitle, composer, arranger, lyricist, and rights.
 *
 * @nosubgrouping
 */
class credit : public ::xml_schema::type {
public:
  /**
   * @name credit-type
   *
   * @brief Accessor and modifier functions for the %credit-type
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string credit_type_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<credit_type_type> credit_type_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef credit_type_sequence::iterator credit_type_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef credit_type_sequence::const_iterator credit_type_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<credit_type_type, char> credit_type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const credit_type_sequence &credit_type() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  credit_type_sequence &credit_type();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void credit_type(const credit_type_sequence &s);

  //@}

  /**
   * @name link
   *
   * @brief Accessor and modifier functions for the %link
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::link link_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<link_type> link_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef link_sequence::iterator link_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef link_sequence::const_iterator link_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<link_type, char> link_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const link_sequence &link() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  link_sequence &link();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void link(const link_sequence &s);

  //@}

  /**
   * @name bookmark
   *
   * @brief Accessor and modifier functions for the %bookmark
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bookmark bookmark_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<bookmark_type> bookmark_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef bookmark_sequence::iterator bookmark_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef bookmark_sequence::const_iterator bookmark_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bookmark_type, char> bookmark_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const bookmark_sequence &bookmark() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  bookmark_sequence &bookmark();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void bookmark(const bookmark_sequence &s);

  //@}

  /**
   * @name credit-image
   *
   * @brief Accessor and modifier functions for the %credit-image
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::image credit_image_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<credit_image_type> credit_image_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<credit_image_type, char> credit_image_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const credit_image_optional &credit_image() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  credit_image_optional &credit_image();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void credit_image(const credit_image_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void credit_image(const credit_image_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void credit_image(::std::unique_ptr<credit_image_type> p);

  //@}

  /**
   * @name credit-words
   *
   * @brief Accessor and modifier functions for the %credit-words
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text credit_words_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<credit_words_type> credit_words_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef credit_words_sequence::iterator credit_words_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef credit_words_sequence::const_iterator credit_words_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<credit_words_type, char> credit_words_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const credit_words_sequence &credit_words() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  credit_words_sequence &credit_words();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void credit_words(const credit_words_sequence &s);

  //@}

  /**
   * @name page
   *
   * @brief Accessor and modifier functions for the %page
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer page_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<page_type> page_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<page_type, char> page_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const page_optional &page() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  page_optional &page();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void page(const page_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void page(const page_optional &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  credit();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  credit(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  credit(const credit &x, ::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual credit *_clone(::xml_schema::flags f = 0,
                         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  credit &operator=(const credit &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~credit();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  credit_type_sequence credit_type_;
  link_sequence link_;
  bookmark_sequence bookmark_;
  credit_image_optional credit_image_;
  credit_words_sequence credit_words_;
  page_optional page_;

  //@endcond
};

/**
 * @brief Class corresponding to the %defaults schema type.
 *
 * The defaults type specifies score-wide defaults for scaling, layout,
 * and appearance.
 *
 * @nosubgrouping
 */
class defaults : public ::xml_schema::type {
public:
  /**
   * @name scaling
   *
   * @brief Accessor and modifier functions for the %scaling
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::scaling scaling_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<scaling_type> scaling_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<scaling_type, char> scaling_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const scaling_optional &scaling() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  scaling_optional &scaling();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void scaling(const scaling_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void scaling(const scaling_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void scaling(::std::unique_ptr<scaling_type> p);

  //@}

  /**
   * @name page-layout
   *
   * @brief Accessor and modifier functions for the %page-layout
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::page_layout page_layout_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<page_layout_type> page_layout_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<page_layout_type, char> page_layout_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const page_layout_optional &page_layout() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  page_layout_optional &page_layout();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void page_layout(const page_layout_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void page_layout(const page_layout_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void page_layout(::std::unique_ptr<page_layout_type> p);

  //@}

  /**
   * @name system-layout
   *
   * @brief Accessor and modifier functions for the %system-layout
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::system_layout system_layout_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<system_layout_type> system_layout_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<system_layout_type, char>
    system_layout_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const system_layout_optional &system_layout() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  system_layout_optional &system_layout();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void system_layout(const system_layout_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void system_layout(const system_layout_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void system_layout(::std::unique_ptr<system_layout_type> p);

  //@}

  /**
   * @name staff-layout
   *
   * @brief Accessor and modifier functions for the %staff-layout
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::staff_layout staff_layout_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<staff_layout_type> staff_layout_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef staff_layout_sequence::iterator staff_layout_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef staff_layout_sequence::const_iterator staff_layout_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<staff_layout_type, char> staff_layout_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const staff_layout_sequence &staff_layout() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  staff_layout_sequence &staff_layout();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void staff_layout(const staff_layout_sequence &s);

  //@}

  /**
   * @name appearance
   *
   * @brief Accessor and modifier functions for the %appearance
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::appearance appearance_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<appearance_type> appearance_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<appearance_type, char> appearance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const appearance_optional &appearance() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  appearance_optional &appearance();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void appearance(const appearance_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void appearance(const appearance_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void appearance(::std::unique_ptr<appearance_type> p);

  //@}

  /**
   * @name music-font
   *
   * @brief Accessor and modifier functions for the %music-font
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_font music_font_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<music_font_type> music_font_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<music_font_type, char> music_font_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const music_font_optional &music_font() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  music_font_optional &music_font();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void music_font(const music_font_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void music_font(const music_font_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void music_font(::std::unique_ptr<music_font_type> p);

  //@}

  /**
   * @name word-font
   *
   * @brief Accessor and modifier functions for the %word-font
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty_font word_font_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<word_font_type> word_font_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<word_font_type, char> word_font_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const word_font_optional &word_font() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  word_font_optional &word_font();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void word_font(const word_font_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void word_font(const word_font_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void word_font(::std::unique_ptr<word_font_type> p);

  //@}

  /**
   * @name lyric-font
   *
   * @brief Accessor and modifier functions for the %lyric-font
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::lyric_font lyric_font_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<lyric_font_type> lyric_font_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef lyric_font_sequence::iterator lyric_font_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef lyric_font_sequence::const_iterator lyric_font_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<lyric_font_type, char> lyric_font_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const lyric_font_sequence &lyric_font() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  lyric_font_sequence &lyric_font();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void lyric_font(const lyric_font_sequence &s);

  //@}

  /**
   * @name lyric-language
   *
   * @brief Accessor and modifier functions for the %lyric-language
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::lyric_language lyric_language_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<lyric_language_type>
    lyric_language_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef lyric_language_sequence::iterator lyric_language_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef lyric_language_sequence::const_iterator lyric_language_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<lyric_language_type, char>
    lyric_language_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const lyric_language_sequence &lyric_language() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  lyric_language_sequence &lyric_language();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void lyric_language(const lyric_language_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  defaults();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  defaults(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  defaults(const defaults &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual defaults *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  defaults &operator=(const defaults &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~defaults();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  scaling_optional scaling_;
  page_layout_optional page_layout_;
  system_layout_optional system_layout_;
  staff_layout_sequence staff_layout_;
  appearance_optional appearance_;
  music_font_optional music_font_;
  word_font_optional word_font_;
  lyric_font_sequence lyric_font_;
  lyric_language_sequence lyric_language_;

  //@endcond
};

/**
 * @brief Class corresponding to the %empty-font schema type.
 *
 * The empty-font type represents an empty element with font attributes.
 *
 * @nosubgrouping
 */
class empty_font : public ::xml_schema::type {
public:
  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  empty_font();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  empty_font(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_font(const empty_font &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual empty_font *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  empty_font &operator=(const empty_font &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~empty_font();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;

  //@endcond
};

/**
 * @brief Class corresponding to the %group-barline schema type.
 *
 * The group-barline type indicates if the group should have common
 * barlines.
 *
 * @nosubgrouping
 */
class group_barline : public ::musicxml::group_barline_value {
public:
  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  group_barline(::musicxml::group_barline_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  group_barline(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  group_barline(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  group_barline(const ::musicxml::group_barline_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_barline(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  group_barline(const group_barline &x, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual group_barline *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  group_barline &operator=(const group_barline &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~group_barline();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %group-name schema type.
 *
 * The group-name type describes the name or abbreviation of a part-group
 * element. Formatting attributes in the group-name type are deprecated
 * in Version 2.0 in favor of the new group-name-display and
 * group-abbreviation-display elements.
 *
 * @nosubgrouping
 */
class group_name : public ::xml_schema::string {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name justify
   *
   * @brief Accessor and modifier functions for the %justify
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right justify_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<justify_type> justify_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<justify_type, char> justify_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const justify_optional &justify() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  justify_optional &justify();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void justify(const justify_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void justify(const justify_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void justify(::std::unique_ptr<justify_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  group_name();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  group_name(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  group_name(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  group_name(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_name(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  group_name(const group_name &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual group_name *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  group_name &operator=(const group_name &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~group_name();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  justify_optional justify_;

  //@endcond
};

/**
 * @brief Class corresponding to the %group-symbol schema type.
 *
 * The group-symbol type indicates how the symbol for a group is
 * indicated in the score.
 *
 * @nosubgrouping
 */
class group_symbol : public ::musicxml::group_symbol_value {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the underlying enum value
   * and initializers for required elements and attributes.
   */
  group_symbol(::musicxml::group_symbol_value::value);

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  group_symbol(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  group_symbol(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  group_symbol(const ::musicxml::group_symbol_value &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  group_symbol(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  group_symbol(const group_symbol &x, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual group_symbol *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  group_symbol &operator=(const group_symbol &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~group_symbol();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  color_optional color_;

  //@endcond
};

/**
 * @brief Class corresponding to the %lyric-font schema type.
 *
 * The lyric-font type specifies the default font for a particular name
 * and number of lyric.
 *
 * @nosubgrouping
 */
class lyric_font : public ::xml_schema::type {
public:
  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::nmtoken number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token name_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<name_type> name_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const name_optional &name() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  name_optional &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void name(const name_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  lyric_font();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  lyric_font(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  lyric_font(const lyric_font &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual lyric_font *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  lyric_font &operator=(const lyric_font &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~lyric_font();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  number_optional number_;
  name_optional name_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;

  //@endcond
};

/**
 * @brief Class corresponding to the %lyric-language schema type.
 *
 * The lyric-language type specifies the default language for a
 * particular name and number of lyric.
 *
 * @nosubgrouping
 */
class lyric_language : public ::xml_schema::type {
public:
  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::nmtoken number_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<number_type> number_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const number_optional &number() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  number_optional &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void number(const number_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token name_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<name_type> name_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const name_optional &name() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  name_optional &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void name(const name_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name lang
   *
   * @brief Accessor and modifier functions for the %lang
   * required attribute.
   *
   * Attempting to install the relevant ISO 2- and 3-letter
   * codes as the enumerated possible values is probably never
   * going to be a realistic possibility.  See
   * RFC 3066 at http://www.ietf.org/rfc/rfc3066.txt and the IANA registry
   * at http://www.iana.org/assignments/lang-tag-apps.htm for
   * further information.
   *
   * The union allows for the 'un-declaration' of xml:lang with
   * the empty string.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::namespace_::lang lang_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<lang_type, char> lang_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const lang_type &lang() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  lang_type &lang();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void lang(const lang_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void lang(::std::unique_ptr<lang_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  lyric_language(const lang_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  lyric_language(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  lyric_language(const lyric_language &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual lyric_language *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  lyric_language &operator=(const lyric_language &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~lyric_language();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  number_optional number_;
  name_optional name_;
  ::xsd::cxx::tree::one<lang_type> lang_;

  //@endcond
};

/**
 * @brief Class corresponding to the %opus schema type.
 *
 * The opus type represents a link to a MusicXML opus document that
 * composes multiple MusicXML scores into a collection.
 *
 * @nosubgrouping
 */
class opus : public ::xml_schema::type {
public:
  /**
   * @name href
   *
   * @brief Accessor and modifier functions for the %href
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::uri href_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<href_type, char> href_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const href_type &href() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  href_type &href();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void href(const href_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void href(::std::unique_ptr<href_type> p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xlink::type type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const type_type &type_default_value();

  //@}

  /**
   * @name role
   *
   * @brief Accessor and modifier functions for the %role
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token role_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<role_type> role_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<role_type, char> role_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const role_optional &role() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  role_optional &role();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void role(const role_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void role(const role_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void role(::std::unique_ptr<role_type> p);

  //@}

  /**
   * @name title
   *
   * @brief Accessor and modifier functions for the %title
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token title_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<title_type> title_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<title_type, char> title_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const title_optional &title() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  title_optional &title();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void title(const title_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void title(const title_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void title(::std::unique_ptr<title_type> p);

  //@}

  /**
   * @name show
   *
   * @brief Accessor and modifier functions for the %show
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xlink::show show_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<show_type, char> show_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const show_type &show() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  show_type &show();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void show(const show_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void show(::std::unique_ptr<show_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const show_type &show_default_value();

  //@}

  /**
   * @name actuate
   *
   * @brief Accessor and modifier functions for the %actuate
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xlink::actuate actuate_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<actuate_type, char> actuate_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const actuate_type &actuate() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  actuate_type &actuate();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void actuate(const actuate_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void actuate(::std::unique_ptr<actuate_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const actuate_type &actuate_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  opus(const href_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  opus(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  opus(const opus &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual opus *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  opus &operator=(const opus &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~opus();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<href_type> href_;
  ::xsd::cxx::tree::one<type_type> type_;
  static const type_type type_default_value_;
  role_optional role_;
  title_optional title_;
  ::xsd::cxx::tree::one<show_type> show_;
  static const show_type show_default_value_;
  ::xsd::cxx::tree::one<actuate_type> actuate_;
  static const actuate_type actuate_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %part-group schema type.
 *
 * The part-group element indicates groupings of parts in the score,
 * usually indicated by braces and brackets. Braces that are used for
 * multi-staff parts should be defined in the attributes element for that
 * part. The part-group start element appears before the first score-part
 * in the group. The part-group stop element appears after the last
 * score-part in the group.
 *
 * The number attribute is used to distinguish overlapping and nested
 * part-groups, not the sequence of groups. As with parts, groups can
 * have a name and abbreviation. Values for the child elements are
 * ignored at the stop of a group.
 *
 * A part-group element is not needed for a single multi-staff part. By
 * default, multi-staff parts include a brace symbol and (if appropriate
 * given the bar-style) common barlines. The symbol formatting for a
 * multi-staff part can be more fully specified using the part-symbol
 * element.
 *
 * @nosubgrouping
 */
class part_group : public ::xml_schema::type {
public:
  /**
   * @name group-name
   *
   * @brief Accessor and modifier functions for the %group-name
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::group_name group_name_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<group_name_type> group_name_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<group_name_type, char> group_name_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const group_name_optional &group_name() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  group_name_optional &group_name();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void group_name(const group_name_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void group_name(const group_name_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void group_name(::std::unique_ptr<group_name_type> p);

  //@}

  /**
   * @name group-name-display
   *
   * @brief Accessor and modifier functions for the %group-name-display
   * optional element.
   *
   * Formatting specified in the group-name-display element overrides
   * formatting specified in the group-name element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::name_display group_name_display_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<group_name_display_type>
    group_name_display_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<group_name_display_type, char>
    group_name_display_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const group_name_display_optional &group_name_display() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  group_name_display_optional &group_name_display();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void group_name_display(const group_name_display_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void group_name_display(const group_name_display_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void group_name_display(::std::unique_ptr<group_name_display_type> p);

  //@}

  /**
   * @name group-abbreviation
   *
   * @brief Accessor and modifier functions for the %group-abbreviation
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::group_name group_abbreviation_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<group_abbreviation_type>
    group_abbreviation_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<group_abbreviation_type, char>
    group_abbreviation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const group_abbreviation_optional &group_abbreviation() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  group_abbreviation_optional &group_abbreviation();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void group_abbreviation(const group_abbreviation_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void group_abbreviation(const group_abbreviation_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void group_abbreviation(::std::unique_ptr<group_abbreviation_type> p);

  //@}

  /**
   * @name group-abbreviation-display
   *
   * @brief Accessor and modifier functions for the %group-abbreviation-display
   * optional element.
   *
   * Formatting specified in the group-abbreviation-display element
   * overrides formatting specified in the group-abbreviation element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::name_display group_abbreviation_display_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<group_abbreviation_display_type>
    group_abbreviation_display_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<group_abbreviation_display_type, char>
    group_abbreviation_display_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const group_abbreviation_display_optional &group_abbreviation_display() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  group_abbreviation_display_optional &group_abbreviation_display();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void group_abbreviation_display(const group_abbreviation_display_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void group_abbreviation_display(const group_abbreviation_display_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void group_abbreviation_display(
    ::std::unique_ptr<group_abbreviation_display_type> p);

  //@}

  /**
   * @name group-symbol
   *
   * @brief Accessor and modifier functions for the %group-symbol
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::group_symbol group_symbol_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<group_symbol_type> group_symbol_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<group_symbol_type, char> group_symbol_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const group_symbol_optional &group_symbol() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  group_symbol_optional &group_symbol();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void group_symbol(const group_symbol_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void group_symbol(const group_symbol_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void group_symbol(::std::unique_ptr<group_symbol_type> p);

  //@}

  /**
   * @name group-barline
   *
   * @brief Accessor and modifier functions for the %group-barline
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::group_barline group_barline_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<group_barline_type> group_barline_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<group_barline_type, char>
    group_barline_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const group_barline_optional &group_barline() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  group_barline_optional &group_barline();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void group_barline(const group_barline_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void group_barline(const group_barline_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void group_barline(::std::unique_ptr<group_barline_type> p);

  //@}

  /**
   * @name group-time
   *
   * @brief Accessor and modifier functions for the %group-time
   * optional element.
   *
   * The group-time element indicates that the displayed time signatures
   * should stretch across all parts and staves in the group.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty group_time_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<group_time_type> group_time_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<group_time_type, char> group_time_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const group_time_optional &group_time() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  group_time_optional &group_time();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void group_time(const group_time_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void group_time(const group_time_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void group_time(::std::unique_ptr<group_time_type> p);

  //@}

  /**
   * @name footnote
   *
   * @brief Accessor and modifier functions for the %footnote
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::formatted_text footnote_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<footnote_type> footnote_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<footnote_type, char> footnote_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const footnote_optional &footnote() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  footnote_optional &footnote();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void footnote(const footnote_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void footnote(const footnote_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void footnote(::std::unique_ptr<footnote_type> p);

  //@}

  /**
   * @name level
   *
   * @brief Accessor and modifier functions for the %level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::level level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<level_type> level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<level_type, char> level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const level_optional &level() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  level_optional &level();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void level(const level_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void level(const level_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void level(::std::unique_ptr<level_type> p);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::start_stop type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const number_type &number_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  part_group(const type_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  part_group(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part_group(const part_group &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual part_group *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part_group &operator=(const part_group &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~part_group();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  group_name_optional group_name_;
  group_name_display_optional group_name_display_;
  group_abbreviation_optional group_abbreviation_;
  group_abbreviation_display_optional group_abbreviation_display_;
  group_symbol_optional group_symbol_;
  group_barline_optional group_barline_;
  group_time_optional group_time_;
  footnote_optional footnote_;
  level_optional level_;
  ::xsd::cxx::tree::one<type_type> type_;
  ::xsd::cxx::tree::one<number_type> number_;
  static const number_type number_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %part-list schema type.
 *
 * The part-list identifies the different musical parts in this movement.
 * Each part has an ID that is used later within the musical data. Since
 * parts may be encoded separately and combined later, identification
 * elements are present at both the score and score-part levels. There
 * must be at least one score-part, combined as desired with part-group
 * elements that indicate braces and brackets. Parts are ordered from top
 * to bottom in a score based on the order in which they appear in the
 * part-list.
 *
 * @nosubgrouping
 */
class part_list : public ::xml_schema::type {
public:
  /**
   * @name part-group
   *
   * @brief Accessor and modifier functions for the %part-group
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::part_group part_group_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<part_group_type> part_group_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef part_group_sequence::iterator part_group_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef part_group_sequence::const_iterator part_group_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_group_type, char> part_group_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const part_group_sequence &part_group() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  part_group_sequence &part_group();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void part_group(const part_group_sequence &s);

  //@}

  /**
   * @name score-part
   *
   * @brief Accessor and modifier functions for the %score-part
   * sequence element.
   *
   * Each MusicXML part corresponds to a track in a Standard MIDI Format 1
   * file. The score-instrument elements are used when there are multiple
   * instruments per track. The midi-device element is used to make a MIDI
   * device or port assignment for the given track. Initial midi-instrument
   * assignments may be made here as well.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::score_part score_part_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<score_part_type> score_part_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef score_part_sequence::iterator score_part_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef score_part_sequence::const_iterator score_part_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<score_part_type, char> score_part_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const score_part_sequence &score_part() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  score_part_sequence &score_part();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void score_part(const score_part_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  part_list();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  part_list(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part_list(const part_list &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual part_list *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part_list &operator=(const part_list &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~part_list();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  part_group_sequence part_group_;
  score_part_sequence score_part_;

  //@endcond
};

/**
 * @brief Class corresponding to the %part-name schema type.
 *
 * The part-name type describes the name or abbreviation of a score-part
 * element. Formatting attributes for the part-name element are
 * deprecated in Version 2.0 in favor of the new part-name-display and
 * part-abbreviation-display elements.
 *
 * @nosubgrouping
 */
class part_name : public ::xml_schema::string {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name print-object
   *
   * @brief Accessor and modifier functions for the %print-object
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no print_object_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<print_object_type> print_object_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_object_type, char> print_object_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const print_object_optional &print_object() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  print_object_optional &print_object();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void print_object(const print_object_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void print_object(const print_object_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void print_object(::std::unique_ptr<print_object_type> p);

  //@}

  /**
   * @name justify
   *
   * @brief Accessor and modifier functions for the %justify
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::left_center_right justify_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<justify_type> justify_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<justify_type, char> justify_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const justify_optional &justify() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  justify_optional &justify();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void justify(const justify_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void justify(const justify_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void justify(::std::unique_ptr<justify_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  part_name();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  part_name(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  part_name(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  part_name(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  part_name(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part_name(const part_name &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual part_name *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part_name &operator=(const part_name &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~part_name();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  print_object_optional print_object_;
  justify_optional justify_;

  //@endcond
};

/**
 * @brief Class corresponding to the %score-instrument schema type.
 *
 * The score-instrument type represents a single instrument within a
 * score-part. As with the score-part type, each score-instrument has a
 * required ID attribute, a name, and an optional abbreviation.
 *
 * A score-instrument type is also required if the score specifies MIDI
 * 1.0 channels, banks, or programs. An initial midi-instrument
 * assignment can also be made here. MusicXML software should be able to
 * automatically assign reasonable channels and instruments without these
 * elements in simple cases, such as where part names match General MIDI
 * instrument names.
 *
 * @nosubgrouping
 */
class score_instrument : public ::xml_schema::type {
public:
  /**
   * @name instrument-name
   *
   * @brief Accessor and modifier functions for the %instrument-name
   * required element.
   *
   * The instrument-name element is typically used within a software
   * application, rather than appearing on the printed page of a score.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string instrument_name_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<instrument_name_type, char>
    instrument_name_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const instrument_name_type &instrument_name() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  instrument_name_type &instrument_name();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void instrument_name(const instrument_name_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void instrument_name(::std::unique_ptr<instrument_name_type> p);

  //@}

  /**
   * @name instrument-abbreviation
   *
   * @brief Accessor and modifier functions for the %instrument-abbreviation
   * optional element.
   *
   * The optional instrument-abbreviation element is typically used within
   * a software application, rather than appearing on the printed page of a
   * score.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string instrument_abbreviation_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<instrument_abbreviation_type>
    instrument_abbreviation_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<instrument_abbreviation_type, char>
    instrument_abbreviation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const instrument_abbreviation_optional &instrument_abbreviation() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  instrument_abbreviation_optional &instrument_abbreviation();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void instrument_abbreviation(const instrument_abbreviation_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void instrument_abbreviation(const instrument_abbreviation_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  instrument_abbreviation(::std::unique_ptr<instrument_abbreviation_type> p);

  //@}

  /**
   * @name instrument-sound
   *
   * @brief Accessor and modifier functions for the %instrument-sound
   * optional element.
   *
   * The instrument-sound element describes the default timbre of the
   * score-instrument. This description is independent of a particular
   * virtual or MIDI instrument specification and allows playback to be
   * shared more easily between applications and libraries.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string instrument_sound_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<instrument_sound_type>
    instrument_sound_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<instrument_sound_type, char>
    instrument_sound_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const instrument_sound_optional &instrument_sound() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  instrument_sound_optional &instrument_sound();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void instrument_sound(const instrument_sound_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void instrument_sound(const instrument_sound_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void instrument_sound(::std::unique_ptr<instrument_sound_type> p);

  //@}

  /**
   * @name solo
   *
   * @brief Accessor and modifier functions for the %solo
   * optional element.
   *
   * The solo element was added in Version 2.0. It is present if
   * performance is intended by a solo instrument.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::empty solo_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<solo_type> solo_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<solo_type, char> solo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const solo_optional &solo() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  solo_optional &solo();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void solo(const solo_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void solo(const solo_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void solo(::std::unique_ptr<solo_type> p);

  //@}

  /**
   * @name ensemble
   *
   * @brief Accessor and modifier functions for the %ensemble
   * optional element.
   *
   * The ensemble element was added in Version 2.0. It is present if
   * performance is intended by an ensemble such as an orchestral section.
   * The text of the ensemble element contains the size of the section, or
   * is empty if the ensemble size is not specified.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::positive_integer_or_empty ensemble_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<ensemble_type> ensemble_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<ensemble_type, char> ensemble_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ensemble_optional &ensemble() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  ensemble_optional &ensemble();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void ensemble(const ensemble_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void ensemble(const ensemble_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void ensemble(::std::unique_ptr<ensemble_type> p);

  //@}

  /**
   * @name virtual-instrument
   *
   * @brief Accessor and modifier functions for the %virtual-instrument
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::virtual_instrument virtual_instrument_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<virtual_instrument_type>
    virtual_instrument_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<virtual_instrument_type, char>
    virtual_instrument_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const virtual_instrument_optional &virtual_instrument() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  virtual_instrument_optional &virtual_instrument();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void virtual_instrument(const virtual_instrument_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void virtual_instrument(const virtual_instrument_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void virtual_instrument(::std::unique_ptr<virtual_instrument_type> p);

  //@}

  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::id id_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const id_type &id() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  id_type &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  score_instrument(const instrument_name_type &, const id_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  score_instrument(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  score_instrument(const score_instrument &x, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual score_instrument *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  score_instrument &operator=(const score_instrument &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~score_instrument();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  ::xsd::cxx::tree::one<instrument_name_type> instrument_name_;
  instrument_abbreviation_optional instrument_abbreviation_;
  instrument_sound_optional instrument_sound_;
  solo_optional solo_;
  ensemble_optional ensemble_;
  virtual_instrument_optional virtual_instrument_;
  ::xsd::cxx::tree::one<id_type> id_;

  //@endcond
};

/**
 * @brief Class corresponding to the %score-part schema type.
 *
 * Each MusicXML part corresponds to a track in a Standard MIDI Format 1
 * file. The score-instrument elements are used when there are multiple
 * instruments per track. The midi-device element is used to make a MIDI
 * device or port assignment for the given track or specific MIDI
 * instruments. Initial midi-instrument assignments may be made here as
 * well.
 *
 * @nosubgrouping
 */
class score_part : public ::xml_schema::type {
public:
  /**
   * @name identification
   *
   * @brief Accessor and modifier functions for the %identification
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::identification identification_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<identification_type>
    identification_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<identification_type, char>
    identification_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const identification_optional &identification() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  identification_optional &identification();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void identification(const identification_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void identification(const identification_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void identification(::std::unique_ptr<identification_type> p);

  //@}

  /**
   * @name part-name
   *
   * @brief Accessor and modifier functions for the %part-name
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::part_name part_name_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_name_type, char> part_name_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const part_name_type &part_name() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  part_name_type &part_name();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_name(const part_name_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void part_name(::std::unique_ptr<part_name_type> p);

  //@}

  /**
   * @name part-name-display
   *
   * @brief Accessor and modifier functions for the %part-name-display
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::name_display part_name_display_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<part_name_display_type>
    part_name_display_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_name_display_type, char>
    part_name_display_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const part_name_display_optional &part_name_display() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  part_name_display_optional &part_name_display();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_name_display(const part_name_display_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void part_name_display(const part_name_display_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void part_name_display(::std::unique_ptr<part_name_display_type> p);

  //@}

  /**
   * @name part-abbreviation
   *
   * @brief Accessor and modifier functions for the %part-abbreviation
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::part_name part_abbreviation_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<part_abbreviation_type>
    part_abbreviation_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_abbreviation_type, char>
    part_abbreviation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const part_abbreviation_optional &part_abbreviation() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  part_abbreviation_optional &part_abbreviation();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_abbreviation(const part_abbreviation_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void part_abbreviation(const part_abbreviation_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void part_abbreviation(::std::unique_ptr<part_abbreviation_type> p);

  //@}

  /**
   * @name part-abbreviation-display
   *
   * @brief Accessor and modifier functions for the %part-abbreviation-display
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::name_display part_abbreviation_display_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<part_abbreviation_display_type>
    part_abbreviation_display_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_abbreviation_display_type, char>
    part_abbreviation_display_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const part_abbreviation_display_optional &part_abbreviation_display() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  part_abbreviation_display_optional &part_abbreviation_display();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_abbreviation_display(const part_abbreviation_display_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void part_abbreviation_display(const part_abbreviation_display_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void part_abbreviation_display(
    ::std::unique_ptr<part_abbreviation_display_type> p);

  //@}

  /**
   * @name group
   *
   * @brief Accessor and modifier functions for the %group
   * sequence element.
   *
   * The group element allows the use of different versions of the part for
   * different purposes. Typical values include score, parts, sound, and
   * data. Ordering information that is directly encoded in MuseData can be
   * derived from the ordering within a MusicXML score or opus.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string group_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<group_type> group_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef group_sequence::iterator group_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef group_sequence::const_iterator group_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<group_type, char> group_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const group_sequence &group() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  group_sequence &group();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void group(const group_sequence &s);

  //@}

  /**
   * @name score-instrument
   *
   * @brief Accessor and modifier functions for the %score-instrument
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::score_instrument score_instrument_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<score_instrument_type>
    score_instrument_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef score_instrument_sequence::iterator score_instrument_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef score_instrument_sequence::const_iterator
    score_instrument_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<score_instrument_type, char>
    score_instrument_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const score_instrument_sequence &score_instrument() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  score_instrument_sequence &score_instrument();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void score_instrument(const score_instrument_sequence &s);

  //@}

  /**
   * @name midi-device
   *
   * @brief Accessor and modifier functions for the %midi-device
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::midi_device midi_device_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<midi_device_type> midi_device_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef midi_device_sequence::iterator midi_device_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef midi_device_sequence::const_iterator midi_device_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_device_type, char> midi_device_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const midi_device_sequence &midi_device() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  midi_device_sequence &midi_device();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void midi_device(const midi_device_sequence &s);

  //@}

  /**
   * @name midi-instrument
   *
   * @brief Accessor and modifier functions for the %midi-instrument
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::midi_instrument midi_instrument_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<midi_instrument_type>
    midi_instrument_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef midi_instrument_sequence::iterator midi_instrument_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef midi_instrument_sequence::const_iterator
    midi_instrument_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<midi_instrument_type, char>
    midi_instrument_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const midi_instrument_sequence &midi_instrument() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  midi_instrument_sequence &midi_instrument();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void midi_instrument(const midi_instrument_sequence &s);

  //@}

  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::id id_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const id_type &id() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  id_type &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  score_part(const part_name_type &, const id_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  score_part(::std::unique_ptr<part_name_type>, const id_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  score_part(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  score_part(const score_part &x, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual score_part *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  score_part &operator=(const score_part &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~score_part();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  identification_optional identification_;
  ::xsd::cxx::tree::one<part_name_type> part_name_;
  part_name_display_optional part_name_display_;
  part_abbreviation_optional part_abbreviation_;
  part_abbreviation_display_optional part_abbreviation_display_;
  group_sequence group_;
  score_instrument_sequence score_instrument_;
  midi_device_sequence midi_device_;
  midi_instrument_sequence midi_instrument_;
  ::xsd::cxx::tree::one<id_type> id_;

  //@endcond
};

/**
 * @brief Class corresponding to the %virtual-instrument schema type.
 *
 * The virtual-instrument element defines a specific virtual instrument
 * used for an instrument sound.
 *
 * @nosubgrouping
 */
class virtual_instrument : public ::xml_schema::type {
public:
  /**
   * @name virtual-library
   *
   * @brief Accessor and modifier functions for the %virtual-library
   * optional element.
   *
   * The virtual-library element indicates the virtual instrument library
   * name.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string virtual_library_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<virtual_library_type>
    virtual_library_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<virtual_library_type, char>
    virtual_library_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const virtual_library_optional &virtual_library() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  virtual_library_optional &virtual_library();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void virtual_library(const virtual_library_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void virtual_library(const virtual_library_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void virtual_library(::std::unique_ptr<virtual_library_type> p);

  //@}

  /**
   * @name virtual-name
   *
   * @brief Accessor and modifier functions for the %virtual-name
   * optional element.
   *
   * The virtual-name element indicates the library-specific name for the
   * virtual instrument.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string virtual_name_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<virtual_name_type> virtual_name_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<virtual_name_type, char> virtual_name_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const virtual_name_optional &virtual_name() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  virtual_name_optional &virtual_name();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void virtual_name(const virtual_name_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void virtual_name(const virtual_name_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void virtual_name(::std::unique_ptr<virtual_name_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  virtual_instrument();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  virtual_instrument(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  virtual_instrument(const virtual_instrument &x, ::xml_schema::flags f = 0,
                     ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual virtual_instrument *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  virtual_instrument &operator=(const virtual_instrument &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~virtual_instrument();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  virtual_library_optional virtual_library_;
  virtual_name_optional virtual_name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %work schema type.
 *
 * Works are optionally identified by number and title. The work type
 * also may indicate a link to the opus document that composes multiple
 * scores into a collection.
 *
 * @nosubgrouping
 */
class work : public ::xml_schema::type {
public:
  /**
   * @name work-number
   *
   * @brief Accessor and modifier functions for the %work-number
   * optional element.
   *
   * The work-number element specifies the number of a work, such as its
   * opus number.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string work_number_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<work_number_type> work_number_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<work_number_type, char> work_number_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const work_number_optional &work_number() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  work_number_optional &work_number();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void work_number(const work_number_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void work_number(const work_number_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void work_number(::std::unique_ptr<work_number_type> p);

  //@}

  /**
   * @name work-title
   *
   * @brief Accessor and modifier functions for the %work-title
   * optional element.
   *
   * The work-title element specifies the title of a work, not including
   * its opus or other work number.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string work_title_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<work_title_type> work_title_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<work_title_type, char> work_title_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const work_title_optional &work_title() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  work_title_optional &work_title();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void work_title(const work_title_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void work_title(const work_title_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void work_title(::std::unique_ptr<work_title_type> p);

  //@}

  /**
   * @name opus
   *
   * @brief Accessor and modifier functions for the %opus
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::opus opus_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<opus_type> opus_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<opus_type, char> opus_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const opus_optional &opus() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  opus_optional &opus();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void opus(const opus_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void opus(const opus_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void opus(::std::unique_ptr<opus_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  work();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  work(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  work(const work &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual work *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  work &operator=(const work &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~work();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  work_number_optional work_number_;
  work_title_optional work_title_;
  opus_optional opus_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %number-or-normal_member
 * schema type.
 */
class number_or_normal_member : public ::xml_schema::token {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { normal };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  number_or_normal_member(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  number_or_normal_member(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  number_or_normal_member(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  number_or_normal_member(const ::xml_schema::token &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_or_normal_member(const ::xercesc::DOMElement &e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_or_normal_member(const ::xercesc::DOMAttr &a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  number_or_normal_member(const ::std::string &s,
                          const ::xercesc::DOMElement *e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  number_or_normal_member(const number_or_normal_member &x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual number_or_normal_member *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  number_or_normal_member &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const {
    return _xsd_number_or_normal_member_convert();
  }

  //@cond

protected:
  value _xsd_number_or_normal_member_convert() const;

public:
  static const char *const _xsd_number_or_normal_member_literals_[1];
  static const value _xsd_number_or_normal_member_indexes_[1];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the
 * %positive-integer-or-empty_member
 * schema type.
 */
class positive_integer_or_empty_member : public ::xml_schema::string {
public:
  /**
   * @brief Underlying enum type.
   */
  enum value { empty };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  positive_integer_or_empty_member(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  positive_integer_or_empty_member(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  positive_integer_or_empty_member(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  positive_integer_or_empty_member(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_integer_or_empty_member(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_integer_or_empty_member(const ::xercesc::DOMAttr &a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  positive_integer_or_empty_member(const ::std::string &s,
                                   const ::xercesc::DOMElement *e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  positive_integer_or_empty_member(const positive_integer_or_empty_member &x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual positive_integer_or_empty_member *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  positive_integer_or_empty_member &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const {
    return _xsd_positive_integer_or_empty_member_convert();
  }

  //@cond

protected:
  value _xsd_positive_integer_or_empty_member_convert() const;

public:
  static const char *const _xsd_positive_integer_or_empty_member_literals_[1];
  static const value _xsd_positive_integer_or_empty_member_indexes_[1];

  //@endcond
};

/**
 * @brief Class corresponding to the %directive schema type.
 *
 * @nosubgrouping
 */
class directive : public ::xml_schema::string {
public:
  /**
   * @name default-x
   *
   * @brief Accessor and modifier functions for the %default-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_x_type> default_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_x_type, char> default_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_x_optional &default_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_x_optional &default_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_x(const default_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_x(const default_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_x(::std::unique_ptr<default_x_type> p);

  //@}

  /**
   * @name default-y
   *
   * @brief Accessor and modifier functions for the %default-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths default_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<default_y_type> default_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<default_y_type, char> default_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_y_optional &default_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_y_optional &default_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void default_y(const default_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void default_y(const default_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void default_y(::std::unique_ptr<default_y_type> p);

  //@}

  /**
   * @name relative-x
   *
   * @brief Accessor and modifier functions for the %relative-x
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_x_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_x_type> relative_x_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_x_type, char> relative_x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_x_optional &relative_x() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_x_optional &relative_x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_x(const relative_x_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_x(const relative_x_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_x(::std::unique_ptr<relative_x_type> p);

  //@}

  /**
   * @name relative-y
   *
   * @brief Accessor and modifier functions for the %relative-y
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths relative_y_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<relative_y_type> relative_y_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<relative_y_type, char> relative_y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const relative_y_optional &relative_y() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  relative_y_optional &relative_y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void relative_y(const relative_y_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void relative_y(const relative_y_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void relative_y(::std::unique_ptr<relative_y_type> p);

  //@}

  /**
   * @name font-family
   *
   * @brief Accessor and modifier functions for the %font-family
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::comma_separated_text font_family_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_family_type> font_family_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_family_type, char> font_family_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_family_optional &font_family() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_family_optional &font_family();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_family(const font_family_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_family(const font_family_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_family(::std::unique_ptr<font_family_type> p);

  //@}

  /**
   * @name font-style
   *
   * @brief Accessor and modifier functions for the %font-style
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_style font_style_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_style_type> font_style_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_style_type, char> font_style_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_style_optional &font_style() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_style_optional &font_style();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_style(const font_style_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_style(const font_style_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_style(::std::unique_ptr<font_style_type> p);

  //@}

  /**
   * @name font-size
   *
   * @brief Accessor and modifier functions for the %font-size
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_size font_size_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_size_type> font_size_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_size_type, char> font_size_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_size_optional &font_size() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_size_optional &font_size();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_size(const font_size_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_size(const font_size_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_size(::std::unique_ptr<font_size_type> p);

  //@}

  /**
   * @name font-weight
   *
   * @brief Accessor and modifier functions for the %font-weight
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::font_weight font_weight_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<font_weight_type> font_weight_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<font_weight_type, char> font_weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const font_weight_optional &font_weight() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  font_weight_optional &font_weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void font_weight(const font_weight_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void font_weight(const font_weight_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void font_weight(::std::unique_ptr<font_weight_type> p);

  //@}

  /**
   * @name color
   *
   * @brief Accessor and modifier functions for the %color
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::color color_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<color_type> color_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<color_type, char> color_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const color_optional &color() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  color_optional &color();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void color(const color_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void color(const color_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void color(::std::unique_ptr<color_type> p);

  //@}

  /**
   * @name lang
   *
   * @brief Accessor and modifier functions for the %lang
   * optional attribute.
   *
   * Attempting to install the relevant ISO 2- and 3-letter
   * codes as the enumerated possible values is probably never
   * going to be a realistic possibility.  See
   * RFC 3066 at http://www.ietf.org/rfc/rfc3066.txt and the IANA registry
   * at http://www.iana.org/assignments/lang-tag-apps.htm for
   * further information.
   *
   * The union allows for the 'un-declaration' of xml:lang with
   * the empty string.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::namespace_::lang lang_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<lang_type> lang_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<lang_type, char> lang_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const lang_optional &lang() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  lang_optional &lang();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void lang(const lang_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void lang(const lang_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void lang(::std::unique_ptr<lang_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  directive();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  directive(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  directive(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  directive(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  directive(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  directive(const directive &x, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual directive *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  directive &operator=(const directive &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~directive();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  default_x_optional default_x_;
  default_y_optional default_y_;
  relative_x_optional relative_x_;
  relative_y_optional relative_y_;
  font_family_optional font_family_;
  font_style_optional font_style_;
  font_size_optional font_size_;
  font_weight_optional font_weight_;
  color_optional color_;
  lang_optional lang_;

  //@endcond
};

/**
 * @brief Class corresponding to the %score-partwise schema type.
 *
 * @nosubgrouping
 */
class score_partwise : public ::xml_schema::type {
public:
  /**
   * @name work
   *
   * @brief Accessor and modifier functions for the %work
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::work work_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<work_type> work_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<work_type, char> work_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const work_optional &work() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  work_optional &work();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void work(const work_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void work(const work_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void work(::std::unique_ptr<work_type> p);

  //@}

  /**
   * @name movement-number
   *
   * @brief Accessor and modifier functions for the %movement-number
   * optional element.
   *
   * The movement-number element specifies the number of a movement.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string movement_number_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<movement_number_type>
    movement_number_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<movement_number_type, char>
    movement_number_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const movement_number_optional &movement_number() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  movement_number_optional &movement_number();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void movement_number(const movement_number_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void movement_number(const movement_number_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void movement_number(::std::unique_ptr<movement_number_type> p);

  //@}

  /**
   * @name movement-title
   *
   * @brief Accessor and modifier functions for the %movement-title
   * optional element.
   *
   * The movement-title element specifies the title of a movement, not
   * including its number.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string movement_title_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<movement_title_type>
    movement_title_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<movement_title_type, char>
    movement_title_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const movement_title_optional &movement_title() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  movement_title_optional &movement_title();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void movement_title(const movement_title_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void movement_title(const movement_title_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void movement_title(::std::unique_ptr<movement_title_type> p);

  //@}

  /**
   * @name identification
   *
   * @brief Accessor and modifier functions for the %identification
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::identification identification_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<identification_type>
    identification_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<identification_type, char>
    identification_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const identification_optional &identification() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  identification_optional &identification();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void identification(const identification_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void identification(const identification_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void identification(::std::unique_ptr<identification_type> p);

  //@}

  /**
   * @name defaults
   *
   * @brief Accessor and modifier functions for the %defaults
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::defaults defaults_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<defaults_type> defaults_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<defaults_type, char> defaults_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const defaults_optional &defaults() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  defaults_optional &defaults();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void defaults(const defaults_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void defaults(const defaults_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void defaults(::std::unique_ptr<defaults_type> p);

  //@}

  /**
   * @name credit
   *
   * @brief Accessor and modifier functions for the %credit
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::credit credit_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<credit_type> credit_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef credit_sequence::iterator credit_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef credit_sequence::const_iterator credit_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<credit_type, char> credit_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const credit_sequence &credit() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  credit_sequence &credit();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void credit(const credit_sequence &s);

  //@}

  /**
   * @name part-list
   *
   * @brief Accessor and modifier functions for the %part-list
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::part_list part_list_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_list_type, char> part_list_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const part_list_type &part_list() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  part_list_type &part_list();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_list(const part_list_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void part_list(::std::unique_ptr<part_list_type> p);

  //@}

  /**
   * @name part
   *
   * @brief Accessor and modifier functions for the %part
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::part part_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<part_type> part_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef part_sequence::iterator part_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef part_sequence::const_iterator part_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_type, char> part_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const part_sequence &part() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  part_sequence &part();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void part(const part_sequence &s);

  //@}

  /**
   * @name version
   *
   * @brief Accessor and modifier functions for the %version
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token version_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<version_type, char> version_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const version_type &version() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  version_type &version();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void version(const version_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void version(::std::unique_ptr<version_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const version_type &version_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  score_partwise(const part_list_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  score_partwise(::std::unique_ptr<part_list_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  score_partwise(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  score_partwise(const score_partwise &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual score_partwise *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  score_partwise &operator=(const score_partwise &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~score_partwise();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  work_optional work_;
  movement_number_optional movement_number_;
  movement_title_optional movement_title_;
  identification_optional identification_;
  defaults_optional defaults_;
  credit_sequence credit_;
  ::xsd::cxx::tree::one<part_list_type> part_list_;
  part_sequence part_;
  ::xsd::cxx::tree::one<version_type> version_;
  static const version_type version_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %score-timewise schema type.
 *
 * @nosubgrouping
 */
class score_timewise : public ::xml_schema::type {
public:
  /**
   * @name work
   *
   * @brief Accessor and modifier functions for the %work
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::work work_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<work_type> work_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<work_type, char> work_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const work_optional &work() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  work_optional &work();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void work(const work_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void work(const work_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void work(::std::unique_ptr<work_type> p);

  //@}

  /**
   * @name movement-number
   *
   * @brief Accessor and modifier functions for the %movement-number
   * optional element.
   *
   * The movement-number element specifies the number of a movement.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string movement_number_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<movement_number_type>
    movement_number_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<movement_number_type, char>
    movement_number_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const movement_number_optional &movement_number() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  movement_number_optional &movement_number();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void movement_number(const movement_number_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void movement_number(const movement_number_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void movement_number(::std::unique_ptr<movement_number_type> p);

  //@}

  /**
   * @name movement-title
   *
   * @brief Accessor and modifier functions for the %movement-title
   * optional element.
   *
   * The movement-title element specifies the title of a movement, not
   * including its number.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string movement_title_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<movement_title_type>
    movement_title_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<movement_title_type, char>
    movement_title_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const movement_title_optional &movement_title() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  movement_title_optional &movement_title();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void movement_title(const movement_title_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void movement_title(const movement_title_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void movement_title(::std::unique_ptr<movement_title_type> p);

  //@}

  /**
   * @name identification
   *
   * @brief Accessor and modifier functions for the %identification
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::identification identification_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<identification_type>
    identification_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<identification_type, char>
    identification_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const identification_optional &identification() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  identification_optional &identification();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void identification(const identification_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void identification(const identification_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void identification(::std::unique_ptr<identification_type> p);

  //@}

  /**
   * @name defaults
   *
   * @brief Accessor and modifier functions for the %defaults
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::defaults defaults_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<defaults_type> defaults_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<defaults_type, char> defaults_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const defaults_optional &defaults() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  defaults_optional &defaults();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void defaults(const defaults_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void defaults(const defaults_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void defaults(::std::unique_ptr<defaults_type> p);

  //@}

  /**
   * @name credit
   *
   * @brief Accessor and modifier functions for the %credit
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::credit credit_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<credit_type> credit_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef credit_sequence::iterator credit_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef credit_sequence::const_iterator credit_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<credit_type, char> credit_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const credit_sequence &credit() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  credit_sequence &credit();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void credit(const credit_sequence &s);

  //@}

  /**
   * @name part-list
   *
   * @brief Accessor and modifier functions for the %part-list
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::part_list part_list_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_list_type, char> part_list_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const part_list_type &part_list() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  part_list_type &part_list();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void part_list(const part_list_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void part_list(::std::unique_ptr<part_list_type> p);

  //@}

  /**
   * @name measure
   *
   * @brief Accessor and modifier functions for the %measure
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::measure measure_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<measure_type> measure_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef measure_sequence::iterator measure_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef measure_sequence::const_iterator measure_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<measure_type, char> measure_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const measure_sequence &measure() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  measure_sequence &measure();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void measure(const measure_sequence &s);

  //@}

  /**
   * @name version
   *
   * @brief Accessor and modifier functions for the %version
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token version_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<version_type, char> version_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const version_type &version() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  version_type &version();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void version(const version_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void version(::std::unique_ptr<version_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const version_type &version_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  score_timewise(const part_list_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  score_timewise(::std::unique_ptr<part_list_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  score_timewise(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  score_timewise(const score_timewise &x, ::xml_schema::flags f = 0,
                 ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual score_timewise *
  _clone(::xml_schema::flags f = 0,
         ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  score_timewise &operator=(const score_timewise &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~score_timewise();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  work_optional work_;
  movement_number_optional movement_number_;
  movement_title_optional movement_title_;
  identification_optional identification_;
  defaults_optional defaults_;
  credit_sequence credit_;
  ::xsd::cxx::tree::one<part_list_type> part_list_;
  measure_sequence measure_;
  ::xsd::cxx::tree::one<version_type> version_;
  static const version_type version_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %part schema type.
 *
 * @nosubgrouping
 */
class part : public ::xml_schema::type {
public:
  /**
   * @name measure
   *
   * @brief Accessor and modifier functions for the %measure
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::measure1 measure_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<measure_type> measure_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef measure_sequence::iterator measure_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef measure_sequence::const_iterator measure_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<measure_type, char> measure_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const measure_sequence &measure() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  measure_sequence &measure();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void measure(const measure_sequence &s);

  //@}

  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::idref id_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const id_type &id() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  id_type &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  part(const id_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  part(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part(const part &x, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual part *_clone(::xml_schema::flags f = 0,
                       ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part &operator=(const part &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~part();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  measure_sequence measure_;
  ::xsd::cxx::tree::one<id_type> id_;

  //@endcond
};

/**
 * @brief Class corresponding to the %measure schema type.
 *
 * @nosubgrouping
 */
class measure : public ::xml_schema::type {
public:
  /**
   * @name part
   *
   * @brief Accessor and modifier functions for the %part
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::part1 part_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<part_type> part_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef part_sequence::iterator part_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef part_sequence::const_iterator part_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<part_type, char> part_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const part_sequence &part() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  part_sequence &part();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void part(const part_sequence &s);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name implicit
   *
   * @brief Accessor and modifier functions for the %implicit
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no implicit_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<implicit_type> implicit_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<implicit_type, char> implicit_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const implicit_optional &implicit() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  implicit_optional &implicit();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void implicit(const implicit_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void implicit(const implicit_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void implicit(::std::unique_ptr<implicit_type> p);

  //@}

  /**
   * @name non-controlling
   *
   * @brief Accessor and modifier functions for the %non-controlling
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no non_controlling_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<non_controlling_type>
    non_controlling_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<non_controlling_type, char>
    non_controlling_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const non_controlling_optional &non_controlling() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  non_controlling_optional &non_controlling();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void non_controlling(const non_controlling_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void non_controlling(const non_controlling_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void non_controlling(::std::unique_ptr<non_controlling_type> p);

  //@}

  /**
   * @name width
   *
   * @brief Accessor and modifier functions for the %width
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths width_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<width_type> width_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<width_type, char> width_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const width_optional &width() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  width_optional &width();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void width(const width_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void width(const width_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void width(::std::unique_ptr<width_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  measure(const number_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure(const measure &x, ::xml_schema::flags f = 0,
          ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual measure *_clone(::xml_schema::flags f = 0,
                          ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure &operator=(const measure &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~measure();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  part_sequence part_;
  ::xsd::cxx::tree::one<number_type> number_;
  implicit_optional implicit_;
  non_controlling_optional non_controlling_;
  width_optional width_;

  //@endcond
};

/**
 * @brief Class corresponding to the %measure1 schema type.
 *
 * @nosubgrouping
 */
class measure1 : public ::xml_schema::type {
public:
  /**
   * @name note
   *
   * @brief Accessor and modifier functions for the %note
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note note_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<note_type> note_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef note_sequence::iterator note_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef note_sequence::const_iterator note_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<note_type, char> note_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t note_id = 1UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const note_sequence &note() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  note_sequence &note();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void note(const note_sequence &s);

  //@}

  /**
   * @name backup
   *
   * @brief Accessor and modifier functions for the %backup
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::backup backup_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<backup_type> backup_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef backup_sequence::iterator backup_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef backup_sequence::const_iterator backup_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<backup_type, char> backup_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t backup_id = 2UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const backup_sequence &backup() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  backup_sequence &backup();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void backup(const backup_sequence &s);

  //@}

  /**
   * @name forward
   *
   * @brief Accessor and modifier functions for the %forward
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::forward forward_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<forward_type> forward_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef forward_sequence::iterator forward_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef forward_sequence::const_iterator forward_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<forward_type, char> forward_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t forward_id = 3UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const forward_sequence &forward() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  forward_sequence &forward();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void forward(const forward_sequence &s);

  //@}

  /**
   * @name direction
   *
   * @brief Accessor and modifier functions for the %direction
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::direction direction_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<direction_type> direction_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef direction_sequence::iterator direction_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef direction_sequence::const_iterator direction_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<direction_type, char> direction_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t direction_id = 4UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const direction_sequence &direction() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  direction_sequence &direction();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void direction(const direction_sequence &s);

  //@}

  /**
   * @name attributes
   *
   * @brief Accessor and modifier functions for the %attributes
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::attributes attributes_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<attributes_type> attributes_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef attributes_sequence::iterator attributes_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef attributes_sequence::const_iterator attributes_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<attributes_type, char> attributes_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t attributes_id = 5UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const attributes_sequence &attributes() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  attributes_sequence &attributes();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void attributes(const attributes_sequence &s);

  //@}

  /**
   * @name harmony
   *
   * @brief Accessor and modifier functions for the %harmony
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::harmony harmony_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<harmony_type> harmony_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef harmony_sequence::iterator harmony_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef harmony_sequence::const_iterator harmony_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<harmony_type, char> harmony_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t harmony_id = 6UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const harmony_sequence &harmony() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  harmony_sequence &harmony();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void harmony(const harmony_sequence &s);

  //@}

  /**
   * @name figured-bass
   *
   * @brief Accessor and modifier functions for the %figured-bass
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::figured_bass figured_bass_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<figured_bass_type> figured_bass_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef figured_bass_sequence::iterator figured_bass_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef figured_bass_sequence::const_iterator figured_bass_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<figured_bass_type, char> figured_bass_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t figured_bass_id = 7UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const figured_bass_sequence &figured_bass() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  figured_bass_sequence &figured_bass();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void figured_bass(const figured_bass_sequence &s);

  //@}

  /**
   * @name print
   *
   * @brief Accessor and modifier functions for the %print
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::print print_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<print_type> print_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef print_sequence::iterator print_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef print_sequence::const_iterator print_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_type, char> print_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t print_id = 8UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const print_sequence &print() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  print_sequence &print();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void print(const print_sequence &s);

  //@}

  /**
   * @name sound
   *
   * @brief Accessor and modifier functions for the %sound
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::sound sound_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<sound_type> sound_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sound_sequence::iterator sound_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sound_sequence::const_iterator sound_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sound_type, char> sound_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t sound_id = 9UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sound_sequence &sound() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sound_sequence &sound();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void sound(const sound_sequence &s);

  //@}

  /**
   * @name barline
   *
   * @brief Accessor and modifier functions for the %barline
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::barline barline_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<barline_type> barline_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef barline_sequence::iterator barline_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef barline_sequence::const_iterator barline_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<barline_type, char> barline_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t barline_id = 10UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const barline_sequence &barline() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  barline_sequence &barline();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void barline(const barline_sequence &s);

  //@}

  /**
   * @name grouping
   *
   * @brief Accessor and modifier functions for the %grouping
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::grouping grouping_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<grouping_type> grouping_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef grouping_sequence::iterator grouping_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef grouping_sequence::const_iterator grouping_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<grouping_type, char> grouping_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t grouping_id = 11UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const grouping_sequence &grouping() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  grouping_sequence &grouping();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void grouping(const grouping_sequence &s);

  //@}

  /**
   * @name link
   *
   * @brief Accessor and modifier functions for the %link
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::link link_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<link_type> link_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef link_sequence::iterator link_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef link_sequence::const_iterator link_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<link_type, char> link_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t link_id = 12UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const link_sequence &link() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  link_sequence &link();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void link(const link_sequence &s);

  //@}

  /**
   * @name bookmark
   *
   * @brief Accessor and modifier functions for the %bookmark
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bookmark bookmark_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<bookmark_type> bookmark_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef bookmark_sequence::iterator bookmark_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef bookmark_sequence::const_iterator bookmark_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bookmark_type, char> bookmark_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t bookmark_id = 13UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const bookmark_sequence &bookmark() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  bookmark_sequence &bookmark();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void bookmark(const bookmark_sequence &s);

  //@}

  /**
   * @name number
   *
   * @brief Accessor and modifier functions for the %number
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::token number_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<number_type, char> number_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const number_type &number() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  number_type &number();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void number(const number_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void number(::std::unique_ptr<number_type> p);

  //@}

  /**
   * @name implicit
   *
   * @brief Accessor and modifier functions for the %implicit
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no implicit_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<implicit_type> implicit_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<implicit_type, char> implicit_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const implicit_optional &implicit() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  implicit_optional &implicit();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void implicit(const implicit_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void implicit(const implicit_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void implicit(::std::unique_ptr<implicit_type> p);

  //@}

  /**
   * @name non-controlling
   *
   * @brief Accessor and modifier functions for the %non-controlling
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::yes_no non_controlling_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<non_controlling_type>
    non_controlling_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<non_controlling_type, char>
    non_controlling_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const non_controlling_optional &non_controlling() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  non_controlling_optional &non_controlling();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void non_controlling(const non_controlling_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void non_controlling(const non_controlling_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void non_controlling(::std::unique_ptr<non_controlling_type> p);

  //@}

  /**
   * @name width
   *
   * @brief Accessor and modifier functions for the %width
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::musicxml::tenths width_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<width_type> width_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<width_type, char> width_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const width_optional &width() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  width_optional &width();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void width(const width_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void width(const width_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void width(::std::unique_ptr<width_type> p);

  //@}

  /**
   * @name content_order
   *
   * @brief Accessor and modifier functions for content order.
   */
  //@{

  /**
   * @brief Content order entry type.
   */
  typedef ::xml_schema::content_order content_order_type;

  /**
   * @brief Content order sequence container type.
   */
  typedef ::std::vector<content_order_type> content_order_sequence;

  /**
   * @brief Content order iterator type.
   */
  typedef content_order_sequence::iterator content_order_iterator;

  /**
   * @brief Content order constant iterator type.
   */
  typedef content_order_sequence::const_iterator content_order_const_iterator;

  /**
   * @brief Return a read-only (constant) reference to the content
   * order sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const content_order_sequence &content_order() const;

  /**
   * @brief Return a read-write reference to the content order
   * sequence.
   *
   * @return A reference to the sequence container.
   */
  content_order_sequence &content_order();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy entries from.
   *
   * For each element in @a s this function add it to the sequence.
   * Note that this operation completely changes the sequence and
   * all old elements will be lost.
   */
  void content_order(const content_order_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  measure1(const number_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  measure1(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure1(const measure1 &x, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual measure1 *_clone(::xml_schema::flags f = 0,
                           ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  measure1 &operator=(const measure1 &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~measure1();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  content_order_sequence content_order_;

  note_sequence note_;
  backup_sequence backup_;
  forward_sequence forward_;
  direction_sequence direction_;
  attributes_sequence attributes_;
  harmony_sequence harmony_;
  figured_bass_sequence figured_bass_;
  print_sequence print_;
  sound_sequence sound_;
  barline_sequence barline_;
  grouping_sequence grouping_;
  link_sequence link_;
  bookmark_sequence bookmark_;
  ::xsd::cxx::tree::one<number_type> number_;
  implicit_optional implicit_;
  non_controlling_optional non_controlling_;
  width_optional width_;

  //@endcond
};

/**
 * @brief Class corresponding to the %part1 schema type.
 *
 * @nosubgrouping
 */
class part1 : public ::xml_schema::type {
public:
  /**
   * @name note
   *
   * @brief Accessor and modifier functions for the %note
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::note note_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<note_type> note_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef note_sequence::iterator note_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef note_sequence::const_iterator note_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<note_type, char> note_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t note_id = 1UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const note_sequence &note() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  note_sequence &note();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void note(const note_sequence &s);

  //@}

  /**
   * @name backup
   *
   * @brief Accessor and modifier functions for the %backup
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::backup backup_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<backup_type> backup_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef backup_sequence::iterator backup_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef backup_sequence::const_iterator backup_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<backup_type, char> backup_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t backup_id = 2UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const backup_sequence &backup() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  backup_sequence &backup();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void backup(const backup_sequence &s);

  //@}

  /**
   * @name forward
   *
   * @brief Accessor and modifier functions for the %forward
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::forward forward_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<forward_type> forward_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef forward_sequence::iterator forward_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef forward_sequence::const_iterator forward_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<forward_type, char> forward_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t forward_id = 3UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const forward_sequence &forward() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  forward_sequence &forward();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void forward(const forward_sequence &s);

  //@}

  /**
   * @name direction
   *
   * @brief Accessor and modifier functions for the %direction
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::direction direction_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<direction_type> direction_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef direction_sequence::iterator direction_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef direction_sequence::const_iterator direction_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<direction_type, char> direction_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t direction_id = 4UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const direction_sequence &direction() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  direction_sequence &direction();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void direction(const direction_sequence &s);

  //@}

  /**
   * @name attributes
   *
   * @brief Accessor and modifier functions for the %attributes
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::attributes attributes_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<attributes_type> attributes_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef attributes_sequence::iterator attributes_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef attributes_sequence::const_iterator attributes_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<attributes_type, char> attributes_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t attributes_id = 5UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const attributes_sequence &attributes() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  attributes_sequence &attributes();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void attributes(const attributes_sequence &s);

  //@}

  /**
   * @name harmony
   *
   * @brief Accessor and modifier functions for the %harmony
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::harmony harmony_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<harmony_type> harmony_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef harmony_sequence::iterator harmony_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef harmony_sequence::const_iterator harmony_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<harmony_type, char> harmony_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t harmony_id = 6UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const harmony_sequence &harmony() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  harmony_sequence &harmony();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void harmony(const harmony_sequence &s);

  //@}

  /**
   * @name figured-bass
   *
   * @brief Accessor and modifier functions for the %figured-bass
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::figured_bass figured_bass_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<figured_bass_type> figured_bass_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef figured_bass_sequence::iterator figured_bass_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef figured_bass_sequence::const_iterator figured_bass_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<figured_bass_type, char> figured_bass_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t figured_bass_id = 7UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const figured_bass_sequence &figured_bass() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  figured_bass_sequence &figured_bass();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void figured_bass(const figured_bass_sequence &s);

  //@}

  /**
   * @name print
   *
   * @brief Accessor and modifier functions for the %print
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::print print_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<print_type> print_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef print_sequence::iterator print_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef print_sequence::const_iterator print_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<print_type, char> print_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t print_id = 8UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const print_sequence &print() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  print_sequence &print();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void print(const print_sequence &s);

  //@}

  /**
   * @name sound
   *
   * @brief Accessor and modifier functions for the %sound
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::sound sound_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<sound_type> sound_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sound_sequence::iterator sound_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sound_sequence::const_iterator sound_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sound_type, char> sound_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t sound_id = 9UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sound_sequence &sound() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sound_sequence &sound();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void sound(const sound_sequence &s);

  //@}

  /**
   * @name barline
   *
   * @brief Accessor and modifier functions for the %barline
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::barline barline_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<barline_type> barline_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef barline_sequence::iterator barline_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef barline_sequence::const_iterator barline_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<barline_type, char> barline_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t barline_id = 10UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const barline_sequence &barline() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  barline_sequence &barline();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void barline(const barline_sequence &s);

  //@}

  /**
   * @name grouping
   *
   * @brief Accessor and modifier functions for the %grouping
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::grouping grouping_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<grouping_type> grouping_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef grouping_sequence::iterator grouping_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef grouping_sequence::const_iterator grouping_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<grouping_type, char> grouping_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t grouping_id = 11UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const grouping_sequence &grouping() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  grouping_sequence &grouping();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void grouping(const grouping_sequence &s);

  //@}

  /**
   * @name link
   *
   * @brief Accessor and modifier functions for the %link
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::link link_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<link_type> link_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef link_sequence::iterator link_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef link_sequence::const_iterator link_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<link_type, char> link_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t link_id = 12UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const link_sequence &link() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  link_sequence &link();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void link(const link_sequence &s);

  //@}

  /**
   * @name bookmark
   *
   * @brief Accessor and modifier functions for the %bookmark
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::musicxml::bookmark bookmark_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<bookmark_type> bookmark_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef bookmark_sequence::iterator bookmark_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef bookmark_sequence::const_iterator bookmark_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<bookmark_type, char> bookmark_traits;

  /**
   * @brief Element id used for capturing content order.
   */
  static const ::std::size_t bookmark_id = 13UL;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const bookmark_sequence &bookmark() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  bookmark_sequence &bookmark();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void bookmark(const bookmark_sequence &s);

  //@}

  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::idref id_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<id_type, char> id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const id_type &id() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  id_type &id();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void id(const id_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void id(::std::unique_ptr<id_type> p);

  //@}

  /**
   * @name content_order
   *
   * @brief Accessor and modifier functions for content order.
   */
  //@{

  /**
   * @brief Content order entry type.
   */
  typedef ::xml_schema::content_order content_order_type;

  /**
   * @brief Content order sequence container type.
   */
  typedef ::std::vector<content_order_type> content_order_sequence;

  /**
   * @brief Content order iterator type.
   */
  typedef content_order_sequence::iterator content_order_iterator;

  /**
   * @brief Content order constant iterator type.
   */
  typedef content_order_sequence::const_iterator content_order_const_iterator;

  /**
   * @brief Return a read-only (constant) reference to the content
   * order sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const content_order_sequence &content_order() const;

  /**
   * @brief Return a read-write reference to the content order
   * sequence.
   *
   * @return A reference to the sequence container.
   */
  content_order_sequence &content_order();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy entries from.
   *
   * For each element in @a s this function add it to the sequence.
   * Note that this operation completely changes the sequence and
   * all old elements will be lost.
   */
  void content_order(const content_order_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  part1(const id_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  part1(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part1(const part1 &x, ::xml_schema::flags f = 0,
        ::xml_schema::container *c = nullptr);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual part1 *_clone(::xml_schema::flags f = 0,
                        ::xml_schema::container *c = nullptr) const override;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  part1 &operator=(const part1 &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~part1();

  // Implementation.
  //

  //@cond

protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

protected:
  content_order_sequence content_order_;

  note_sequence note_;
  backup_sequence backup_;
  forward_sequence forward_;
  direction_sequence direction_;
  attributes_sequence attributes_;
  harmony_sequence harmony_;
  figured_bass_sequence figured_bass_;
  print_sequence print_;
  sound_sequence sound_;
  barline_sequence barline_;
  grouping_sequence grouping_;
  link_sequence link_;
  bookmark_sequence bookmark_;
  ::xsd::cxx::tree::one<id_type> id_;

  //@endcond
};
}

#include <iosfwd>

namespace musicxml {
::std::ostream &operator<<(::std::ostream &, above_below::value);

::std::ostream &operator<<(::std::ostream &, const above_below &);

::std::ostream &operator<<(::std::ostream &, const beam_level &);

::std::ostream &operator<<(::std::ostream &, const color &);

::std::ostream &operator<<(::std::ostream &, const comma_separated_text &);

::std::ostream &operator<<(::std::ostream &, css_font_size::value);

::std::ostream &operator<<(::std::ostream &, const css_font_size &);

::std::ostream &operator<<(::std::ostream &, const divisions &);

::std::ostream &operator<<(::std::ostream &, enclosure_shape::value);

::std::ostream &operator<<(::std::ostream &, const enclosure_shape &);

::std::ostream &operator<<(::std::ostream &, fermata_shape::value);

::std::ostream &operator<<(::std::ostream &, const fermata_shape &);

::std::ostream &operator<<(::std::ostream &, const font_size &);

::std::ostream &operator<<(::std::ostream &, font_style::value);

::std::ostream &operator<<(::std::ostream &, const font_style &);

::std::ostream &operator<<(::std::ostream &, font_weight::value);

::std::ostream &operator<<(::std::ostream &, const font_weight &);

::std::ostream &operator<<(::std::ostream &, left_center_right::value);

::std::ostream &operator<<(::std::ostream &, const left_center_right &);

::std::ostream &operator<<(::std::ostream &, left_right::value);

::std::ostream &operator<<(::std::ostream &, const left_right &);

::std::ostream &operator<<(::std::ostream &, line_shape::value);

::std::ostream &operator<<(::std::ostream &, const line_shape &);

::std::ostream &operator<<(::std::ostream &, line_type::value);

::std::ostream &operator<<(::std::ostream &, const line_type &);

::std::ostream &operator<<(::std::ostream &, const midi_16 &);

::std::ostream &operator<<(::std::ostream &, const midi_128 &);

::std::ostream &operator<<(::std::ostream &, const midi_16384 &);

::std::ostream &operator<<(::std::ostream &, mute::value);

::std::ostream &operator<<(::std::ostream &, const mute &);

::std::ostream &operator<<(::std::ostream &, const non_negative_decimal &);

::std::ostream &operator<<(::std::ostream &, const number_level &);

::std::ostream &operator<<(::std::ostream &, const number_of_lines &);

::std::ostream &operator<<(::std::ostream &, const number_or_normal &);

::std::ostream &operator<<(::std::ostream &, over_under::value);

::std::ostream &operator<<(::std::ostream &, const over_under &);

::std::ostream &operator<<(::std::ostream &, const percent &);

::std::ostream &operator<<(::std::ostream &, const positive_decimal &);

::std::ostream &operator<<(::std::ostream &, const positive_divisions &);

::std::ostream &operator<<(::std::ostream &, const positive_integer_or_empty &);

::std::ostream &operator<<(::std::ostream &, const rotation_degrees &);

::std::ostream &operator<<(::std::ostream &, semi_pitched::value);

::std::ostream &operator<<(::std::ostream &, const semi_pitched &);

::std::ostream &operator<<(::std::ostream &, start_note::value);

::std::ostream &operator<<(::std::ostream &, const start_note &);

::std::ostream &operator<<(::std::ostream &, start_stop::value);

::std::ostream &operator<<(::std::ostream &, const start_stop &);

::std::ostream &operator<<(::std::ostream &, start_stop_continue::value);

::std::ostream &operator<<(::std::ostream &, const start_stop_continue &);

::std::ostream &operator<<(::std::ostream &, start_stop_single::value);

::std::ostream &operator<<(::std::ostream &, const start_stop_single &);

::std::ostream &operator<<(::std::ostream &, const string_number &);

::std::ostream &operator<<(::std::ostream &, symbol_size::value);

::std::ostream &operator<<(::std::ostream &, const symbol_size &);

::std::ostream &operator<<(::std::ostream &, const tenths &);

::std::ostream &operator<<(::std::ostream &, text_direction::value);

::std::ostream &operator<<(::std::ostream &, const text_direction &);

::std::ostream &operator<<(::std::ostream &, const time_only &);

::std::ostream &operator<<(::std::ostream &, top_bottom::value);

::std::ostream &operator<<(::std::ostream &, const top_bottom &);

::std::ostream &operator<<(::std::ostream &, const trill_beats &);

::std::ostream &operator<<(::std::ostream &, trill_step::value);

::std::ostream &operator<<(::std::ostream &, const trill_step &);

::std::ostream &operator<<(::std::ostream &, two_note_turn::value);

::std::ostream &operator<<(::std::ostream &, const two_note_turn &);

::std::ostream &operator<<(::std::ostream &, up_down::value);

::std::ostream &operator<<(::std::ostream &, const up_down &);

::std::ostream &operator<<(::std::ostream &, upright_inverted::value);

::std::ostream &operator<<(::std::ostream &, const upright_inverted &);

::std::ostream &operator<<(::std::ostream &, valign::value);

::std::ostream &operator<<(::std::ostream &, const valign &);

::std::ostream &operator<<(::std::ostream &, valign_image::value);

::std::ostream &operator<<(::std::ostream &, const valign_image &);

::std::ostream &operator<<(::std::ostream &, yes_no::value);

::std::ostream &operator<<(::std::ostream &, const yes_no &);

::std::ostream &operator<<(::std::ostream &, const yes_no_number &);

::std::ostream &operator<<(::std::ostream &, const yyyy_mm_dd &);

::std::ostream &operator<<(::std::ostream &, cancel_location::value);

::std::ostream &operator<<(::std::ostream &, const cancel_location &);

::std::ostream &operator<<(::std::ostream &, clef_sign::value);

::std::ostream &operator<<(::std::ostream &, const clef_sign &);

::std::ostream &operator<<(::std::ostream &, const fifths &);

::std::ostream &operator<<(::std::ostream &, const mode &);

::std::ostream &operator<<(::std::ostream &, show_frets::value);

::std::ostream &operator<<(::std::ostream &, const show_frets &);

::std::ostream &operator<<(::std::ostream &, const staff_line &);

::std::ostream &operator<<(::std::ostream &, const staff_number &);

::std::ostream &operator<<(::std::ostream &, staff_type::value);

::std::ostream &operator<<(::std::ostream &, const staff_type &);

::std::ostream &operator<<(::std::ostream &, time_relation::value);

::std::ostream &operator<<(::std::ostream &, const time_relation &);

::std::ostream &operator<<(::std::ostream &, time_separator::value);

::std::ostream &operator<<(::std::ostream &, const time_separator &);

::std::ostream &operator<<(::std::ostream &, time_symbol::value);

::std::ostream &operator<<(::std::ostream &, const time_symbol &);

::std::ostream &operator<<(::std::ostream &, backward_forward::value);

::std::ostream &operator<<(::std::ostream &, const backward_forward &);

::std::ostream &operator<<(::std::ostream &, bar_style::value);

::std::ostream &operator<<(::std::ostream &, const bar_style &);

::std::ostream &operator<<(::std::ostream &, const ending_number &);

::std::ostream &operator<<(::std::ostream &, right_left_middle::value);

::std::ostream &operator<<(::std::ostream &, const right_left_middle &);

::std::ostream &operator<<(::std::ostream &, start_stop_discontinue::value);

::std::ostream &operator<<(::std::ostream &, const start_stop_discontinue &);

::std::ostream &operator<<(::std::ostream &, winged::value);

::std::ostream &operator<<(::std::ostream &, const winged &);

::std::ostream &operator<<(::std::ostream &, const accordion_middle &);

::std::ostream &operator<<(::std::ostream &, beater_value::value);

::std::ostream &operator<<(::std::ostream &, const beater_value &);

::std::ostream &operator<<(::std::ostream &, degree_symbol_value::value);

::std::ostream &operator<<(::std::ostream &, const degree_symbol_value &);

::std::ostream &operator<<(::std::ostream &, degree_type_value::value);

::std::ostream &operator<<(::std::ostream &, const degree_type_value &);

::std::ostream &operator<<(::std::ostream &, effect::value);

::std::ostream &operator<<(::std::ostream &, const effect &);

::std::ostream &operator<<(::std::ostream &, glass::value);

::std::ostream &operator<<(::std::ostream &, const glass &);

::std::ostream &operator<<(::std::ostream &, harmony_type::value);

::std::ostream &operator<<(::std::ostream &, const harmony_type &);

::std::ostream &operator<<(::std::ostream &, kind_value::value);

::std::ostream &operator<<(::std::ostream &, const kind_value &);

::std::ostream &operator<<(::std::ostream &, line_end::value);

::std::ostream &operator<<(::std::ostream &, const line_end &);

::std::ostream &operator<<(::std::ostream &, measure_numbering_value::value);

::std::ostream &operator<<(::std::ostream &, const measure_numbering_value &);

::std::ostream &operator<<(::std::ostream &, membrane::value);

::std::ostream &operator<<(::std::ostream &, const membrane &);

::std::ostream &operator<<(::std::ostream &, metal::value);

::std::ostream &operator<<(::std::ostream &, const metal &);

::std::ostream &operator<<(::std::ostream &, on_off::value);

::std::ostream &operator<<(::std::ostream &, const on_off &);

::std::ostream &operator<<(::std::ostream &, pitched::value);

::std::ostream &operator<<(::std::ostream &, const pitched &);

::std::ostream &operator<<(::std::ostream &, principal_voice_symbol::value);

::std::ostream &operator<<(::std::ostream &, const principal_voice_symbol &);

::std::ostream &operator<<(::std::ostream &, start_stop_change_continue::value);

::std::ostream &operator<<(::std::ostream &,
                           const start_stop_change_continue &);

::std::ostream &operator<<(::std::ostream &, tip_direction::value);

::std::ostream &operator<<(::std::ostream &, const tip_direction &);

::std::ostream &operator<<(::std::ostream &, stick_location::value);

::std::ostream &operator<<(::std::ostream &, const stick_location &);

::std::ostream &operator<<(::std::ostream &, stick_material::value);

::std::ostream &operator<<(::std::ostream &, const stick_material &);

::std::ostream &operator<<(::std::ostream &, stick_type::value);

::std::ostream &operator<<(::std::ostream &, const stick_type &);

::std::ostream &operator<<(::std::ostream &, up_down_stop_continue::value);

::std::ostream &operator<<(::std::ostream &, const up_down_stop_continue &);

::std::ostream &operator<<(::std::ostream &, wedge_type::value);

::std::ostream &operator<<(::std::ostream &, const wedge_type &);

::std::ostream &operator<<(::std::ostream &, wood::value);

::std::ostream &operator<<(::std::ostream &, const wood &);

::std::ostream &operator<<(::std::ostream &, const distance_type &);

::std::ostream &operator<<(::std::ostream &, const line_width_type &);

::std::ostream &operator<<(::std::ostream &, margin_type::value);

::std::ostream &operator<<(::std::ostream &, const margin_type &);

::std::ostream &operator<<(::std::ostream &, const millimeters &);

::std::ostream &operator<<(::std::ostream &, note_size_type::value);

::std::ostream &operator<<(::std::ostream &, const note_size_type &);

::std::ostream &operator<<(::std::ostream &, accidental_value::value);

::std::ostream &operator<<(::std::ostream &, const accidental_value &);

::std::ostream &operator<<(::std::ostream &, arrow_direction::value);

::std::ostream &operator<<(::std::ostream &, const arrow_direction &);

::std::ostream &operator<<(::std::ostream &, arrow_style::value);

::std::ostream &operator<<(::std::ostream &, const arrow_style &);

::std::ostream &operator<<(::std::ostream &, beam_value::value);

::std::ostream &operator<<(::std::ostream &, const beam_value &);

::std::ostream &operator<<(::std::ostream &, breath_mark_value::value);

::std::ostream &operator<<(::std::ostream &, const breath_mark_value &);

::std::ostream &operator<<(::std::ostream &, circular_arrow::value);

::std::ostream &operator<<(::std::ostream &, const circular_arrow &);

::std::ostream &operator<<(::std::ostream &, fan::value);

::std::ostream &operator<<(::std::ostream &, const fan &);

::std::ostream &operator<<(::std::ostream &, handbell_value::value);

::std::ostream &operator<<(::std::ostream &, const handbell_value &);

::std::ostream &operator<<(::std::ostream &, hole_closed_location::value);

::std::ostream &operator<<(::std::ostream &, const hole_closed_location &);

::std::ostream &operator<<(::std::ostream &, hole_closed_value::value);

::std::ostream &operator<<(::std::ostream &, const hole_closed_value &);

::std::ostream &operator<<(::std::ostream &, note_type_value::value);

::std::ostream &operator<<(::std::ostream &, const note_type_value &);

::std::ostream &operator<<(::std::ostream &, notehead_value::value);

::std::ostream &operator<<(::std::ostream &, const notehead_value &);

::std::ostream &operator<<(::std::ostream &, const octave &);

::std::ostream &operator<<(::std::ostream &, const semitones &);

::std::ostream &operator<<(::std::ostream &, show_tuplet::value);

::std::ostream &operator<<(::std::ostream &, const show_tuplet &);

::std::ostream &operator<<(::std::ostream &, stem_value::value);

::std::ostream &operator<<(::std::ostream &, const stem_value &);

::std::ostream &operator<<(::std::ostream &, step::value);

::std::ostream &operator<<(::std::ostream &, const step &);

::std::ostream &operator<<(::std::ostream &, syllabic::value);

::std::ostream &operator<<(::std::ostream &, const syllabic &);

::std::ostream &operator<<(::std::ostream &, const tremolo_marks &);

::std::ostream &operator<<(::std::ostream &, group_barline_value::value);

::std::ostream &operator<<(::std::ostream &, const group_barline_value &);

::std::ostream &operator<<(::std::ostream &, group_symbol_value::value);

::std::ostream &operator<<(::std::ostream &, const group_symbol_value &);

::std::ostream &operator<<(::std::ostream &, const accidental_text &);

::std::ostream &operator<<(::std::ostream &, const dynamics &);

::std::ostream &operator<<(::std::ostream &, const empty &);

::std::ostream &operator<<(::std::ostream &, const empty_placement &);

::std::ostream &operator<<(::std::ostream &, const empty_print_style &);

::std::ostream &operator<<(::std::ostream &, const empty_print_style_align &);

::std::ostream &operator<<(::std::ostream &,
                           const empty_print_object_style_align &);

::std::ostream &operator<<(::std::ostream &, const empty_trill_sound &);

::std::ostream &operator<<(::std::ostream &, const horizontal_turn &);

::std::ostream &operator<<(::std::ostream &, const fermata &);

::std::ostream &operator<<(::std::ostream &, const fingering &);

::std::ostream &operator<<(::std::ostream &, const formatted_text &);

::std::ostream &operator<<(::std::ostream &, const fret &);

::std::ostream &operator<<(::std::ostream &, const level &);

::std::ostream &operator<<(::std::ostream &, const midi_device &);

::std::ostream &operator<<(::std::ostream &, const midi_instrument &);

::std::ostream &operator<<(::std::ostream &, const name_display &);

::std::ostream &operator<<(::std::ostream &, const other_play &);

::std::ostream &operator<<(::std::ostream &, const play &);

::std::ostream &operator<<(::std::ostream &, const string &);

::std::ostream &operator<<(::std::ostream &, const typed_text &);

::std::ostream &operator<<(::std::ostream &, const wavy_line &);

::std::ostream &operator<<(::std::ostream &, const attributes &);

::std::ostream &operator<<(::std::ostream &, const beat_repeat &);

::std::ostream &operator<<(::std::ostream &, const cancel &);

::std::ostream &operator<<(::std::ostream &, const clef &);

::std::ostream &operator<<(::std::ostream &, const interchangeable &);

::std::ostream &operator<<(::std::ostream &, const key &);

::std::ostream &operator<<(::std::ostream &, const key_octave &);

::std::ostream &operator<<(::std::ostream &, const measure_repeat &);

::std::ostream &operator<<(::std::ostream &, const measure_style &);

::std::ostream &operator<<(::std::ostream &, const multiple_rest &);

::std::ostream &operator<<(::std::ostream &, const part_symbol &);

::std::ostream &operator<<(::std::ostream &, const slash &);

::std::ostream &operator<<(::std::ostream &, const staff_details &);

::std::ostream &operator<<(::std::ostream &, const staff_tuning &);

::std::ostream &operator<<(::std::ostream &, const time &);

::std::ostream &operator<<(::std::ostream &, const transpose &);

::std::ostream &operator<<(::std::ostream &, const bar_style_color &);

::std::ostream &operator<<(::std::ostream &, const barline &);

::std::ostream &operator<<(::std::ostream &, const ending &);

::std::ostream &operator<<(::std::ostream &, const repeat &);

::std::ostream &operator<<(::std::ostream &, const accord &);

::std::ostream &operator<<(::std::ostream &, const accordion_registration &);

::std::ostream &operator<<(::std::ostream &, const barre &);

::std::ostream &operator<<(::std::ostream &, const bass &);

::std::ostream &operator<<(::std::ostream &, const bass_alter &);

::std::ostream &operator<<(::std::ostream &, const bass_step &);

::std::ostream &operator<<(::std::ostream &, const beater &);

::std::ostream &operator<<(::std::ostream &, const bracket &);

::std::ostream &operator<<(::std::ostream &, const dashes &);

::std::ostream &operator<<(::std::ostream &, const degree &);

::std::ostream &operator<<(::std::ostream &, const degree_alter &);

::std::ostream &operator<<(::std::ostream &, const degree_type &);

::std::ostream &operator<<(::std::ostream &, const degree_value &);

::std::ostream &operator<<(::std::ostream &, const direction &);

::std::ostream &operator<<(::std::ostream &, const direction_type &);

::std::ostream &operator<<(::std::ostream &, const feature &);

::std::ostream &operator<<(::std::ostream &, const first_fret &);

::std::ostream &operator<<(::std::ostream &, const frame &);

::std::ostream &operator<<(::std::ostream &, const frame_note &);

::std::ostream &operator<<(::std::ostream &, const grouping &);

::std::ostream &operator<<(::std::ostream &, const harmony &);

::std::ostream &operator<<(::std::ostream &, const harp_pedals &);

::std::ostream &operator<<(::std::ostream &, const image &);

::std::ostream &operator<<(::std::ostream &, const inversion &);

::std::ostream &operator<<(::std::ostream &, const kind &);

::std::ostream &operator<<(::std::ostream &, const measure_numbering &);

::std::ostream &operator<<(::std::ostream &, const metronome &);

::std::ostream &operator<<(::std::ostream &, const metronome_beam &);

::std::ostream &operator<<(::std::ostream &, const metronome_note &);

::std::ostream &operator<<(::std::ostream &, const time_modification &);

::std::ostream &operator<<(::std::ostream &, const metronome_tuplet &);

::std::ostream &operator<<(::std::ostream &, const octave_shift &);

::std::ostream &operator<<(::std::ostream &, const offset &);

::std::ostream &operator<<(::std::ostream &, const other_direction &);

::std::ostream &operator<<(::std::ostream &, const pedal &);

::std::ostream &operator<<(::std::ostream &, const pedal_tuning &);

::std::ostream &operator<<(::std::ostream &, const per_minute &);

::std::ostream &operator<<(::std::ostream &, const percussion &);

::std::ostream &operator<<(::std::ostream &, const principal_voice &);

::std::ostream &operator<<(::std::ostream &, const print &);

::std::ostream &operator<<(::std::ostream &, const root &);

::std::ostream &operator<<(::std::ostream &, const root_alter &);

::std::ostream &operator<<(::std::ostream &, const root_step &);

::std::ostream &operator<<(::std::ostream &, const scordatura &);

::std::ostream &operator<<(::std::ostream &, const sound &);

::std::ostream &operator<<(::std::ostream &, const stick &);

::std::ostream &operator<<(::std::ostream &, const string_mute &);

::std::ostream &operator<<(::std::ostream &, const wedge &);

::std::ostream &operator<<(::std::ostream &, const encoding &);

::std::ostream &operator<<(::std::ostream &, const identification &);

::std::ostream &operator<<(::std::ostream &, const miscellaneous &);

::std::ostream &operator<<(::std::ostream &, const miscellaneous_field &);

::std::ostream &operator<<(::std::ostream &, const supports &);

::std::ostream &operator<<(::std::ostream &, const appearance &);

::std::ostream &operator<<(::std::ostream &, const distance &);

::std::ostream &operator<<(::std::ostream &, const line_width &);

::std::ostream &operator<<(::std::ostream &, const measure_layout &);

::std::ostream &operator<<(::std::ostream &, const note_size &);

::std::ostream &operator<<(::std::ostream &, const other_appearance &);

::std::ostream &operator<<(::std::ostream &, const page_layout &);

::std::ostream &operator<<(::std::ostream &, const page_margins &);

::std::ostream &operator<<(::std::ostream &, const scaling &);

::std::ostream &operator<<(::std::ostream &, const staff_layout &);

::std::ostream &operator<<(::std::ostream &, const system_dividers &);

::std::ostream &operator<<(::std::ostream &, const system_layout &);

::std::ostream &operator<<(::std::ostream &, const system_margins &);

::std::ostream &operator<<(::std::ostream &, const bookmark &);

::std::ostream &operator<<(::std::ostream &, const link &);

::std::ostream &operator<<(::std::ostream &, const accidental &);

::std::ostream &operator<<(::std::ostream &, const accidental_mark &);

::std::ostream &operator<<(::std::ostream &, const arpeggiate &);

::std::ostream &operator<<(::std::ostream &, const articulations &);

::std::ostream &operator<<(::std::ostream &, const arrow &);

::std::ostream &operator<<(::std::ostream &, const backup &);

::std::ostream &operator<<(::std::ostream &, const beam &);

::std::ostream &operator<<(::std::ostream &, const bend &);

::std::ostream &operator<<(::std::ostream &, const breath_mark &);

::std::ostream &operator<<(::std::ostream &, const empty_line &);

::std::ostream &operator<<(::std::ostream &, const extend &);

::std::ostream &operator<<(::std::ostream &, const figure &);

::std::ostream &operator<<(::std::ostream &, const figured_bass &);

::std::ostream &operator<<(::std::ostream &, const forward &);

::std::ostream &operator<<(::std::ostream &, const glissando &);

::std::ostream &operator<<(::std::ostream &, const grace &);

::std::ostream &operator<<(::std::ostream &, const hammer_on_pull_off &);

::std::ostream &operator<<(::std::ostream &, const handbell &);

::std::ostream &operator<<(::std::ostream &, const harmonic &);

::std::ostream &operator<<(::std::ostream &, const heel_toe &);

::std::ostream &operator<<(::std::ostream &, const hole &);

::std::ostream &operator<<(::std::ostream &, const hole_closed &);

::std::ostream &operator<<(::std::ostream &, const instrument &);

::std::ostream &operator<<(::std::ostream &, const lyric &);

::std::ostream &operator<<(::std::ostream &, const mordent &);

::std::ostream &operator<<(::std::ostream &, const non_arpeggiate &);

::std::ostream &operator<<(::std::ostream &, const notations &);

::std::ostream &operator<<(::std::ostream &, const note &);

::std::ostream &operator<<(::std::ostream &, const note_type &);

::std::ostream &operator<<(::std::ostream &, const notehead &);

::std::ostream &operator<<(::std::ostream &, const notehead_text &);

::std::ostream &operator<<(::std::ostream &, const ornaments &);

::std::ostream &operator<<(::std::ostream &, const other_notation &);

::std::ostream &operator<<(::std::ostream &, const pitch &);

::std::ostream &operator<<(::std::ostream &, const placement_text &);

::std::ostream &operator<<(::std::ostream &, const rest &);

::std::ostream &operator<<(::std::ostream &, const slide &);

::std::ostream &operator<<(::std::ostream &, const slur &);

::std::ostream &operator<<(::std::ostream &, const stem &);

::std::ostream &operator<<(::std::ostream &, const strong_accent &);

::std::ostream &operator<<(::std::ostream &, const style_text &);

::std::ostream &operator<<(::std::ostream &, const technical &);

::std::ostream &operator<<(::std::ostream &, const text_element_data &);

::std::ostream &operator<<(::std::ostream &, const text_font_color &);

::std::ostream &operator<<(::std::ostream &, const tie &);

::std::ostream &operator<<(::std::ostream &, const tied &);

::std::ostream &operator<<(::std::ostream &, const tremolo &);

::std::ostream &operator<<(::std::ostream &, const tuplet &);

::std::ostream &operator<<(::std::ostream &, const tuplet_dot &);

::std::ostream &operator<<(::std::ostream &, const tuplet_number &);

::std::ostream &operator<<(::std::ostream &, const tuplet_portion &);

::std::ostream &operator<<(::std::ostream &, const tuplet_type &);

::std::ostream &operator<<(::std::ostream &, const unpitched &);

::std::ostream &operator<<(::std::ostream &, const credit &);

::std::ostream &operator<<(::std::ostream &, const defaults &);

::std::ostream &operator<<(::std::ostream &, const empty_font &);

::std::ostream &operator<<(::std::ostream &, const group_barline &);

::std::ostream &operator<<(::std::ostream &, const group_name &);

::std::ostream &operator<<(::std::ostream &, const group_symbol &);

::std::ostream &operator<<(::std::ostream &, const lyric_font &);

::std::ostream &operator<<(::std::ostream &, const lyric_language &);

::std::ostream &operator<<(::std::ostream &, const opus &);

::std::ostream &operator<<(::std::ostream &, const part_group &);

::std::ostream &operator<<(::std::ostream &, const part_list &);

::std::ostream &operator<<(::std::ostream &, const part_name &);

::std::ostream &operator<<(::std::ostream &, const score_instrument &);

::std::ostream &operator<<(::std::ostream &, const score_part &);

::std::ostream &operator<<(::std::ostream &, const virtual_instrument &);

::std::ostream &operator<<(::std::ostream &, const work &);

::std::ostream &operator<<(::std::ostream &, number_or_normal_member::value);

::std::ostream &operator<<(::std::ostream &, const number_or_normal_member &);

::std::ostream &operator<<(::std::ostream &,
                           positive_integer_or_empty_member::value);

::std::ostream &operator<<(::std::ostream &,
                           const positive_integer_or_empty_member &);

::std::ostream &operator<<(::std::ostream &, const directive &);

::std::ostream &operator<<(::std::ostream &, const score_partwise &);

::std::ostream &operator<<(::std::ostream &, const score_timewise &);

::std::ostream &operator<<(::std::ostream &, const part &);

::std::ostream &operator<<(::std::ostream &, const measure &);

::std::ostream &operator<<(::std::ostream &, const measure1 &);

::std::ostream &operator<<(::std::ostream &, const part1 &);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace musicxml {
/**
 * @name Parsing functions for the %score-partwise document root.
 *
 * The score-partwise element is the root element for a partwise MusicXML
 * score. It includes a score-header group followed by a series of parts
 * with measures inside. The document-attributes attribute group includes
 * the version attribute.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(const ::std::string &uri, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(const ::std::string &uri, ::xml_schema::error_handler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(const ::std::string &uri, ::xercesc::DOMErrorHandler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, ::xml_schema::error_handler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, ::xercesc::DOMErrorHandler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, const ::std::string &id,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, const ::std::string &id,
                ::xml_schema::error_handler &eh, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, const ::std::string &id,
                ::xercesc::DOMErrorHandler &eh, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::xercesc::InputSource &is, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::xercesc::InputSource &is, ::xml_schema::error_handler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::xercesc::InputSource &is, ::xercesc::DOMErrorHandler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(const ::xercesc::DOMDocument &d, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

//@}

/**
 * @name Parsing functions for the %score-timewise document root.
 *
 * The score-timewise element is the root element for a timewise MusicXML
 * score. It includes a score-header group followed by a series of
 * measures with parts inside. The document-attributes attribute group
 * includes the version attribute.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(const ::std::string &uri, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(const ::std::string &uri, ::xml_schema::error_handler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(const ::std::string &uri, ::xercesc::DOMErrorHandler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, ::xml_schema::error_handler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, ::xercesc::DOMErrorHandler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, const ::std::string &id,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, const ::std::string &id,
                ::xml_schema::error_handler &eh, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, const ::std::string &id,
                ::xercesc::DOMErrorHandler &eh, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::xercesc::InputSource &is, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::xercesc::InputSource &is, ::xml_schema::error_handler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::xercesc::InputSource &is, ::xercesc::DOMErrorHandler &eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(const ::xercesc::DOMDocument &d, ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties &p = ::xml_schema::properties());

//@}
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace musicxml {
void operator<<(::xercesc::DOMElement &, const above_below &);

void operator<<(::xercesc::DOMAttr &, const above_below &);

void operator<<(::xml_schema::list_stream &, const above_below &);

void operator<<(::xercesc::DOMElement &, const beam_level &);

void operator<<(::xercesc::DOMAttr &, const beam_level &);

void operator<<(::xml_schema::list_stream &, const beam_level &);

void operator<<(::xercesc::DOMElement &, const color &);

void operator<<(::xercesc::DOMAttr &, const color &);

void operator<<(::xml_schema::list_stream &, const color &);

void operator<<(::xercesc::DOMElement &, const comma_separated_text &);

void operator<<(::xercesc::DOMAttr &, const comma_separated_text &);

void operator<<(::xml_schema::list_stream &, const comma_separated_text &);

void operator<<(::xercesc::DOMElement &, const css_font_size &);

void operator<<(::xercesc::DOMAttr &, const css_font_size &);

void operator<<(::xml_schema::list_stream &, const css_font_size &);

void operator<<(::xercesc::DOMElement &, const divisions &);

void operator<<(::xercesc::DOMAttr &, const divisions &);

void operator<<(::xml_schema::list_stream &, const divisions &);

void operator<<(::xercesc::DOMElement &, const enclosure_shape &);

void operator<<(::xercesc::DOMAttr &, const enclosure_shape &);

void operator<<(::xml_schema::list_stream &, const enclosure_shape &);

void operator<<(::xercesc::DOMElement &, const fermata_shape &);

void operator<<(::xercesc::DOMAttr &, const fermata_shape &);

void operator<<(::xml_schema::list_stream &, const fermata_shape &);

void operator<<(::xercesc::DOMElement &, const font_size &);

void operator<<(::xercesc::DOMAttr &, const font_size &);

void operator<<(::xml_schema::list_stream &, const font_size &);

void operator<<(::xercesc::DOMElement &, const font_style &);

void operator<<(::xercesc::DOMAttr &, const font_style &);

void operator<<(::xml_schema::list_stream &, const font_style &);

void operator<<(::xercesc::DOMElement &, const font_weight &);

void operator<<(::xercesc::DOMAttr &, const font_weight &);

void operator<<(::xml_schema::list_stream &, const font_weight &);

void operator<<(::xercesc::DOMElement &, const left_center_right &);

void operator<<(::xercesc::DOMAttr &, const left_center_right &);

void operator<<(::xml_schema::list_stream &, const left_center_right &);

void operator<<(::xercesc::DOMElement &, const left_right &);

void operator<<(::xercesc::DOMAttr &, const left_right &);

void operator<<(::xml_schema::list_stream &, const left_right &);

void operator<<(::xercesc::DOMElement &, const line_shape &);

void operator<<(::xercesc::DOMAttr &, const line_shape &);

void operator<<(::xml_schema::list_stream &, const line_shape &);

void operator<<(::xercesc::DOMElement &, const line_type &);

void operator<<(::xercesc::DOMAttr &, const line_type &);

void operator<<(::xml_schema::list_stream &, const line_type &);

void operator<<(::xercesc::DOMElement &, const midi_16 &);

void operator<<(::xercesc::DOMAttr &, const midi_16 &);

void operator<<(::xml_schema::list_stream &, const midi_16 &);

void operator<<(::xercesc::DOMElement &, const midi_128 &);

void operator<<(::xercesc::DOMAttr &, const midi_128 &);

void operator<<(::xml_schema::list_stream &, const midi_128 &);

void operator<<(::xercesc::DOMElement &, const midi_16384 &);

void operator<<(::xercesc::DOMAttr &, const midi_16384 &);

void operator<<(::xml_schema::list_stream &, const midi_16384 &);

void operator<<(::xercesc::DOMElement &, const mute &);

void operator<<(::xercesc::DOMAttr &, const mute &);

void operator<<(::xml_schema::list_stream &, const mute &);

void operator<<(::xercesc::DOMElement &, const non_negative_decimal &);

void operator<<(::xercesc::DOMAttr &, const non_negative_decimal &);

void operator<<(::xml_schema::list_stream &, const non_negative_decimal &);

void operator<<(::xercesc::DOMElement &, const number_level &);

void operator<<(::xercesc::DOMAttr &, const number_level &);

void operator<<(::xml_schema::list_stream &, const number_level &);

void operator<<(::xercesc::DOMElement &, const number_of_lines &);

void operator<<(::xercesc::DOMAttr &, const number_of_lines &);

void operator<<(::xml_schema::list_stream &, const number_of_lines &);

void operator<<(::xercesc::DOMElement &, const number_or_normal &);

void operator<<(::xercesc::DOMAttr &, const number_or_normal &);

void operator<<(::xml_schema::list_stream &, const number_or_normal &);

void operator<<(::xercesc::DOMElement &, const over_under &);

void operator<<(::xercesc::DOMAttr &, const over_under &);

void operator<<(::xml_schema::list_stream &, const over_under &);

void operator<<(::xercesc::DOMElement &, const percent &);

void operator<<(::xercesc::DOMAttr &, const percent &);

void operator<<(::xml_schema::list_stream &, const percent &);

void operator<<(::xercesc::DOMElement &, const positive_decimal &);

void operator<<(::xercesc::DOMAttr &, const positive_decimal &);

void operator<<(::xml_schema::list_stream &, const positive_decimal &);

void operator<<(::xercesc::DOMElement &, const positive_divisions &);

void operator<<(::xercesc::DOMAttr &, const positive_divisions &);

void operator<<(::xml_schema::list_stream &, const positive_divisions &);

void operator<<(::xercesc::DOMElement &, const positive_integer_or_empty &);

void operator<<(::xercesc::DOMAttr &, const positive_integer_or_empty &);

void operator<<(::xml_schema::list_stream &, const positive_integer_or_empty &);

void operator<<(::xercesc::DOMElement &, const rotation_degrees &);

void operator<<(::xercesc::DOMAttr &, const rotation_degrees &);

void operator<<(::xml_schema::list_stream &, const rotation_degrees &);

void operator<<(::xercesc::DOMElement &, const semi_pitched &);

void operator<<(::xercesc::DOMAttr &, const semi_pitched &);

void operator<<(::xml_schema::list_stream &, const semi_pitched &);

void operator<<(::xercesc::DOMElement &, const start_note &);

void operator<<(::xercesc::DOMAttr &, const start_note &);

void operator<<(::xml_schema::list_stream &, const start_note &);

void operator<<(::xercesc::DOMElement &, const start_stop &);

void operator<<(::xercesc::DOMAttr &, const start_stop &);

void operator<<(::xml_schema::list_stream &, const start_stop &);

void operator<<(::xercesc::DOMElement &, const start_stop_continue &);

void operator<<(::xercesc::DOMAttr &, const start_stop_continue &);

void operator<<(::xml_schema::list_stream &, const start_stop_continue &);

void operator<<(::xercesc::DOMElement &, const start_stop_single &);

void operator<<(::xercesc::DOMAttr &, const start_stop_single &);

void operator<<(::xml_schema::list_stream &, const start_stop_single &);

void operator<<(::xercesc::DOMElement &, const string_number &);

void operator<<(::xercesc::DOMAttr &, const string_number &);

void operator<<(::xml_schema::list_stream &, const string_number &);

void operator<<(::xercesc::DOMElement &, const symbol_size &);

void operator<<(::xercesc::DOMAttr &, const symbol_size &);

void operator<<(::xml_schema::list_stream &, const symbol_size &);

void operator<<(::xercesc::DOMElement &, const tenths &);

void operator<<(::xercesc::DOMAttr &, const tenths &);

void operator<<(::xml_schema::list_stream &, const tenths &);

void operator<<(::xercesc::DOMElement &, const text_direction &);

void operator<<(::xercesc::DOMAttr &, const text_direction &);

void operator<<(::xml_schema::list_stream &, const text_direction &);

void operator<<(::xercesc::DOMElement &, const time_only &);

void operator<<(::xercesc::DOMAttr &, const time_only &);

void operator<<(::xml_schema::list_stream &, const time_only &);

void operator<<(::xercesc::DOMElement &, const top_bottom &);

void operator<<(::xercesc::DOMAttr &, const top_bottom &);

void operator<<(::xml_schema::list_stream &, const top_bottom &);

void operator<<(::xercesc::DOMElement &, const trill_beats &);

void operator<<(::xercesc::DOMAttr &, const trill_beats &);

void operator<<(::xml_schema::list_stream &, const trill_beats &);

void operator<<(::xercesc::DOMElement &, const trill_step &);

void operator<<(::xercesc::DOMAttr &, const trill_step &);

void operator<<(::xml_schema::list_stream &, const trill_step &);

void operator<<(::xercesc::DOMElement &, const two_note_turn &);

void operator<<(::xercesc::DOMAttr &, const two_note_turn &);

void operator<<(::xml_schema::list_stream &, const two_note_turn &);

void operator<<(::xercesc::DOMElement &, const up_down &);

void operator<<(::xercesc::DOMAttr &, const up_down &);

void operator<<(::xml_schema::list_stream &, const up_down &);

void operator<<(::xercesc::DOMElement &, const upright_inverted &);

void operator<<(::xercesc::DOMAttr &, const upright_inverted &);

void operator<<(::xml_schema::list_stream &, const upright_inverted &);

void operator<<(::xercesc::DOMElement &, const valign &);

void operator<<(::xercesc::DOMAttr &, const valign &);

void operator<<(::xml_schema::list_stream &, const valign &);

void operator<<(::xercesc::DOMElement &, const valign_image &);

void operator<<(::xercesc::DOMAttr &, const valign_image &);

void operator<<(::xml_schema::list_stream &, const valign_image &);

void operator<<(::xercesc::DOMElement &, const yes_no &);

void operator<<(::xercesc::DOMAttr &, const yes_no &);

void operator<<(::xml_schema::list_stream &, const yes_no &);

void operator<<(::xercesc::DOMElement &, const yes_no_number &);

void operator<<(::xercesc::DOMAttr &, const yes_no_number &);

void operator<<(::xml_schema::list_stream &, const yes_no_number &);

void operator<<(::xercesc::DOMElement &, const yyyy_mm_dd &);

void operator<<(::xercesc::DOMAttr &, const yyyy_mm_dd &);

void operator<<(::xml_schema::list_stream &, const yyyy_mm_dd &);

void operator<<(::xercesc::DOMElement &, const cancel_location &);

void operator<<(::xercesc::DOMAttr &, const cancel_location &);

void operator<<(::xml_schema::list_stream &, const cancel_location &);

void operator<<(::xercesc::DOMElement &, const clef_sign &);

void operator<<(::xercesc::DOMAttr &, const clef_sign &);

void operator<<(::xml_schema::list_stream &, const clef_sign &);

void operator<<(::xercesc::DOMElement &, const fifths &);

void operator<<(::xercesc::DOMAttr &, const fifths &);

void operator<<(::xml_schema::list_stream &, const fifths &);

void operator<<(::xercesc::DOMElement &, const mode &);

void operator<<(::xercesc::DOMAttr &, const mode &);

void operator<<(::xml_schema::list_stream &, const mode &);

void operator<<(::xercesc::DOMElement &, const show_frets &);

void operator<<(::xercesc::DOMAttr &, const show_frets &);

void operator<<(::xml_schema::list_stream &, const show_frets &);

void operator<<(::xercesc::DOMElement &, const staff_line &);

void operator<<(::xercesc::DOMAttr &, const staff_line &);

void operator<<(::xml_schema::list_stream &, const staff_line &);

void operator<<(::xercesc::DOMElement &, const staff_number &);

void operator<<(::xercesc::DOMAttr &, const staff_number &);

void operator<<(::xml_schema::list_stream &, const staff_number &);

void operator<<(::xercesc::DOMElement &, const staff_type &);

void operator<<(::xercesc::DOMAttr &, const staff_type &);

void operator<<(::xml_schema::list_stream &, const staff_type &);

void operator<<(::xercesc::DOMElement &, const time_relation &);

void operator<<(::xercesc::DOMAttr &, const time_relation &);

void operator<<(::xml_schema::list_stream &, const time_relation &);

void operator<<(::xercesc::DOMElement &, const time_separator &);

void operator<<(::xercesc::DOMAttr &, const time_separator &);

void operator<<(::xml_schema::list_stream &, const time_separator &);

void operator<<(::xercesc::DOMElement &, const time_symbol &);

void operator<<(::xercesc::DOMAttr &, const time_symbol &);

void operator<<(::xml_schema::list_stream &, const time_symbol &);

void operator<<(::xercesc::DOMElement &, const backward_forward &);

void operator<<(::xercesc::DOMAttr &, const backward_forward &);

void operator<<(::xml_schema::list_stream &, const backward_forward &);

void operator<<(::xercesc::DOMElement &, const bar_style &);

void operator<<(::xercesc::DOMAttr &, const bar_style &);

void operator<<(::xml_schema::list_stream &, const bar_style &);

void operator<<(::xercesc::DOMElement &, const ending_number &);

void operator<<(::xercesc::DOMAttr &, const ending_number &);

void operator<<(::xml_schema::list_stream &, const ending_number &);

void operator<<(::xercesc::DOMElement &, const right_left_middle &);

void operator<<(::xercesc::DOMAttr &, const right_left_middle &);

void operator<<(::xml_schema::list_stream &, const right_left_middle &);

void operator<<(::xercesc::DOMElement &, const start_stop_discontinue &);

void operator<<(::xercesc::DOMAttr &, const start_stop_discontinue &);

void operator<<(::xml_schema::list_stream &, const start_stop_discontinue &);

void operator<<(::xercesc::DOMElement &, const winged &);

void operator<<(::xercesc::DOMAttr &, const winged &);

void operator<<(::xml_schema::list_stream &, const winged &);

void operator<<(::xercesc::DOMElement &, const accordion_middle &);

void operator<<(::xercesc::DOMAttr &, const accordion_middle &);

void operator<<(::xml_schema::list_stream &, const accordion_middle &);

void operator<<(::xercesc::DOMElement &, const beater_value &);

void operator<<(::xercesc::DOMAttr &, const beater_value &);

void operator<<(::xml_schema::list_stream &, const beater_value &);

void operator<<(::xercesc::DOMElement &, const degree_symbol_value &);

void operator<<(::xercesc::DOMAttr &, const degree_symbol_value &);

void operator<<(::xml_schema::list_stream &, const degree_symbol_value &);

void operator<<(::xercesc::DOMElement &, const degree_type_value &);

void operator<<(::xercesc::DOMAttr &, const degree_type_value &);

void operator<<(::xml_schema::list_stream &, const degree_type_value &);

void operator<<(::xercesc::DOMElement &, const effect &);

void operator<<(::xercesc::DOMAttr &, const effect &);

void operator<<(::xml_schema::list_stream &, const effect &);

void operator<<(::xercesc::DOMElement &, const glass &);

void operator<<(::xercesc::DOMAttr &, const glass &);

void operator<<(::xml_schema::list_stream &, const glass &);

void operator<<(::xercesc::DOMElement &, const harmony_type &);

void operator<<(::xercesc::DOMAttr &, const harmony_type &);

void operator<<(::xml_schema::list_stream &, const harmony_type &);

void operator<<(::xercesc::DOMElement &, const kind_value &);

void operator<<(::xercesc::DOMAttr &, const kind_value &);

void operator<<(::xml_schema::list_stream &, const kind_value &);

void operator<<(::xercesc::DOMElement &, const line_end &);

void operator<<(::xercesc::DOMAttr &, const line_end &);

void operator<<(::xml_schema::list_stream &, const line_end &);

void operator<<(::xercesc::DOMElement &, const measure_numbering_value &);

void operator<<(::xercesc::DOMAttr &, const measure_numbering_value &);

void operator<<(::xml_schema::list_stream &, const measure_numbering_value &);

void operator<<(::xercesc::DOMElement &, const membrane &);

void operator<<(::xercesc::DOMAttr &, const membrane &);

void operator<<(::xml_schema::list_stream &, const membrane &);

void operator<<(::xercesc::DOMElement &, const metal &);

void operator<<(::xercesc::DOMAttr &, const metal &);

void operator<<(::xml_schema::list_stream &, const metal &);

void operator<<(::xercesc::DOMElement &, const on_off &);

void operator<<(::xercesc::DOMAttr &, const on_off &);

void operator<<(::xml_schema::list_stream &, const on_off &);

void operator<<(::xercesc::DOMElement &, const pitched &);

void operator<<(::xercesc::DOMAttr &, const pitched &);

void operator<<(::xml_schema::list_stream &, const pitched &);

void operator<<(::xercesc::DOMElement &, const principal_voice_symbol &);

void operator<<(::xercesc::DOMAttr &, const principal_voice_symbol &);

void operator<<(::xml_schema::list_stream &, const principal_voice_symbol &);

void operator<<(::xercesc::DOMElement &, const start_stop_change_continue &);

void operator<<(::xercesc::DOMAttr &, const start_stop_change_continue &);

void operator<<(::xml_schema::list_stream &,
                const start_stop_change_continue &);

void operator<<(::xercesc::DOMElement &, const tip_direction &);

void operator<<(::xercesc::DOMAttr &, const tip_direction &);

void operator<<(::xml_schema::list_stream &, const tip_direction &);

void operator<<(::xercesc::DOMElement &, const stick_location &);

void operator<<(::xercesc::DOMAttr &, const stick_location &);

void operator<<(::xml_schema::list_stream &, const stick_location &);

void operator<<(::xercesc::DOMElement &, const stick_material &);

void operator<<(::xercesc::DOMAttr &, const stick_material &);

void operator<<(::xml_schema::list_stream &, const stick_material &);

void operator<<(::xercesc::DOMElement &, const stick_type &);

void operator<<(::xercesc::DOMAttr &, const stick_type &);

void operator<<(::xml_schema::list_stream &, const stick_type &);

void operator<<(::xercesc::DOMElement &, const up_down_stop_continue &);

void operator<<(::xercesc::DOMAttr &, const up_down_stop_continue &);

void operator<<(::xml_schema::list_stream &, const up_down_stop_continue &);

void operator<<(::xercesc::DOMElement &, const wedge_type &);

void operator<<(::xercesc::DOMAttr &, const wedge_type &);

void operator<<(::xml_schema::list_stream &, const wedge_type &);

void operator<<(::xercesc::DOMElement &, const wood &);

void operator<<(::xercesc::DOMAttr &, const wood &);

void operator<<(::xml_schema::list_stream &, const wood &);

void operator<<(::xercesc::DOMElement &, const distance_type &);

void operator<<(::xercesc::DOMAttr &, const distance_type &);

void operator<<(::xml_schema::list_stream &, const distance_type &);

void operator<<(::xercesc::DOMElement &, const line_width_type &);

void operator<<(::xercesc::DOMAttr &, const line_width_type &);

void operator<<(::xml_schema::list_stream &, const line_width_type &);

void operator<<(::xercesc::DOMElement &, const margin_type &);

void operator<<(::xercesc::DOMAttr &, const margin_type &);

void operator<<(::xml_schema::list_stream &, const margin_type &);

void operator<<(::xercesc::DOMElement &, const millimeters &);

void operator<<(::xercesc::DOMAttr &, const millimeters &);

void operator<<(::xml_schema::list_stream &, const millimeters &);

void operator<<(::xercesc::DOMElement &, const note_size_type &);

void operator<<(::xercesc::DOMAttr &, const note_size_type &);

void operator<<(::xml_schema::list_stream &, const note_size_type &);

void operator<<(::xercesc::DOMElement &, const accidental_value &);

void operator<<(::xercesc::DOMAttr &, const accidental_value &);

void operator<<(::xml_schema::list_stream &, const accidental_value &);

void operator<<(::xercesc::DOMElement &, const arrow_direction &);

void operator<<(::xercesc::DOMAttr &, const arrow_direction &);

void operator<<(::xml_schema::list_stream &, const arrow_direction &);

void operator<<(::xercesc::DOMElement &, const arrow_style &);

void operator<<(::xercesc::DOMAttr &, const arrow_style &);

void operator<<(::xml_schema::list_stream &, const arrow_style &);

void operator<<(::xercesc::DOMElement &, const beam_value &);

void operator<<(::xercesc::DOMAttr &, const beam_value &);

void operator<<(::xml_schema::list_stream &, const beam_value &);

void operator<<(::xercesc::DOMElement &, const breath_mark_value &);

void operator<<(::xercesc::DOMAttr &, const breath_mark_value &);

void operator<<(::xml_schema::list_stream &, const breath_mark_value &);

void operator<<(::xercesc::DOMElement &, const circular_arrow &);

void operator<<(::xercesc::DOMAttr &, const circular_arrow &);

void operator<<(::xml_schema::list_stream &, const circular_arrow &);

void operator<<(::xercesc::DOMElement &, const fan &);

void operator<<(::xercesc::DOMAttr &, const fan &);

void operator<<(::xml_schema::list_stream &, const fan &);

void operator<<(::xercesc::DOMElement &, const handbell_value &);

void operator<<(::xercesc::DOMAttr &, const handbell_value &);

void operator<<(::xml_schema::list_stream &, const handbell_value &);

void operator<<(::xercesc::DOMElement &, const hole_closed_location &);

void operator<<(::xercesc::DOMAttr &, const hole_closed_location &);

void operator<<(::xml_schema::list_stream &, const hole_closed_location &);

void operator<<(::xercesc::DOMElement &, const hole_closed_value &);

void operator<<(::xercesc::DOMAttr &, const hole_closed_value &);

void operator<<(::xml_schema::list_stream &, const hole_closed_value &);

void operator<<(::xercesc::DOMElement &, const note_type_value &);

void operator<<(::xercesc::DOMAttr &, const note_type_value &);

void operator<<(::xml_schema::list_stream &, const note_type_value &);

void operator<<(::xercesc::DOMElement &, const notehead_value &);

void operator<<(::xercesc::DOMAttr &, const notehead_value &);

void operator<<(::xml_schema::list_stream &, const notehead_value &);

void operator<<(::xercesc::DOMElement &, const octave &);

void operator<<(::xercesc::DOMAttr &, const octave &);

void operator<<(::xml_schema::list_stream &, const octave &);

void operator<<(::xercesc::DOMElement &, const semitones &);

void operator<<(::xercesc::DOMAttr &, const semitones &);

void operator<<(::xml_schema::list_stream &, const semitones &);

void operator<<(::xercesc::DOMElement &, const show_tuplet &);

void operator<<(::xercesc::DOMAttr &, const show_tuplet &);

void operator<<(::xml_schema::list_stream &, const show_tuplet &);

void operator<<(::xercesc::DOMElement &, const stem_value &);

void operator<<(::xercesc::DOMAttr &, const stem_value &);

void operator<<(::xml_schema::list_stream &, const stem_value &);

void operator<<(::xercesc::DOMElement &, const step &);

void operator<<(::xercesc::DOMAttr &, const step &);

void operator<<(::xml_schema::list_stream &, const step &);

void operator<<(::xercesc::DOMElement &, const syllabic &);

void operator<<(::xercesc::DOMAttr &, const syllabic &);

void operator<<(::xml_schema::list_stream &, const syllabic &);

void operator<<(::xercesc::DOMElement &, const tremolo_marks &);

void operator<<(::xercesc::DOMAttr &, const tremolo_marks &);

void operator<<(::xml_schema::list_stream &, const tremolo_marks &);

void operator<<(::xercesc::DOMElement &, const group_barline_value &);

void operator<<(::xercesc::DOMAttr &, const group_barline_value &);

void operator<<(::xml_schema::list_stream &, const group_barline_value &);

void operator<<(::xercesc::DOMElement &, const group_symbol_value &);

void operator<<(::xercesc::DOMAttr &, const group_symbol_value &);

void operator<<(::xml_schema::list_stream &, const group_symbol_value &);

void operator<<(::xercesc::DOMElement &, const accidental_text &);

void operator<<(::xercesc::DOMElement &, const dynamics &);

void operator<<(::xercesc::DOMElement &, const empty &);

void operator<<(::xercesc::DOMAttr &, const empty &);

void operator<<(::xml_schema::list_stream &, const empty &);

void operator<<(::xercesc::DOMElement &, const empty_placement &);

void operator<<(::xercesc::DOMElement &, const empty_print_style &);

void operator<<(::xercesc::DOMElement &, const empty_print_style_align &);

void operator<<(::xercesc::DOMElement &,
                const empty_print_object_style_align &);

void operator<<(::xercesc::DOMElement &, const empty_trill_sound &);

void operator<<(::xercesc::DOMElement &, const horizontal_turn &);

void operator<<(::xercesc::DOMElement &, const fermata &);

void operator<<(::xercesc::DOMElement &, const fingering &);

void operator<<(::xercesc::DOMElement &, const formatted_text &);

void operator<<(::xercesc::DOMElement &, const fret &);

void operator<<(::xercesc::DOMElement &, const level &);

void operator<<(::xercesc::DOMElement &, const midi_device &);

void operator<<(::xercesc::DOMElement &, const midi_instrument &);

void operator<<(::xercesc::DOMElement &, const name_display &);

void operator<<(::xercesc::DOMElement &, const other_play &);

void operator<<(::xercesc::DOMElement &, const play &);

void operator<<(::xercesc::DOMElement &, const string &);

void operator<<(::xercesc::DOMElement &, const typed_text &);

void operator<<(::xercesc::DOMElement &, const wavy_line &);

void operator<<(::xercesc::DOMElement &, const attributes &);

void operator<<(::xercesc::DOMElement &, const beat_repeat &);

void operator<<(::xercesc::DOMElement &, const cancel &);

void operator<<(::xercesc::DOMElement &, const clef &);

void operator<<(::xercesc::DOMElement &, const interchangeable &);

void operator<<(::xercesc::DOMElement &, const key &);

void operator<<(::xercesc::DOMElement &, const key_octave &);

void operator<<(::xercesc::DOMElement &, const measure_repeat &);

void operator<<(::xercesc::DOMElement &, const measure_style &);

void operator<<(::xercesc::DOMElement &, const multiple_rest &);

void operator<<(::xercesc::DOMElement &, const part_symbol &);

void operator<<(::xercesc::DOMElement &, const slash &);

void operator<<(::xercesc::DOMElement &, const staff_details &);

void operator<<(::xercesc::DOMElement &, const staff_tuning &);

void operator<<(::xercesc::DOMElement &, const time &);

void operator<<(::xercesc::DOMElement &, const transpose &);

void operator<<(::xercesc::DOMElement &, const bar_style_color &);

void operator<<(::xercesc::DOMElement &, const barline &);

void operator<<(::xercesc::DOMElement &, const ending &);

void operator<<(::xercesc::DOMElement &, const repeat &);

void operator<<(::xercesc::DOMElement &, const accord &);

void operator<<(::xercesc::DOMElement &, const accordion_registration &);

void operator<<(::xercesc::DOMElement &, const barre &);

void operator<<(::xercesc::DOMElement &, const bass &);

void operator<<(::xercesc::DOMElement &, const bass_alter &);

void operator<<(::xercesc::DOMElement &, const bass_step &);

void operator<<(::xercesc::DOMElement &, const beater &);

void operator<<(::xercesc::DOMElement &, const bracket &);

void operator<<(::xercesc::DOMElement &, const dashes &);

void operator<<(::xercesc::DOMElement &, const degree &);

void operator<<(::xercesc::DOMElement &, const degree_alter &);

void operator<<(::xercesc::DOMElement &, const degree_type &);

void operator<<(::xercesc::DOMElement &, const degree_value &);

void operator<<(::xercesc::DOMElement &, const direction &);

void operator<<(::xercesc::DOMElement &, const direction_type &);

void operator<<(::xercesc::DOMElement &, const feature &);

void operator<<(::xercesc::DOMElement &, const first_fret &);

void operator<<(::xercesc::DOMElement &, const frame &);

void operator<<(::xercesc::DOMElement &, const frame_note &);

void operator<<(::xercesc::DOMElement &, const grouping &);

void operator<<(::xercesc::DOMElement &, const harmony &);

void operator<<(::xercesc::DOMElement &, const harp_pedals &);

void operator<<(::xercesc::DOMElement &, const image &);

void operator<<(::xercesc::DOMElement &, const inversion &);

void operator<<(::xercesc::DOMElement &, const kind &);

void operator<<(::xercesc::DOMElement &, const measure_numbering &);

void operator<<(::xercesc::DOMElement &, const metronome &);

void operator<<(::xercesc::DOMElement &, const metronome_beam &);

void operator<<(::xercesc::DOMElement &, const metronome_note &);

void operator<<(::xercesc::DOMElement &, const time_modification &);

void operator<<(::xercesc::DOMElement &, const metronome_tuplet &);

void operator<<(::xercesc::DOMElement &, const octave_shift &);

void operator<<(::xercesc::DOMElement &, const offset &);

void operator<<(::xercesc::DOMElement &, const other_direction &);

void operator<<(::xercesc::DOMElement &, const pedal &);

void operator<<(::xercesc::DOMElement &, const pedal_tuning &);

void operator<<(::xercesc::DOMElement &, const per_minute &);

void operator<<(::xercesc::DOMElement &, const percussion &);

void operator<<(::xercesc::DOMElement &, const principal_voice &);

void operator<<(::xercesc::DOMElement &, const print &);

void operator<<(::xercesc::DOMElement &, const root &);

void operator<<(::xercesc::DOMElement &, const root_alter &);

void operator<<(::xercesc::DOMElement &, const root_step &);

void operator<<(::xercesc::DOMElement &, const scordatura &);

void operator<<(::xercesc::DOMElement &, const sound &);

void operator<<(::xercesc::DOMElement &, const stick &);

void operator<<(::xercesc::DOMElement &, const string_mute &);

void operator<<(::xercesc::DOMElement &, const wedge &);

void operator<<(::xercesc::DOMElement &, const encoding &);

void operator<<(::xercesc::DOMElement &, const identification &);

void operator<<(::xercesc::DOMElement &, const miscellaneous &);

void operator<<(::xercesc::DOMElement &, const miscellaneous_field &);

void operator<<(::xercesc::DOMElement &, const supports &);

void operator<<(::xercesc::DOMElement &, const appearance &);

void operator<<(::xercesc::DOMElement &, const distance &);

void operator<<(::xercesc::DOMElement &, const line_width &);

void operator<<(::xercesc::DOMElement &, const measure_layout &);

void operator<<(::xercesc::DOMElement &, const note_size &);

void operator<<(::xercesc::DOMElement &, const other_appearance &);

void operator<<(::xercesc::DOMElement &, const page_layout &);

void operator<<(::xercesc::DOMElement &, const page_margins &);

void operator<<(::xercesc::DOMElement &, const scaling &);

void operator<<(::xercesc::DOMElement &, const staff_layout &);

void operator<<(::xercesc::DOMElement &, const system_dividers &);

void operator<<(::xercesc::DOMElement &, const system_layout &);

void operator<<(::xercesc::DOMElement &, const system_margins &);

void operator<<(::xercesc::DOMElement &, const bookmark &);

void operator<<(::xercesc::DOMElement &, const link &);

void operator<<(::xercesc::DOMElement &, const accidental &);

void operator<<(::xercesc::DOMElement &, const accidental_mark &);

void operator<<(::xercesc::DOMElement &, const arpeggiate &);

void operator<<(::xercesc::DOMElement &, const articulations &);

void operator<<(::xercesc::DOMElement &, const arrow &);

void operator<<(::xercesc::DOMElement &, const backup &);

void operator<<(::xercesc::DOMElement &, const beam &);

void operator<<(::xercesc::DOMElement &, const bend &);

void operator<<(::xercesc::DOMElement &, const breath_mark &);

void operator<<(::xercesc::DOMElement &, const empty_line &);

void operator<<(::xercesc::DOMElement &, const extend &);

void operator<<(::xercesc::DOMElement &, const figure &);

void operator<<(::xercesc::DOMElement &, const figured_bass &);

void operator<<(::xercesc::DOMElement &, const forward &);

void operator<<(::xercesc::DOMElement &, const glissando &);

void operator<<(::xercesc::DOMElement &, const grace &);

void operator<<(::xercesc::DOMElement &, const hammer_on_pull_off &);

void operator<<(::xercesc::DOMElement &, const handbell &);

void operator<<(::xercesc::DOMElement &, const harmonic &);

void operator<<(::xercesc::DOMElement &, const heel_toe &);

void operator<<(::xercesc::DOMElement &, const hole &);

void operator<<(::xercesc::DOMElement &, const hole_closed &);

void operator<<(::xercesc::DOMElement &, const instrument &);

void operator<<(::xercesc::DOMElement &, const lyric &);

void operator<<(::xercesc::DOMElement &, const mordent &);

void operator<<(::xercesc::DOMElement &, const non_arpeggiate &);

void operator<<(::xercesc::DOMElement &, const notations &);

void operator<<(::xercesc::DOMElement &, const note &);

void operator<<(::xercesc::DOMElement &, const note_type &);

void operator<<(::xercesc::DOMElement &, const notehead &);

void operator<<(::xercesc::DOMElement &, const notehead_text &);

void operator<<(::xercesc::DOMElement &, const ornaments &);

void operator<<(::xercesc::DOMElement &, const other_notation &);

void operator<<(::xercesc::DOMElement &, const pitch &);

void operator<<(::xercesc::DOMElement &, const placement_text &);

void operator<<(::xercesc::DOMElement &, const rest &);

void operator<<(::xercesc::DOMElement &, const slide &);

void operator<<(::xercesc::DOMElement &, const slur &);

void operator<<(::xercesc::DOMElement &, const stem &);

void operator<<(::xercesc::DOMElement &, const strong_accent &);

void operator<<(::xercesc::DOMElement &, const style_text &);

void operator<<(::xercesc::DOMElement &, const technical &);

void operator<<(::xercesc::DOMElement &, const text_element_data &);

void operator<<(::xercesc::DOMElement &, const text_font_color &);

void operator<<(::xercesc::DOMElement &, const tie &);

void operator<<(::xercesc::DOMElement &, const tied &);

void operator<<(::xercesc::DOMElement &, const tremolo &);

void operator<<(::xercesc::DOMElement &, const tuplet &);

void operator<<(::xercesc::DOMElement &, const tuplet_dot &);

void operator<<(::xercesc::DOMElement &, const tuplet_number &);

void operator<<(::xercesc::DOMElement &, const tuplet_portion &);

void operator<<(::xercesc::DOMElement &, const tuplet_type &);

void operator<<(::xercesc::DOMElement &, const unpitched &);

void operator<<(::xercesc::DOMElement &, const credit &);

void operator<<(::xercesc::DOMElement &, const defaults &);

void operator<<(::xercesc::DOMElement &, const empty_font &);

void operator<<(::xercesc::DOMElement &, const group_barline &);

void operator<<(::xercesc::DOMElement &, const group_name &);

void operator<<(::xercesc::DOMElement &, const group_symbol &);

void operator<<(::xercesc::DOMElement &, const lyric_font &);

void operator<<(::xercesc::DOMElement &, const lyric_language &);

void operator<<(::xercesc::DOMElement &, const opus &);

void operator<<(::xercesc::DOMElement &, const part_group &);

void operator<<(::xercesc::DOMElement &, const part_list &);

void operator<<(::xercesc::DOMElement &, const part_name &);

void operator<<(::xercesc::DOMElement &, const score_instrument &);

void operator<<(::xercesc::DOMElement &, const score_part &);

void operator<<(::xercesc::DOMElement &, const virtual_instrument &);

void operator<<(::xercesc::DOMElement &, const work &);

/**
 * @name Serialization functions for the %score-partwise document root.
 *
 * The score-partwise element is the root element for a partwise MusicXML
 * score. It includes a score-header group followed by a series of parts
 * with measures inside. The document-attributes attribute group includes
 * the version attribute.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void score_partwise_(
  ::std::ostream &os, const ::musicxml::score_partwise &x,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void score_partwise_(
  ::std::ostream &os, const ::musicxml::score_partwise &x,
  ::xml_schema::error_handler &eh,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void score_partwise_(
  ::std::ostream &os, const ::musicxml::score_partwise &x,
  ::xercesc::DOMErrorHandler &eh,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void score_partwise_(
  ::xercesc::XMLFormatTarget &ft, const ::musicxml::score_partwise &x,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void score_partwise_(
  ::xercesc::XMLFormatTarget &ft, const ::musicxml::score_partwise &x,
  ::xml_schema::error_handler &eh,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void score_partwise_(
  ::xercesc::XMLFormatTarget &ft, const ::musicxml::score_partwise &x,
  ::xercesc::DOMErrorHandler &eh,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void score_partwise_(::xercesc::DOMDocument &d,
                     const ::musicxml::score_partwise &x,
                     ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> score_partwise_(
  const ::musicxml::score_partwise &x,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  ::xml_schema::flags f = 0);

//@}

/**
 * @name Serialization functions for the %score-timewise document root.
 *
 * The score-timewise element is the root element for a timewise MusicXML
 * score. It includes a score-header group followed by a series of
 * measures with parts inside. The document-attributes attribute group
 * includes the version attribute.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void score_timewise_(
  ::std::ostream &os, const ::musicxml::score_timewise &x,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void score_timewise_(
  ::std::ostream &os, const ::musicxml::score_timewise &x,
  ::xml_schema::error_handler &eh,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void score_timewise_(
  ::std::ostream &os, const ::musicxml::score_timewise &x,
  ::xercesc::DOMErrorHandler &eh,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void score_timewise_(
  ::xercesc::XMLFormatTarget &ft, const ::musicxml::score_timewise &x,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void score_timewise_(
  ::xercesc::XMLFormatTarget &ft, const ::musicxml::score_timewise &x,
  ::xml_schema::error_handler &eh,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void score_timewise_(
  ::xercesc::XMLFormatTarget &ft, const ::musicxml::score_timewise &x,
  ::xercesc::DOMErrorHandler &eh,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void score_timewise_(::xercesc::DOMDocument &d,
                     const ::musicxml::score_timewise &x,
                     ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> score_timewise_(
  const ::musicxml::score_timewise &x,
  const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
  ::xml_schema::flags f = 0);

//@}

void operator<<(::xercesc::DOMElement &, const number_or_normal_member &);

void operator<<(::xercesc::DOMAttr &, const number_or_normal_member &);

void operator<<(::xml_schema::list_stream &, const number_or_normal_member &);

void operator<<(::xercesc::DOMElement &,
                const positive_integer_or_empty_member &);

void operator<<(::xercesc::DOMAttr &, const positive_integer_or_empty_member &);

void operator<<(::xml_schema::list_stream &,
                const positive_integer_or_empty_member &);

void operator<<(::xercesc::DOMElement &, const directive &);

void operator<<(::xercesc::DOMElement &, const score_partwise &);

void operator<<(::xercesc::DOMElement &, const score_timewise &);

void operator<<(::xercesc::DOMElement &, const part &);

void operator<<(::xercesc::DOMElement &, const measure &);

void operator<<(::xercesc::DOMElement &, const measure1 &);

void operator<<(::xercesc::DOMElement &, const part1 &);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // MUSICXML_HXX
