// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "musicxml.hxx"

namespace musicxml {
// above_below
//

above_below::above_below(value v)
: ::xml_schema::token(_xsd_above_below_literals_[v]) {}

above_below::above_below(const char *v) : ::xml_schema::token(v) {}

above_below::above_below(const ::std::string &v) : ::xml_schema::token(v) {}

above_below::above_below(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

above_below::above_below(const above_below &v, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

above_below &above_below::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_above_below_literals_[v]);

  return *this;
}

// beam_level
//

// color
//

// comma_separated_text
//

// css_font_size
//

css_font_size::css_font_size(value v)
: ::xml_schema::token(_xsd_css_font_size_literals_[v]) {}

css_font_size::css_font_size(const char *v) : ::xml_schema::token(v) {}

css_font_size::css_font_size(const ::std::string &v) : ::xml_schema::token(v) {}

css_font_size::css_font_size(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

css_font_size::css_font_size(const css_font_size &v, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

css_font_size &css_font_size::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_css_font_size_literals_[v]);

  return *this;
}

// divisions
//

// enclosure_shape
//

enclosure_shape::enclosure_shape(value v)
: ::xml_schema::token(_xsd_enclosure_shape_literals_[v]) {}

enclosure_shape::enclosure_shape(const char *v) : ::xml_schema::token(v) {}

enclosure_shape::enclosure_shape(const ::std::string &v)
: ::xml_schema::token(v) {}

enclosure_shape::enclosure_shape(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

enclosure_shape::enclosure_shape(const enclosure_shape &v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

enclosure_shape &enclosure_shape::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_enclosure_shape_literals_[v]);

  return *this;
}

// fermata_shape
//

fermata_shape::fermata_shape(value v)
: ::xml_schema::string(_xsd_fermata_shape_literals_[v]) {}

fermata_shape::fermata_shape(const char *v) : ::xml_schema::string(v) {}

fermata_shape::fermata_shape(const ::std::string &v)
: ::xml_schema::string(v) {}

fermata_shape::fermata_shape(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

fermata_shape::fermata_shape(const fermata_shape &v, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

fermata_shape &fermata_shape::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_fermata_shape_literals_[v]);

  return *this;
}

// font_size
//

font_size::font_size(const char *s) : ::xml_schema::string(s) {}

font_size::font_size(const ::std::string &s) : ::xml_schema::string(s) {}

font_size::font_size(const font_size &o, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(o, f, c) {}

// font_style
//

font_style::font_style(value v)
: ::xml_schema::token(_xsd_font_style_literals_[v]) {}

font_style::font_style(const char *v) : ::xml_schema::token(v) {}

font_style::font_style(const ::std::string &v) : ::xml_schema::token(v) {}

font_style::font_style(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

font_style::font_style(const font_style &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

font_style &font_style::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_font_style_literals_[v]);

  return *this;
}

// font_weight
//

font_weight::font_weight(value v)
: ::xml_schema::token(_xsd_font_weight_literals_[v]) {}

font_weight::font_weight(const char *v) : ::xml_schema::token(v) {}

font_weight::font_weight(const ::std::string &v) : ::xml_schema::token(v) {}

font_weight::font_weight(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

font_weight::font_weight(const font_weight &v, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

font_weight &font_weight::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_font_weight_literals_[v]);

  return *this;
}

// left_center_right
//

left_center_right::left_center_right(value v)
: ::xml_schema::token(_xsd_left_center_right_literals_[v]) {}

left_center_right::left_center_right(const char *v) : ::xml_schema::token(v) {}

left_center_right::left_center_right(const ::std::string &v)
: ::xml_schema::token(v) {}

left_center_right::left_center_right(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

left_center_right::left_center_right(const left_center_right &v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

left_center_right &left_center_right::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_left_center_right_literals_[v]);

  return *this;
}

// left_right
//

left_right::left_right(value v)
: ::xml_schema::token(_xsd_left_right_literals_[v]) {}

left_right::left_right(const char *v) : ::xml_schema::token(v) {}

left_right::left_right(const ::std::string &v) : ::xml_schema::token(v) {}

left_right::left_right(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

left_right::left_right(const left_right &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

left_right &left_right::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_left_right_literals_[v]);

  return *this;
}

// line_shape
//

line_shape::line_shape(value v)
: ::xml_schema::token(_xsd_line_shape_literals_[v]) {}

line_shape::line_shape(const char *v) : ::xml_schema::token(v) {}

line_shape::line_shape(const ::std::string &v) : ::xml_schema::token(v) {}

line_shape::line_shape(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

line_shape::line_shape(const line_shape &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

line_shape &line_shape::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_line_shape_literals_[v]);

  return *this;
}

// line_type
//

line_type::line_type(value v)
: ::xml_schema::token(_xsd_line_type_literals_[v]) {}

line_type::line_type(const char *v) : ::xml_schema::token(v) {}

line_type::line_type(const ::std::string &v) : ::xml_schema::token(v) {}

line_type::line_type(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

line_type::line_type(const line_type &v, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

line_type &line_type::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_line_type_literals_[v]);

  return *this;
}

// midi_16
//

// midi_128
//

// midi_16384
//

// mute
//

mute::mute(value v) : ::xml_schema::string(_xsd_mute_literals_[v]) {}

mute::mute(const char *v) : ::xml_schema::string(v) {}

mute::mute(const ::std::string &v) : ::xml_schema::string(v) {}

mute::mute(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

mute::mute(const mute &v, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

mute &mute::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_mute_literals_[v]);

  return *this;
}

// non_negative_decimal
//

// number_level
//

// number_of_lines
//

// number_or_normal
//

number_or_normal::number_or_normal(const char *s) : ::xml_schema::string(s) {}

number_or_normal::number_or_normal(const ::std::string &s)
: ::xml_schema::string(s) {}

number_or_normal::number_or_normal(const number_or_normal &o,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(o, f, c) {}

// over_under
//

over_under::over_under(value v)
: ::xml_schema::token(_xsd_over_under_literals_[v]) {}

over_under::over_under(const char *v) : ::xml_schema::token(v) {}

over_under::over_under(const ::std::string &v) : ::xml_schema::token(v) {}

over_under::over_under(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

over_under::over_under(const over_under &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

over_under &over_under::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_over_under_literals_[v]);

  return *this;
}

// percent
//

// positive_decimal
//

// positive_divisions
//

// positive_integer_or_empty
//

positive_integer_or_empty::positive_integer_or_empty(const char *s)
: ::xml_schema::string(s) {}

positive_integer_or_empty::positive_integer_or_empty(const ::std::string &s)
: ::xml_schema::string(s) {}

positive_integer_or_empty::positive_integer_or_empty(
  const positive_integer_or_empty &o, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(o, f, c) {}

// rotation_degrees
//

// semi_pitched
//

semi_pitched::semi_pitched(value v)
: ::xml_schema::string(_xsd_semi_pitched_literals_[v]) {}

semi_pitched::semi_pitched(const char *v) : ::xml_schema::string(v) {}

semi_pitched::semi_pitched(const ::std::string &v) : ::xml_schema::string(v) {}

semi_pitched::semi_pitched(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

semi_pitched::semi_pitched(const semi_pitched &v, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

semi_pitched &semi_pitched::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_semi_pitched_literals_[v]);

  return *this;
}

// start_note
//

start_note::start_note(value v)
: ::xml_schema::token(_xsd_start_note_literals_[v]) {}

start_note::start_note(const char *v) : ::xml_schema::token(v) {}

start_note::start_note(const ::std::string &v) : ::xml_schema::token(v) {}

start_note::start_note(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

start_note::start_note(const start_note &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

start_note &start_note::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_start_note_literals_[v]);

  return *this;
}

// start_stop
//

start_stop::start_stop(value v)
: ::xml_schema::token(_xsd_start_stop_literals_[v]) {}

start_stop::start_stop(const char *v) : ::xml_schema::token(v) {}

start_stop::start_stop(const ::std::string &v) : ::xml_schema::token(v) {}

start_stop::start_stop(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

start_stop::start_stop(const start_stop &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

start_stop &start_stop::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_start_stop_literals_[v]);

  return *this;
}

// start_stop_continue
//

start_stop_continue::start_stop_continue(value v)
: ::xml_schema::token(_xsd_start_stop_continue_literals_[v]) {}

start_stop_continue::start_stop_continue(const char *v)
: ::xml_schema::token(v) {}

start_stop_continue::start_stop_continue(const ::std::string &v)
: ::xml_schema::token(v) {}

start_stop_continue::start_stop_continue(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

start_stop_continue::start_stop_continue(const start_stop_continue &v,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

start_stop_continue &start_stop_continue::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_start_stop_continue_literals_[v]);

  return *this;
}

// start_stop_single
//

start_stop_single::start_stop_single(value v)
: ::xml_schema::token(_xsd_start_stop_single_literals_[v]) {}

start_stop_single::start_stop_single(const char *v) : ::xml_schema::token(v) {}

start_stop_single::start_stop_single(const ::std::string &v)
: ::xml_schema::token(v) {}

start_stop_single::start_stop_single(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

start_stop_single::start_stop_single(const start_stop_single &v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

start_stop_single &start_stop_single::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_start_stop_single_literals_[v]);

  return *this;
}

// string_number
//

// symbol_size
//

symbol_size::symbol_size(value v)
: ::xml_schema::token(_xsd_symbol_size_literals_[v]) {}

symbol_size::symbol_size(const char *v) : ::xml_schema::token(v) {}

symbol_size::symbol_size(const ::std::string &v) : ::xml_schema::token(v) {}

symbol_size::symbol_size(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

symbol_size::symbol_size(const symbol_size &v, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

symbol_size &symbol_size::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_symbol_size_literals_[v]);

  return *this;
}

// tenths
//

// text_direction
//

text_direction::text_direction(value v)
: ::xml_schema::token(_xsd_text_direction_literals_[v]) {}

text_direction::text_direction(const char *v) : ::xml_schema::token(v) {}

text_direction::text_direction(const ::std::string &v)
: ::xml_schema::token(v) {}

text_direction::text_direction(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

text_direction::text_direction(const text_direction &v, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

text_direction &text_direction::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_text_direction_literals_[v]);

  return *this;
}

// time_only
//

// top_bottom
//

top_bottom::top_bottom(value v)
: ::xml_schema::token(_xsd_top_bottom_literals_[v]) {}

top_bottom::top_bottom(const char *v) : ::xml_schema::token(v) {}

top_bottom::top_bottom(const ::std::string &v) : ::xml_schema::token(v) {}

top_bottom::top_bottom(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

top_bottom::top_bottom(const top_bottom &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

top_bottom &top_bottom::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_top_bottom_literals_[v]);

  return *this;
}

// trill_beats
//

// trill_step
//

trill_step::trill_step(value v)
: ::xml_schema::token(_xsd_trill_step_literals_[v]) {}

trill_step::trill_step(const char *v) : ::xml_schema::token(v) {}

trill_step::trill_step(const ::std::string &v) : ::xml_schema::token(v) {}

trill_step::trill_step(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

trill_step::trill_step(const trill_step &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

trill_step &trill_step::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_trill_step_literals_[v]);

  return *this;
}

// two_note_turn
//

two_note_turn::two_note_turn(value v)
: ::xml_schema::token(_xsd_two_note_turn_literals_[v]) {}

two_note_turn::two_note_turn(const char *v) : ::xml_schema::token(v) {}

two_note_turn::two_note_turn(const ::std::string &v) : ::xml_schema::token(v) {}

two_note_turn::two_note_turn(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

two_note_turn::two_note_turn(const two_note_turn &v, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

two_note_turn &two_note_turn::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_two_note_turn_literals_[v]);

  return *this;
}

// up_down
//

up_down::up_down(value v) : ::xml_schema::token(_xsd_up_down_literals_[v]) {}

up_down::up_down(const char *v) : ::xml_schema::token(v) {}

up_down::up_down(const ::std::string &v) : ::xml_schema::token(v) {}

up_down::up_down(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

up_down::up_down(const up_down &v, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

up_down &up_down::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_up_down_literals_[v]);

  return *this;
}

// upright_inverted
//

upright_inverted::upright_inverted(value v)
: ::xml_schema::token(_xsd_upright_inverted_literals_[v]) {}

upright_inverted::upright_inverted(const char *v) : ::xml_schema::token(v) {}

upright_inverted::upright_inverted(const ::std::string &v)
: ::xml_schema::token(v) {}

upright_inverted::upright_inverted(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

upright_inverted::upright_inverted(const upright_inverted &v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

upright_inverted &upright_inverted::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_upright_inverted_literals_[v]);

  return *this;
}

// valign
//

valign::valign(value v) : ::xml_schema::token(_xsd_valign_literals_[v]) {}

valign::valign(const char *v) : ::xml_schema::token(v) {}

valign::valign(const ::std::string &v) : ::xml_schema::token(v) {}

valign::valign(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

valign::valign(const valign &v, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

valign &valign::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_valign_literals_[v]);

  return *this;
}

// valign_image
//

valign_image::valign_image(value v)
: ::xml_schema::token(_xsd_valign_image_literals_[v]) {}

valign_image::valign_image(const char *v) : ::xml_schema::token(v) {}

valign_image::valign_image(const ::std::string &v) : ::xml_schema::token(v) {}

valign_image::valign_image(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

valign_image::valign_image(const valign_image &v, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

valign_image &valign_image::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_valign_image_literals_[v]);

  return *this;
}

// yes_no
//

yes_no::yes_no(value v) : ::xml_schema::token(_xsd_yes_no_literals_[v]) {}

yes_no::yes_no(const char *v) : ::xml_schema::token(v) {}

yes_no::yes_no(const ::std::string &v) : ::xml_schema::token(v) {}

yes_no::yes_no(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

yes_no::yes_no(const yes_no &v, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

yes_no &yes_no::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_yes_no_literals_[v]);

  return *this;
}

// yes_no_number
//

yes_no_number::yes_no_number(const char *s) : ::xml_schema::string(s) {}

yes_no_number::yes_no_number(const ::std::string &s)
: ::xml_schema::string(s) {}

yes_no_number::yes_no_number(const yes_no_number &o, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::string(o, f, c) {}

// yyyy_mm_dd
//

// cancel_location
//

cancel_location::cancel_location(value v)
: ::xml_schema::string(_xsd_cancel_location_literals_[v]) {}

cancel_location::cancel_location(const char *v) : ::xml_schema::string(v) {}

cancel_location::cancel_location(const ::std::string &v)
: ::xml_schema::string(v) {}

cancel_location::cancel_location(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

cancel_location::cancel_location(const cancel_location &v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

cancel_location &cancel_location::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_cancel_location_literals_[v]);

  return *this;
}

// clef_sign
//

clef_sign::clef_sign(value v)
: ::xml_schema::string(_xsd_clef_sign_literals_[v]) {}

clef_sign::clef_sign(const char *v) : ::xml_schema::string(v) {}

clef_sign::clef_sign(const ::std::string &v) : ::xml_schema::string(v) {}

clef_sign::clef_sign(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

clef_sign::clef_sign(const clef_sign &v, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

clef_sign &clef_sign::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_clef_sign_literals_[v]);

  return *this;
}

// fifths
//

// mode
//

// show_frets
//

show_frets::show_frets(value v)
: ::xml_schema::token(_xsd_show_frets_literals_[v]) {}

show_frets::show_frets(const char *v) : ::xml_schema::token(v) {}

show_frets::show_frets(const ::std::string &v) : ::xml_schema::token(v) {}

show_frets::show_frets(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

show_frets::show_frets(const show_frets &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

show_frets &show_frets::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_show_frets_literals_[v]);

  return *this;
}

// staff_line
//

// staff_number
//

// staff_type
//

staff_type::staff_type(value v)
: ::xml_schema::string(_xsd_staff_type_literals_[v]) {}

staff_type::staff_type(const char *v) : ::xml_schema::string(v) {}

staff_type::staff_type(const ::std::string &v) : ::xml_schema::string(v) {}

staff_type::staff_type(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

staff_type::staff_type(const staff_type &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

staff_type &staff_type::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_staff_type_literals_[v]);

  return *this;
}

// time_relation
//

time_relation::time_relation(value v)
: ::xml_schema::string(_xsd_time_relation_literals_[v]) {}

time_relation::time_relation(const char *v) : ::xml_schema::string(v) {}

time_relation::time_relation(const ::std::string &v)
: ::xml_schema::string(v) {}

time_relation::time_relation(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

time_relation::time_relation(const time_relation &v, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

time_relation &time_relation::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_time_relation_literals_[v]);

  return *this;
}

// time_separator
//

time_separator::time_separator(value v)
: ::xml_schema::token(_xsd_time_separator_literals_[v]) {}

time_separator::time_separator(const char *v) : ::xml_schema::token(v) {}

time_separator::time_separator(const ::std::string &v)
: ::xml_schema::token(v) {}

time_separator::time_separator(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

time_separator::time_separator(const time_separator &v, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

time_separator &time_separator::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_time_separator_literals_[v]);

  return *this;
}

// time_symbol
//

time_symbol::time_symbol(value v)
: ::xml_schema::token(_xsd_time_symbol_literals_[v]) {}

time_symbol::time_symbol(const char *v) : ::xml_schema::token(v) {}

time_symbol::time_symbol(const ::std::string &v) : ::xml_schema::token(v) {}

time_symbol::time_symbol(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

time_symbol::time_symbol(const time_symbol &v, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

time_symbol &time_symbol::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_time_symbol_literals_[v]);

  return *this;
}

// backward_forward
//

backward_forward::backward_forward(value v)
: ::xml_schema::token(_xsd_backward_forward_literals_[v]) {}

backward_forward::backward_forward(const char *v) : ::xml_schema::token(v) {}

backward_forward::backward_forward(const ::std::string &v)
: ::xml_schema::token(v) {}

backward_forward::backward_forward(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

backward_forward::backward_forward(const backward_forward &v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

backward_forward &backward_forward::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_backward_forward_literals_[v]);

  return *this;
}

// bar_style
//

bar_style::bar_style(value v)
: ::xml_schema::string(_xsd_bar_style_literals_[v]) {}

bar_style::bar_style(const char *v) : ::xml_schema::string(v) {}

bar_style::bar_style(const ::std::string &v) : ::xml_schema::string(v) {}

bar_style::bar_style(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

bar_style::bar_style(const bar_style &v, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

bar_style &bar_style::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_bar_style_literals_[v]);

  return *this;
}

// ending_number
//

// right_left_middle
//

right_left_middle::right_left_middle(value v)
: ::xml_schema::token(_xsd_right_left_middle_literals_[v]) {}

right_left_middle::right_left_middle(const char *v) : ::xml_schema::token(v) {}

right_left_middle::right_left_middle(const ::std::string &v)
: ::xml_schema::token(v) {}

right_left_middle::right_left_middle(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

right_left_middle::right_left_middle(const right_left_middle &v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

right_left_middle &right_left_middle::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_right_left_middle_literals_[v]);

  return *this;
}

// start_stop_discontinue
//

start_stop_discontinue::start_stop_discontinue(value v)
: ::xml_schema::token(_xsd_start_stop_discontinue_literals_[v]) {}

start_stop_discontinue::start_stop_discontinue(const char *v)
: ::xml_schema::token(v) {}

start_stop_discontinue::start_stop_discontinue(const ::std::string &v)
: ::xml_schema::token(v) {}

start_stop_discontinue::start_stop_discontinue(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

start_stop_discontinue::start_stop_discontinue(const start_stop_discontinue &v,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

start_stop_discontinue &start_stop_discontinue::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_start_stop_discontinue_literals_[v]);

  return *this;
}

// winged
//

winged::winged(value v) : ::xml_schema::token(_xsd_winged_literals_[v]) {}

winged::winged(const char *v) : ::xml_schema::token(v) {}

winged::winged(const ::std::string &v) : ::xml_schema::token(v) {}

winged::winged(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

winged::winged(const winged &v, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

winged &winged::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_winged_literals_[v]);

  return *this;
}

// accordion_middle
//

// beater_value
//

beater_value::beater_value(value v)
: ::xml_schema::string(_xsd_beater_value_literals_[v]) {}

beater_value::beater_value(const char *v) : ::xml_schema::string(v) {}

beater_value::beater_value(const ::std::string &v) : ::xml_schema::string(v) {}

beater_value::beater_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

beater_value::beater_value(const beater_value &v, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

beater_value &beater_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_beater_value_literals_[v]);

  return *this;
}

// degree_symbol_value
//

degree_symbol_value::degree_symbol_value(value v)
: ::xml_schema::token(_xsd_degree_symbol_value_literals_[v]) {}

degree_symbol_value::degree_symbol_value(const char *v)
: ::xml_schema::token(v) {}

degree_symbol_value::degree_symbol_value(const ::std::string &v)
: ::xml_schema::token(v) {}

degree_symbol_value::degree_symbol_value(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

degree_symbol_value::degree_symbol_value(const degree_symbol_value &v,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

degree_symbol_value &degree_symbol_value::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_degree_symbol_value_literals_[v]);

  return *this;
}

// degree_type_value
//

degree_type_value::degree_type_value(value v)
: ::xml_schema::string(_xsd_degree_type_value_literals_[v]) {}

degree_type_value::degree_type_value(const char *v) : ::xml_schema::string(v) {}

degree_type_value::degree_type_value(const ::std::string &v)
: ::xml_schema::string(v) {}

degree_type_value::degree_type_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

degree_type_value::degree_type_value(const degree_type_value &v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

degree_type_value &degree_type_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_degree_type_value_literals_[v]);

  return *this;
}

// effect
//

effect::effect(value v) : ::xml_schema::string(_xsd_effect_literals_[v]) {}

effect::effect(const char *v) : ::xml_schema::string(v) {}

effect::effect(const ::std::string &v) : ::xml_schema::string(v) {}

effect::effect(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

effect::effect(const effect &v, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

effect &effect::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_effect_literals_[v]);

  return *this;
}

// glass
//

glass::glass(value v) : ::xml_schema::string(_xsd_glass_literals_[v]) {}

glass::glass(const char *v) : ::xml_schema::string(v) {}

glass::glass(const ::std::string &v) : ::xml_schema::string(v) {}

glass::glass(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

glass::glass(const glass &v, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

glass &glass::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_glass_literals_[v]);

  return *this;
}

// harmony_type
//

harmony_type::harmony_type(value v)
: ::xml_schema::token(_xsd_harmony_type_literals_[v]) {}

harmony_type::harmony_type(const char *v) : ::xml_schema::token(v) {}

harmony_type::harmony_type(const ::std::string &v) : ::xml_schema::token(v) {}

harmony_type::harmony_type(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

harmony_type::harmony_type(const harmony_type &v, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

harmony_type &harmony_type::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_harmony_type_literals_[v]);

  return *this;
}

// kind_value
//

kind_value::kind_value(value v)
: ::xml_schema::string(_xsd_kind_value_literals_[v]) {}

kind_value::kind_value(const char *v) : ::xml_schema::string(v) {}

kind_value::kind_value(const ::std::string &v) : ::xml_schema::string(v) {}

kind_value::kind_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

kind_value::kind_value(const kind_value &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

kind_value &kind_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_kind_value_literals_[v]);

  return *this;
}

// line_end
//

line_end::line_end(value v) : ::xml_schema::token(_xsd_line_end_literals_[v]) {}

line_end::line_end(const char *v) : ::xml_schema::token(v) {}

line_end::line_end(const ::std::string &v) : ::xml_schema::token(v) {}

line_end::line_end(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

line_end::line_end(const line_end &v, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

line_end &line_end::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_line_end_literals_[v]);

  return *this;
}

// measure_numbering_value
//

measure_numbering_value::measure_numbering_value(value v)
: ::xml_schema::string(_xsd_measure_numbering_value_literals_[v]) {}

measure_numbering_value::measure_numbering_value(const char *v)
: ::xml_schema::string(v) {}

measure_numbering_value::measure_numbering_value(const ::std::string &v)
: ::xml_schema::string(v) {}

measure_numbering_value::measure_numbering_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

measure_numbering_value::measure_numbering_value(
  const measure_numbering_value &v, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

measure_numbering_value &measure_numbering_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_measure_numbering_value_literals_[v]);

  return *this;
}

// membrane
//

membrane::membrane(value v)
: ::xml_schema::string(_xsd_membrane_literals_[v]) {}

membrane::membrane(const char *v) : ::xml_schema::string(v) {}

membrane::membrane(const ::std::string &v) : ::xml_schema::string(v) {}

membrane::membrane(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

membrane::membrane(const membrane &v, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

membrane &membrane::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_membrane_literals_[v]);

  return *this;
}

// metal
//

metal::metal(value v) : ::xml_schema::string(_xsd_metal_literals_[v]) {}

metal::metal(const char *v) : ::xml_schema::string(v) {}

metal::metal(const ::std::string &v) : ::xml_schema::string(v) {}

metal::metal(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

metal::metal(const metal &v, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

metal &metal::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_metal_literals_[v]);

  return *this;
}

// on_off
//

on_off::on_off(value v) : ::xml_schema::token(_xsd_on_off_literals_[v]) {}

on_off::on_off(const char *v) : ::xml_schema::token(v) {}

on_off::on_off(const ::std::string &v) : ::xml_schema::token(v) {}

on_off::on_off(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

on_off::on_off(const on_off &v, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

on_off &on_off::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_on_off_literals_[v]);

  return *this;
}

// pitched
//

pitched::pitched(value v) : ::xml_schema::string(_xsd_pitched_literals_[v]) {}

pitched::pitched(const char *v) : ::xml_schema::string(v) {}

pitched::pitched(const ::std::string &v) : ::xml_schema::string(v) {}

pitched::pitched(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

pitched::pitched(const pitched &v, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

pitched &pitched::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_pitched_literals_[v]);

  return *this;
}

// principal_voice_symbol
//

principal_voice_symbol::principal_voice_symbol(value v)
: ::xml_schema::string(_xsd_principal_voice_symbol_literals_[v]) {}

principal_voice_symbol::principal_voice_symbol(const char *v)
: ::xml_schema::string(v) {}

principal_voice_symbol::principal_voice_symbol(const ::std::string &v)
: ::xml_schema::string(v) {}

principal_voice_symbol::principal_voice_symbol(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

principal_voice_symbol::principal_voice_symbol(const principal_voice_symbol &v,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

principal_voice_symbol &principal_voice_symbol::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_principal_voice_symbol_literals_[v]);

  return *this;
}

// start_stop_change_continue
//

start_stop_change_continue::start_stop_change_continue(value v)
: ::xml_schema::token(_xsd_start_stop_change_continue_literals_[v]) {}

start_stop_change_continue::start_stop_change_continue(const char *v)
: ::xml_schema::token(v) {}

start_stop_change_continue::start_stop_change_continue(const ::std::string &v)
: ::xml_schema::token(v) {}

start_stop_change_continue::start_stop_change_continue(
  const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

start_stop_change_continue::start_stop_change_continue(
  const start_stop_change_continue &v, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

start_stop_change_continue &start_stop_change_continue::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_start_stop_change_continue_literals_[v]);

  return *this;
}

// tip_direction
//

tip_direction::tip_direction(value v)
: ::xml_schema::string(_xsd_tip_direction_literals_[v]) {}

tip_direction::tip_direction(const char *v) : ::xml_schema::string(v) {}

tip_direction::tip_direction(const ::std::string &v)
: ::xml_schema::string(v) {}

tip_direction::tip_direction(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

tip_direction::tip_direction(const tip_direction &v, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

tip_direction &tip_direction::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_tip_direction_literals_[v]);

  return *this;
}

// stick_location
//

stick_location::stick_location(value v)
: ::xml_schema::string(_xsd_stick_location_literals_[v]) {}

stick_location::stick_location(const char *v) : ::xml_schema::string(v) {}

stick_location::stick_location(const ::std::string &v)
: ::xml_schema::string(v) {}

stick_location::stick_location(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

stick_location::stick_location(const stick_location &v, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

stick_location &stick_location::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_stick_location_literals_[v]);

  return *this;
}

// stick_material
//

stick_material::stick_material(value v)
: ::xml_schema::string(_xsd_stick_material_literals_[v]) {}

stick_material::stick_material(const char *v) : ::xml_schema::string(v) {}

stick_material::stick_material(const ::std::string &v)
: ::xml_schema::string(v) {}

stick_material::stick_material(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

stick_material::stick_material(const stick_material &v, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

stick_material &stick_material::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_stick_material_literals_[v]);

  return *this;
}

// stick_type
//

stick_type::stick_type(value v)
: ::xml_schema::string(_xsd_stick_type_literals_[v]) {}

stick_type::stick_type(const char *v) : ::xml_schema::string(v) {}

stick_type::stick_type(const ::std::string &v) : ::xml_schema::string(v) {}

stick_type::stick_type(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

stick_type::stick_type(const stick_type &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

stick_type &stick_type::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_stick_type_literals_[v]);

  return *this;
}

// up_down_stop_continue
//

up_down_stop_continue::up_down_stop_continue(value v)
: ::xml_schema::token(_xsd_up_down_stop_continue_literals_[v]) {}

up_down_stop_continue::up_down_stop_continue(const char *v)
: ::xml_schema::token(v) {}

up_down_stop_continue::up_down_stop_continue(const ::std::string &v)
: ::xml_schema::token(v) {}

up_down_stop_continue::up_down_stop_continue(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

up_down_stop_continue::up_down_stop_continue(const up_down_stop_continue &v,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

up_down_stop_continue &up_down_stop_continue::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_up_down_stop_continue_literals_[v]);

  return *this;
}

// wedge_type
//

wedge_type::wedge_type(value v)
: ::xml_schema::token(_xsd_wedge_type_literals_[v]) {}

wedge_type::wedge_type(const char *v) : ::xml_schema::token(v) {}

wedge_type::wedge_type(const ::std::string &v) : ::xml_schema::token(v) {}

wedge_type::wedge_type(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

wedge_type::wedge_type(const wedge_type &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

wedge_type &wedge_type::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_wedge_type_literals_[v]);

  return *this;
}

// wood
//

wood::wood(value v) : ::xml_schema::string(_xsd_wood_literals_[v]) {}

wood::wood(const char *v) : ::xml_schema::string(v) {}

wood::wood(const ::std::string &v) : ::xml_schema::string(v) {}

wood::wood(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

wood::wood(const wood &v, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

wood &wood::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_wood_literals_[v]);

  return *this;
}

// distance_type
//

// line_width_type
//

// margin_type
//

margin_type::margin_type(value v)
: ::xml_schema::token(_xsd_margin_type_literals_[v]) {}

margin_type::margin_type(const char *v) : ::xml_schema::token(v) {}

margin_type::margin_type(const ::std::string &v) : ::xml_schema::token(v) {}

margin_type::margin_type(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

margin_type::margin_type(const margin_type &v, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

margin_type &margin_type::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_margin_type_literals_[v]);

  return *this;
}

// millimeters
//

// note_size_type
//

note_size_type::note_size_type(value v)
: ::xml_schema::token(_xsd_note_size_type_literals_[v]) {}

note_size_type::note_size_type(const char *v) : ::xml_schema::token(v) {}

note_size_type::note_size_type(const ::std::string &v)
: ::xml_schema::token(v) {}

note_size_type::note_size_type(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

note_size_type::note_size_type(const note_size_type &v, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

note_size_type &note_size_type::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_note_size_type_literals_[v]);

  return *this;
}

// accidental_value
//

accidental_value::accidental_value(value v)
: ::xml_schema::string(_xsd_accidental_value_literals_[v]) {}

accidental_value::accidental_value(const char *v) : ::xml_schema::string(v) {}

accidental_value::accidental_value(const ::std::string &v)
: ::xml_schema::string(v) {}

accidental_value::accidental_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

accidental_value::accidental_value(const accidental_value &v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

accidental_value &accidental_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_accidental_value_literals_[v]);

  return *this;
}

// arrow_direction
//

arrow_direction::arrow_direction(value v)
: ::xml_schema::string(_xsd_arrow_direction_literals_[v]) {}

arrow_direction::arrow_direction(const char *v) : ::xml_schema::string(v) {}

arrow_direction::arrow_direction(const ::std::string &v)
: ::xml_schema::string(v) {}

arrow_direction::arrow_direction(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

arrow_direction::arrow_direction(const arrow_direction &v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

arrow_direction &arrow_direction::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_arrow_direction_literals_[v]);

  return *this;
}

// arrow_style
//

arrow_style::arrow_style(value v)
: ::xml_schema::string(_xsd_arrow_style_literals_[v]) {}

arrow_style::arrow_style(const char *v) : ::xml_schema::string(v) {}

arrow_style::arrow_style(const ::std::string &v) : ::xml_schema::string(v) {}

arrow_style::arrow_style(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

arrow_style::arrow_style(const arrow_style &v, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

arrow_style &arrow_style::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_arrow_style_literals_[v]);

  return *this;
}

// beam_value
//

beam_value::beam_value(value v)
: ::xml_schema::string(_xsd_beam_value_literals_[v]) {}

beam_value::beam_value(const char *v) : ::xml_schema::string(v) {}

beam_value::beam_value(const ::std::string &v) : ::xml_schema::string(v) {}

beam_value::beam_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

beam_value::beam_value(const beam_value &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

beam_value &beam_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_beam_value_literals_[v]);

  return *this;
}

// breath_mark_value
//

breath_mark_value::breath_mark_value(value v)
: ::xml_schema::string(_xsd_breath_mark_value_literals_[v]) {}

breath_mark_value::breath_mark_value(const char *v) : ::xml_schema::string(v) {}

breath_mark_value::breath_mark_value(const ::std::string &v)
: ::xml_schema::string(v) {}

breath_mark_value::breath_mark_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

breath_mark_value::breath_mark_value(const breath_mark_value &v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

breath_mark_value &breath_mark_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_breath_mark_value_literals_[v]);

  return *this;
}

// circular_arrow
//

circular_arrow::circular_arrow(value v)
: ::xml_schema::string(_xsd_circular_arrow_literals_[v]) {}

circular_arrow::circular_arrow(const char *v) : ::xml_schema::string(v) {}

circular_arrow::circular_arrow(const ::std::string &v)
: ::xml_schema::string(v) {}

circular_arrow::circular_arrow(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

circular_arrow::circular_arrow(const circular_arrow &v, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

circular_arrow &circular_arrow::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_circular_arrow_literals_[v]);

  return *this;
}

// fan
//

fan::fan(value v) : ::xml_schema::token(_xsd_fan_literals_[v]) {}

fan::fan(const char *v) : ::xml_schema::token(v) {}

fan::fan(const ::std::string &v) : ::xml_schema::token(v) {}

fan::fan(const ::xml_schema::token &v) : ::xml_schema::token(v) {}

fan::fan(const fan &v, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

fan &fan::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_fan_literals_[v]);

  return *this;
}

// handbell_value
//

handbell_value::handbell_value(value v)
: ::xml_schema::string(_xsd_handbell_value_literals_[v]) {}

handbell_value::handbell_value(const char *v) : ::xml_schema::string(v) {}

handbell_value::handbell_value(const ::std::string &v)
: ::xml_schema::string(v) {}

handbell_value::handbell_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

handbell_value::handbell_value(const handbell_value &v, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

handbell_value &handbell_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_handbell_value_literals_[v]);

  return *this;
}

// hole_closed_location
//

hole_closed_location::hole_closed_location(value v)
: ::xml_schema::string(_xsd_hole_closed_location_literals_[v]) {}

hole_closed_location::hole_closed_location(const char *v)
: ::xml_schema::string(v) {}

hole_closed_location::hole_closed_location(const ::std::string &v)
: ::xml_schema::string(v) {}

hole_closed_location::hole_closed_location(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

hole_closed_location::hole_closed_location(const hole_closed_location &v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

hole_closed_location &hole_closed_location::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_hole_closed_location_literals_[v]);

  return *this;
}

// hole_closed_value
//

hole_closed_value::hole_closed_value(value v)
: ::xml_schema::string(_xsd_hole_closed_value_literals_[v]) {}

hole_closed_value::hole_closed_value(const char *v) : ::xml_schema::string(v) {}

hole_closed_value::hole_closed_value(const ::std::string &v)
: ::xml_schema::string(v) {}

hole_closed_value::hole_closed_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

hole_closed_value::hole_closed_value(const hole_closed_value &v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

hole_closed_value &hole_closed_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_hole_closed_value_literals_[v]);

  return *this;
}

// note_type_value
//

note_type_value::note_type_value(value v)
: ::xml_schema::string(_xsd_note_type_value_literals_[v]) {}

note_type_value::note_type_value(const char *v) : ::xml_schema::string(v) {}

note_type_value::note_type_value(const ::std::string &v)
: ::xml_schema::string(v) {}

note_type_value::note_type_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

note_type_value::note_type_value(const note_type_value &v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

note_type_value &note_type_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_note_type_value_literals_[v]);

  return *this;
}

// notehead_value
//

notehead_value::notehead_value(value v)
: ::xml_schema::string(_xsd_notehead_value_literals_[v]) {}

notehead_value::notehead_value(const char *v) : ::xml_schema::string(v) {}

notehead_value::notehead_value(const ::std::string &v)
: ::xml_schema::string(v) {}

notehead_value::notehead_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

notehead_value::notehead_value(const notehead_value &v, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

notehead_value &notehead_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_notehead_value_literals_[v]);

  return *this;
}

// octave
//

// semitones
//

// show_tuplet
//

show_tuplet::show_tuplet(value v)
: ::xml_schema::token(_xsd_show_tuplet_literals_[v]) {}

show_tuplet::show_tuplet(const char *v) : ::xml_schema::token(v) {}

show_tuplet::show_tuplet(const ::std::string &v) : ::xml_schema::token(v) {}

show_tuplet::show_tuplet(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

show_tuplet::show_tuplet(const show_tuplet &v, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

show_tuplet &show_tuplet::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_show_tuplet_literals_[v]);

  return *this;
}

// stem_value
//

stem_value::stem_value(value v)
: ::xml_schema::string(_xsd_stem_value_literals_[v]) {}

stem_value::stem_value(const char *v) : ::xml_schema::string(v) {}

stem_value::stem_value(const ::std::string &v) : ::xml_schema::string(v) {}

stem_value::stem_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

stem_value::stem_value(const stem_value &v, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

stem_value &stem_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_stem_value_literals_[v]);

  return *this;
}

// step
//

step::step(value v) : ::xml_schema::string(_xsd_step_literals_[v]) {}

step::step(const char *v) : ::xml_schema::string(v) {}

step::step(const ::std::string &v) : ::xml_schema::string(v) {}

step::step(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

step::step(const step &v, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

step &step::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_step_literals_[v]);

  return *this;
}

// syllabic
//

syllabic::syllabic(value v)
: ::xml_schema::string(_xsd_syllabic_literals_[v]) {}

syllabic::syllabic(const char *v) : ::xml_schema::string(v) {}

syllabic::syllabic(const ::std::string &v) : ::xml_schema::string(v) {}

syllabic::syllabic(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

syllabic::syllabic(const syllabic &v, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

syllabic &syllabic::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_syllabic_literals_[v]);

  return *this;
}

// tremolo_marks
//

// group_barline_value
//

group_barline_value::group_barline_value(value v)
: ::xml_schema::string(_xsd_group_barline_value_literals_[v]) {}

group_barline_value::group_barline_value(const char *v)
: ::xml_schema::string(v) {}

group_barline_value::group_barline_value(const ::std::string &v)
: ::xml_schema::string(v) {}

group_barline_value::group_barline_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

group_barline_value::group_barline_value(const group_barline_value &v,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

group_barline_value &group_barline_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_group_barline_value_literals_[v]);

  return *this;
}

// group_symbol_value
//

group_symbol_value::group_symbol_value(value v)
: ::xml_schema::string(_xsd_group_symbol_value_literals_[v]) {}

group_symbol_value::group_symbol_value(const char *v)
: ::xml_schema::string(v) {}

group_symbol_value::group_symbol_value(const ::std::string &v)
: ::xml_schema::string(v) {}

group_symbol_value::group_symbol_value(const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

group_symbol_value::group_symbol_value(const group_symbol_value &v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

group_symbol_value &group_symbol_value::operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_group_symbol_value_literals_[v]);

  return *this;
}

// accidental_text
//

const accidental_text::justify_optional &accidental_text::justify() const {
  return this->justify_;
}

accidental_text::justify_optional &accidental_text::justify() {
  return this->justify_;
}

void accidental_text::justify(const justify_type &x) { this->justify_.set(x); }

void accidental_text::justify(const justify_optional &x) { this->justify_ = x; }

void accidental_text::justify(::std::unique_ptr<justify_type> x) {
  this->justify_.set(std::move(x));
}

const accidental_text::default_x_optional &accidental_text::default_x() const {
  return this->default_x_;
}

accidental_text::default_x_optional &accidental_text::default_x() {
  return this->default_x_;
}

void accidental_text::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void accidental_text::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void accidental_text::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const accidental_text::default_y_optional &accidental_text::default_y() const {
  return this->default_y_;
}

accidental_text::default_y_optional &accidental_text::default_y() {
  return this->default_y_;
}

void accidental_text::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void accidental_text::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void accidental_text::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const accidental_text::relative_x_optional &
accidental_text::relative_x() const {
  return this->relative_x_;
}

accidental_text::relative_x_optional &accidental_text::relative_x() {
  return this->relative_x_;
}

void accidental_text::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void accidental_text::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void accidental_text::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const accidental_text::relative_y_optional &
accidental_text::relative_y() const {
  return this->relative_y_;
}

accidental_text::relative_y_optional &accidental_text::relative_y() {
  return this->relative_y_;
}

void accidental_text::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void accidental_text::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void accidental_text::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const accidental_text::font_family_optional &
accidental_text::font_family() const {
  return this->font_family_;
}

accidental_text::font_family_optional &accidental_text::font_family() {
  return this->font_family_;
}

void accidental_text::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void accidental_text::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void accidental_text::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const accidental_text::font_style_optional &
accidental_text::font_style() const {
  return this->font_style_;
}

accidental_text::font_style_optional &accidental_text::font_style() {
  return this->font_style_;
}

void accidental_text::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void accidental_text::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void accidental_text::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const accidental_text::font_size_optional &accidental_text::font_size() const {
  return this->font_size_;
}

accidental_text::font_size_optional &accidental_text::font_size() {
  return this->font_size_;
}

void accidental_text::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void accidental_text::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void accidental_text::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const accidental_text::font_weight_optional &
accidental_text::font_weight() const {
  return this->font_weight_;
}

accidental_text::font_weight_optional &accidental_text::font_weight() {
  return this->font_weight_;
}

void accidental_text::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void accidental_text::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void accidental_text::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const accidental_text::color_optional &accidental_text::color() const {
  return this->color_;
}

accidental_text::color_optional &accidental_text::color() {
  return this->color_;
}

void accidental_text::color(const color_type &x) { this->color_.set(x); }

void accidental_text::color(const color_optional &x) { this->color_ = x; }

void accidental_text::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const accidental_text::halign_optional &accidental_text::halign() const {
  return this->halign_;
}

accidental_text::halign_optional &accidental_text::halign() {
  return this->halign_;
}

void accidental_text::halign(const halign_type &x) { this->halign_.set(x); }

void accidental_text::halign(const halign_optional &x) { this->halign_ = x; }

void accidental_text::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const accidental_text::valign_optional &accidental_text::valign() const {
  return this->valign_;
}

accidental_text::valign_optional &accidental_text::valign() {
  return this->valign_;
}

void accidental_text::valign(const valign_type &x) { this->valign_.set(x); }

void accidental_text::valign(const valign_optional &x) { this->valign_ = x; }

void accidental_text::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

const accidental_text::underline_optional &accidental_text::underline() const {
  return this->underline_;
}

accidental_text::underline_optional &accidental_text::underline() {
  return this->underline_;
}

void accidental_text::underline(const underline_type &x) {
  this->underline_.set(x);
}

void accidental_text::underline(const underline_optional &x) {
  this->underline_ = x;
}

void accidental_text::underline(::std::unique_ptr<underline_type> x) {
  this->underline_.set(std::move(x));
}

const accidental_text::overline_optional &accidental_text::overline() const {
  return this->overline_;
}

accidental_text::overline_optional &accidental_text::overline() {
  return this->overline_;
}

void accidental_text::overline(const overline_type &x) {
  this->overline_.set(x);
}

void accidental_text::overline(const overline_optional &x) {
  this->overline_ = x;
}

void accidental_text::overline(::std::unique_ptr<overline_type> x) {
  this->overline_.set(std::move(x));
}

const accidental_text::line_through_optional &
accidental_text::line_through() const {
  return this->line_through_;
}

accidental_text::line_through_optional &accidental_text::line_through() {
  return this->line_through_;
}

void accidental_text::line_through(const line_through_type &x) {
  this->line_through_.set(x);
}

void accidental_text::line_through(const line_through_optional &x) {
  this->line_through_ = x;
}

void accidental_text::line_through(::std::unique_ptr<line_through_type> x) {
  this->line_through_.set(std::move(x));
}

const accidental_text::rotation_optional &accidental_text::rotation() const {
  return this->rotation_;
}

accidental_text::rotation_optional &accidental_text::rotation() {
  return this->rotation_;
}

void accidental_text::rotation(const rotation_type &x) {
  this->rotation_.set(x);
}

void accidental_text::rotation(const rotation_optional &x) {
  this->rotation_ = x;
}

void accidental_text::rotation(::std::unique_ptr<rotation_type> x) {
  this->rotation_.set(std::move(x));
}

const accidental_text::letter_spacing_optional &
accidental_text::letter_spacing() const {
  return this->letter_spacing_;
}

accidental_text::letter_spacing_optional &accidental_text::letter_spacing() {
  return this->letter_spacing_;
}

void accidental_text::letter_spacing(const letter_spacing_type &x) {
  this->letter_spacing_.set(x);
}

void accidental_text::letter_spacing(const letter_spacing_optional &x) {
  this->letter_spacing_ = x;
}

void accidental_text::letter_spacing(::std::unique_ptr<letter_spacing_type> x) {
  this->letter_spacing_.set(std::move(x));
}

const accidental_text::line_height_optional &
accidental_text::line_height() const {
  return this->line_height_;
}

accidental_text::line_height_optional &accidental_text::line_height() {
  return this->line_height_;
}

void accidental_text::line_height(const line_height_type &x) {
  this->line_height_.set(x);
}

void accidental_text::line_height(const line_height_optional &x) {
  this->line_height_ = x;
}

void accidental_text::line_height(::std::unique_ptr<line_height_type> x) {
  this->line_height_.set(std::move(x));
}

const accidental_text::lang_optional &accidental_text::lang() const {
  return this->lang_;
}

accidental_text::lang_optional &accidental_text::lang() { return this->lang_; }

void accidental_text::lang(const lang_type &x) { this->lang_.set(x); }

void accidental_text::lang(const lang_optional &x) { this->lang_ = x; }

void accidental_text::lang(::std::unique_ptr<lang_type> x) {
  this->lang_.set(std::move(x));
}

const accidental_text::space_optional &accidental_text::space() const {
  return this->space_;
}

accidental_text::space_optional &accidental_text::space() {
  return this->space_;
}

void accidental_text::space(const space_type &x) { this->space_.set(x); }

void accidental_text::space(const space_optional &x) { this->space_ = x; }

void accidental_text::space(::std::unique_ptr<space_type> x) {
  this->space_.set(std::move(x));
}

const accidental_text::dir_optional &accidental_text::dir() const {
  return this->dir_;
}

accidental_text::dir_optional &accidental_text::dir() { return this->dir_; }

void accidental_text::dir(const dir_type &x) { this->dir_.set(x); }

void accidental_text::dir(const dir_optional &x) { this->dir_ = x; }

void accidental_text::dir(::std::unique_ptr<dir_type> x) {
  this->dir_.set(std::move(x));
}

const accidental_text::enclosure_optional &accidental_text::enclosure() const {
  return this->enclosure_;
}

accidental_text::enclosure_optional &accidental_text::enclosure() {
  return this->enclosure_;
}

void accidental_text::enclosure(const enclosure_type &x) {
  this->enclosure_.set(x);
}

void accidental_text::enclosure(const enclosure_optional &x) {
  this->enclosure_ = x;
}

void accidental_text::enclosure(::std::unique_ptr<enclosure_type> x) {
  this->enclosure_.set(std::move(x));
}

// dynamics
//

const dynamics::p_sequence &dynamics::p() const { return this->p_; }

dynamics::p_sequence &dynamics::p() { return this->p_; }

void dynamics::p(const p_sequence &s) { this->p_ = s; }

const dynamics::pp_sequence &dynamics::pp() const { return this->pp_; }

dynamics::pp_sequence &dynamics::pp() { return this->pp_; }

void dynamics::pp(const pp_sequence &s) { this->pp_ = s; }

const dynamics::ppp_sequence &dynamics::ppp() const { return this->ppp_; }

dynamics::ppp_sequence &dynamics::ppp() { return this->ppp_; }

void dynamics::ppp(const ppp_sequence &s) { this->ppp_ = s; }

const dynamics::pppp_sequence &dynamics::pppp() const { return this->pppp_; }

dynamics::pppp_sequence &dynamics::pppp() { return this->pppp_; }

void dynamics::pppp(const pppp_sequence &s) { this->pppp_ = s; }

const dynamics::ppppp_sequence &dynamics::ppppp() const { return this->ppppp_; }

dynamics::ppppp_sequence &dynamics::ppppp() { return this->ppppp_; }

void dynamics::ppppp(const ppppp_sequence &s) { this->ppppp_ = s; }

const dynamics::pppppp_sequence &dynamics::pppppp() const {
  return this->pppppp_;
}

dynamics::pppppp_sequence &dynamics::pppppp() { return this->pppppp_; }

void dynamics::pppppp(const pppppp_sequence &s) { this->pppppp_ = s; }

const dynamics::f_sequence &dynamics::f() const { return this->f_; }

dynamics::f_sequence &dynamics::f() { return this->f_; }

void dynamics::f(const f_sequence &s) { this->f_ = s; }

const dynamics::ff_sequence &dynamics::ff() const { return this->ff_; }

dynamics::ff_sequence &dynamics::ff() { return this->ff_; }

void dynamics::ff(const ff_sequence &s) { this->ff_ = s; }

const dynamics::fff_sequence &dynamics::fff() const { return this->fff_; }

dynamics::fff_sequence &dynamics::fff() { return this->fff_; }

void dynamics::fff(const fff_sequence &s) { this->fff_ = s; }

const dynamics::ffff_sequence &dynamics::ffff() const { return this->ffff_; }

dynamics::ffff_sequence &dynamics::ffff() { return this->ffff_; }

void dynamics::ffff(const ffff_sequence &s) { this->ffff_ = s; }

const dynamics::fffff_sequence &dynamics::fffff() const { return this->fffff_; }

dynamics::fffff_sequence &dynamics::fffff() { return this->fffff_; }

void dynamics::fffff(const fffff_sequence &s) { this->fffff_ = s; }

const dynamics::ffffff_sequence &dynamics::ffffff() const {
  return this->ffffff_;
}

dynamics::ffffff_sequence &dynamics::ffffff() { return this->ffffff_; }

void dynamics::ffffff(const ffffff_sequence &s) { this->ffffff_ = s; }

const dynamics::mp_sequence &dynamics::mp() const { return this->mp_; }

dynamics::mp_sequence &dynamics::mp() { return this->mp_; }

void dynamics::mp(const mp_sequence &s) { this->mp_ = s; }

const dynamics::mf_sequence &dynamics::mf() const { return this->mf_; }

dynamics::mf_sequence &dynamics::mf() { return this->mf_; }

void dynamics::mf(const mf_sequence &s) { this->mf_ = s; }

const dynamics::sf_sequence &dynamics::sf() const { return this->sf_; }

dynamics::sf_sequence &dynamics::sf() { return this->sf_; }

void dynamics::sf(const sf_sequence &s) { this->sf_ = s; }

const dynamics::sfp_sequence &dynamics::sfp() const { return this->sfp_; }

dynamics::sfp_sequence &dynamics::sfp() { return this->sfp_; }

void dynamics::sfp(const sfp_sequence &s) { this->sfp_ = s; }

const dynamics::sfpp_sequence &dynamics::sfpp() const { return this->sfpp_; }

dynamics::sfpp_sequence &dynamics::sfpp() { return this->sfpp_; }

void dynamics::sfpp(const sfpp_sequence &s) { this->sfpp_ = s; }

const dynamics::fp_sequence &dynamics::fp() const { return this->fp_; }

dynamics::fp_sequence &dynamics::fp() { return this->fp_; }

void dynamics::fp(const fp_sequence &s) { this->fp_ = s; }

const dynamics::rf_sequence &dynamics::rf() const { return this->rf_; }

dynamics::rf_sequence &dynamics::rf() { return this->rf_; }

void dynamics::rf(const rf_sequence &s) { this->rf_ = s; }

const dynamics::rfz_sequence &dynamics::rfz() const { return this->rfz_; }

dynamics::rfz_sequence &dynamics::rfz() { return this->rfz_; }

void dynamics::rfz(const rfz_sequence &s) { this->rfz_ = s; }

const dynamics::sfz_sequence &dynamics::sfz() const { return this->sfz_; }

dynamics::sfz_sequence &dynamics::sfz() { return this->sfz_; }

void dynamics::sfz(const sfz_sequence &s) { this->sfz_ = s; }

const dynamics::sffz_sequence &dynamics::sffz() const { return this->sffz_; }

dynamics::sffz_sequence &dynamics::sffz() { return this->sffz_; }

void dynamics::sffz(const sffz_sequence &s) { this->sffz_ = s; }

const dynamics::fz_sequence &dynamics::fz() const { return this->fz_; }

dynamics::fz_sequence &dynamics::fz() { return this->fz_; }

void dynamics::fz(const fz_sequence &s) { this->fz_ = s; }

const dynamics::other_dynamics_sequence &dynamics::other_dynamics() const {
  return this->other_dynamics_;
}

dynamics::other_dynamics_sequence &dynamics::other_dynamics() {
  return this->other_dynamics_;
}

void dynamics::other_dynamics(const other_dynamics_sequence &s) {
  this->other_dynamics_ = s;
}

const dynamics::default_x_optional &dynamics::default_x() const {
  return this->default_x_;
}

dynamics::default_x_optional &dynamics::default_x() { return this->default_x_; }

void dynamics::default_x(const default_x_type &x) { this->default_x_.set(x); }

void dynamics::default_x(const default_x_optional &x) { this->default_x_ = x; }

void dynamics::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const dynamics::default_y_optional &dynamics::default_y() const {
  return this->default_y_;
}

dynamics::default_y_optional &dynamics::default_y() { return this->default_y_; }

void dynamics::default_y(const default_y_type &x) { this->default_y_.set(x); }

void dynamics::default_y(const default_y_optional &x) { this->default_y_ = x; }

void dynamics::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const dynamics::relative_x_optional &dynamics::relative_x() const {
  return this->relative_x_;
}

dynamics::relative_x_optional &dynamics::relative_x() {
  return this->relative_x_;
}

void dynamics::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void dynamics::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void dynamics::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const dynamics::relative_y_optional &dynamics::relative_y() const {
  return this->relative_y_;
}

dynamics::relative_y_optional &dynamics::relative_y() {
  return this->relative_y_;
}

void dynamics::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void dynamics::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void dynamics::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const dynamics::font_family_optional &dynamics::font_family() const {
  return this->font_family_;
}

dynamics::font_family_optional &dynamics::font_family() {
  return this->font_family_;
}

void dynamics::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void dynamics::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void dynamics::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const dynamics::font_style_optional &dynamics::font_style() const {
  return this->font_style_;
}

dynamics::font_style_optional &dynamics::font_style() {
  return this->font_style_;
}

void dynamics::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void dynamics::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void dynamics::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const dynamics::font_size_optional &dynamics::font_size() const {
  return this->font_size_;
}

dynamics::font_size_optional &dynamics::font_size() { return this->font_size_; }

void dynamics::font_size(const font_size_type &x) { this->font_size_.set(x); }

void dynamics::font_size(const font_size_optional &x) { this->font_size_ = x; }

void dynamics::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const dynamics::font_weight_optional &dynamics::font_weight() const {
  return this->font_weight_;
}

dynamics::font_weight_optional &dynamics::font_weight() {
  return this->font_weight_;
}

void dynamics::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void dynamics::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void dynamics::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const dynamics::color_optional &dynamics::color() const { return this->color_; }

dynamics::color_optional &dynamics::color() { return this->color_; }

void dynamics::color(const color_type &x) { this->color_.set(x); }

void dynamics::color(const color_optional &x) { this->color_ = x; }

void dynamics::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const dynamics::halign_optional &dynamics::halign() const {
  return this->halign_;
}

dynamics::halign_optional &dynamics::halign() { return this->halign_; }

void dynamics::halign(const halign_type &x) { this->halign_.set(x); }

void dynamics::halign(const halign_optional &x) { this->halign_ = x; }

void dynamics::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const dynamics::valign_optional &dynamics::valign() const {
  return this->valign_;
}

dynamics::valign_optional &dynamics::valign() { return this->valign_; }

void dynamics::valign(const valign_type &x) { this->valign_.set(x); }

void dynamics::valign(const valign_optional &x) { this->valign_ = x; }

void dynamics::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

const dynamics::placement_optional &dynamics::placement() const {
  return this->placement_;
}

dynamics::placement_optional &dynamics::placement() { return this->placement_; }

void dynamics::placement(const placement_type &x) { this->placement_.set(x); }

void dynamics::placement(const placement_optional &x) { this->placement_ = x; }

void dynamics::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const dynamics::underline_optional &dynamics::underline() const {
  return this->underline_;
}

dynamics::underline_optional &dynamics::underline() { return this->underline_; }

void dynamics::underline(const underline_type &x) { this->underline_.set(x); }

void dynamics::underline(const underline_optional &x) { this->underline_ = x; }

void dynamics::underline(::std::unique_ptr<underline_type> x) {
  this->underline_.set(std::move(x));
}

const dynamics::overline_optional &dynamics::overline() const {
  return this->overline_;
}

dynamics::overline_optional &dynamics::overline() { return this->overline_; }

void dynamics::overline(const overline_type &x) { this->overline_.set(x); }

void dynamics::overline(const overline_optional &x) { this->overline_ = x; }

void dynamics::overline(::std::unique_ptr<overline_type> x) {
  this->overline_.set(std::move(x));
}

const dynamics::line_through_optional &dynamics::line_through() const {
  return this->line_through_;
}

dynamics::line_through_optional &dynamics::line_through() {
  return this->line_through_;
}

void dynamics::line_through(const line_through_type &x) {
  this->line_through_.set(x);
}

void dynamics::line_through(const line_through_optional &x) {
  this->line_through_ = x;
}

void dynamics::line_through(::std::unique_ptr<line_through_type> x) {
  this->line_through_.set(std::move(x));
}

const dynamics::enclosure_optional &dynamics::enclosure() const {
  return this->enclosure_;
}

dynamics::enclosure_optional &dynamics::enclosure() { return this->enclosure_; }

void dynamics::enclosure(const enclosure_type &x) { this->enclosure_.set(x); }

void dynamics::enclosure(const enclosure_optional &x) { this->enclosure_ = x; }

void dynamics::enclosure(::std::unique_ptr<enclosure_type> x) {
  this->enclosure_.set(std::move(x));
}

// empty
//

// empty_placement
//

const empty_placement::default_x_optional &empty_placement::default_x() const {
  return this->default_x_;
}

empty_placement::default_x_optional &empty_placement::default_x() {
  return this->default_x_;
}

void empty_placement::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void empty_placement::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void empty_placement::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const empty_placement::default_y_optional &empty_placement::default_y() const {
  return this->default_y_;
}

empty_placement::default_y_optional &empty_placement::default_y() {
  return this->default_y_;
}

void empty_placement::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void empty_placement::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void empty_placement::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const empty_placement::relative_x_optional &
empty_placement::relative_x() const {
  return this->relative_x_;
}

empty_placement::relative_x_optional &empty_placement::relative_x() {
  return this->relative_x_;
}

void empty_placement::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void empty_placement::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void empty_placement::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const empty_placement::relative_y_optional &
empty_placement::relative_y() const {
  return this->relative_y_;
}

empty_placement::relative_y_optional &empty_placement::relative_y() {
  return this->relative_y_;
}

void empty_placement::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void empty_placement::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void empty_placement::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const empty_placement::font_family_optional &
empty_placement::font_family() const {
  return this->font_family_;
}

empty_placement::font_family_optional &empty_placement::font_family() {
  return this->font_family_;
}

void empty_placement::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void empty_placement::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void empty_placement::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const empty_placement::font_style_optional &
empty_placement::font_style() const {
  return this->font_style_;
}

empty_placement::font_style_optional &empty_placement::font_style() {
  return this->font_style_;
}

void empty_placement::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void empty_placement::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void empty_placement::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const empty_placement::font_size_optional &empty_placement::font_size() const {
  return this->font_size_;
}

empty_placement::font_size_optional &empty_placement::font_size() {
  return this->font_size_;
}

void empty_placement::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void empty_placement::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void empty_placement::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const empty_placement::font_weight_optional &
empty_placement::font_weight() const {
  return this->font_weight_;
}

empty_placement::font_weight_optional &empty_placement::font_weight() {
  return this->font_weight_;
}

void empty_placement::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void empty_placement::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void empty_placement::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const empty_placement::color_optional &empty_placement::color() const {
  return this->color_;
}

empty_placement::color_optional &empty_placement::color() {
  return this->color_;
}

void empty_placement::color(const color_type &x) { this->color_.set(x); }

void empty_placement::color(const color_optional &x) { this->color_ = x; }

void empty_placement::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const empty_placement::placement_optional &empty_placement::placement() const {
  return this->placement_;
}

empty_placement::placement_optional &empty_placement::placement() {
  return this->placement_;
}

void empty_placement::placement(const placement_type &x) {
  this->placement_.set(x);
}

void empty_placement::placement(const placement_optional &x) {
  this->placement_ = x;
}

void empty_placement::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// empty_print_style
//

const empty_print_style::default_x_optional &
empty_print_style::default_x() const {
  return this->default_x_;
}

empty_print_style::default_x_optional &empty_print_style::default_x() {
  return this->default_x_;
}

void empty_print_style::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void empty_print_style::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void empty_print_style::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const empty_print_style::default_y_optional &
empty_print_style::default_y() const {
  return this->default_y_;
}

empty_print_style::default_y_optional &empty_print_style::default_y() {
  return this->default_y_;
}

void empty_print_style::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void empty_print_style::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void empty_print_style::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const empty_print_style::relative_x_optional &
empty_print_style::relative_x() const {
  return this->relative_x_;
}

empty_print_style::relative_x_optional &empty_print_style::relative_x() {
  return this->relative_x_;
}

void empty_print_style::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void empty_print_style::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void empty_print_style::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const empty_print_style::relative_y_optional &
empty_print_style::relative_y() const {
  return this->relative_y_;
}

empty_print_style::relative_y_optional &empty_print_style::relative_y() {
  return this->relative_y_;
}

void empty_print_style::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void empty_print_style::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void empty_print_style::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const empty_print_style::font_family_optional &
empty_print_style::font_family() const {
  return this->font_family_;
}

empty_print_style::font_family_optional &empty_print_style::font_family() {
  return this->font_family_;
}

void empty_print_style::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void empty_print_style::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void empty_print_style::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const empty_print_style::font_style_optional &
empty_print_style::font_style() const {
  return this->font_style_;
}

empty_print_style::font_style_optional &empty_print_style::font_style() {
  return this->font_style_;
}

void empty_print_style::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void empty_print_style::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void empty_print_style::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const empty_print_style::font_size_optional &
empty_print_style::font_size() const {
  return this->font_size_;
}

empty_print_style::font_size_optional &empty_print_style::font_size() {
  return this->font_size_;
}

void empty_print_style::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void empty_print_style::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void empty_print_style::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const empty_print_style::font_weight_optional &
empty_print_style::font_weight() const {
  return this->font_weight_;
}

empty_print_style::font_weight_optional &empty_print_style::font_weight() {
  return this->font_weight_;
}

void empty_print_style::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void empty_print_style::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void empty_print_style::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const empty_print_style::color_optional &empty_print_style::color() const {
  return this->color_;
}

empty_print_style::color_optional &empty_print_style::color() {
  return this->color_;
}

void empty_print_style::color(const color_type &x) { this->color_.set(x); }

void empty_print_style::color(const color_optional &x) { this->color_ = x; }

void empty_print_style::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// empty_print_style_align
//

const empty_print_style_align::default_x_optional &
empty_print_style_align::default_x() const {
  return this->default_x_;
}

empty_print_style_align::default_x_optional &
empty_print_style_align::default_x() {
  return this->default_x_;
}

void empty_print_style_align::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void empty_print_style_align::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void empty_print_style_align::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const empty_print_style_align::default_y_optional &
empty_print_style_align::default_y() const {
  return this->default_y_;
}

empty_print_style_align::default_y_optional &
empty_print_style_align::default_y() {
  return this->default_y_;
}

void empty_print_style_align::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void empty_print_style_align::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void empty_print_style_align::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const empty_print_style_align::relative_x_optional &
empty_print_style_align::relative_x() const {
  return this->relative_x_;
}

empty_print_style_align::relative_x_optional &
empty_print_style_align::relative_x() {
  return this->relative_x_;
}

void empty_print_style_align::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void empty_print_style_align::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void empty_print_style_align::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const empty_print_style_align::relative_y_optional &
empty_print_style_align::relative_y() const {
  return this->relative_y_;
}

empty_print_style_align::relative_y_optional &
empty_print_style_align::relative_y() {
  return this->relative_y_;
}

void empty_print_style_align::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void empty_print_style_align::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void empty_print_style_align::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const empty_print_style_align::font_family_optional &
empty_print_style_align::font_family() const {
  return this->font_family_;
}

empty_print_style_align::font_family_optional &
empty_print_style_align::font_family() {
  return this->font_family_;
}

void empty_print_style_align::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void empty_print_style_align::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void
empty_print_style_align::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const empty_print_style_align::font_style_optional &
empty_print_style_align::font_style() const {
  return this->font_style_;
}

empty_print_style_align::font_style_optional &
empty_print_style_align::font_style() {
  return this->font_style_;
}

void empty_print_style_align::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void empty_print_style_align::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void empty_print_style_align::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const empty_print_style_align::font_size_optional &
empty_print_style_align::font_size() const {
  return this->font_size_;
}

empty_print_style_align::font_size_optional &
empty_print_style_align::font_size() {
  return this->font_size_;
}

void empty_print_style_align::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void empty_print_style_align::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void empty_print_style_align::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const empty_print_style_align::font_weight_optional &
empty_print_style_align::font_weight() const {
  return this->font_weight_;
}

empty_print_style_align::font_weight_optional &
empty_print_style_align::font_weight() {
  return this->font_weight_;
}

void empty_print_style_align::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void empty_print_style_align::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void
empty_print_style_align::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const empty_print_style_align::color_optional &
empty_print_style_align::color() const {
  return this->color_;
}

empty_print_style_align::color_optional &empty_print_style_align::color() {
  return this->color_;
}

void empty_print_style_align::color(const color_type &x) {
  this->color_.set(x);
}

void empty_print_style_align::color(const color_optional &x) {
  this->color_ = x;
}

void empty_print_style_align::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const empty_print_style_align::halign_optional &
empty_print_style_align::halign() const {
  return this->halign_;
}

empty_print_style_align::halign_optional &empty_print_style_align::halign() {
  return this->halign_;
}

void empty_print_style_align::halign(const halign_type &x) {
  this->halign_.set(x);
}

void empty_print_style_align::halign(const halign_optional &x) {
  this->halign_ = x;
}

void empty_print_style_align::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const empty_print_style_align::valign_optional &
empty_print_style_align::valign() const {
  return this->valign_;
}

empty_print_style_align::valign_optional &empty_print_style_align::valign() {
  return this->valign_;
}

void empty_print_style_align::valign(const valign_type &x) {
  this->valign_.set(x);
}

void empty_print_style_align::valign(const valign_optional &x) {
  this->valign_ = x;
}

void empty_print_style_align::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// empty_print_object_style_align
//

const empty_print_object_style_align::print_object_optional &
empty_print_object_style_align::print_object() const {
  return this->print_object_;
}

empty_print_object_style_align::print_object_optional &
empty_print_object_style_align::print_object() {
  return this->print_object_;
}

void empty_print_object_style_align::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void
empty_print_object_style_align::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void empty_print_object_style_align::print_object(
  ::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const empty_print_object_style_align::default_x_optional &
empty_print_object_style_align::default_x() const {
  return this->default_x_;
}

empty_print_object_style_align::default_x_optional &
empty_print_object_style_align::default_x() {
  return this->default_x_;
}

void empty_print_object_style_align::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void empty_print_object_style_align::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void
empty_print_object_style_align::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const empty_print_object_style_align::default_y_optional &
empty_print_object_style_align::default_y() const {
  return this->default_y_;
}

empty_print_object_style_align::default_y_optional &
empty_print_object_style_align::default_y() {
  return this->default_y_;
}

void empty_print_object_style_align::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void empty_print_object_style_align::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void
empty_print_object_style_align::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const empty_print_object_style_align::relative_x_optional &
empty_print_object_style_align::relative_x() const {
  return this->relative_x_;
}

empty_print_object_style_align::relative_x_optional &
empty_print_object_style_align::relative_x() {
  return this->relative_x_;
}

void empty_print_object_style_align::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void empty_print_object_style_align::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void empty_print_object_style_align::relative_x(
  ::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const empty_print_object_style_align::relative_y_optional &
empty_print_object_style_align::relative_y() const {
  return this->relative_y_;
}

empty_print_object_style_align::relative_y_optional &
empty_print_object_style_align::relative_y() {
  return this->relative_y_;
}

void empty_print_object_style_align::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void empty_print_object_style_align::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void empty_print_object_style_align::relative_y(
  ::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const empty_print_object_style_align::font_family_optional &
empty_print_object_style_align::font_family() const {
  return this->font_family_;
}

empty_print_object_style_align::font_family_optional &
empty_print_object_style_align::font_family() {
  return this->font_family_;
}

void empty_print_object_style_align::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void
empty_print_object_style_align::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void empty_print_object_style_align::font_family(
  ::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const empty_print_object_style_align::font_style_optional &
empty_print_object_style_align::font_style() const {
  return this->font_style_;
}

empty_print_object_style_align::font_style_optional &
empty_print_object_style_align::font_style() {
  return this->font_style_;
}

void empty_print_object_style_align::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void empty_print_object_style_align::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void empty_print_object_style_align::font_style(
  ::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const empty_print_object_style_align::font_size_optional &
empty_print_object_style_align::font_size() const {
  return this->font_size_;
}

empty_print_object_style_align::font_size_optional &
empty_print_object_style_align::font_size() {
  return this->font_size_;
}

void empty_print_object_style_align::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void empty_print_object_style_align::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void
empty_print_object_style_align::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const empty_print_object_style_align::font_weight_optional &
empty_print_object_style_align::font_weight() const {
  return this->font_weight_;
}

empty_print_object_style_align::font_weight_optional &
empty_print_object_style_align::font_weight() {
  return this->font_weight_;
}

void empty_print_object_style_align::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void
empty_print_object_style_align::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void empty_print_object_style_align::font_weight(
  ::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const empty_print_object_style_align::color_optional &
empty_print_object_style_align::color() const {
  return this->color_;
}

empty_print_object_style_align::color_optional &
empty_print_object_style_align::color() {
  return this->color_;
}

void empty_print_object_style_align::color(const color_type &x) {
  this->color_.set(x);
}

void empty_print_object_style_align::color(const color_optional &x) {
  this->color_ = x;
}

void empty_print_object_style_align::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const empty_print_object_style_align::halign_optional &
empty_print_object_style_align::halign() const {
  return this->halign_;
}

empty_print_object_style_align::halign_optional &
empty_print_object_style_align::halign() {
  return this->halign_;
}

void empty_print_object_style_align::halign(const halign_type &x) {
  this->halign_.set(x);
}

void empty_print_object_style_align::halign(const halign_optional &x) {
  this->halign_ = x;
}

void empty_print_object_style_align::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const empty_print_object_style_align::valign_optional &
empty_print_object_style_align::valign() const {
  return this->valign_;
}

empty_print_object_style_align::valign_optional &
empty_print_object_style_align::valign() {
  return this->valign_;
}

void empty_print_object_style_align::valign(const valign_type &x) {
  this->valign_.set(x);
}

void empty_print_object_style_align::valign(const valign_optional &x) {
  this->valign_ = x;
}

void empty_print_object_style_align::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// empty_trill_sound
//

const empty_trill_sound::default_x_optional &
empty_trill_sound::default_x() const {
  return this->default_x_;
}

empty_trill_sound::default_x_optional &empty_trill_sound::default_x() {
  return this->default_x_;
}

void empty_trill_sound::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void empty_trill_sound::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void empty_trill_sound::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const empty_trill_sound::default_y_optional &
empty_trill_sound::default_y() const {
  return this->default_y_;
}

empty_trill_sound::default_y_optional &empty_trill_sound::default_y() {
  return this->default_y_;
}

void empty_trill_sound::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void empty_trill_sound::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void empty_trill_sound::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const empty_trill_sound::relative_x_optional &
empty_trill_sound::relative_x() const {
  return this->relative_x_;
}

empty_trill_sound::relative_x_optional &empty_trill_sound::relative_x() {
  return this->relative_x_;
}

void empty_trill_sound::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void empty_trill_sound::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void empty_trill_sound::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const empty_trill_sound::relative_y_optional &
empty_trill_sound::relative_y() const {
  return this->relative_y_;
}

empty_trill_sound::relative_y_optional &empty_trill_sound::relative_y() {
  return this->relative_y_;
}

void empty_trill_sound::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void empty_trill_sound::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void empty_trill_sound::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const empty_trill_sound::font_family_optional &
empty_trill_sound::font_family() const {
  return this->font_family_;
}

empty_trill_sound::font_family_optional &empty_trill_sound::font_family() {
  return this->font_family_;
}

void empty_trill_sound::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void empty_trill_sound::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void empty_trill_sound::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const empty_trill_sound::font_style_optional &
empty_trill_sound::font_style() const {
  return this->font_style_;
}

empty_trill_sound::font_style_optional &empty_trill_sound::font_style() {
  return this->font_style_;
}

void empty_trill_sound::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void empty_trill_sound::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void empty_trill_sound::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const empty_trill_sound::font_size_optional &
empty_trill_sound::font_size() const {
  return this->font_size_;
}

empty_trill_sound::font_size_optional &empty_trill_sound::font_size() {
  return this->font_size_;
}

void empty_trill_sound::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void empty_trill_sound::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void empty_trill_sound::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const empty_trill_sound::font_weight_optional &
empty_trill_sound::font_weight() const {
  return this->font_weight_;
}

empty_trill_sound::font_weight_optional &empty_trill_sound::font_weight() {
  return this->font_weight_;
}

void empty_trill_sound::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void empty_trill_sound::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void empty_trill_sound::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const empty_trill_sound::color_optional &empty_trill_sound::color() const {
  return this->color_;
}

empty_trill_sound::color_optional &empty_trill_sound::color() {
  return this->color_;
}

void empty_trill_sound::color(const color_type &x) { this->color_.set(x); }

void empty_trill_sound::color(const color_optional &x) { this->color_ = x; }

void empty_trill_sound::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const empty_trill_sound::placement_optional &
empty_trill_sound::placement() const {
  return this->placement_;
}

empty_trill_sound::placement_optional &empty_trill_sound::placement() {
  return this->placement_;
}

void empty_trill_sound::placement(const placement_type &x) {
  this->placement_.set(x);
}

void empty_trill_sound::placement(const placement_optional &x) {
  this->placement_ = x;
}

void empty_trill_sound::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const empty_trill_sound::start_note_optional &
empty_trill_sound::start_note() const {
  return this->start_note_;
}

empty_trill_sound::start_note_optional &empty_trill_sound::start_note() {
  return this->start_note_;
}

void empty_trill_sound::start_note(const start_note_type &x) {
  this->start_note_.set(x);
}

void empty_trill_sound::start_note(const start_note_optional &x) {
  this->start_note_ = x;
}

void empty_trill_sound::start_note(::std::unique_ptr<start_note_type> x) {
  this->start_note_.set(std::move(x));
}

const empty_trill_sound::trill_step_optional &
empty_trill_sound::trill_step() const {
  return this->trill_step_;
}

empty_trill_sound::trill_step_optional &empty_trill_sound::trill_step() {
  return this->trill_step_;
}

void empty_trill_sound::trill_step(const trill_step_type &x) {
  this->trill_step_.set(x);
}

void empty_trill_sound::trill_step(const trill_step_optional &x) {
  this->trill_step_ = x;
}

void empty_trill_sound::trill_step(::std::unique_ptr<trill_step_type> x) {
  this->trill_step_.set(std::move(x));
}

const empty_trill_sound::two_note_turn_optional &
empty_trill_sound::two_note_turn() const {
  return this->two_note_turn_;
}

empty_trill_sound::two_note_turn_optional &empty_trill_sound::two_note_turn() {
  return this->two_note_turn_;
}

void empty_trill_sound::two_note_turn(const two_note_turn_type &x) {
  this->two_note_turn_.set(x);
}

void empty_trill_sound::two_note_turn(const two_note_turn_optional &x) {
  this->two_note_turn_ = x;
}

void empty_trill_sound::two_note_turn(::std::unique_ptr<two_note_turn_type> x) {
  this->two_note_turn_.set(std::move(x));
}

const empty_trill_sound::accelerate_optional &
empty_trill_sound::accelerate() const {
  return this->accelerate_;
}

empty_trill_sound::accelerate_optional &empty_trill_sound::accelerate() {
  return this->accelerate_;
}

void empty_trill_sound::accelerate(const accelerate_type &x) {
  this->accelerate_.set(x);
}

void empty_trill_sound::accelerate(const accelerate_optional &x) {
  this->accelerate_ = x;
}

void empty_trill_sound::accelerate(::std::unique_ptr<accelerate_type> x) {
  this->accelerate_.set(std::move(x));
}

const empty_trill_sound::beats_optional &empty_trill_sound::beats() const {
  return this->beats_;
}

empty_trill_sound::beats_optional &empty_trill_sound::beats() {
  return this->beats_;
}

void empty_trill_sound::beats(const beats_type &x) { this->beats_.set(x); }

void empty_trill_sound::beats(const beats_optional &x) { this->beats_ = x; }

void empty_trill_sound::beats(::std::unique_ptr<beats_type> x) {
  this->beats_.set(std::move(x));
}

const empty_trill_sound::second_beat_optional &
empty_trill_sound::second_beat() const {
  return this->second_beat_;
}

empty_trill_sound::second_beat_optional &empty_trill_sound::second_beat() {
  return this->second_beat_;
}

void empty_trill_sound::second_beat(const second_beat_type &x) {
  this->second_beat_.set(x);
}

void empty_trill_sound::second_beat(const second_beat_optional &x) {
  this->second_beat_ = x;
}

void empty_trill_sound::second_beat(::std::unique_ptr<second_beat_type> x) {
  this->second_beat_.set(std::move(x));
}

const empty_trill_sound::last_beat_optional &
empty_trill_sound::last_beat() const {
  return this->last_beat_;
}

empty_trill_sound::last_beat_optional &empty_trill_sound::last_beat() {
  return this->last_beat_;
}

void empty_trill_sound::last_beat(const last_beat_type &x) {
  this->last_beat_.set(x);
}

void empty_trill_sound::last_beat(const last_beat_optional &x) {
  this->last_beat_ = x;
}

void empty_trill_sound::last_beat(::std::unique_ptr<last_beat_type> x) {
  this->last_beat_.set(std::move(x));
}

// horizontal_turn
//

const horizontal_turn::default_x_optional &horizontal_turn::default_x() const {
  return this->default_x_;
}

horizontal_turn::default_x_optional &horizontal_turn::default_x() {
  return this->default_x_;
}

void horizontal_turn::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void horizontal_turn::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void horizontal_turn::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const horizontal_turn::default_y_optional &horizontal_turn::default_y() const {
  return this->default_y_;
}

horizontal_turn::default_y_optional &horizontal_turn::default_y() {
  return this->default_y_;
}

void horizontal_turn::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void horizontal_turn::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void horizontal_turn::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const horizontal_turn::relative_x_optional &
horizontal_turn::relative_x() const {
  return this->relative_x_;
}

horizontal_turn::relative_x_optional &horizontal_turn::relative_x() {
  return this->relative_x_;
}

void horizontal_turn::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void horizontal_turn::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void horizontal_turn::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const horizontal_turn::relative_y_optional &
horizontal_turn::relative_y() const {
  return this->relative_y_;
}

horizontal_turn::relative_y_optional &horizontal_turn::relative_y() {
  return this->relative_y_;
}

void horizontal_turn::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void horizontal_turn::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void horizontal_turn::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const horizontal_turn::font_family_optional &
horizontal_turn::font_family() const {
  return this->font_family_;
}

horizontal_turn::font_family_optional &horizontal_turn::font_family() {
  return this->font_family_;
}

void horizontal_turn::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void horizontal_turn::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void horizontal_turn::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const horizontal_turn::font_style_optional &
horizontal_turn::font_style() const {
  return this->font_style_;
}

horizontal_turn::font_style_optional &horizontal_turn::font_style() {
  return this->font_style_;
}

void horizontal_turn::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void horizontal_turn::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void horizontal_turn::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const horizontal_turn::font_size_optional &horizontal_turn::font_size() const {
  return this->font_size_;
}

horizontal_turn::font_size_optional &horizontal_turn::font_size() {
  return this->font_size_;
}

void horizontal_turn::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void horizontal_turn::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void horizontal_turn::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const horizontal_turn::font_weight_optional &
horizontal_turn::font_weight() const {
  return this->font_weight_;
}

horizontal_turn::font_weight_optional &horizontal_turn::font_weight() {
  return this->font_weight_;
}

void horizontal_turn::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void horizontal_turn::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void horizontal_turn::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const horizontal_turn::color_optional &horizontal_turn::color() const {
  return this->color_;
}

horizontal_turn::color_optional &horizontal_turn::color() {
  return this->color_;
}

void horizontal_turn::color(const color_type &x) { this->color_.set(x); }

void horizontal_turn::color(const color_optional &x) { this->color_ = x; }

void horizontal_turn::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const horizontal_turn::placement_optional &horizontal_turn::placement() const {
  return this->placement_;
}

horizontal_turn::placement_optional &horizontal_turn::placement() {
  return this->placement_;
}

void horizontal_turn::placement(const placement_type &x) {
  this->placement_.set(x);
}

void horizontal_turn::placement(const placement_optional &x) {
  this->placement_ = x;
}

void horizontal_turn::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const horizontal_turn::start_note_optional &
horizontal_turn::start_note() const {
  return this->start_note_;
}

horizontal_turn::start_note_optional &horizontal_turn::start_note() {
  return this->start_note_;
}

void horizontal_turn::start_note(const start_note_type &x) {
  this->start_note_.set(x);
}

void horizontal_turn::start_note(const start_note_optional &x) {
  this->start_note_ = x;
}

void horizontal_turn::start_note(::std::unique_ptr<start_note_type> x) {
  this->start_note_.set(std::move(x));
}

const horizontal_turn::trill_step_optional &
horizontal_turn::trill_step() const {
  return this->trill_step_;
}

horizontal_turn::trill_step_optional &horizontal_turn::trill_step() {
  return this->trill_step_;
}

void horizontal_turn::trill_step(const trill_step_type &x) {
  this->trill_step_.set(x);
}

void horizontal_turn::trill_step(const trill_step_optional &x) {
  this->trill_step_ = x;
}

void horizontal_turn::trill_step(::std::unique_ptr<trill_step_type> x) {
  this->trill_step_.set(std::move(x));
}

const horizontal_turn::two_note_turn_optional &
horizontal_turn::two_note_turn() const {
  return this->two_note_turn_;
}

horizontal_turn::two_note_turn_optional &horizontal_turn::two_note_turn() {
  return this->two_note_turn_;
}

void horizontal_turn::two_note_turn(const two_note_turn_type &x) {
  this->two_note_turn_.set(x);
}

void horizontal_turn::two_note_turn(const two_note_turn_optional &x) {
  this->two_note_turn_ = x;
}

void horizontal_turn::two_note_turn(::std::unique_ptr<two_note_turn_type> x) {
  this->two_note_turn_.set(std::move(x));
}

const horizontal_turn::accelerate_optional &
horizontal_turn::accelerate() const {
  return this->accelerate_;
}

horizontal_turn::accelerate_optional &horizontal_turn::accelerate() {
  return this->accelerate_;
}

void horizontal_turn::accelerate(const accelerate_type &x) {
  this->accelerate_.set(x);
}

void horizontal_turn::accelerate(const accelerate_optional &x) {
  this->accelerate_ = x;
}

void horizontal_turn::accelerate(::std::unique_ptr<accelerate_type> x) {
  this->accelerate_.set(std::move(x));
}

const horizontal_turn::beats_optional &horizontal_turn::beats() const {
  return this->beats_;
}

horizontal_turn::beats_optional &horizontal_turn::beats() {
  return this->beats_;
}

void horizontal_turn::beats(const beats_type &x) { this->beats_.set(x); }

void horizontal_turn::beats(const beats_optional &x) { this->beats_ = x; }

void horizontal_turn::beats(::std::unique_ptr<beats_type> x) {
  this->beats_.set(std::move(x));
}

const horizontal_turn::second_beat_optional &
horizontal_turn::second_beat() const {
  return this->second_beat_;
}

horizontal_turn::second_beat_optional &horizontal_turn::second_beat() {
  return this->second_beat_;
}

void horizontal_turn::second_beat(const second_beat_type &x) {
  this->second_beat_.set(x);
}

void horizontal_turn::second_beat(const second_beat_optional &x) {
  this->second_beat_ = x;
}

void horizontal_turn::second_beat(::std::unique_ptr<second_beat_type> x) {
  this->second_beat_.set(std::move(x));
}

const horizontal_turn::last_beat_optional &horizontal_turn::last_beat() const {
  return this->last_beat_;
}

horizontal_turn::last_beat_optional &horizontal_turn::last_beat() {
  return this->last_beat_;
}

void horizontal_turn::last_beat(const last_beat_type &x) {
  this->last_beat_.set(x);
}

void horizontal_turn::last_beat(const last_beat_optional &x) {
  this->last_beat_ = x;
}

void horizontal_turn::last_beat(::std::unique_ptr<last_beat_type> x) {
  this->last_beat_.set(std::move(x));
}

const horizontal_turn::slash_optional &horizontal_turn::slash() const {
  return this->slash_;
}

horizontal_turn::slash_optional &horizontal_turn::slash() {
  return this->slash_;
}

void horizontal_turn::slash(const slash_type &x) { this->slash_.set(x); }

void horizontal_turn::slash(const slash_optional &x) { this->slash_ = x; }

void horizontal_turn::slash(::std::unique_ptr<slash_type> x) {
  this->slash_.set(std::move(x));
}

// fermata
//

const fermata::type_optional &fermata::type() const { return this->type_; }

fermata::type_optional &fermata::type() { return this->type_; }

void fermata::type(const type_type &x) { this->type_.set(x); }

void fermata::type(const type_optional &x) { this->type_ = x; }

void fermata::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const fermata::default_x_optional &fermata::default_x() const {
  return this->default_x_;
}

fermata::default_x_optional &fermata::default_x() { return this->default_x_; }

void fermata::default_x(const default_x_type &x) { this->default_x_.set(x); }

void fermata::default_x(const default_x_optional &x) { this->default_x_ = x; }

void fermata::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const fermata::default_y_optional &fermata::default_y() const {
  return this->default_y_;
}

fermata::default_y_optional &fermata::default_y() { return this->default_y_; }

void fermata::default_y(const default_y_type &x) { this->default_y_.set(x); }

void fermata::default_y(const default_y_optional &x) { this->default_y_ = x; }

void fermata::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const fermata::relative_x_optional &fermata::relative_x() const {
  return this->relative_x_;
}

fermata::relative_x_optional &fermata::relative_x() {
  return this->relative_x_;
}

void fermata::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void fermata::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void fermata::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const fermata::relative_y_optional &fermata::relative_y() const {
  return this->relative_y_;
}

fermata::relative_y_optional &fermata::relative_y() {
  return this->relative_y_;
}

void fermata::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void fermata::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void fermata::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const fermata::font_family_optional &fermata::font_family() const {
  return this->font_family_;
}

fermata::font_family_optional &fermata::font_family() {
  return this->font_family_;
}

void fermata::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void fermata::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void fermata::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const fermata::font_style_optional &fermata::font_style() const {
  return this->font_style_;
}

fermata::font_style_optional &fermata::font_style() {
  return this->font_style_;
}

void fermata::font_style(const font_style_type &x) { this->font_style_.set(x); }

void fermata::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void fermata::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const fermata::font_size_optional &fermata::font_size() const {
  return this->font_size_;
}

fermata::font_size_optional &fermata::font_size() { return this->font_size_; }

void fermata::font_size(const font_size_type &x) { this->font_size_.set(x); }

void fermata::font_size(const font_size_optional &x) { this->font_size_ = x; }

void fermata::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const fermata::font_weight_optional &fermata::font_weight() const {
  return this->font_weight_;
}

fermata::font_weight_optional &fermata::font_weight() {
  return this->font_weight_;
}

void fermata::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void fermata::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void fermata::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const fermata::color_optional &fermata::color() const { return this->color_; }

fermata::color_optional &fermata::color() { return this->color_; }

void fermata::color(const color_type &x) { this->color_.set(x); }

void fermata::color(const color_optional &x) { this->color_ = x; }

void fermata::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// fingering
//

const fingering::substitution_optional &fingering::substitution() const {
  return this->substitution_;
}

fingering::substitution_optional &fingering::substitution() {
  return this->substitution_;
}

void fingering::substitution(const substitution_type &x) {
  this->substitution_.set(x);
}

void fingering::substitution(const substitution_optional &x) {
  this->substitution_ = x;
}

void fingering::substitution(::std::unique_ptr<substitution_type> x) {
  this->substitution_.set(std::move(x));
}

const fingering::alternate_optional &fingering::alternate() const {
  return this->alternate_;
}

fingering::alternate_optional &fingering::alternate() {
  return this->alternate_;
}

void fingering::alternate(const alternate_type &x) { this->alternate_.set(x); }

void fingering::alternate(const alternate_optional &x) { this->alternate_ = x; }

void fingering::alternate(::std::unique_ptr<alternate_type> x) {
  this->alternate_.set(std::move(x));
}

const fingering::default_x_optional &fingering::default_x() const {
  return this->default_x_;
}

fingering::default_x_optional &fingering::default_x() {
  return this->default_x_;
}

void fingering::default_x(const default_x_type &x) { this->default_x_.set(x); }

void fingering::default_x(const default_x_optional &x) { this->default_x_ = x; }

void fingering::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const fingering::default_y_optional &fingering::default_y() const {
  return this->default_y_;
}

fingering::default_y_optional &fingering::default_y() {
  return this->default_y_;
}

void fingering::default_y(const default_y_type &x) { this->default_y_.set(x); }

void fingering::default_y(const default_y_optional &x) { this->default_y_ = x; }

void fingering::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const fingering::relative_x_optional &fingering::relative_x() const {
  return this->relative_x_;
}

fingering::relative_x_optional &fingering::relative_x() {
  return this->relative_x_;
}

void fingering::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void fingering::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void fingering::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const fingering::relative_y_optional &fingering::relative_y() const {
  return this->relative_y_;
}

fingering::relative_y_optional &fingering::relative_y() {
  return this->relative_y_;
}

void fingering::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void fingering::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void fingering::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const fingering::font_family_optional &fingering::font_family() const {
  return this->font_family_;
}

fingering::font_family_optional &fingering::font_family() {
  return this->font_family_;
}

void fingering::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void fingering::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void fingering::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const fingering::font_style_optional &fingering::font_style() const {
  return this->font_style_;
}

fingering::font_style_optional &fingering::font_style() {
  return this->font_style_;
}

void fingering::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void fingering::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void fingering::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const fingering::font_size_optional &fingering::font_size() const {
  return this->font_size_;
}

fingering::font_size_optional &fingering::font_size() {
  return this->font_size_;
}

void fingering::font_size(const font_size_type &x) { this->font_size_.set(x); }

void fingering::font_size(const font_size_optional &x) { this->font_size_ = x; }

void fingering::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const fingering::font_weight_optional &fingering::font_weight() const {
  return this->font_weight_;
}

fingering::font_weight_optional &fingering::font_weight() {
  return this->font_weight_;
}

void fingering::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void fingering::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void fingering::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const fingering::color_optional &fingering::color() const {
  return this->color_;
}

fingering::color_optional &fingering::color() { return this->color_; }

void fingering::color(const color_type &x) { this->color_.set(x); }

void fingering::color(const color_optional &x) { this->color_ = x; }

void fingering::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const fingering::placement_optional &fingering::placement() const {
  return this->placement_;
}

fingering::placement_optional &fingering::placement() {
  return this->placement_;
}

void fingering::placement(const placement_type &x) { this->placement_.set(x); }

void fingering::placement(const placement_optional &x) { this->placement_ = x; }

void fingering::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// formatted_text
//

const formatted_text::justify_optional &formatted_text::justify() const {
  return this->justify_;
}

formatted_text::justify_optional &formatted_text::justify() {
  return this->justify_;
}

void formatted_text::justify(const justify_type &x) { this->justify_.set(x); }

void formatted_text::justify(const justify_optional &x) { this->justify_ = x; }

void formatted_text::justify(::std::unique_ptr<justify_type> x) {
  this->justify_.set(std::move(x));
}

const formatted_text::default_x_optional &formatted_text::default_x() const {
  return this->default_x_;
}

formatted_text::default_x_optional &formatted_text::default_x() {
  return this->default_x_;
}

void formatted_text::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void formatted_text::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void formatted_text::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const formatted_text::default_y_optional &formatted_text::default_y() const {
  return this->default_y_;
}

formatted_text::default_y_optional &formatted_text::default_y() {
  return this->default_y_;
}

void formatted_text::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void formatted_text::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void formatted_text::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const formatted_text::relative_x_optional &formatted_text::relative_x() const {
  return this->relative_x_;
}

formatted_text::relative_x_optional &formatted_text::relative_x() {
  return this->relative_x_;
}

void formatted_text::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void formatted_text::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void formatted_text::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const formatted_text::relative_y_optional &formatted_text::relative_y() const {
  return this->relative_y_;
}

formatted_text::relative_y_optional &formatted_text::relative_y() {
  return this->relative_y_;
}

void formatted_text::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void formatted_text::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void formatted_text::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const formatted_text::font_family_optional &
formatted_text::font_family() const {
  return this->font_family_;
}

formatted_text::font_family_optional &formatted_text::font_family() {
  return this->font_family_;
}

void formatted_text::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void formatted_text::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void formatted_text::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const formatted_text::font_style_optional &formatted_text::font_style() const {
  return this->font_style_;
}

formatted_text::font_style_optional &formatted_text::font_style() {
  return this->font_style_;
}

void formatted_text::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void formatted_text::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void formatted_text::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const formatted_text::font_size_optional &formatted_text::font_size() const {
  return this->font_size_;
}

formatted_text::font_size_optional &formatted_text::font_size() {
  return this->font_size_;
}

void formatted_text::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void formatted_text::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void formatted_text::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const formatted_text::font_weight_optional &
formatted_text::font_weight() const {
  return this->font_weight_;
}

formatted_text::font_weight_optional &formatted_text::font_weight() {
  return this->font_weight_;
}

void formatted_text::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void formatted_text::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void formatted_text::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const formatted_text::color_optional &formatted_text::color() const {
  return this->color_;
}

formatted_text::color_optional &formatted_text::color() { return this->color_; }

void formatted_text::color(const color_type &x) { this->color_.set(x); }

void formatted_text::color(const color_optional &x) { this->color_ = x; }

void formatted_text::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const formatted_text::halign_optional &formatted_text::halign() const {
  return this->halign_;
}

formatted_text::halign_optional &formatted_text::halign() {
  return this->halign_;
}

void formatted_text::halign(const halign_type &x) { this->halign_.set(x); }

void formatted_text::halign(const halign_optional &x) { this->halign_ = x; }

void formatted_text::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const formatted_text::valign_optional &formatted_text::valign() const {
  return this->valign_;
}

formatted_text::valign_optional &formatted_text::valign() {
  return this->valign_;
}

void formatted_text::valign(const valign_type &x) { this->valign_.set(x); }

void formatted_text::valign(const valign_optional &x) { this->valign_ = x; }

void formatted_text::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

const formatted_text::underline_optional &formatted_text::underline() const {
  return this->underline_;
}

formatted_text::underline_optional &formatted_text::underline() {
  return this->underline_;
}

void formatted_text::underline(const underline_type &x) {
  this->underline_.set(x);
}

void formatted_text::underline(const underline_optional &x) {
  this->underline_ = x;
}

void formatted_text::underline(::std::unique_ptr<underline_type> x) {
  this->underline_.set(std::move(x));
}

const formatted_text::overline_optional &formatted_text::overline() const {
  return this->overline_;
}

formatted_text::overline_optional &formatted_text::overline() {
  return this->overline_;
}

void formatted_text::overline(const overline_type &x) {
  this->overline_.set(x);
}

void formatted_text::overline(const overline_optional &x) {
  this->overline_ = x;
}

void formatted_text::overline(::std::unique_ptr<overline_type> x) {
  this->overline_.set(std::move(x));
}

const formatted_text::line_through_optional &
formatted_text::line_through() const {
  return this->line_through_;
}

formatted_text::line_through_optional &formatted_text::line_through() {
  return this->line_through_;
}

void formatted_text::line_through(const line_through_type &x) {
  this->line_through_.set(x);
}

void formatted_text::line_through(const line_through_optional &x) {
  this->line_through_ = x;
}

void formatted_text::line_through(::std::unique_ptr<line_through_type> x) {
  this->line_through_.set(std::move(x));
}

const formatted_text::rotation_optional &formatted_text::rotation() const {
  return this->rotation_;
}

formatted_text::rotation_optional &formatted_text::rotation() {
  return this->rotation_;
}

void formatted_text::rotation(const rotation_type &x) {
  this->rotation_.set(x);
}

void formatted_text::rotation(const rotation_optional &x) {
  this->rotation_ = x;
}

void formatted_text::rotation(::std::unique_ptr<rotation_type> x) {
  this->rotation_.set(std::move(x));
}

const formatted_text::letter_spacing_optional &
formatted_text::letter_spacing() const {
  return this->letter_spacing_;
}

formatted_text::letter_spacing_optional &formatted_text::letter_spacing() {
  return this->letter_spacing_;
}

void formatted_text::letter_spacing(const letter_spacing_type &x) {
  this->letter_spacing_.set(x);
}

void formatted_text::letter_spacing(const letter_spacing_optional &x) {
  this->letter_spacing_ = x;
}

void formatted_text::letter_spacing(::std::unique_ptr<letter_spacing_type> x) {
  this->letter_spacing_.set(std::move(x));
}

const formatted_text::line_height_optional &
formatted_text::line_height() const {
  return this->line_height_;
}

formatted_text::line_height_optional &formatted_text::line_height() {
  return this->line_height_;
}

void formatted_text::line_height(const line_height_type &x) {
  this->line_height_.set(x);
}

void formatted_text::line_height(const line_height_optional &x) {
  this->line_height_ = x;
}

void formatted_text::line_height(::std::unique_ptr<line_height_type> x) {
  this->line_height_.set(std::move(x));
}

const formatted_text::lang_optional &formatted_text::lang() const {
  return this->lang_;
}

formatted_text::lang_optional &formatted_text::lang() { return this->lang_; }

void formatted_text::lang(const lang_type &x) { this->lang_.set(x); }

void formatted_text::lang(const lang_optional &x) { this->lang_ = x; }

void formatted_text::lang(::std::unique_ptr<lang_type> x) {
  this->lang_.set(std::move(x));
}

const formatted_text::space_optional &formatted_text::space() const {
  return this->space_;
}

formatted_text::space_optional &formatted_text::space() { return this->space_; }

void formatted_text::space(const space_type &x) { this->space_.set(x); }

void formatted_text::space(const space_optional &x) { this->space_ = x; }

void formatted_text::space(::std::unique_ptr<space_type> x) {
  this->space_.set(std::move(x));
}

const formatted_text::dir_optional &formatted_text::dir() const {
  return this->dir_;
}

formatted_text::dir_optional &formatted_text::dir() { return this->dir_; }

void formatted_text::dir(const dir_type &x) { this->dir_.set(x); }

void formatted_text::dir(const dir_optional &x) { this->dir_ = x; }

void formatted_text::dir(::std::unique_ptr<dir_type> x) {
  this->dir_.set(std::move(x));
}

const formatted_text::enclosure_optional &formatted_text::enclosure() const {
  return this->enclosure_;
}

formatted_text::enclosure_optional &formatted_text::enclosure() {
  return this->enclosure_;
}

void formatted_text::enclosure(const enclosure_type &x) {
  this->enclosure_.set(x);
}

void formatted_text::enclosure(const enclosure_optional &x) {
  this->enclosure_ = x;
}

void formatted_text::enclosure(::std::unique_ptr<enclosure_type> x) {
  this->enclosure_.set(std::move(x));
}

// fret
//

const fret::font_family_optional &fret::font_family() const {
  return this->font_family_;
}

fret::font_family_optional &fret::font_family() { return this->font_family_; }

void fret::font_family(const font_family_type &x) { this->font_family_.set(x); }

void fret::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void fret::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const fret::font_style_optional &fret::font_style() const {
  return this->font_style_;
}

fret::font_style_optional &fret::font_style() { return this->font_style_; }

void fret::font_style(const font_style_type &x) { this->font_style_.set(x); }

void fret::font_style(const font_style_optional &x) { this->font_style_ = x; }

void fret::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const fret::font_size_optional &fret::font_size() const {
  return this->font_size_;
}

fret::font_size_optional &fret::font_size() { return this->font_size_; }

void fret::font_size(const font_size_type &x) { this->font_size_.set(x); }

void fret::font_size(const font_size_optional &x) { this->font_size_ = x; }

void fret::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const fret::font_weight_optional &fret::font_weight() const {
  return this->font_weight_;
}

fret::font_weight_optional &fret::font_weight() { return this->font_weight_; }

void fret::font_weight(const font_weight_type &x) { this->font_weight_.set(x); }

void fret::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void fret::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const fret::color_optional &fret::color() const { return this->color_; }

fret::color_optional &fret::color() { return this->color_; }

void fret::color(const color_type &x) { this->color_.set(x); }

void fret::color(const color_optional &x) { this->color_ = x; }

void fret::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// level
//

const level::reference_optional &level::reference() const {
  return this->reference_;
}

level::reference_optional &level::reference() { return this->reference_; }

void level::reference(const reference_type &x) { this->reference_.set(x); }

void level::reference(const reference_optional &x) { this->reference_ = x; }

void level::reference(::std::unique_ptr<reference_type> x) {
  this->reference_.set(std::move(x));
}

const level::parentheses_optional &level::parentheses() const {
  return this->parentheses_;
}

level::parentheses_optional &level::parentheses() { return this->parentheses_; }

void level::parentheses(const parentheses_type &x) {
  this->parentheses_.set(x);
}

void level::parentheses(const parentheses_optional &x) {
  this->parentheses_ = x;
}

void level::parentheses(::std::unique_ptr<parentheses_type> x) {
  this->parentheses_.set(std::move(x));
}

const level::bracket_optional &level::bracket() const { return this->bracket_; }

level::bracket_optional &level::bracket() { return this->bracket_; }

void level::bracket(const bracket_type &x) { this->bracket_.set(x); }

void level::bracket(const bracket_optional &x) { this->bracket_ = x; }

void level::bracket(::std::unique_ptr<bracket_type> x) {
  this->bracket_.set(std::move(x));
}

const level::size_optional &level::size() const { return this->size_; }

level::size_optional &level::size() { return this->size_; }

void level::size(const size_type &x) { this->size_.set(x); }

void level::size(const size_optional &x) { this->size_ = x; }

void level::size(::std::unique_ptr<size_type> x) {
  this->size_.set(std::move(x));
}

// midi_device
//

const midi_device::port_optional &midi_device::port() const {
  return this->port_;
}

midi_device::port_optional &midi_device::port() { return this->port_; }

void midi_device::port(const port_type &x) { this->port_.set(x); }

void midi_device::port(const port_optional &x) { this->port_ = x; }

void midi_device::port(::std::unique_ptr<port_type> x) {
  this->port_.set(std::move(x));
}

const midi_device::id_optional &midi_device::id() const { return this->id_; }

midi_device::id_optional &midi_device::id() { return this->id_; }

void midi_device::id(const id_type &x) { this->id_.set(x); }

void midi_device::id(const id_optional &x) { this->id_ = x; }

void midi_device::id(::std::unique_ptr<id_type> x) {
  this->id_.set(std::move(x));
}

// midi_instrument
//

const midi_instrument::midi_channel_optional &
midi_instrument::midi_channel() const {
  return this->midi_channel_;
}

midi_instrument::midi_channel_optional &midi_instrument::midi_channel() {
  return this->midi_channel_;
}

void midi_instrument::midi_channel(const midi_channel_type &x) {
  this->midi_channel_.set(x);
}

void midi_instrument::midi_channel(const midi_channel_optional &x) {
  this->midi_channel_ = x;
}

void midi_instrument::midi_channel(::std::unique_ptr<midi_channel_type> x) {
  this->midi_channel_.set(std::move(x));
}

const midi_instrument::midi_name_optional &midi_instrument::midi_name() const {
  return this->midi_name_;
}

midi_instrument::midi_name_optional &midi_instrument::midi_name() {
  return this->midi_name_;
}

void midi_instrument::midi_name(const midi_name_type &x) {
  this->midi_name_.set(x);
}

void midi_instrument::midi_name(const midi_name_optional &x) {
  this->midi_name_ = x;
}

void midi_instrument::midi_name(::std::unique_ptr<midi_name_type> x) {
  this->midi_name_.set(std::move(x));
}

const midi_instrument::midi_bank_optional &midi_instrument::midi_bank() const {
  return this->midi_bank_;
}

midi_instrument::midi_bank_optional &midi_instrument::midi_bank() {
  return this->midi_bank_;
}

void midi_instrument::midi_bank(const midi_bank_type &x) {
  this->midi_bank_.set(x);
}

void midi_instrument::midi_bank(const midi_bank_optional &x) {
  this->midi_bank_ = x;
}

void midi_instrument::midi_bank(::std::unique_ptr<midi_bank_type> x) {
  this->midi_bank_.set(std::move(x));
}

const midi_instrument::midi_program_optional &
midi_instrument::midi_program() const {
  return this->midi_program_;
}

midi_instrument::midi_program_optional &midi_instrument::midi_program() {
  return this->midi_program_;
}

void midi_instrument::midi_program(const midi_program_type &x) {
  this->midi_program_.set(x);
}

void midi_instrument::midi_program(const midi_program_optional &x) {
  this->midi_program_ = x;
}

void midi_instrument::midi_program(::std::unique_ptr<midi_program_type> x) {
  this->midi_program_.set(std::move(x));
}

const midi_instrument::midi_unpitched_optional &
midi_instrument::midi_unpitched() const {
  return this->midi_unpitched_;
}

midi_instrument::midi_unpitched_optional &midi_instrument::midi_unpitched() {
  return this->midi_unpitched_;
}

void midi_instrument::midi_unpitched(const midi_unpitched_type &x) {
  this->midi_unpitched_.set(x);
}

void midi_instrument::midi_unpitched(const midi_unpitched_optional &x) {
  this->midi_unpitched_ = x;
}

void midi_instrument::midi_unpitched(::std::unique_ptr<midi_unpitched_type> x) {
  this->midi_unpitched_.set(std::move(x));
}

const midi_instrument::volume_optional &midi_instrument::volume() const {
  return this->volume_;
}

midi_instrument::volume_optional &midi_instrument::volume() {
  return this->volume_;
}

void midi_instrument::volume(const volume_type &x) { this->volume_.set(x); }

void midi_instrument::volume(const volume_optional &x) { this->volume_ = x; }

void midi_instrument::volume(::std::unique_ptr<volume_type> x) {
  this->volume_.set(std::move(x));
}

const midi_instrument::pan_optional &midi_instrument::pan() const {
  return this->pan_;
}

midi_instrument::pan_optional &midi_instrument::pan() { return this->pan_; }

void midi_instrument::pan(const pan_type &x) { this->pan_.set(x); }

void midi_instrument::pan(const pan_optional &x) { this->pan_ = x; }

void midi_instrument::pan(::std::unique_ptr<pan_type> x) {
  this->pan_.set(std::move(x));
}

const midi_instrument::elevation_optional &midi_instrument::elevation() const {
  return this->elevation_;
}

midi_instrument::elevation_optional &midi_instrument::elevation() {
  return this->elevation_;
}

void midi_instrument::elevation(const elevation_type &x) {
  this->elevation_.set(x);
}

void midi_instrument::elevation(const elevation_optional &x) {
  this->elevation_ = x;
}

void midi_instrument::elevation(::std::unique_ptr<elevation_type> x) {
  this->elevation_.set(std::move(x));
}

const midi_instrument::id_type &midi_instrument::id() const {
  return this->id_.get();
}

midi_instrument::id_type &midi_instrument::id() { return this->id_.get(); }

void midi_instrument::id(const id_type &x) { this->id_.set(x); }

void midi_instrument::id(::std::unique_ptr<id_type> x) {
  this->id_.set(std::move(x));
}

// name_display
//

const name_display::display_text_sequence &name_display::display_text() const {
  return this->display_text_;
}

name_display::display_text_sequence &name_display::display_text() {
  return this->display_text_;
}

void name_display::display_text(const display_text_sequence &s) {
  this->display_text_ = s;
}

const name_display::accidental_text_sequence &
name_display::accidental_text() const {
  return this->accidental_text_;
}

name_display::accidental_text_sequence &name_display::accidental_text() {
  return this->accidental_text_;
}

void name_display::accidental_text(const accidental_text_sequence &s) {
  this->accidental_text_ = s;
}

const name_display::print_object_optional &name_display::print_object() const {
  return this->print_object_;
}

name_display::print_object_optional &name_display::print_object() {
  return this->print_object_;
}

void name_display::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void name_display::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void name_display::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

// other_play
//

const other_play::type_type &other_play::type() const {
  return this->type_.get();
}

other_play::type_type &other_play::type() { return this->type_.get(); }

void other_play::type(const type_type &x) { this->type_.set(x); }

void other_play::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

// play
//

const play::ipa_sequence &play::ipa() const { return this->ipa_; }

play::ipa_sequence &play::ipa() { return this->ipa_; }

void play::ipa(const ipa_sequence &s) { this->ipa_ = s; }

const play::mute_sequence &play::mute() const { return this->mute_; }

play::mute_sequence &play::mute() { return this->mute_; }

void play::mute(const mute_sequence &s) { this->mute_ = s; }

const play::semi_pitched_sequence &play::semi_pitched() const {
  return this->semi_pitched_;
}

play::semi_pitched_sequence &play::semi_pitched() {
  return this->semi_pitched_;
}

void play::semi_pitched(const semi_pitched_sequence &s) {
  this->semi_pitched_ = s;
}

const play::other_play_sequence &play::other_play() const {
  return this->other_play_;
}

play::other_play_sequence &play::other_play() { return this->other_play_; }

void play::other_play(const other_play_sequence &s) { this->other_play_ = s; }

const play::id_optional &play::id() const { return this->id_; }

play::id_optional &play::id() { return this->id_; }

void play::id(const id_type &x) { this->id_.set(x); }

void play::id(const id_optional &x) { this->id_ = x; }

void play::id(::std::unique_ptr<id_type> x) { this->id_.set(std::move(x)); }

// string
//

const string::default_x_optional &string::default_x() const {
  return this->default_x_;
}

string::default_x_optional &string::default_x() { return this->default_x_; }

void string::default_x(const default_x_type &x) { this->default_x_.set(x); }

void string::default_x(const default_x_optional &x) { this->default_x_ = x; }

void string::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const string::default_y_optional &string::default_y() const {
  return this->default_y_;
}

string::default_y_optional &string::default_y() { return this->default_y_; }

void string::default_y(const default_y_type &x) { this->default_y_.set(x); }

void string::default_y(const default_y_optional &x) { this->default_y_ = x; }

void string::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const string::relative_x_optional &string::relative_x() const {
  return this->relative_x_;
}

string::relative_x_optional &string::relative_x() { return this->relative_x_; }

void string::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void string::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void string::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const string::relative_y_optional &string::relative_y() const {
  return this->relative_y_;
}

string::relative_y_optional &string::relative_y() { return this->relative_y_; }

void string::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void string::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void string::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const string::font_family_optional &string::font_family() const {
  return this->font_family_;
}

string::font_family_optional &string::font_family() {
  return this->font_family_;
}

void string::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void string::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void string::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const string::font_style_optional &string::font_style() const {
  return this->font_style_;
}

string::font_style_optional &string::font_style() { return this->font_style_; }

void string::font_style(const font_style_type &x) { this->font_style_.set(x); }

void string::font_style(const font_style_optional &x) { this->font_style_ = x; }

void string::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const string::font_size_optional &string::font_size() const {
  return this->font_size_;
}

string::font_size_optional &string::font_size() { return this->font_size_; }

void string::font_size(const font_size_type &x) { this->font_size_.set(x); }

void string::font_size(const font_size_optional &x) { this->font_size_ = x; }

void string::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const string::font_weight_optional &string::font_weight() const {
  return this->font_weight_;
}

string::font_weight_optional &string::font_weight() {
  return this->font_weight_;
}

void string::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void string::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void string::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const string::color_optional &string::color() const { return this->color_; }

string::color_optional &string::color() { return this->color_; }

void string::color(const color_type &x) { this->color_.set(x); }

void string::color(const color_optional &x) { this->color_ = x; }

void string::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const string::placement_optional &string::placement() const {
  return this->placement_;
}

string::placement_optional &string::placement() { return this->placement_; }

void string::placement(const placement_type &x) { this->placement_.set(x); }

void string::placement(const placement_optional &x) { this->placement_ = x; }

void string::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// typed_text
//

const typed_text::type_optional &typed_text::type() const {
  return this->type_;
}

typed_text::type_optional &typed_text::type() { return this->type_; }

void typed_text::type(const type_type &x) { this->type_.set(x); }

void typed_text::type(const type_optional &x) { this->type_ = x; }

void typed_text::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

// wavy_line
//

const wavy_line::type_type &wavy_line::type() const {
  return this->type_.get();
}

wavy_line::type_type &wavy_line::type() { return this->type_.get(); }

void wavy_line::type(const type_type &x) { this->type_.set(x); }

void wavy_line::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const wavy_line::number_optional &wavy_line::number() const {
  return this->number_;
}

wavy_line::number_optional &wavy_line::number() { return this->number_; }

void wavy_line::number(const number_type &x) { this->number_.set(x); }

void wavy_line::number(const number_optional &x) { this->number_ = x; }

void wavy_line::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const wavy_line::default_x_optional &wavy_line::default_x() const {
  return this->default_x_;
}

wavy_line::default_x_optional &wavy_line::default_x() {
  return this->default_x_;
}

void wavy_line::default_x(const default_x_type &x) { this->default_x_.set(x); }

void wavy_line::default_x(const default_x_optional &x) { this->default_x_ = x; }

void wavy_line::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const wavy_line::default_y_optional &wavy_line::default_y() const {
  return this->default_y_;
}

wavy_line::default_y_optional &wavy_line::default_y() {
  return this->default_y_;
}

void wavy_line::default_y(const default_y_type &x) { this->default_y_.set(x); }

void wavy_line::default_y(const default_y_optional &x) { this->default_y_ = x; }

void wavy_line::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const wavy_line::relative_x_optional &wavy_line::relative_x() const {
  return this->relative_x_;
}

wavy_line::relative_x_optional &wavy_line::relative_x() {
  return this->relative_x_;
}

void wavy_line::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void wavy_line::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void wavy_line::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const wavy_line::relative_y_optional &wavy_line::relative_y() const {
  return this->relative_y_;
}

wavy_line::relative_y_optional &wavy_line::relative_y() {
  return this->relative_y_;
}

void wavy_line::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void wavy_line::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void wavy_line::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const wavy_line::placement_optional &wavy_line::placement() const {
  return this->placement_;
}

wavy_line::placement_optional &wavy_line::placement() {
  return this->placement_;
}

void wavy_line::placement(const placement_type &x) { this->placement_.set(x); }

void wavy_line::placement(const placement_optional &x) { this->placement_ = x; }

void wavy_line::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const wavy_line::color_optional &wavy_line::color() const {
  return this->color_;
}

wavy_line::color_optional &wavy_line::color() { return this->color_; }

void wavy_line::color(const color_type &x) { this->color_.set(x); }

void wavy_line::color(const color_optional &x) { this->color_ = x; }

void wavy_line::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const wavy_line::start_note_optional &wavy_line::start_note() const {
  return this->start_note_;
}

wavy_line::start_note_optional &wavy_line::start_note() {
  return this->start_note_;
}

void wavy_line::start_note(const start_note_type &x) {
  this->start_note_.set(x);
}

void wavy_line::start_note(const start_note_optional &x) {
  this->start_note_ = x;
}

void wavy_line::start_note(::std::unique_ptr<start_note_type> x) {
  this->start_note_.set(std::move(x));
}

const wavy_line::trill_step_optional &wavy_line::trill_step() const {
  return this->trill_step_;
}

wavy_line::trill_step_optional &wavy_line::trill_step() {
  return this->trill_step_;
}

void wavy_line::trill_step(const trill_step_type &x) {
  this->trill_step_.set(x);
}

void wavy_line::trill_step(const trill_step_optional &x) {
  this->trill_step_ = x;
}

void wavy_line::trill_step(::std::unique_ptr<trill_step_type> x) {
  this->trill_step_.set(std::move(x));
}

const wavy_line::two_note_turn_optional &wavy_line::two_note_turn() const {
  return this->two_note_turn_;
}

wavy_line::two_note_turn_optional &wavy_line::two_note_turn() {
  return this->two_note_turn_;
}

void wavy_line::two_note_turn(const two_note_turn_type &x) {
  this->two_note_turn_.set(x);
}

void wavy_line::two_note_turn(const two_note_turn_optional &x) {
  this->two_note_turn_ = x;
}

void wavy_line::two_note_turn(::std::unique_ptr<two_note_turn_type> x) {
  this->two_note_turn_.set(std::move(x));
}

const wavy_line::accelerate_optional &wavy_line::accelerate() const {
  return this->accelerate_;
}

wavy_line::accelerate_optional &wavy_line::accelerate() {
  return this->accelerate_;
}

void wavy_line::accelerate(const accelerate_type &x) {
  this->accelerate_.set(x);
}

void wavy_line::accelerate(const accelerate_optional &x) {
  this->accelerate_ = x;
}

void wavy_line::accelerate(::std::unique_ptr<accelerate_type> x) {
  this->accelerate_.set(std::move(x));
}

const wavy_line::beats_optional &wavy_line::beats() const {
  return this->beats_;
}

wavy_line::beats_optional &wavy_line::beats() { return this->beats_; }

void wavy_line::beats(const beats_type &x) { this->beats_.set(x); }

void wavy_line::beats(const beats_optional &x) { this->beats_ = x; }

void wavy_line::beats(::std::unique_ptr<beats_type> x) {
  this->beats_.set(std::move(x));
}

const wavy_line::second_beat_optional &wavy_line::second_beat() const {
  return this->second_beat_;
}

wavy_line::second_beat_optional &wavy_line::second_beat() {
  return this->second_beat_;
}

void wavy_line::second_beat(const second_beat_type &x) {
  this->second_beat_.set(x);
}

void wavy_line::second_beat(const second_beat_optional &x) {
  this->second_beat_ = x;
}

void wavy_line::second_beat(::std::unique_ptr<second_beat_type> x) {
  this->second_beat_.set(std::move(x));
}

const wavy_line::last_beat_optional &wavy_line::last_beat() const {
  return this->last_beat_;
}

wavy_line::last_beat_optional &wavy_line::last_beat() {
  return this->last_beat_;
}

void wavy_line::last_beat(const last_beat_type &x) { this->last_beat_.set(x); }

void wavy_line::last_beat(const last_beat_optional &x) { this->last_beat_ = x; }

void wavy_line::last_beat(::std::unique_ptr<last_beat_type> x) {
  this->last_beat_.set(std::move(x));
}

// attributes
//

const attributes::footnote_optional &attributes::footnote() const {
  return this->footnote_;
}

attributes::footnote_optional &attributes::footnote() {
  return this->footnote_;
}

void attributes::footnote(const footnote_type &x) { this->footnote_.set(x); }

void attributes::footnote(const footnote_optional &x) { this->footnote_ = x; }

void attributes::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const attributes::level_optional &attributes::level() const {
  return this->level_;
}

attributes::level_optional &attributes::level() { return this->level_; }

void attributes::level(const level_type &x) { this->level_.set(x); }

void attributes::level(const level_optional &x) { this->level_ = x; }

void attributes::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const attributes::divisions_optional &attributes::divisions() const {
  return this->divisions_;
}

attributes::divisions_optional &attributes::divisions() {
  return this->divisions_;
}

void attributes::divisions(const divisions_type &x) { this->divisions_.set(x); }

void attributes::divisions(const divisions_optional &x) {
  this->divisions_ = x;
}

void attributes::divisions(::std::unique_ptr<divisions_type> x) {
  this->divisions_.set(std::move(x));
}

const attributes::key_sequence &attributes::key() const { return this->key_; }

attributes::key_sequence &attributes::key() { return this->key_; }

void attributes::key(const key_sequence &s) { this->key_ = s; }

const attributes::time_sequence &attributes::time() const {
  return this->time_;
}

attributes::time_sequence &attributes::time() { return this->time_; }

void attributes::time(const time_sequence &s) { this->time_ = s; }

const attributes::staves_optional &attributes::staves() const {
  return this->staves_;
}

attributes::staves_optional &attributes::staves() { return this->staves_; }

void attributes::staves(const staves_type &x) { this->staves_.set(x); }

void attributes::staves(const staves_optional &x) { this->staves_ = x; }

const attributes::part_symbol_optional &attributes::part_symbol() const {
  return this->part_symbol_;
}

attributes::part_symbol_optional &attributes::part_symbol() {
  return this->part_symbol_;
}

void attributes::part_symbol(const part_symbol_type &x) {
  this->part_symbol_.set(x);
}

void attributes::part_symbol(const part_symbol_optional &x) {
  this->part_symbol_ = x;
}

void attributes::part_symbol(::std::unique_ptr<part_symbol_type> x) {
  this->part_symbol_.set(std::move(x));
}

const attributes::instruments_optional &attributes::instruments() const {
  return this->instruments_;
}

attributes::instruments_optional &attributes::instruments() {
  return this->instruments_;
}

void attributes::instruments(const instruments_type &x) {
  this->instruments_.set(x);
}

void attributes::instruments(const instruments_optional &x) {
  this->instruments_ = x;
}

const attributes::clef_sequence &attributes::clef() const {
  return this->clef_;
}

attributes::clef_sequence &attributes::clef() { return this->clef_; }

void attributes::clef(const clef_sequence &s) { this->clef_ = s; }

const attributes::staff_details_sequence &attributes::staff_details() const {
  return this->staff_details_;
}

attributes::staff_details_sequence &attributes::staff_details() {
  return this->staff_details_;
}

void attributes::staff_details(const staff_details_sequence &s) {
  this->staff_details_ = s;
}

const attributes::transpose_sequence &attributes::transpose() const {
  return this->transpose_;
}

attributes::transpose_sequence &attributes::transpose() {
  return this->transpose_;
}

void attributes::transpose(const transpose_sequence &s) {
  this->transpose_ = s;
}

const attributes::directive_sequence &attributes::directive() const {
  return this->directive_;
}

attributes::directive_sequence &attributes::directive() {
  return this->directive_;
}

void attributes::directive(const directive_sequence &s) {
  this->directive_ = s;
}

const attributes::measure_style_sequence &attributes::measure_style() const {
  return this->measure_style_;
}

attributes::measure_style_sequence &attributes::measure_style() {
  return this->measure_style_;
}

void attributes::measure_style(const measure_style_sequence &s) {
  this->measure_style_ = s;
}

// beat_repeat
//

const beat_repeat::slash_type_optional &beat_repeat::slash_type() const {
  return this->slash_type_;
}

beat_repeat::slash_type_optional &beat_repeat::slash_type() {
  return this->slash_type_;
}

void beat_repeat::slash_type(const slash_type_type &x) {
  this->slash_type_.set(x);
}

void beat_repeat::slash_type(const slash_type_optional &x) {
  this->slash_type_ = x;
}

void beat_repeat::slash_type(::std::unique_ptr<slash_type_type> x) {
  this->slash_type_.set(std::move(x));
}

const beat_repeat::slash_dot_sequence &beat_repeat::slash_dot() const {
  return this->slash_dot_;
}

beat_repeat::slash_dot_sequence &beat_repeat::slash_dot() {
  return this->slash_dot_;
}

void beat_repeat::slash_dot(const slash_dot_sequence &s) {
  this->slash_dot_ = s;
}

const beat_repeat::type_type &beat_repeat::type() const {
  return this->type_.get();
}

beat_repeat::type_type &beat_repeat::type() { return this->type_.get(); }

void beat_repeat::type(const type_type &x) { this->type_.set(x); }

void beat_repeat::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const beat_repeat::slashes_optional &beat_repeat::slashes() const {
  return this->slashes_;
}

beat_repeat::slashes_optional &beat_repeat::slashes() { return this->slashes_; }

void beat_repeat::slashes(const slashes_type &x) { this->slashes_.set(x); }

void beat_repeat::slashes(const slashes_optional &x) { this->slashes_ = x; }

const beat_repeat::use_dots_optional &beat_repeat::use_dots() const {
  return this->use_dots_;
}

beat_repeat::use_dots_optional &beat_repeat::use_dots() {
  return this->use_dots_;
}

void beat_repeat::use_dots(const use_dots_type &x) { this->use_dots_.set(x); }

void beat_repeat::use_dots(const use_dots_optional &x) { this->use_dots_ = x; }

void beat_repeat::use_dots(::std::unique_ptr<use_dots_type> x) {
  this->use_dots_.set(std::move(x));
}

// cancel
//

const cancel::location_optional &cancel::location() const {
  return this->location_;
}

cancel::location_optional &cancel::location() { return this->location_; }

void cancel::location(const location_type &x) { this->location_.set(x); }

void cancel::location(const location_optional &x) { this->location_ = x; }

void cancel::location(::std::unique_ptr<location_type> x) {
  this->location_.set(std::move(x));
}

// clef
//

const clef::sign_type &clef::sign() const { return this->sign_.get(); }

clef::sign_type &clef::sign() { return this->sign_.get(); }

void clef::sign(const sign_type &x) { this->sign_.set(x); }

void clef::sign(::std::unique_ptr<sign_type> x) {
  this->sign_.set(std::move(x));
}

const clef::line_optional &clef::line() const { return this->line_; }

clef::line_optional &clef::line() { return this->line_; }

void clef::line(const line_type &x) { this->line_.set(x); }

void clef::line(const line_optional &x) { this->line_ = x; }

void clef::line(::std::unique_ptr<line_type> x) {
  this->line_.set(std::move(x));
}

const clef::clef_octave_change_optional &clef::clef_octave_change() const {
  return this->clef_octave_change_;
}

clef::clef_octave_change_optional &clef::clef_octave_change() {
  return this->clef_octave_change_;
}

void clef::clef_octave_change(const clef_octave_change_type &x) {
  this->clef_octave_change_.set(x);
}

void clef::clef_octave_change(const clef_octave_change_optional &x) {
  this->clef_octave_change_ = x;
}

const clef::number_optional &clef::number() const { return this->number_; }

clef::number_optional &clef::number() { return this->number_; }

void clef::number(const number_type &x) { this->number_.set(x); }

void clef::number(const number_optional &x) { this->number_ = x; }

void clef::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const clef::additional_optional &clef::additional() const {
  return this->additional_;
}

clef::additional_optional &clef::additional() { return this->additional_; }

void clef::additional(const additional_type &x) { this->additional_.set(x); }

void clef::additional(const additional_optional &x) { this->additional_ = x; }

void clef::additional(::std::unique_ptr<additional_type> x) {
  this->additional_.set(std::move(x));
}

const clef::size_optional &clef::size() const { return this->size_; }

clef::size_optional &clef::size() { return this->size_; }

void clef::size(const size_type &x) { this->size_.set(x); }

void clef::size(const size_optional &x) { this->size_ = x; }

void clef::size(::std::unique_ptr<size_type> x) {
  this->size_.set(std::move(x));
}

const clef::after_barline_optional &clef::after_barline() const {
  return this->after_barline_;
}

clef::after_barline_optional &clef::after_barline() {
  return this->after_barline_;
}

void clef::after_barline(const after_barline_type &x) {
  this->after_barline_.set(x);
}

void clef::after_barline(const after_barline_optional &x) {
  this->after_barline_ = x;
}

void clef::after_barline(::std::unique_ptr<after_barline_type> x) {
  this->after_barline_.set(std::move(x));
}

const clef::default_x_optional &clef::default_x() const {
  return this->default_x_;
}

clef::default_x_optional &clef::default_x() { return this->default_x_; }

void clef::default_x(const default_x_type &x) { this->default_x_.set(x); }

void clef::default_x(const default_x_optional &x) { this->default_x_ = x; }

void clef::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const clef::default_y_optional &clef::default_y() const {
  return this->default_y_;
}

clef::default_y_optional &clef::default_y() { return this->default_y_; }

void clef::default_y(const default_y_type &x) { this->default_y_.set(x); }

void clef::default_y(const default_y_optional &x) { this->default_y_ = x; }

void clef::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const clef::relative_x_optional &clef::relative_x() const {
  return this->relative_x_;
}

clef::relative_x_optional &clef::relative_x() { return this->relative_x_; }

void clef::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void clef::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void clef::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const clef::relative_y_optional &clef::relative_y() const {
  return this->relative_y_;
}

clef::relative_y_optional &clef::relative_y() { return this->relative_y_; }

void clef::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void clef::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void clef::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const clef::font_family_optional &clef::font_family() const {
  return this->font_family_;
}

clef::font_family_optional &clef::font_family() { return this->font_family_; }

void clef::font_family(const font_family_type &x) { this->font_family_.set(x); }

void clef::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void clef::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const clef::font_style_optional &clef::font_style() const {
  return this->font_style_;
}

clef::font_style_optional &clef::font_style() { return this->font_style_; }

void clef::font_style(const font_style_type &x) { this->font_style_.set(x); }

void clef::font_style(const font_style_optional &x) { this->font_style_ = x; }

void clef::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const clef::font_size_optional &clef::font_size() const {
  return this->font_size_;
}

clef::font_size_optional &clef::font_size() { return this->font_size_; }

void clef::font_size(const font_size_type &x) { this->font_size_.set(x); }

void clef::font_size(const font_size_optional &x) { this->font_size_ = x; }

void clef::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const clef::font_weight_optional &clef::font_weight() const {
  return this->font_weight_;
}

clef::font_weight_optional &clef::font_weight() { return this->font_weight_; }

void clef::font_weight(const font_weight_type &x) { this->font_weight_.set(x); }

void clef::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void clef::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const clef::color_optional &clef::color() const { return this->color_; }

clef::color_optional &clef::color() { return this->color_; }

void clef::color(const color_type &x) { this->color_.set(x); }

void clef::color(const color_optional &x) { this->color_ = x; }

void clef::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const clef::print_object_optional &clef::print_object() const {
  return this->print_object_;
}

clef::print_object_optional &clef::print_object() {
  return this->print_object_;
}

void clef::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void clef::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void clef::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

// interchangeable
//

const interchangeable::time_relation_optional &
interchangeable::time_relation() const {
  return this->time_relation_;
}

interchangeable::time_relation_optional &interchangeable::time_relation() {
  return this->time_relation_;
}

void interchangeable::time_relation(const time_relation_type &x) {
  this->time_relation_.set(x);
}

void interchangeable::time_relation(const time_relation_optional &x) {
  this->time_relation_ = x;
}

void interchangeable::time_relation(::std::unique_ptr<time_relation_type> x) {
  this->time_relation_.set(std::move(x));
}

const interchangeable::beats_sequence &interchangeable::beats() const {
  return this->beats_;
}

interchangeable::beats_sequence &interchangeable::beats() {
  return this->beats_;
}

void interchangeable::beats(const beats_sequence &s) { this->beats_ = s; }

const interchangeable::beat_type_sequence &interchangeable::beat_type() const {
  return this->beat_type_;
}

interchangeable::beat_type_sequence &interchangeable::beat_type() {
  return this->beat_type_;
}

void interchangeable::beat_type(const beat_type_sequence &s) {
  this->beat_type_ = s;
}

const interchangeable::symbol_optional &interchangeable::symbol() const {
  return this->symbol_;
}

interchangeable::symbol_optional &interchangeable::symbol() {
  return this->symbol_;
}

void interchangeable::symbol(const symbol_type &x) { this->symbol_.set(x); }

void interchangeable::symbol(const symbol_optional &x) { this->symbol_ = x; }

void interchangeable::symbol(::std::unique_ptr<symbol_type> x) {
  this->symbol_.set(std::move(x));
}

const interchangeable::separator_optional &interchangeable::separator() const {
  return this->separator_;
}

interchangeable::separator_optional &interchangeable::separator() {
  return this->separator_;
}

void interchangeable::separator(const separator_type &x) {
  this->separator_.set(x);
}

void interchangeable::separator(const separator_optional &x) {
  this->separator_ = x;
}

void interchangeable::separator(::std::unique_ptr<separator_type> x) {
  this->separator_.set(std::move(x));
}

// key
//

const key::cancel_optional &key::cancel() const { return this->cancel_; }

key::cancel_optional &key::cancel() { return this->cancel_; }

void key::cancel(const cancel_type &x) { this->cancel_.set(x); }

void key::cancel(const cancel_optional &x) { this->cancel_ = x; }

void key::cancel(::std::unique_ptr<cancel_type> x) {
  this->cancel_.set(std::move(x));
}

const key::fifths_optional &key::fifths() const { return this->fifths_; }

key::fifths_optional &key::fifths() { return this->fifths_; }

void key::fifths(const fifths_type &x) { this->fifths_.set(x); }

void key::fifths(const fifths_optional &x) { this->fifths_ = x; }

void key::fifths(::std::unique_ptr<fifths_type> x) {
  this->fifths_.set(std::move(x));
}

const key::mode_optional &key::mode() const { return this->mode_; }

key::mode_optional &key::mode() { return this->mode_; }

void key::mode(const mode_type &x) { this->mode_.set(x); }

void key::mode(const mode_optional &x) { this->mode_ = x; }

void key::mode(::std::unique_ptr<mode_type> x) {
  this->mode_.set(std::move(x));
}

const key::key_step_sequence &key::key_step() const { return this->key_step_; }

key::key_step_sequence &key::key_step() { return this->key_step_; }

void key::key_step(const key_step_sequence &s) { this->key_step_ = s; }

const key::key_alter_sequence &key::key_alter() const {
  return this->key_alter_;
}

key::key_alter_sequence &key::key_alter() { return this->key_alter_; }

void key::key_alter(const key_alter_sequence &s) { this->key_alter_ = s; }

const key::key_accidental_sequence &key::key_accidental() const {
  return this->key_accidental_;
}

key::key_accidental_sequence &key::key_accidental() {
  return this->key_accidental_;
}

void key::key_accidental(const key_accidental_sequence &s) {
  this->key_accidental_ = s;
}

const key::key_octave_sequence &key::key_octave() const {
  return this->key_octave_;
}

key::key_octave_sequence &key::key_octave() { return this->key_octave_; }

void key::key_octave(const key_octave_sequence &s) { this->key_octave_ = s; }

const key::number_optional &key::number() const { return this->number_; }

key::number_optional &key::number() { return this->number_; }

void key::number(const number_type &x) { this->number_.set(x); }

void key::number(const number_optional &x) { this->number_ = x; }

void key::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const key::default_x_optional &key::default_x() const {
  return this->default_x_;
}

key::default_x_optional &key::default_x() { return this->default_x_; }

void key::default_x(const default_x_type &x) { this->default_x_.set(x); }

void key::default_x(const default_x_optional &x) { this->default_x_ = x; }

void key::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const key::default_y_optional &key::default_y() const {
  return this->default_y_;
}

key::default_y_optional &key::default_y() { return this->default_y_; }

void key::default_y(const default_y_type &x) { this->default_y_.set(x); }

void key::default_y(const default_y_optional &x) { this->default_y_ = x; }

void key::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const key::relative_x_optional &key::relative_x() const {
  return this->relative_x_;
}

key::relative_x_optional &key::relative_x() { return this->relative_x_; }

void key::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void key::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void key::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const key::relative_y_optional &key::relative_y() const {
  return this->relative_y_;
}

key::relative_y_optional &key::relative_y() { return this->relative_y_; }

void key::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void key::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void key::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const key::font_family_optional &key::font_family() const {
  return this->font_family_;
}

key::font_family_optional &key::font_family() { return this->font_family_; }

void key::font_family(const font_family_type &x) { this->font_family_.set(x); }

void key::font_family(const font_family_optional &x) { this->font_family_ = x; }

void key::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const key::font_style_optional &key::font_style() const {
  return this->font_style_;
}

key::font_style_optional &key::font_style() { return this->font_style_; }

void key::font_style(const font_style_type &x) { this->font_style_.set(x); }

void key::font_style(const font_style_optional &x) { this->font_style_ = x; }

void key::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const key::font_size_optional &key::font_size() const {
  return this->font_size_;
}

key::font_size_optional &key::font_size() { return this->font_size_; }

void key::font_size(const font_size_type &x) { this->font_size_.set(x); }

void key::font_size(const font_size_optional &x) { this->font_size_ = x; }

void key::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const key::font_weight_optional &key::font_weight() const {
  return this->font_weight_;
}

key::font_weight_optional &key::font_weight() { return this->font_weight_; }

void key::font_weight(const font_weight_type &x) { this->font_weight_.set(x); }

void key::font_weight(const font_weight_optional &x) { this->font_weight_ = x; }

void key::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const key::color_optional &key::color() const { return this->color_; }

key::color_optional &key::color() { return this->color_; }

void key::color(const color_type &x) { this->color_.set(x); }

void key::color(const color_optional &x) { this->color_ = x; }

void key::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const key::print_object_optional &key::print_object() const {
  return this->print_object_;
}

key::print_object_optional &key::print_object() { return this->print_object_; }

void key::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void key::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void key::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

// key_octave
//

const key_octave::number_type &key_octave::number() const {
  return this->number_.get();
}

key_octave::number_type &key_octave::number() { return this->number_.get(); }

void key_octave::number(const number_type &x) { this->number_.set(x); }

const key_octave::cancel_optional &key_octave::cancel() const {
  return this->cancel_;
}

key_octave::cancel_optional &key_octave::cancel() { return this->cancel_; }

void key_octave::cancel(const cancel_type &x) { this->cancel_.set(x); }

void key_octave::cancel(const cancel_optional &x) { this->cancel_ = x; }

void key_octave::cancel(::std::unique_ptr<cancel_type> x) {
  this->cancel_.set(std::move(x));
}

// measure_repeat
//

const measure_repeat::type_type &measure_repeat::type() const {
  return this->type_.get();
}

measure_repeat::type_type &measure_repeat::type() { return this->type_.get(); }

void measure_repeat::type(const type_type &x) { this->type_.set(x); }

void measure_repeat::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const measure_repeat::slashes_optional &measure_repeat::slashes() const {
  return this->slashes_;
}

measure_repeat::slashes_optional &measure_repeat::slashes() {
  return this->slashes_;
}

void measure_repeat::slashes(const slashes_type &x) { this->slashes_.set(x); }

void measure_repeat::slashes(const slashes_optional &x) { this->slashes_ = x; }

// measure_style
//

const measure_style::multiple_rest_optional &
measure_style::multiple_rest() const {
  return this->multiple_rest_;
}

measure_style::multiple_rest_optional &measure_style::multiple_rest() {
  return this->multiple_rest_;
}

void measure_style::multiple_rest(const multiple_rest_type &x) {
  this->multiple_rest_.set(x);
}

void measure_style::multiple_rest(const multiple_rest_optional &x) {
  this->multiple_rest_ = x;
}

void measure_style::multiple_rest(::std::unique_ptr<multiple_rest_type> x) {
  this->multiple_rest_.set(std::move(x));
}

const measure_style::measure_repeat_optional &
measure_style::measure_repeat() const {
  return this->measure_repeat_;
}

measure_style::measure_repeat_optional &measure_style::measure_repeat() {
  return this->measure_repeat_;
}

void measure_style::measure_repeat(const measure_repeat_type &x) {
  this->measure_repeat_.set(x);
}

void measure_style::measure_repeat(const measure_repeat_optional &x) {
  this->measure_repeat_ = x;
}

void measure_style::measure_repeat(::std::unique_ptr<measure_repeat_type> x) {
  this->measure_repeat_.set(std::move(x));
}

const measure_style::beat_repeat_optional &measure_style::beat_repeat() const {
  return this->beat_repeat_;
}

measure_style::beat_repeat_optional &measure_style::beat_repeat() {
  return this->beat_repeat_;
}

void measure_style::beat_repeat(const beat_repeat_type &x) {
  this->beat_repeat_.set(x);
}

void measure_style::beat_repeat(const beat_repeat_optional &x) {
  this->beat_repeat_ = x;
}

void measure_style::beat_repeat(::std::unique_ptr<beat_repeat_type> x) {
  this->beat_repeat_.set(std::move(x));
}

const measure_style::slash_optional &measure_style::slash() const {
  return this->slash_;
}

measure_style::slash_optional &measure_style::slash() { return this->slash_; }

void measure_style::slash(const slash_type &x) { this->slash_.set(x); }

void measure_style::slash(const slash_optional &x) { this->slash_ = x; }

void measure_style::slash(::std::unique_ptr<slash_type> x) {
  this->slash_.set(std::move(x));
}

const measure_style::number_optional &measure_style::number() const {
  return this->number_;
}

measure_style::number_optional &measure_style::number() {
  return this->number_;
}

void measure_style::number(const number_type &x) { this->number_.set(x); }

void measure_style::number(const number_optional &x) { this->number_ = x; }

void measure_style::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const measure_style::font_family_optional &measure_style::font_family() const {
  return this->font_family_;
}

measure_style::font_family_optional &measure_style::font_family() {
  return this->font_family_;
}

void measure_style::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void measure_style::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void measure_style::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const measure_style::font_style_optional &measure_style::font_style() const {
  return this->font_style_;
}

measure_style::font_style_optional &measure_style::font_style() {
  return this->font_style_;
}

void measure_style::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void measure_style::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void measure_style::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const measure_style::font_size_optional &measure_style::font_size() const {
  return this->font_size_;
}

measure_style::font_size_optional &measure_style::font_size() {
  return this->font_size_;
}

void measure_style::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void measure_style::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void measure_style::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const measure_style::font_weight_optional &measure_style::font_weight() const {
  return this->font_weight_;
}

measure_style::font_weight_optional &measure_style::font_weight() {
  return this->font_weight_;
}

void measure_style::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void measure_style::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void measure_style::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const measure_style::color_optional &measure_style::color() const {
  return this->color_;
}

measure_style::color_optional &measure_style::color() { return this->color_; }

void measure_style::color(const color_type &x) { this->color_.set(x); }

void measure_style::color(const color_optional &x) { this->color_ = x; }

void measure_style::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// multiple_rest
//

const multiple_rest::use_symbols_optional &multiple_rest::use_symbols() const {
  return this->use_symbols_;
}

multiple_rest::use_symbols_optional &multiple_rest::use_symbols() {
  return this->use_symbols_;
}

void multiple_rest::use_symbols(const use_symbols_type &x) {
  this->use_symbols_.set(x);
}

void multiple_rest::use_symbols(const use_symbols_optional &x) {
  this->use_symbols_ = x;
}

void multiple_rest::use_symbols(::std::unique_ptr<use_symbols_type> x) {
  this->use_symbols_.set(std::move(x));
}

// part_symbol
//

const part_symbol::top_staff_optional &part_symbol::top_staff() const {
  return this->top_staff_;
}

part_symbol::top_staff_optional &part_symbol::top_staff() {
  return this->top_staff_;
}

void part_symbol::top_staff(const top_staff_type &x) {
  this->top_staff_.set(x);
}

void part_symbol::top_staff(const top_staff_optional &x) {
  this->top_staff_ = x;
}

void part_symbol::top_staff(::std::unique_ptr<top_staff_type> x) {
  this->top_staff_.set(std::move(x));
}

const part_symbol::bottom_staff_optional &part_symbol::bottom_staff() const {
  return this->bottom_staff_;
}

part_symbol::bottom_staff_optional &part_symbol::bottom_staff() {
  return this->bottom_staff_;
}

void part_symbol::bottom_staff(const bottom_staff_type &x) {
  this->bottom_staff_.set(x);
}

void part_symbol::bottom_staff(const bottom_staff_optional &x) {
  this->bottom_staff_ = x;
}

void part_symbol::bottom_staff(::std::unique_ptr<bottom_staff_type> x) {
  this->bottom_staff_.set(std::move(x));
}

const part_symbol::default_x_optional &part_symbol::default_x() const {
  return this->default_x_;
}

part_symbol::default_x_optional &part_symbol::default_x() {
  return this->default_x_;
}

void part_symbol::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void part_symbol::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void part_symbol::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const part_symbol::default_y_optional &part_symbol::default_y() const {
  return this->default_y_;
}

part_symbol::default_y_optional &part_symbol::default_y() {
  return this->default_y_;
}

void part_symbol::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void part_symbol::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void part_symbol::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const part_symbol::relative_x_optional &part_symbol::relative_x() const {
  return this->relative_x_;
}

part_symbol::relative_x_optional &part_symbol::relative_x() {
  return this->relative_x_;
}

void part_symbol::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void part_symbol::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void part_symbol::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const part_symbol::relative_y_optional &part_symbol::relative_y() const {
  return this->relative_y_;
}

part_symbol::relative_y_optional &part_symbol::relative_y() {
  return this->relative_y_;
}

void part_symbol::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void part_symbol::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void part_symbol::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const part_symbol::color_optional &part_symbol::color() const {
  return this->color_;
}

part_symbol::color_optional &part_symbol::color() { return this->color_; }

void part_symbol::color(const color_type &x) { this->color_.set(x); }

void part_symbol::color(const color_optional &x) { this->color_ = x; }

void part_symbol::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// slash
//

const slash::slash_type_optional &slash::slash_type() const {
  return this->slash_type_;
}

slash::slash_type_optional &slash::slash_type() { return this->slash_type_; }

void slash::slash_type(const slash_type_type &x) { this->slash_type_.set(x); }

void slash::slash_type(const slash_type_optional &x) { this->slash_type_ = x; }

void slash::slash_type(::std::unique_ptr<slash_type_type> x) {
  this->slash_type_.set(std::move(x));
}

const slash::slash_dot_sequence &slash::slash_dot() const {
  return this->slash_dot_;
}

slash::slash_dot_sequence &slash::slash_dot() { return this->slash_dot_; }

void slash::slash_dot(const slash_dot_sequence &s) { this->slash_dot_ = s; }

const slash::type_type &slash::type() const { return this->type_.get(); }

slash::type_type &slash::type() { return this->type_.get(); }

void slash::type(const type_type &x) { this->type_.set(x); }

void slash::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const slash::use_dots_optional &slash::use_dots() const {
  return this->use_dots_;
}

slash::use_dots_optional &slash::use_dots() { return this->use_dots_; }

void slash::use_dots(const use_dots_type &x) { this->use_dots_.set(x); }

void slash::use_dots(const use_dots_optional &x) { this->use_dots_ = x; }

void slash::use_dots(::std::unique_ptr<use_dots_type> x) {
  this->use_dots_.set(std::move(x));
}

const slash::use_stems_optional &slash::use_stems() const {
  return this->use_stems_;
}

slash::use_stems_optional &slash::use_stems() { return this->use_stems_; }

void slash::use_stems(const use_stems_type &x) { this->use_stems_.set(x); }

void slash::use_stems(const use_stems_optional &x) { this->use_stems_ = x; }

void slash::use_stems(::std::unique_ptr<use_stems_type> x) {
  this->use_stems_.set(std::move(x));
}

// staff_details
//

const staff_details::staff_type_optional &staff_details::staff_type() const {
  return this->staff_type_;
}

staff_details::staff_type_optional &staff_details::staff_type() {
  return this->staff_type_;
}

void staff_details::staff_type(const staff_type_type &x) {
  this->staff_type_.set(x);
}

void staff_details::staff_type(const staff_type_optional &x) {
  this->staff_type_ = x;
}

void staff_details::staff_type(::std::unique_ptr<staff_type_type> x) {
  this->staff_type_.set(std::move(x));
}

const staff_details::staff_lines_optional &staff_details::staff_lines() const {
  return this->staff_lines_;
}

staff_details::staff_lines_optional &staff_details::staff_lines() {
  return this->staff_lines_;
}

void staff_details::staff_lines(const staff_lines_type &x) {
  this->staff_lines_.set(x);
}

void staff_details::staff_lines(const staff_lines_optional &x) {
  this->staff_lines_ = x;
}

const staff_details::staff_tuning_sequence &
staff_details::staff_tuning() const {
  return this->staff_tuning_;
}

staff_details::staff_tuning_sequence &staff_details::staff_tuning() {
  return this->staff_tuning_;
}

void staff_details::staff_tuning(const staff_tuning_sequence &s) {
  this->staff_tuning_ = s;
}

const staff_details::capo_optional &staff_details::capo() const {
  return this->capo_;
}

staff_details::capo_optional &staff_details::capo() { return this->capo_; }

void staff_details::capo(const capo_type &x) { this->capo_.set(x); }

void staff_details::capo(const capo_optional &x) { this->capo_ = x; }

const staff_details::staff_size_optional &staff_details::staff_size() const {
  return this->staff_size_;
}

staff_details::staff_size_optional &staff_details::staff_size() {
  return this->staff_size_;
}

void staff_details::staff_size(const staff_size_type &x) {
  this->staff_size_.set(x);
}

void staff_details::staff_size(const staff_size_optional &x) {
  this->staff_size_ = x;
}

void staff_details::staff_size(::std::unique_ptr<staff_size_type> x) {
  this->staff_size_.set(std::move(x));
}

const staff_details::number_optional &staff_details::number() const {
  return this->number_;
}

staff_details::number_optional &staff_details::number() {
  return this->number_;
}

void staff_details::number(const number_type &x) { this->number_.set(x); }

void staff_details::number(const number_optional &x) { this->number_ = x; }

void staff_details::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const staff_details::show_frets_optional &staff_details::show_frets() const {
  return this->show_frets_;
}

staff_details::show_frets_optional &staff_details::show_frets() {
  return this->show_frets_;
}

void staff_details::show_frets(const show_frets_type &x) {
  this->show_frets_.set(x);
}

void staff_details::show_frets(const show_frets_optional &x) {
  this->show_frets_ = x;
}

void staff_details::show_frets(::std::unique_ptr<show_frets_type> x) {
  this->show_frets_.set(std::move(x));
}

const staff_details::print_object_optional &
staff_details::print_object() const {
  return this->print_object_;
}

staff_details::print_object_optional &staff_details::print_object() {
  return this->print_object_;
}

void staff_details::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void staff_details::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void staff_details::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const staff_details::print_spacing_optional &
staff_details::print_spacing() const {
  return this->print_spacing_;
}

staff_details::print_spacing_optional &staff_details::print_spacing() {
  return this->print_spacing_;
}

void staff_details::print_spacing(const print_spacing_type &x) {
  this->print_spacing_.set(x);
}

void staff_details::print_spacing(const print_spacing_optional &x) {
  this->print_spacing_ = x;
}

void staff_details::print_spacing(::std::unique_ptr<print_spacing_type> x) {
  this->print_spacing_.set(std::move(x));
}

// staff_tuning
//

const staff_tuning::tuning_step_type &staff_tuning::tuning_step() const {
  return this->tuning_step_.get();
}

staff_tuning::tuning_step_type &staff_tuning::tuning_step() {
  return this->tuning_step_.get();
}

void staff_tuning::tuning_step(const tuning_step_type &x) {
  this->tuning_step_.set(x);
}

void staff_tuning::tuning_step(::std::unique_ptr<tuning_step_type> x) {
  this->tuning_step_.set(std::move(x));
}

const staff_tuning::tuning_alter_optional &staff_tuning::tuning_alter() const {
  return this->tuning_alter_;
}

staff_tuning::tuning_alter_optional &staff_tuning::tuning_alter() {
  return this->tuning_alter_;
}

void staff_tuning::tuning_alter(const tuning_alter_type &x) {
  this->tuning_alter_.set(x);
}

void staff_tuning::tuning_alter(const tuning_alter_optional &x) {
  this->tuning_alter_ = x;
}

void staff_tuning::tuning_alter(::std::unique_ptr<tuning_alter_type> x) {
  this->tuning_alter_.set(std::move(x));
}

const staff_tuning::tuning_octave_type &staff_tuning::tuning_octave() const {
  return this->tuning_octave_.get();
}

staff_tuning::tuning_octave_type &staff_tuning::tuning_octave() {
  return this->tuning_octave_.get();
}

void staff_tuning::tuning_octave(const tuning_octave_type &x) {
  this->tuning_octave_.set(x);
}

void staff_tuning::tuning_octave(::std::unique_ptr<tuning_octave_type> x) {
  this->tuning_octave_.set(std::move(x));
}

const staff_tuning::line_optional &staff_tuning::line() const {
  return this->line_;
}

staff_tuning::line_optional &staff_tuning::line() { return this->line_; }

void staff_tuning::line(const line_type &x) { this->line_.set(x); }

void staff_tuning::line(const line_optional &x) { this->line_ = x; }

void staff_tuning::line(::std::unique_ptr<line_type> x) {
  this->line_.set(std::move(x));
}

// time
//

const time::beats_sequence &time::beats() const { return this->beats_; }

time::beats_sequence &time::beats() { return this->beats_; }

void time::beats(const beats_sequence &s) { this->beats_ = s; }

const time::beat_type_sequence &time::beat_type() const {
  return this->beat_type_;
}

time::beat_type_sequence &time::beat_type() { return this->beat_type_; }

void time::beat_type(const beat_type_sequence &s) { this->beat_type_ = s; }

const time::interchangeable_optional &time::interchangeable() const {
  return this->interchangeable_;
}

time::interchangeable_optional &time::interchangeable() {
  return this->interchangeable_;
}

void time::interchangeable(const interchangeable_type &x) {
  this->interchangeable_.set(x);
}

void time::interchangeable(const interchangeable_optional &x) {
  this->interchangeable_ = x;
}

void time::interchangeable(::std::unique_ptr<interchangeable_type> x) {
  this->interchangeable_.set(std::move(x));
}

const time::senza_misura_optional &time::senza_misura() const {
  return this->senza_misura_;
}

time::senza_misura_optional &time::senza_misura() {
  return this->senza_misura_;
}

void time::senza_misura(const senza_misura_type &x) {
  this->senza_misura_.set(x);
}

void time::senza_misura(const senza_misura_optional &x) {
  this->senza_misura_ = x;
}

void time::senza_misura(::std::unique_ptr<senza_misura_type> x) {
  this->senza_misura_.set(std::move(x));
}

const time::number_optional &time::number() const { return this->number_; }

time::number_optional &time::number() { return this->number_; }

void time::number(const number_type &x) { this->number_.set(x); }

void time::number(const number_optional &x) { this->number_ = x; }

void time::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const time::symbol_optional &time::symbol() const { return this->symbol_; }

time::symbol_optional &time::symbol() { return this->symbol_; }

void time::symbol(const symbol_type &x) { this->symbol_.set(x); }

void time::symbol(const symbol_optional &x) { this->symbol_ = x; }

void time::symbol(::std::unique_ptr<symbol_type> x) {
  this->symbol_.set(std::move(x));
}

const time::separator_optional &time::separator() const {
  return this->separator_;
}

time::separator_optional &time::separator() { return this->separator_; }

void time::separator(const separator_type &x) { this->separator_.set(x); }

void time::separator(const separator_optional &x) { this->separator_ = x; }

void time::separator(::std::unique_ptr<separator_type> x) {
  this->separator_.set(std::move(x));
}

const time::default_x_optional &time::default_x() const {
  return this->default_x_;
}

time::default_x_optional &time::default_x() { return this->default_x_; }

void time::default_x(const default_x_type &x) { this->default_x_.set(x); }

void time::default_x(const default_x_optional &x) { this->default_x_ = x; }

void time::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const time::default_y_optional &time::default_y() const {
  return this->default_y_;
}

time::default_y_optional &time::default_y() { return this->default_y_; }

void time::default_y(const default_y_type &x) { this->default_y_.set(x); }

void time::default_y(const default_y_optional &x) { this->default_y_ = x; }

void time::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const time::relative_x_optional &time::relative_x() const {
  return this->relative_x_;
}

time::relative_x_optional &time::relative_x() { return this->relative_x_; }

void time::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void time::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void time::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const time::relative_y_optional &time::relative_y() const {
  return this->relative_y_;
}

time::relative_y_optional &time::relative_y() { return this->relative_y_; }

void time::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void time::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void time::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const time::font_family_optional &time::font_family() const {
  return this->font_family_;
}

time::font_family_optional &time::font_family() { return this->font_family_; }

void time::font_family(const font_family_type &x) { this->font_family_.set(x); }

void time::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void time::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const time::font_style_optional &time::font_style() const {
  return this->font_style_;
}

time::font_style_optional &time::font_style() { return this->font_style_; }

void time::font_style(const font_style_type &x) { this->font_style_.set(x); }

void time::font_style(const font_style_optional &x) { this->font_style_ = x; }

void time::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const time::font_size_optional &time::font_size() const {
  return this->font_size_;
}

time::font_size_optional &time::font_size() { return this->font_size_; }

void time::font_size(const font_size_type &x) { this->font_size_.set(x); }

void time::font_size(const font_size_optional &x) { this->font_size_ = x; }

void time::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const time::font_weight_optional &time::font_weight() const {
  return this->font_weight_;
}

time::font_weight_optional &time::font_weight() { return this->font_weight_; }

void time::font_weight(const font_weight_type &x) { this->font_weight_.set(x); }

void time::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void time::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const time::color_optional &time::color() const { return this->color_; }

time::color_optional &time::color() { return this->color_; }

void time::color(const color_type &x) { this->color_.set(x); }

void time::color(const color_optional &x) { this->color_ = x; }

void time::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const time::halign_optional &time::halign() const { return this->halign_; }

time::halign_optional &time::halign() { return this->halign_; }

void time::halign(const halign_type &x) { this->halign_.set(x); }

void time::halign(const halign_optional &x) { this->halign_ = x; }

void time::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const time::valign_optional &time::valign() const { return this->valign_; }

time::valign_optional &time::valign() { return this->valign_; }

void time::valign(const valign_type &x) { this->valign_.set(x); }

void time::valign(const valign_optional &x) { this->valign_ = x; }

void time::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

const time::print_object_optional &time::print_object() const {
  return this->print_object_;
}

time::print_object_optional &time::print_object() {
  return this->print_object_;
}

void time::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void time::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void time::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

// transpose
//

const transpose::diatonic_optional &transpose::diatonic() const {
  return this->diatonic_;
}

transpose::diatonic_optional &transpose::diatonic() { return this->diatonic_; }

void transpose::diatonic(const diatonic_type &x) { this->diatonic_.set(x); }

void transpose::diatonic(const diatonic_optional &x) { this->diatonic_ = x; }

const transpose::chromatic_type &transpose::chromatic() const {
  return this->chromatic_.get();
}

transpose::chromatic_type &transpose::chromatic() {
  return this->chromatic_.get();
}

void transpose::chromatic(const chromatic_type &x) { this->chromatic_.set(x); }

void transpose::chromatic(::std::unique_ptr<chromatic_type> x) {
  this->chromatic_.set(std::move(x));
}

const transpose::octave_change_optional &transpose::octave_change() const {
  return this->octave_change_;
}

transpose::octave_change_optional &transpose::octave_change() {
  return this->octave_change_;
}

void transpose::octave_change(const octave_change_type &x) {
  this->octave_change_.set(x);
}

void transpose::octave_change(const octave_change_optional &x) {
  this->octave_change_ = x;
}

const transpose::double_optional &transpose::double_() const {
  return this->double__;
}

transpose::double_optional &transpose::double_() { return this->double__; }

void transpose::double_(const double_type &x) { this->double__.set(x); }

void transpose::double_(const double_optional &x) { this->double__ = x; }

void transpose::double_(::std::unique_ptr<double_type> x) {
  this->double__.set(std::move(x));
}

const transpose::number_optional &transpose::number() const {
  return this->number_;
}

transpose::number_optional &transpose::number() { return this->number_; }

void transpose::number(const number_type &x) { this->number_.set(x); }

void transpose::number(const number_optional &x) { this->number_ = x; }

void transpose::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

// bar_style_color
//

const bar_style_color::color_optional &bar_style_color::color() const {
  return this->color_;
}

bar_style_color::color_optional &bar_style_color::color() {
  return this->color_;
}

void bar_style_color::color(const color_type &x) { this->color_.set(x); }

void bar_style_color::color(const color_optional &x) { this->color_ = x; }

void bar_style_color::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// barline
//

const barline::bar_style_optional &barline::bar_style() const {
  return this->bar_style_;
}

barline::bar_style_optional &barline::bar_style() { return this->bar_style_; }

void barline::bar_style(const bar_style_type &x) { this->bar_style_.set(x); }

void barline::bar_style(const bar_style_optional &x) { this->bar_style_ = x; }

void barline::bar_style(::std::unique_ptr<bar_style_type> x) {
  this->bar_style_.set(std::move(x));
}

const barline::footnote_optional &barline::footnote() const {
  return this->footnote_;
}

barline::footnote_optional &barline::footnote() { return this->footnote_; }

void barline::footnote(const footnote_type &x) { this->footnote_.set(x); }

void barline::footnote(const footnote_optional &x) { this->footnote_ = x; }

void barline::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const barline::level_optional &barline::level() const { return this->level_; }

barline::level_optional &barline::level() { return this->level_; }

void barline::level(const level_type &x) { this->level_.set(x); }

void barline::level(const level_optional &x) { this->level_ = x; }

void barline::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const barline::wavy_line_optional &barline::wavy_line() const {
  return this->wavy_line_;
}

barline::wavy_line_optional &barline::wavy_line() { return this->wavy_line_; }

void barline::wavy_line(const wavy_line_type &x) { this->wavy_line_.set(x); }

void barline::wavy_line(const wavy_line_optional &x) { this->wavy_line_ = x; }

void barline::wavy_line(::std::unique_ptr<wavy_line_type> x) {
  this->wavy_line_.set(std::move(x));
}

const barline::segno_optional &barline::segno() const { return this->segno_; }

barline::segno_optional &barline::segno() { return this->segno_; }

void barline::segno(const segno_type &x) { this->segno_.set(x); }

void barline::segno(const segno_optional &x) { this->segno_ = x; }

void barline::segno(::std::unique_ptr<segno_type> x) {
  this->segno_.set(std::move(x));
}

const barline::coda_optional &barline::coda() const { return this->coda_; }

barline::coda_optional &barline::coda() { return this->coda_; }

void barline::coda(const coda_type &x) { this->coda_.set(x); }

void barline::coda(const coda_optional &x) { this->coda_ = x; }

void barline::coda(::std::unique_ptr<coda_type> x) {
  this->coda_.set(std::move(x));
}

const barline::fermata_sequence &barline::fermata() const {
  return this->fermata_;
}

barline::fermata_sequence &barline::fermata() { return this->fermata_; }

void barline::fermata(const fermata_sequence &s) { this->fermata_ = s; }

const barline::ending_optional &barline::ending() const {
  return this->ending_;
}

barline::ending_optional &barline::ending() { return this->ending_; }

void barline::ending(const ending_type &x) { this->ending_.set(x); }

void barline::ending(const ending_optional &x) { this->ending_ = x; }

void barline::ending(::std::unique_ptr<ending_type> x) {
  this->ending_.set(std::move(x));
}

const barline::repeat_optional &barline::repeat() const {
  return this->repeat_;
}

barline::repeat_optional &barline::repeat() { return this->repeat_; }

void barline::repeat(const repeat_type &x) { this->repeat_.set(x); }

void barline::repeat(const repeat_optional &x) { this->repeat_ = x; }

void barline::repeat(::std::unique_ptr<repeat_type> x) {
  this->repeat_.set(std::move(x));
}

const barline::location_type &barline::location() const {
  return this->location_.get();
}

barline::location_type &barline::location() { return this->location_.get(); }

void barline::location(const location_type &x) { this->location_.set(x); }

void barline::location(::std::unique_ptr<location_type> x) {
  this->location_.set(std::move(x));
}

const barline::location_type &barline::location_default_value() {
  return location_default_value_;
}

const barline::segno1_optional &barline::segno1() const {
  return this->segno1_;
}

barline::segno1_optional &barline::segno1() { return this->segno1_; }

void barline::segno1(const segno1_type &x) { this->segno1_.set(x); }

void barline::segno1(const segno1_optional &x) { this->segno1_ = x; }

void barline::segno1(::std::unique_ptr<segno1_type> x) {
  this->segno1_.set(std::move(x));
}

const barline::coda1_optional &barline::coda1() const { return this->coda1_; }

barline::coda1_optional &barline::coda1() { return this->coda1_; }

void barline::coda1(const coda1_type &x) { this->coda1_.set(x); }

void barline::coda1(const coda1_optional &x) { this->coda1_ = x; }

void barline::coda1(::std::unique_ptr<coda1_type> x) {
  this->coda1_.set(std::move(x));
}

const barline::divisions_optional &barline::divisions() const {
  return this->divisions_;
}

barline::divisions_optional &barline::divisions() { return this->divisions_; }

void barline::divisions(const divisions_type &x) { this->divisions_.set(x); }

void barline::divisions(const divisions_optional &x) { this->divisions_ = x; }

void barline::divisions(::std::unique_ptr<divisions_type> x) {
  this->divisions_.set(std::move(x));
}

// ending
//

const ending::number_type &ending::number() const {
  return this->number_.get();
}

ending::number_type &ending::number() { return this->number_.get(); }

void ending::number(const number_type &x) { this->number_.set(x); }

void ending::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const ending::type_type &ending::type() const { return this->type_.get(); }

ending::type_type &ending::type() { return this->type_.get(); }

void ending::type(const type_type &x) { this->type_.set(x); }

void ending::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const ending::print_object_optional &ending::print_object() const {
  return this->print_object_;
}

ending::print_object_optional &ending::print_object() {
  return this->print_object_;
}

void ending::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void ending::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void ending::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const ending::default_x_optional &ending::default_x() const {
  return this->default_x_;
}

ending::default_x_optional &ending::default_x() { return this->default_x_; }

void ending::default_x(const default_x_type &x) { this->default_x_.set(x); }

void ending::default_x(const default_x_optional &x) { this->default_x_ = x; }

void ending::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const ending::default_y_optional &ending::default_y() const {
  return this->default_y_;
}

ending::default_y_optional &ending::default_y() { return this->default_y_; }

void ending::default_y(const default_y_type &x) { this->default_y_.set(x); }

void ending::default_y(const default_y_optional &x) { this->default_y_ = x; }

void ending::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const ending::relative_x_optional &ending::relative_x() const {
  return this->relative_x_;
}

ending::relative_x_optional &ending::relative_x() { return this->relative_x_; }

void ending::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void ending::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void ending::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const ending::relative_y_optional &ending::relative_y() const {
  return this->relative_y_;
}

ending::relative_y_optional &ending::relative_y() { return this->relative_y_; }

void ending::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void ending::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void ending::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const ending::font_family_optional &ending::font_family() const {
  return this->font_family_;
}

ending::font_family_optional &ending::font_family() {
  return this->font_family_;
}

void ending::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void ending::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void ending::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const ending::font_style_optional &ending::font_style() const {
  return this->font_style_;
}

ending::font_style_optional &ending::font_style() { return this->font_style_; }

void ending::font_style(const font_style_type &x) { this->font_style_.set(x); }

void ending::font_style(const font_style_optional &x) { this->font_style_ = x; }

void ending::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const ending::font_size_optional &ending::font_size() const {
  return this->font_size_;
}

ending::font_size_optional &ending::font_size() { return this->font_size_; }

void ending::font_size(const font_size_type &x) { this->font_size_.set(x); }

void ending::font_size(const font_size_optional &x) { this->font_size_ = x; }

void ending::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const ending::font_weight_optional &ending::font_weight() const {
  return this->font_weight_;
}

ending::font_weight_optional &ending::font_weight() {
  return this->font_weight_;
}

void ending::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void ending::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void ending::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const ending::color_optional &ending::color() const { return this->color_; }

ending::color_optional &ending::color() { return this->color_; }

void ending::color(const color_type &x) { this->color_.set(x); }

void ending::color(const color_optional &x) { this->color_ = x; }

void ending::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const ending::end_length_optional &ending::end_length() const {
  return this->end_length_;
}

ending::end_length_optional &ending::end_length() { return this->end_length_; }

void ending::end_length(const end_length_type &x) { this->end_length_.set(x); }

void ending::end_length(const end_length_optional &x) { this->end_length_ = x; }

void ending::end_length(::std::unique_ptr<end_length_type> x) {
  this->end_length_.set(std::move(x));
}

const ending::text_x_optional &ending::text_x() const { return this->text_x_; }

ending::text_x_optional &ending::text_x() { return this->text_x_; }

void ending::text_x(const text_x_type &x) { this->text_x_.set(x); }

void ending::text_x(const text_x_optional &x) { this->text_x_ = x; }

void ending::text_x(::std::unique_ptr<text_x_type> x) {
  this->text_x_.set(std::move(x));
}

const ending::text_y_optional &ending::text_y() const { return this->text_y_; }

ending::text_y_optional &ending::text_y() { return this->text_y_; }

void ending::text_y(const text_y_type &x) { this->text_y_.set(x); }

void ending::text_y(const text_y_optional &x) { this->text_y_ = x; }

void ending::text_y(::std::unique_ptr<text_y_type> x) {
  this->text_y_.set(std::move(x));
}

// repeat
//

const repeat::direction_type &repeat::direction() const {
  return this->direction_.get();
}

repeat::direction_type &repeat::direction() { return this->direction_.get(); }

void repeat::direction(const direction_type &x) { this->direction_.set(x); }

void repeat::direction(::std::unique_ptr<direction_type> x) {
  this->direction_.set(std::move(x));
}

const repeat::times_optional &repeat::times() const { return this->times_; }

repeat::times_optional &repeat::times() { return this->times_; }

void repeat::times(const times_type &x) { this->times_.set(x); }

void repeat::times(const times_optional &x) { this->times_ = x; }

const repeat::winged_optional &repeat::winged() const { return this->winged_; }

repeat::winged_optional &repeat::winged() { return this->winged_; }

void repeat::winged(const winged_type &x) { this->winged_.set(x); }

void repeat::winged(const winged_optional &x) { this->winged_ = x; }

void repeat::winged(::std::unique_ptr<winged_type> x) {
  this->winged_.set(std::move(x));
}

// accord
//

const accord::tuning_step_type &accord::tuning_step() const {
  return this->tuning_step_.get();
}

accord::tuning_step_type &accord::tuning_step() {
  return this->tuning_step_.get();
}

void accord::tuning_step(const tuning_step_type &x) {
  this->tuning_step_.set(x);
}

void accord::tuning_step(::std::unique_ptr<tuning_step_type> x) {
  this->tuning_step_.set(std::move(x));
}

const accord::tuning_alter_optional &accord::tuning_alter() const {
  return this->tuning_alter_;
}

accord::tuning_alter_optional &accord::tuning_alter() {
  return this->tuning_alter_;
}

void accord::tuning_alter(const tuning_alter_type &x) {
  this->tuning_alter_.set(x);
}

void accord::tuning_alter(const tuning_alter_optional &x) {
  this->tuning_alter_ = x;
}

void accord::tuning_alter(::std::unique_ptr<tuning_alter_type> x) {
  this->tuning_alter_.set(std::move(x));
}

const accord::tuning_octave_type &accord::tuning_octave() const {
  return this->tuning_octave_.get();
}

accord::tuning_octave_type &accord::tuning_octave() {
  return this->tuning_octave_.get();
}

void accord::tuning_octave(const tuning_octave_type &x) {
  this->tuning_octave_.set(x);
}

void accord::tuning_octave(::std::unique_ptr<tuning_octave_type> x) {
  this->tuning_octave_.set(std::move(x));
}

const accord::string_optional &accord::string() const { return this->string_; }

accord::string_optional &accord::string() { return this->string_; }

void accord::string(const string_type &x) { this->string_.set(x); }

void accord::string(const string_optional &x) { this->string_ = x; }

void accord::string(::std::unique_ptr<string_type> x) {
  this->string_.set(std::move(x));
}

// accordion_registration
//

const accordion_registration::accordion_high_optional &
accordion_registration::accordion_high() const {
  return this->accordion_high_;
}

accordion_registration::accordion_high_optional &
accordion_registration::accordion_high() {
  return this->accordion_high_;
}

void accordion_registration::accordion_high(const accordion_high_type &x) {
  this->accordion_high_.set(x);
}

void accordion_registration::accordion_high(const accordion_high_optional &x) {
  this->accordion_high_ = x;
}

void accordion_registration::accordion_high(
  ::std::unique_ptr<accordion_high_type> x) {
  this->accordion_high_.set(std::move(x));
}

const accordion_registration::accordion_middle_optional &
accordion_registration::accordion_middle() const {
  return this->accordion_middle_;
}

accordion_registration::accordion_middle_optional &
accordion_registration::accordion_middle() {
  return this->accordion_middle_;
}

void accordion_registration::accordion_middle(const accordion_middle_type &x) {
  this->accordion_middle_.set(x);
}

void
accordion_registration::accordion_middle(const accordion_middle_optional &x) {
  this->accordion_middle_ = x;
}

void accordion_registration::accordion_middle(
  ::std::unique_ptr<accordion_middle_type> x) {
  this->accordion_middle_.set(std::move(x));
}

const accordion_registration::accordion_low_optional &
accordion_registration::accordion_low() const {
  return this->accordion_low_;
}

accordion_registration::accordion_low_optional &
accordion_registration::accordion_low() {
  return this->accordion_low_;
}

void accordion_registration::accordion_low(const accordion_low_type &x) {
  this->accordion_low_.set(x);
}

void accordion_registration::accordion_low(const accordion_low_optional &x) {
  this->accordion_low_ = x;
}

void
accordion_registration::accordion_low(::std::unique_ptr<accordion_low_type> x) {
  this->accordion_low_.set(std::move(x));
}

const accordion_registration::default_x_optional &
accordion_registration::default_x() const {
  return this->default_x_;
}

accordion_registration::default_x_optional &
accordion_registration::default_x() {
  return this->default_x_;
}

void accordion_registration::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void accordion_registration::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void accordion_registration::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const accordion_registration::default_y_optional &
accordion_registration::default_y() const {
  return this->default_y_;
}

accordion_registration::default_y_optional &
accordion_registration::default_y() {
  return this->default_y_;
}

void accordion_registration::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void accordion_registration::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void accordion_registration::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const accordion_registration::relative_x_optional &
accordion_registration::relative_x() const {
  return this->relative_x_;
}

accordion_registration::relative_x_optional &
accordion_registration::relative_x() {
  return this->relative_x_;
}

void accordion_registration::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void accordion_registration::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void accordion_registration::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const accordion_registration::relative_y_optional &
accordion_registration::relative_y() const {
  return this->relative_y_;
}

accordion_registration::relative_y_optional &
accordion_registration::relative_y() {
  return this->relative_y_;
}

void accordion_registration::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void accordion_registration::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void accordion_registration::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const accordion_registration::font_family_optional &
accordion_registration::font_family() const {
  return this->font_family_;
}

accordion_registration::font_family_optional &
accordion_registration::font_family() {
  return this->font_family_;
}

void accordion_registration::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void accordion_registration::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void
accordion_registration::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const accordion_registration::font_style_optional &
accordion_registration::font_style() const {
  return this->font_style_;
}

accordion_registration::font_style_optional &
accordion_registration::font_style() {
  return this->font_style_;
}

void accordion_registration::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void accordion_registration::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void accordion_registration::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const accordion_registration::font_size_optional &
accordion_registration::font_size() const {
  return this->font_size_;
}

accordion_registration::font_size_optional &
accordion_registration::font_size() {
  return this->font_size_;
}

void accordion_registration::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void accordion_registration::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void accordion_registration::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const accordion_registration::font_weight_optional &
accordion_registration::font_weight() const {
  return this->font_weight_;
}

accordion_registration::font_weight_optional &
accordion_registration::font_weight() {
  return this->font_weight_;
}

void accordion_registration::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void accordion_registration::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void
accordion_registration::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const accordion_registration::color_optional &
accordion_registration::color() const {
  return this->color_;
}

accordion_registration::color_optional &accordion_registration::color() {
  return this->color_;
}

void accordion_registration::color(const color_type &x) { this->color_.set(x); }

void accordion_registration::color(const color_optional &x) {
  this->color_ = x;
}

void accordion_registration::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const accordion_registration::halign_optional &
accordion_registration::halign() const {
  return this->halign_;
}

accordion_registration::halign_optional &accordion_registration::halign() {
  return this->halign_;
}

void accordion_registration::halign(const halign_type &x) {
  this->halign_.set(x);
}

void accordion_registration::halign(const halign_optional &x) {
  this->halign_ = x;
}

void accordion_registration::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const accordion_registration::valign_optional &
accordion_registration::valign() const {
  return this->valign_;
}

accordion_registration::valign_optional &accordion_registration::valign() {
  return this->valign_;
}

void accordion_registration::valign(const valign_type &x) {
  this->valign_.set(x);
}

void accordion_registration::valign(const valign_optional &x) {
  this->valign_ = x;
}

void accordion_registration::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// barre
//

const barre::type_type &barre::type() const { return this->type_.get(); }

barre::type_type &barre::type() { return this->type_.get(); }

void barre::type(const type_type &x) { this->type_.set(x); }

void barre::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const barre::color_optional &barre::color() const { return this->color_; }

barre::color_optional &barre::color() { return this->color_; }

void barre::color(const color_type &x) { this->color_.set(x); }

void barre::color(const color_optional &x) { this->color_ = x; }

void barre::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// bass
//

const bass::bass_step_type &bass::bass_step() const {
  return this->bass_step_.get();
}

bass::bass_step_type &bass::bass_step() { return this->bass_step_.get(); }

void bass::bass_step(const bass_step_type &x) { this->bass_step_.set(x); }

void bass::bass_step(::std::unique_ptr<bass_step_type> x) {
  this->bass_step_.set(std::move(x));
}

const bass::bass_alter_optional &bass::bass_alter() const {
  return this->bass_alter_;
}

bass::bass_alter_optional &bass::bass_alter() { return this->bass_alter_; }

void bass::bass_alter(const bass_alter_type &x) { this->bass_alter_.set(x); }

void bass::bass_alter(const bass_alter_optional &x) { this->bass_alter_ = x; }

void bass::bass_alter(::std::unique_ptr<bass_alter_type> x) {
  this->bass_alter_.set(std::move(x));
}

// bass_alter
//

const bass_alter::print_object_optional &bass_alter::print_object() const {
  return this->print_object_;
}

bass_alter::print_object_optional &bass_alter::print_object() {
  return this->print_object_;
}

void bass_alter::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void bass_alter::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void bass_alter::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const bass_alter::default_x_optional &bass_alter::default_x() const {
  return this->default_x_;
}

bass_alter::default_x_optional &bass_alter::default_x() {
  return this->default_x_;
}

void bass_alter::default_x(const default_x_type &x) { this->default_x_.set(x); }

void bass_alter::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void bass_alter::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const bass_alter::default_y_optional &bass_alter::default_y() const {
  return this->default_y_;
}

bass_alter::default_y_optional &bass_alter::default_y() {
  return this->default_y_;
}

void bass_alter::default_y(const default_y_type &x) { this->default_y_.set(x); }

void bass_alter::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void bass_alter::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const bass_alter::relative_x_optional &bass_alter::relative_x() const {
  return this->relative_x_;
}

bass_alter::relative_x_optional &bass_alter::relative_x() {
  return this->relative_x_;
}

void bass_alter::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void bass_alter::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void bass_alter::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const bass_alter::relative_y_optional &bass_alter::relative_y() const {
  return this->relative_y_;
}

bass_alter::relative_y_optional &bass_alter::relative_y() {
  return this->relative_y_;
}

void bass_alter::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void bass_alter::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void bass_alter::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const bass_alter::font_family_optional &bass_alter::font_family() const {
  return this->font_family_;
}

bass_alter::font_family_optional &bass_alter::font_family() {
  return this->font_family_;
}

void bass_alter::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void bass_alter::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void bass_alter::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const bass_alter::font_style_optional &bass_alter::font_style() const {
  return this->font_style_;
}

bass_alter::font_style_optional &bass_alter::font_style() {
  return this->font_style_;
}

void bass_alter::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void bass_alter::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void bass_alter::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const bass_alter::font_size_optional &bass_alter::font_size() const {
  return this->font_size_;
}

bass_alter::font_size_optional &bass_alter::font_size() {
  return this->font_size_;
}

void bass_alter::font_size(const font_size_type &x) { this->font_size_.set(x); }

void bass_alter::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void bass_alter::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const bass_alter::font_weight_optional &bass_alter::font_weight() const {
  return this->font_weight_;
}

bass_alter::font_weight_optional &bass_alter::font_weight() {
  return this->font_weight_;
}

void bass_alter::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void bass_alter::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void bass_alter::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const bass_alter::color_optional &bass_alter::color() const {
  return this->color_;
}

bass_alter::color_optional &bass_alter::color() { return this->color_; }

void bass_alter::color(const color_type &x) { this->color_.set(x); }

void bass_alter::color(const color_optional &x) { this->color_ = x; }

void bass_alter::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const bass_alter::location_optional &bass_alter::location() const {
  return this->location_;
}

bass_alter::location_optional &bass_alter::location() {
  return this->location_;
}

void bass_alter::location(const location_type &x) { this->location_.set(x); }

void bass_alter::location(const location_optional &x) { this->location_ = x; }

void bass_alter::location(::std::unique_ptr<location_type> x) {
  this->location_.set(std::move(x));
}

// bass_step
//

const bass_step::text_optional &bass_step::text() const { return this->text_; }

bass_step::text_optional &bass_step::text() { return this->text_; }

void bass_step::text(const text_type &x) { this->text_.set(x); }

void bass_step::text(const text_optional &x) { this->text_ = x; }

void bass_step::text(::std::unique_ptr<text_type> x) {
  this->text_.set(std::move(x));
}

const bass_step::default_x_optional &bass_step::default_x() const {
  return this->default_x_;
}

bass_step::default_x_optional &bass_step::default_x() {
  return this->default_x_;
}

void bass_step::default_x(const default_x_type &x) { this->default_x_.set(x); }

void bass_step::default_x(const default_x_optional &x) { this->default_x_ = x; }

void bass_step::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const bass_step::default_y_optional &bass_step::default_y() const {
  return this->default_y_;
}

bass_step::default_y_optional &bass_step::default_y() {
  return this->default_y_;
}

void bass_step::default_y(const default_y_type &x) { this->default_y_.set(x); }

void bass_step::default_y(const default_y_optional &x) { this->default_y_ = x; }

void bass_step::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const bass_step::relative_x_optional &bass_step::relative_x() const {
  return this->relative_x_;
}

bass_step::relative_x_optional &bass_step::relative_x() {
  return this->relative_x_;
}

void bass_step::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void bass_step::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void bass_step::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const bass_step::relative_y_optional &bass_step::relative_y() const {
  return this->relative_y_;
}

bass_step::relative_y_optional &bass_step::relative_y() {
  return this->relative_y_;
}

void bass_step::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void bass_step::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void bass_step::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const bass_step::font_family_optional &bass_step::font_family() const {
  return this->font_family_;
}

bass_step::font_family_optional &bass_step::font_family() {
  return this->font_family_;
}

void bass_step::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void bass_step::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void bass_step::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const bass_step::font_style_optional &bass_step::font_style() const {
  return this->font_style_;
}

bass_step::font_style_optional &bass_step::font_style() {
  return this->font_style_;
}

void bass_step::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void bass_step::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void bass_step::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const bass_step::font_size_optional &bass_step::font_size() const {
  return this->font_size_;
}

bass_step::font_size_optional &bass_step::font_size() {
  return this->font_size_;
}

void bass_step::font_size(const font_size_type &x) { this->font_size_.set(x); }

void bass_step::font_size(const font_size_optional &x) { this->font_size_ = x; }

void bass_step::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const bass_step::font_weight_optional &bass_step::font_weight() const {
  return this->font_weight_;
}

bass_step::font_weight_optional &bass_step::font_weight() {
  return this->font_weight_;
}

void bass_step::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void bass_step::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void bass_step::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const bass_step::color_optional &bass_step::color() const {
  return this->color_;
}

bass_step::color_optional &bass_step::color() { return this->color_; }

void bass_step::color(const color_type &x) { this->color_.set(x); }

void bass_step::color(const color_optional &x) { this->color_ = x; }

void bass_step::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// beater
//

const beater::tip_optional &beater::tip() const { return this->tip_; }

beater::tip_optional &beater::tip() { return this->tip_; }

void beater::tip(const tip_type &x) { this->tip_.set(x); }

void beater::tip(const tip_optional &x) { this->tip_ = x; }

void beater::tip(::std::unique_ptr<tip_type> x) {
  this->tip_.set(std::move(x));
}

// bracket
//

const bracket::type_type &bracket::type() const { return this->type_.get(); }

bracket::type_type &bracket::type() { return this->type_.get(); }

void bracket::type(const type_type &x) { this->type_.set(x); }

void bracket::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const bracket::number_optional &bracket::number() const {
  return this->number_;
}

bracket::number_optional &bracket::number() { return this->number_; }

void bracket::number(const number_type &x) { this->number_.set(x); }

void bracket::number(const number_optional &x) { this->number_ = x; }

void bracket::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const bracket::line_end_type &bracket::line_end() const {
  return this->line_end_.get();
}

bracket::line_end_type &bracket::line_end() { return this->line_end_.get(); }

void bracket::line_end(const line_end_type &x) { this->line_end_.set(x); }

void bracket::line_end(::std::unique_ptr<line_end_type> x) {
  this->line_end_.set(std::move(x));
}

const bracket::end_length_optional &bracket::end_length() const {
  return this->end_length_;
}

bracket::end_length_optional &bracket::end_length() {
  return this->end_length_;
}

void bracket::end_length(const end_length_type &x) { this->end_length_.set(x); }

void bracket::end_length(const end_length_optional &x) {
  this->end_length_ = x;
}

void bracket::end_length(::std::unique_ptr<end_length_type> x) {
  this->end_length_.set(std::move(x));
}

const bracket::line_type_optional &bracket::line_type() const {
  return this->line_type_;
}

bracket::line_type_optional &bracket::line_type() { return this->line_type_; }

void bracket::line_type(const line_type_type &x) { this->line_type_.set(x); }

void bracket::line_type(const line_type_optional &x) { this->line_type_ = x; }

void bracket::line_type(::std::unique_ptr<line_type_type> x) {
  this->line_type_.set(std::move(x));
}

const bracket::dash_length_optional &bracket::dash_length() const {
  return this->dash_length_;
}

bracket::dash_length_optional &bracket::dash_length() {
  return this->dash_length_;
}

void bracket::dash_length(const dash_length_type &x) {
  this->dash_length_.set(x);
}

void bracket::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void bracket::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const bracket::space_length_optional &bracket::space_length() const {
  return this->space_length_;
}

bracket::space_length_optional &bracket::space_length() {
  return this->space_length_;
}

void bracket::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void bracket::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void bracket::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const bracket::default_x_optional &bracket::default_x() const {
  return this->default_x_;
}

bracket::default_x_optional &bracket::default_x() { return this->default_x_; }

void bracket::default_x(const default_x_type &x) { this->default_x_.set(x); }

void bracket::default_x(const default_x_optional &x) { this->default_x_ = x; }

void bracket::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const bracket::default_y_optional &bracket::default_y() const {
  return this->default_y_;
}

bracket::default_y_optional &bracket::default_y() { return this->default_y_; }

void bracket::default_y(const default_y_type &x) { this->default_y_.set(x); }

void bracket::default_y(const default_y_optional &x) { this->default_y_ = x; }

void bracket::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const bracket::relative_x_optional &bracket::relative_x() const {
  return this->relative_x_;
}

bracket::relative_x_optional &bracket::relative_x() {
  return this->relative_x_;
}

void bracket::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void bracket::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void bracket::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const bracket::relative_y_optional &bracket::relative_y() const {
  return this->relative_y_;
}

bracket::relative_y_optional &bracket::relative_y() {
  return this->relative_y_;
}

void bracket::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void bracket::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void bracket::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const bracket::color_optional &bracket::color() const { return this->color_; }

bracket::color_optional &bracket::color() { return this->color_; }

void bracket::color(const color_type &x) { this->color_.set(x); }

void bracket::color(const color_optional &x) { this->color_ = x; }

void bracket::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// dashes
//

const dashes::type_type &dashes::type() const { return this->type_.get(); }

dashes::type_type &dashes::type() { return this->type_.get(); }

void dashes::type(const type_type &x) { this->type_.set(x); }

void dashes::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const dashes::number_optional &dashes::number() const { return this->number_; }

dashes::number_optional &dashes::number() { return this->number_; }

void dashes::number(const number_type &x) { this->number_.set(x); }

void dashes::number(const number_optional &x) { this->number_ = x; }

void dashes::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const dashes::dash_length_optional &dashes::dash_length() const {
  return this->dash_length_;
}

dashes::dash_length_optional &dashes::dash_length() {
  return this->dash_length_;
}

void dashes::dash_length(const dash_length_type &x) {
  this->dash_length_.set(x);
}

void dashes::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void dashes::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const dashes::space_length_optional &dashes::space_length() const {
  return this->space_length_;
}

dashes::space_length_optional &dashes::space_length() {
  return this->space_length_;
}

void dashes::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void dashes::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void dashes::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const dashes::default_x_optional &dashes::default_x() const {
  return this->default_x_;
}

dashes::default_x_optional &dashes::default_x() { return this->default_x_; }

void dashes::default_x(const default_x_type &x) { this->default_x_.set(x); }

void dashes::default_x(const default_x_optional &x) { this->default_x_ = x; }

void dashes::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const dashes::default_y_optional &dashes::default_y() const {
  return this->default_y_;
}

dashes::default_y_optional &dashes::default_y() { return this->default_y_; }

void dashes::default_y(const default_y_type &x) { this->default_y_.set(x); }

void dashes::default_y(const default_y_optional &x) { this->default_y_ = x; }

void dashes::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const dashes::relative_x_optional &dashes::relative_x() const {
  return this->relative_x_;
}

dashes::relative_x_optional &dashes::relative_x() { return this->relative_x_; }

void dashes::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void dashes::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void dashes::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const dashes::relative_y_optional &dashes::relative_y() const {
  return this->relative_y_;
}

dashes::relative_y_optional &dashes::relative_y() { return this->relative_y_; }

void dashes::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void dashes::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void dashes::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const dashes::color_optional &dashes::color() const { return this->color_; }

dashes::color_optional &dashes::color() { return this->color_; }

void dashes::color(const color_type &x) { this->color_.set(x); }

void dashes::color(const color_optional &x) { this->color_ = x; }

void dashes::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// degree
//

const degree::degree_value_type &degree::degree_value() const {
  return this->degree_value_.get();
}

degree::degree_value_type &degree::degree_value() {
  return this->degree_value_.get();
}

void degree::degree_value(const degree_value_type &x) {
  this->degree_value_.set(x);
}

void degree::degree_value(::std::unique_ptr<degree_value_type> x) {
  this->degree_value_.set(std::move(x));
}

const degree::degree_alter_type &degree::degree_alter() const {
  return this->degree_alter_.get();
}

degree::degree_alter_type &degree::degree_alter() {
  return this->degree_alter_.get();
}

void degree::degree_alter(const degree_alter_type &x) {
  this->degree_alter_.set(x);
}

void degree::degree_alter(::std::unique_ptr<degree_alter_type> x) {
  this->degree_alter_.set(std::move(x));
}

const degree::degree_type_type &degree::degree_type() const {
  return this->degree_type_.get();
}

degree::degree_type_type &degree::degree_type() {
  return this->degree_type_.get();
}

void degree::degree_type(const degree_type_type &x) {
  this->degree_type_.set(x);
}

void degree::degree_type(::std::unique_ptr<degree_type_type> x) {
  this->degree_type_.set(std::move(x));
}

const degree::print_object_optional &degree::print_object() const {
  return this->print_object_;
}

degree::print_object_optional &degree::print_object() {
  return this->print_object_;
}

void degree::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void degree::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void degree::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

// degree_alter
//

const degree_alter::default_x_optional &degree_alter::default_x() const {
  return this->default_x_;
}

degree_alter::default_x_optional &degree_alter::default_x() {
  return this->default_x_;
}

void degree_alter::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void degree_alter::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void degree_alter::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const degree_alter::default_y_optional &degree_alter::default_y() const {
  return this->default_y_;
}

degree_alter::default_y_optional &degree_alter::default_y() {
  return this->default_y_;
}

void degree_alter::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void degree_alter::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void degree_alter::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const degree_alter::relative_x_optional &degree_alter::relative_x() const {
  return this->relative_x_;
}

degree_alter::relative_x_optional &degree_alter::relative_x() {
  return this->relative_x_;
}

void degree_alter::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void degree_alter::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void degree_alter::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const degree_alter::relative_y_optional &degree_alter::relative_y() const {
  return this->relative_y_;
}

degree_alter::relative_y_optional &degree_alter::relative_y() {
  return this->relative_y_;
}

void degree_alter::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void degree_alter::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void degree_alter::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const degree_alter::font_family_optional &degree_alter::font_family() const {
  return this->font_family_;
}

degree_alter::font_family_optional &degree_alter::font_family() {
  return this->font_family_;
}

void degree_alter::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void degree_alter::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void degree_alter::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const degree_alter::font_style_optional &degree_alter::font_style() const {
  return this->font_style_;
}

degree_alter::font_style_optional &degree_alter::font_style() {
  return this->font_style_;
}

void degree_alter::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void degree_alter::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void degree_alter::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const degree_alter::font_size_optional &degree_alter::font_size() const {
  return this->font_size_;
}

degree_alter::font_size_optional &degree_alter::font_size() {
  return this->font_size_;
}

void degree_alter::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void degree_alter::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void degree_alter::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const degree_alter::font_weight_optional &degree_alter::font_weight() const {
  return this->font_weight_;
}

degree_alter::font_weight_optional &degree_alter::font_weight() {
  return this->font_weight_;
}

void degree_alter::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void degree_alter::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void degree_alter::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const degree_alter::color_optional &degree_alter::color() const {
  return this->color_;
}

degree_alter::color_optional &degree_alter::color() { return this->color_; }

void degree_alter::color(const color_type &x) { this->color_.set(x); }

void degree_alter::color(const color_optional &x) { this->color_ = x; }

void degree_alter::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const degree_alter::plus_minus_optional &degree_alter::plus_minus() const {
  return this->plus_minus_;
}

degree_alter::plus_minus_optional &degree_alter::plus_minus() {
  return this->plus_minus_;
}

void degree_alter::plus_minus(const plus_minus_type &x) {
  this->plus_minus_.set(x);
}

void degree_alter::plus_minus(const plus_minus_optional &x) {
  this->plus_minus_ = x;
}

void degree_alter::plus_minus(::std::unique_ptr<plus_minus_type> x) {
  this->plus_minus_.set(std::move(x));
}

// degree_type
//

const degree_type::text_optional &degree_type::text() const {
  return this->text_;
}

degree_type::text_optional &degree_type::text() { return this->text_; }

void degree_type::text(const text_type &x) { this->text_.set(x); }

void degree_type::text(const text_optional &x) { this->text_ = x; }

void degree_type::text(::std::unique_ptr<text_type> x) {
  this->text_.set(std::move(x));
}

const degree_type::default_x_optional &degree_type::default_x() const {
  return this->default_x_;
}

degree_type::default_x_optional &degree_type::default_x() {
  return this->default_x_;
}

void degree_type::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void degree_type::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void degree_type::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const degree_type::default_y_optional &degree_type::default_y() const {
  return this->default_y_;
}

degree_type::default_y_optional &degree_type::default_y() {
  return this->default_y_;
}

void degree_type::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void degree_type::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void degree_type::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const degree_type::relative_x_optional &degree_type::relative_x() const {
  return this->relative_x_;
}

degree_type::relative_x_optional &degree_type::relative_x() {
  return this->relative_x_;
}

void degree_type::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void degree_type::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void degree_type::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const degree_type::relative_y_optional &degree_type::relative_y() const {
  return this->relative_y_;
}

degree_type::relative_y_optional &degree_type::relative_y() {
  return this->relative_y_;
}

void degree_type::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void degree_type::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void degree_type::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const degree_type::font_family_optional &degree_type::font_family() const {
  return this->font_family_;
}

degree_type::font_family_optional &degree_type::font_family() {
  return this->font_family_;
}

void degree_type::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void degree_type::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void degree_type::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const degree_type::font_style_optional &degree_type::font_style() const {
  return this->font_style_;
}

degree_type::font_style_optional &degree_type::font_style() {
  return this->font_style_;
}

void degree_type::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void degree_type::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void degree_type::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const degree_type::font_size_optional &degree_type::font_size() const {
  return this->font_size_;
}

degree_type::font_size_optional &degree_type::font_size() {
  return this->font_size_;
}

void degree_type::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void degree_type::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void degree_type::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const degree_type::font_weight_optional &degree_type::font_weight() const {
  return this->font_weight_;
}

degree_type::font_weight_optional &degree_type::font_weight() {
  return this->font_weight_;
}

void degree_type::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void degree_type::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void degree_type::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const degree_type::color_optional &degree_type::color() const {
  return this->color_;
}

degree_type::color_optional &degree_type::color() { return this->color_; }

void degree_type::color(const color_type &x) { this->color_.set(x); }

void degree_type::color(const color_optional &x) { this->color_ = x; }

void degree_type::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// degree_value
//

const degree_value::symbol_optional &degree_value::symbol() const {
  return this->symbol_;
}

degree_value::symbol_optional &degree_value::symbol() { return this->symbol_; }

void degree_value::symbol(const symbol_type &x) { this->symbol_.set(x); }

void degree_value::symbol(const symbol_optional &x) { this->symbol_ = x; }

void degree_value::symbol(::std::unique_ptr<symbol_type> x) {
  this->symbol_.set(std::move(x));
}

const degree_value::text_optional &degree_value::text() const {
  return this->text_;
}

degree_value::text_optional &degree_value::text() { return this->text_; }

void degree_value::text(const text_type &x) { this->text_.set(x); }

void degree_value::text(const text_optional &x) { this->text_ = x; }

void degree_value::text(::std::unique_ptr<text_type> x) {
  this->text_.set(std::move(x));
}

const degree_value::default_x_optional &degree_value::default_x() const {
  return this->default_x_;
}

degree_value::default_x_optional &degree_value::default_x() {
  return this->default_x_;
}

void degree_value::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void degree_value::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void degree_value::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const degree_value::default_y_optional &degree_value::default_y() const {
  return this->default_y_;
}

degree_value::default_y_optional &degree_value::default_y() {
  return this->default_y_;
}

void degree_value::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void degree_value::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void degree_value::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const degree_value::relative_x_optional &degree_value::relative_x() const {
  return this->relative_x_;
}

degree_value::relative_x_optional &degree_value::relative_x() {
  return this->relative_x_;
}

void degree_value::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void degree_value::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void degree_value::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const degree_value::relative_y_optional &degree_value::relative_y() const {
  return this->relative_y_;
}

degree_value::relative_y_optional &degree_value::relative_y() {
  return this->relative_y_;
}

void degree_value::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void degree_value::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void degree_value::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const degree_value::font_family_optional &degree_value::font_family() const {
  return this->font_family_;
}

degree_value::font_family_optional &degree_value::font_family() {
  return this->font_family_;
}

void degree_value::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void degree_value::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void degree_value::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const degree_value::font_style_optional &degree_value::font_style() const {
  return this->font_style_;
}

degree_value::font_style_optional &degree_value::font_style() {
  return this->font_style_;
}

void degree_value::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void degree_value::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void degree_value::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const degree_value::font_size_optional &degree_value::font_size() const {
  return this->font_size_;
}

degree_value::font_size_optional &degree_value::font_size() {
  return this->font_size_;
}

void degree_value::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void degree_value::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void degree_value::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const degree_value::font_weight_optional &degree_value::font_weight() const {
  return this->font_weight_;
}

degree_value::font_weight_optional &degree_value::font_weight() {
  return this->font_weight_;
}

void degree_value::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void degree_value::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void degree_value::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const degree_value::color_optional &degree_value::color() const {
  return this->color_;
}

degree_value::color_optional &degree_value::color() { return this->color_; }

void degree_value::color(const color_type &x) { this->color_.set(x); }

void degree_value::color(const color_optional &x) { this->color_ = x; }

void degree_value::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// direction
//

const direction::direction_type_sequence &direction::direction_type() const {
  return this->direction_type_;
}

direction::direction_type_sequence &direction::direction_type() {
  return this->direction_type_;
}

void direction::direction_type(const direction_type_sequence &s) {
  this->direction_type_ = s;
}

const direction::offset_optional &direction::offset() const {
  return this->offset_;
}

direction::offset_optional &direction::offset() { return this->offset_; }

void direction::offset(const offset_type &x) { this->offset_.set(x); }

void direction::offset(const offset_optional &x) { this->offset_ = x; }

void direction::offset(::std::unique_ptr<offset_type> x) {
  this->offset_.set(std::move(x));
}

const direction::footnote_optional &direction::footnote() const {
  return this->footnote_;
}

direction::footnote_optional &direction::footnote() { return this->footnote_; }

void direction::footnote(const footnote_type &x) { this->footnote_.set(x); }

void direction::footnote(const footnote_optional &x) { this->footnote_ = x; }

void direction::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const direction::level_optional &direction::level() const {
  return this->level_;
}

direction::level_optional &direction::level() { return this->level_; }

void direction::level(const level_type &x) { this->level_.set(x); }

void direction::level(const level_optional &x) { this->level_ = x; }

void direction::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const direction::voice_optional &direction::voice() const {
  return this->voice_;
}

direction::voice_optional &direction::voice() { return this->voice_; }

void direction::voice(const voice_type &x) { this->voice_.set(x); }

void direction::voice(const voice_optional &x) { this->voice_ = x; }

void direction::voice(::std::unique_ptr<voice_type> x) {
  this->voice_.set(std::move(x));
}

const direction::staff_optional &direction::staff() const {
  return this->staff_;
}

direction::staff_optional &direction::staff() { return this->staff_; }

void direction::staff(const staff_type &x) { this->staff_.set(x); }

void direction::staff(const staff_optional &x) { this->staff_ = x; }

const direction::sound_optional &direction::sound() const {
  return this->sound_;
}

direction::sound_optional &direction::sound() { return this->sound_; }

void direction::sound(const sound_type &x) { this->sound_.set(x); }

void direction::sound(const sound_optional &x) { this->sound_ = x; }

void direction::sound(::std::unique_ptr<sound_type> x) {
  this->sound_.set(std::move(x));
}

const direction::placement_optional &direction::placement() const {
  return this->placement_;
}

direction::placement_optional &direction::placement() {
  return this->placement_;
}

void direction::placement(const placement_type &x) { this->placement_.set(x); }

void direction::placement(const placement_optional &x) { this->placement_ = x; }

void direction::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const direction::directive_optional &direction::directive() const {
  return this->directive_;
}

direction::directive_optional &direction::directive() {
  return this->directive_;
}

void direction::directive(const directive_type &x) { this->directive_.set(x); }

void direction::directive(const directive_optional &x) { this->directive_ = x; }

void direction::directive(::std::unique_ptr<directive_type> x) {
  this->directive_.set(std::move(x));
}

// direction_type
//

const direction_type::rehearsal_sequence &direction_type::rehearsal() const {
  return this->rehearsal_;
}

direction_type::rehearsal_sequence &direction_type::rehearsal() {
  return this->rehearsal_;
}

void direction_type::rehearsal(const rehearsal_sequence &s) {
  this->rehearsal_ = s;
}

const direction_type::segno_sequence &direction_type::segno() const {
  return this->segno_;
}

direction_type::segno_sequence &direction_type::segno() { return this->segno_; }

void direction_type::segno(const segno_sequence &s) { this->segno_ = s; }

const direction_type::words_sequence &direction_type::words() const {
  return this->words_;
}

direction_type::words_sequence &direction_type::words() { return this->words_; }

void direction_type::words(const words_sequence &s) { this->words_ = s; }

const direction_type::coda_sequence &direction_type::coda() const {
  return this->coda_;
}

direction_type::coda_sequence &direction_type::coda() { return this->coda_; }

void direction_type::coda(const coda_sequence &s) { this->coda_ = s; }

const direction_type::wedge_optional &direction_type::wedge() const {
  return this->wedge_;
}

direction_type::wedge_optional &direction_type::wedge() { return this->wedge_; }

void direction_type::wedge(const wedge_type &x) { this->wedge_.set(x); }

void direction_type::wedge(const wedge_optional &x) { this->wedge_ = x; }

void direction_type::wedge(::std::unique_ptr<wedge_type> x) {
  this->wedge_.set(std::move(x));
}

const direction_type::dynamics_sequence &direction_type::dynamics() const {
  return this->dynamics_;
}

direction_type::dynamics_sequence &direction_type::dynamics() {
  return this->dynamics_;
}

void direction_type::dynamics(const dynamics_sequence &s) {
  this->dynamics_ = s;
}

const direction_type::dashes_optional &direction_type::dashes() const {
  return this->dashes_;
}

direction_type::dashes_optional &direction_type::dashes() {
  return this->dashes_;
}

void direction_type::dashes(const dashes_type &x) { this->dashes_.set(x); }

void direction_type::dashes(const dashes_optional &x) { this->dashes_ = x; }

void direction_type::dashes(::std::unique_ptr<dashes_type> x) {
  this->dashes_.set(std::move(x));
}

const direction_type::bracket_optional &direction_type::bracket() const {
  return this->bracket_;
}

direction_type::bracket_optional &direction_type::bracket() {
  return this->bracket_;
}

void direction_type::bracket(const bracket_type &x) { this->bracket_.set(x); }

void direction_type::bracket(const bracket_optional &x) { this->bracket_ = x; }

void direction_type::bracket(::std::unique_ptr<bracket_type> x) {
  this->bracket_.set(std::move(x));
}

const direction_type::pedal_optional &direction_type::pedal() const {
  return this->pedal_;
}

direction_type::pedal_optional &direction_type::pedal() { return this->pedal_; }

void direction_type::pedal(const pedal_type &x) { this->pedal_.set(x); }

void direction_type::pedal(const pedal_optional &x) { this->pedal_ = x; }

void direction_type::pedal(::std::unique_ptr<pedal_type> x) {
  this->pedal_.set(std::move(x));
}

const direction_type::metronome_optional &direction_type::metronome() const {
  return this->metronome_;
}

direction_type::metronome_optional &direction_type::metronome() {
  return this->metronome_;
}

void direction_type::metronome(const metronome_type &x) {
  this->metronome_.set(x);
}

void direction_type::metronome(const metronome_optional &x) {
  this->metronome_ = x;
}

void direction_type::metronome(::std::unique_ptr<metronome_type> x) {
  this->metronome_.set(std::move(x));
}

const direction_type::octave_shift_optional &
direction_type::octave_shift() const {
  return this->octave_shift_;
}

direction_type::octave_shift_optional &direction_type::octave_shift() {
  return this->octave_shift_;
}

void direction_type::octave_shift(const octave_shift_type &x) {
  this->octave_shift_.set(x);
}

void direction_type::octave_shift(const octave_shift_optional &x) {
  this->octave_shift_ = x;
}

void direction_type::octave_shift(::std::unique_ptr<octave_shift_type> x) {
  this->octave_shift_.set(std::move(x));
}

const direction_type::harp_pedals_optional &
direction_type::harp_pedals() const {
  return this->harp_pedals_;
}

direction_type::harp_pedals_optional &direction_type::harp_pedals() {
  return this->harp_pedals_;
}

void direction_type::harp_pedals(const harp_pedals_type &x) {
  this->harp_pedals_.set(x);
}

void direction_type::harp_pedals(const harp_pedals_optional &x) {
  this->harp_pedals_ = x;
}

void direction_type::harp_pedals(::std::unique_ptr<harp_pedals_type> x) {
  this->harp_pedals_.set(std::move(x));
}

const direction_type::damp_optional &direction_type::damp() const {
  return this->damp_;
}

direction_type::damp_optional &direction_type::damp() { return this->damp_; }

void direction_type::damp(const damp_type &x) { this->damp_.set(x); }

void direction_type::damp(const damp_optional &x) { this->damp_ = x; }

void direction_type::damp(::std::unique_ptr<damp_type> x) {
  this->damp_.set(std::move(x));
}

const direction_type::damp_all_optional &direction_type::damp_all() const {
  return this->damp_all_;
}

direction_type::damp_all_optional &direction_type::damp_all() {
  return this->damp_all_;
}

void direction_type::damp_all(const damp_all_type &x) {
  this->damp_all_.set(x);
}

void direction_type::damp_all(const damp_all_optional &x) {
  this->damp_all_ = x;
}

void direction_type::damp_all(::std::unique_ptr<damp_all_type> x) {
  this->damp_all_.set(std::move(x));
}

const direction_type::eyeglasses_optional &direction_type::eyeglasses() const {
  return this->eyeglasses_;
}

direction_type::eyeglasses_optional &direction_type::eyeglasses() {
  return this->eyeglasses_;
}

void direction_type::eyeglasses(const eyeglasses_type &x) {
  this->eyeglasses_.set(x);
}

void direction_type::eyeglasses(const eyeglasses_optional &x) {
  this->eyeglasses_ = x;
}

void direction_type::eyeglasses(::std::unique_ptr<eyeglasses_type> x) {
  this->eyeglasses_.set(std::move(x));
}

const direction_type::string_mute_optional &
direction_type::string_mute() const {
  return this->string_mute_;
}

direction_type::string_mute_optional &direction_type::string_mute() {
  return this->string_mute_;
}

void direction_type::string_mute(const string_mute_type &x) {
  this->string_mute_.set(x);
}

void direction_type::string_mute(const string_mute_optional &x) {
  this->string_mute_ = x;
}

void direction_type::string_mute(::std::unique_ptr<string_mute_type> x) {
  this->string_mute_.set(std::move(x));
}

const direction_type::scordatura_optional &direction_type::scordatura() const {
  return this->scordatura_;
}

direction_type::scordatura_optional &direction_type::scordatura() {
  return this->scordatura_;
}

void direction_type::scordatura(const scordatura_type &x) {
  this->scordatura_.set(x);
}

void direction_type::scordatura(const scordatura_optional &x) {
  this->scordatura_ = x;
}

void direction_type::scordatura(::std::unique_ptr<scordatura_type> x) {
  this->scordatura_.set(std::move(x));
}

const direction_type::image_optional &direction_type::image() const {
  return this->image_;
}

direction_type::image_optional &direction_type::image() { return this->image_; }

void direction_type::image(const image_type &x) { this->image_.set(x); }

void direction_type::image(const image_optional &x) { this->image_ = x; }

void direction_type::image(::std::unique_ptr<image_type> x) {
  this->image_.set(std::move(x));
}

const direction_type::principal_voice_optional &
direction_type::principal_voice() const {
  return this->principal_voice_;
}

direction_type::principal_voice_optional &direction_type::principal_voice() {
  return this->principal_voice_;
}

void direction_type::principal_voice(const principal_voice_type &x) {
  this->principal_voice_.set(x);
}

void direction_type::principal_voice(const principal_voice_optional &x) {
  this->principal_voice_ = x;
}

void
direction_type::principal_voice(::std::unique_ptr<principal_voice_type> x) {
  this->principal_voice_.set(std::move(x));
}

const direction_type::accordion_registration_optional &
direction_type::accordion_registration() const {
  return this->accordion_registration_;
}

direction_type::accordion_registration_optional &
direction_type::accordion_registration() {
  return this->accordion_registration_;
}

void
direction_type::accordion_registration(const accordion_registration_type &x) {
  this->accordion_registration_.set(x);
}

void direction_type::accordion_registration(
  const accordion_registration_optional &x) {
  this->accordion_registration_ = x;
}

void direction_type::accordion_registration(
  ::std::unique_ptr<accordion_registration_type> x) {
  this->accordion_registration_.set(std::move(x));
}

const direction_type::percussion_sequence &direction_type::percussion() const {
  return this->percussion_;
}

direction_type::percussion_sequence &direction_type::percussion() {
  return this->percussion_;
}

void direction_type::percussion(const percussion_sequence &s) {
  this->percussion_ = s;
}

const direction_type::other_direction_optional &
direction_type::other_direction() const {
  return this->other_direction_;
}

direction_type::other_direction_optional &direction_type::other_direction() {
  return this->other_direction_;
}

void direction_type::other_direction(const other_direction_type &x) {
  this->other_direction_.set(x);
}

void direction_type::other_direction(const other_direction_optional &x) {
  this->other_direction_ = x;
}

void
direction_type::other_direction(::std::unique_ptr<other_direction_type> x) {
  this->other_direction_.set(std::move(x));
}

// feature
//

const feature::type_optional &feature::type() const { return this->type_; }

feature::type_optional &feature::type() { return this->type_; }

void feature::type(const type_type &x) { this->type_.set(x); }

void feature::type(const type_optional &x) { this->type_ = x; }

void feature::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

// first_fret
//

const first_fret::text_optional &first_fret::text() const {
  return this->text_;
}

first_fret::text_optional &first_fret::text() { return this->text_; }

void first_fret::text(const text_type &x) { this->text_.set(x); }

void first_fret::text(const text_optional &x) { this->text_ = x; }

void first_fret::text(::std::unique_ptr<text_type> x) {
  this->text_.set(std::move(x));
}

const first_fret::location_optional &first_fret::location() const {
  return this->location_;
}

first_fret::location_optional &first_fret::location() {
  return this->location_;
}

void first_fret::location(const location_type &x) { this->location_.set(x); }

void first_fret::location(const location_optional &x) { this->location_ = x; }

void first_fret::location(::std::unique_ptr<location_type> x) {
  this->location_.set(std::move(x));
}

// frame
//

const frame::frame_strings_type &frame::frame_strings() const {
  return this->frame_strings_.get();
}

frame::frame_strings_type &frame::frame_strings() {
  return this->frame_strings_.get();
}

void frame::frame_strings(const frame_strings_type &x) {
  this->frame_strings_.set(x);
}

const frame::frame_frets_type &frame::frame_frets() const {
  return this->frame_frets_.get();
}

frame::frame_frets_type &frame::frame_frets() {
  return this->frame_frets_.get();
}

void frame::frame_frets(const frame_frets_type &x) {
  this->frame_frets_.set(x);
}

const frame::first_fret_optional &frame::first_fret() const {
  return this->first_fret_;
}

frame::first_fret_optional &frame::first_fret() { return this->first_fret_; }

void frame::first_fret(const first_fret_type &x) { this->first_fret_.set(x); }

void frame::first_fret(const first_fret_optional &x) { this->first_fret_ = x; }

void frame::first_fret(::std::unique_ptr<first_fret_type> x) {
  this->first_fret_.set(std::move(x));
}

const frame::frame_note_sequence &frame::frame_note() const {
  return this->frame_note_;
}

frame::frame_note_sequence &frame::frame_note() { return this->frame_note_; }

void frame::frame_note(const frame_note_sequence &s) { this->frame_note_ = s; }

const frame::default_x_optional &frame::default_x() const {
  return this->default_x_;
}

frame::default_x_optional &frame::default_x() { return this->default_x_; }

void frame::default_x(const default_x_type &x) { this->default_x_.set(x); }

void frame::default_x(const default_x_optional &x) { this->default_x_ = x; }

void frame::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const frame::default_y_optional &frame::default_y() const {
  return this->default_y_;
}

frame::default_y_optional &frame::default_y() { return this->default_y_; }

void frame::default_y(const default_y_type &x) { this->default_y_.set(x); }

void frame::default_y(const default_y_optional &x) { this->default_y_ = x; }

void frame::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const frame::relative_x_optional &frame::relative_x() const {
  return this->relative_x_;
}

frame::relative_x_optional &frame::relative_x() { return this->relative_x_; }

void frame::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void frame::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void frame::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const frame::relative_y_optional &frame::relative_y() const {
  return this->relative_y_;
}

frame::relative_y_optional &frame::relative_y() { return this->relative_y_; }

void frame::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void frame::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void frame::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const frame::color_optional &frame::color() const { return this->color_; }

frame::color_optional &frame::color() { return this->color_; }

void frame::color(const color_type &x) { this->color_.set(x); }

void frame::color(const color_optional &x) { this->color_ = x; }

void frame::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const frame::halign_optional &frame::halign() const { return this->halign_; }

frame::halign_optional &frame::halign() { return this->halign_; }

void frame::halign(const halign_type &x) { this->halign_.set(x); }

void frame::halign(const halign_optional &x) { this->halign_ = x; }

void frame::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const frame::valign_optional &frame::valign() const { return this->valign_; }

frame::valign_optional &frame::valign() { return this->valign_; }

void frame::valign(const valign_type &x) { this->valign_.set(x); }

void frame::valign(const valign_optional &x) { this->valign_ = x; }

void frame::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

const frame::height_optional &frame::height() const { return this->height_; }

frame::height_optional &frame::height() { return this->height_; }

void frame::height(const height_type &x) { this->height_.set(x); }

void frame::height(const height_optional &x) { this->height_ = x; }

void frame::height(::std::unique_ptr<height_type> x) {
  this->height_.set(std::move(x));
}

const frame::width_optional &frame::width() const { return this->width_; }

frame::width_optional &frame::width() { return this->width_; }

void frame::width(const width_type &x) { this->width_.set(x); }

void frame::width(const width_optional &x) { this->width_ = x; }

void frame::width(::std::unique_ptr<width_type> x) {
  this->width_.set(std::move(x));
}

const frame::unplayed_optional &frame::unplayed() const {
  return this->unplayed_;
}

frame::unplayed_optional &frame::unplayed() { return this->unplayed_; }

void frame::unplayed(const unplayed_type &x) { this->unplayed_.set(x); }

void frame::unplayed(const unplayed_optional &x) { this->unplayed_ = x; }

void frame::unplayed(::std::unique_ptr<unplayed_type> x) {
  this->unplayed_.set(std::move(x));
}

// frame_note
//

const frame_note::string_type &frame_note::string() const {
  return this->string_.get();
}

frame_note::string_type &frame_note::string() { return this->string_.get(); }

void frame_note::string(const string_type &x) { this->string_.set(x); }

void frame_note::string(::std::unique_ptr<string_type> x) {
  this->string_.set(std::move(x));
}

const frame_note::fret_type &frame_note::fret() const {
  return this->fret_.get();
}

frame_note::fret_type &frame_note::fret() { return this->fret_.get(); }

void frame_note::fret(const fret_type &x) { this->fret_.set(x); }

void frame_note::fret(::std::unique_ptr<fret_type> x) {
  this->fret_.set(std::move(x));
}

const frame_note::fingering_optional &frame_note::fingering() const {
  return this->fingering_;
}

frame_note::fingering_optional &frame_note::fingering() {
  return this->fingering_;
}

void frame_note::fingering(const fingering_type &x) { this->fingering_.set(x); }

void frame_note::fingering(const fingering_optional &x) {
  this->fingering_ = x;
}

void frame_note::fingering(::std::unique_ptr<fingering_type> x) {
  this->fingering_.set(std::move(x));
}

const frame_note::barre_optional &frame_note::barre() const {
  return this->barre_;
}

frame_note::barre_optional &frame_note::barre() { return this->barre_; }

void frame_note::barre(const barre_type &x) { this->barre_.set(x); }

void frame_note::barre(const barre_optional &x) { this->barre_ = x; }

void frame_note::barre(::std::unique_ptr<barre_type> x) {
  this->barre_.set(std::move(x));
}

// grouping
//

const grouping::feature_sequence &grouping::feature() const {
  return this->feature_;
}

grouping::feature_sequence &grouping::feature() { return this->feature_; }

void grouping::feature(const feature_sequence &s) { this->feature_ = s; }

const grouping::type_type &grouping::type() const { return this->type_.get(); }

grouping::type_type &grouping::type() { return this->type_.get(); }

void grouping::type(const type_type &x) { this->type_.set(x); }

void grouping::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const grouping::number_type &grouping::number() const {
  return this->number_.get();
}

grouping::number_type &grouping::number() { return this->number_.get(); }

void grouping::number(const number_type &x) { this->number_.set(x); }

void grouping::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const grouping::number_type &grouping::number_default_value() {
  return number_default_value_;
}

const grouping::member_of_optional &grouping::member_of() const {
  return this->member_of_;
}

grouping::member_of_optional &grouping::member_of() { return this->member_of_; }

void grouping::member_of(const member_of_type &x) { this->member_of_.set(x); }

void grouping::member_of(const member_of_optional &x) { this->member_of_ = x; }

void grouping::member_of(::std::unique_ptr<member_of_type> x) {
  this->member_of_.set(std::move(x));
}

// harmony
//

const harmony::root_sequence &harmony::root() const { return this->root_; }

harmony::root_sequence &harmony::root() { return this->root_; }

void harmony::root(const root_sequence &s) { this->root_ = s; }

const harmony::function_sequence &harmony::function() const {
  return this->function_;
}

harmony::function_sequence &harmony::function() { return this->function_; }

void harmony::function(const function_sequence &s) { this->function_ = s; }

const harmony::kind_sequence &harmony::kind() const { return this->kind_; }

harmony::kind_sequence &harmony::kind() { return this->kind_; }

void harmony::kind(const kind_sequence &s) { this->kind_ = s; }

const harmony::inversion_sequence &harmony::inversion() const {
  return this->inversion_;
}

harmony::inversion_sequence &harmony::inversion() { return this->inversion_; }

void harmony::inversion(const inversion_sequence &s) { this->inversion_ = s; }

const harmony::bass_sequence &harmony::bass() const { return this->bass_; }

harmony::bass_sequence &harmony::bass() { return this->bass_; }

void harmony::bass(const bass_sequence &s) { this->bass_ = s; }

const harmony::degree_sequence &harmony::degree() const {
  return this->degree_;
}

harmony::degree_sequence &harmony::degree() { return this->degree_; }

void harmony::degree(const degree_sequence &s) { this->degree_ = s; }

const harmony::frame_optional &harmony::frame() const { return this->frame_; }

harmony::frame_optional &harmony::frame() { return this->frame_; }

void harmony::frame(const frame_type &x) { this->frame_.set(x); }

void harmony::frame(const frame_optional &x) { this->frame_ = x; }

void harmony::frame(::std::unique_ptr<frame_type> x) {
  this->frame_.set(std::move(x));
}

const harmony::offset_optional &harmony::offset() const {
  return this->offset_;
}

harmony::offset_optional &harmony::offset() { return this->offset_; }

void harmony::offset(const offset_type &x) { this->offset_.set(x); }

void harmony::offset(const offset_optional &x) { this->offset_ = x; }

void harmony::offset(::std::unique_ptr<offset_type> x) {
  this->offset_.set(std::move(x));
}

const harmony::footnote_optional &harmony::footnote() const {
  return this->footnote_;
}

harmony::footnote_optional &harmony::footnote() { return this->footnote_; }

void harmony::footnote(const footnote_type &x) { this->footnote_.set(x); }

void harmony::footnote(const footnote_optional &x) { this->footnote_ = x; }

void harmony::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const harmony::level_optional &harmony::level() const { return this->level_; }

harmony::level_optional &harmony::level() { return this->level_; }

void harmony::level(const level_type &x) { this->level_.set(x); }

void harmony::level(const level_optional &x) { this->level_ = x; }

void harmony::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const harmony::staff_optional &harmony::staff() const { return this->staff_; }

harmony::staff_optional &harmony::staff() { return this->staff_; }

void harmony::staff(const staff_type &x) { this->staff_.set(x); }

void harmony::staff(const staff_optional &x) { this->staff_ = x; }

const harmony::type_optional &harmony::type() const { return this->type_; }

harmony::type_optional &harmony::type() { return this->type_; }

void harmony::type(const type_type &x) { this->type_.set(x); }

void harmony::type(const type_optional &x) { this->type_ = x; }

void harmony::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const harmony::print_object_optional &harmony::print_object() const {
  return this->print_object_;
}

harmony::print_object_optional &harmony::print_object() {
  return this->print_object_;
}

void harmony::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void harmony::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void harmony::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const harmony::print_frame_optional &harmony::print_frame() const {
  return this->print_frame_;
}

harmony::print_frame_optional &harmony::print_frame() {
  return this->print_frame_;
}

void harmony::print_frame(const print_frame_type &x) {
  this->print_frame_.set(x);
}

void harmony::print_frame(const print_frame_optional &x) {
  this->print_frame_ = x;
}

void harmony::print_frame(::std::unique_ptr<print_frame_type> x) {
  this->print_frame_.set(std::move(x));
}

const harmony::default_x_optional &harmony::default_x() const {
  return this->default_x_;
}

harmony::default_x_optional &harmony::default_x() { return this->default_x_; }

void harmony::default_x(const default_x_type &x) { this->default_x_.set(x); }

void harmony::default_x(const default_x_optional &x) { this->default_x_ = x; }

void harmony::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const harmony::default_y_optional &harmony::default_y() const {
  return this->default_y_;
}

harmony::default_y_optional &harmony::default_y() { return this->default_y_; }

void harmony::default_y(const default_y_type &x) { this->default_y_.set(x); }

void harmony::default_y(const default_y_optional &x) { this->default_y_ = x; }

void harmony::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const harmony::relative_x_optional &harmony::relative_x() const {
  return this->relative_x_;
}

harmony::relative_x_optional &harmony::relative_x() {
  return this->relative_x_;
}

void harmony::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void harmony::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void harmony::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const harmony::relative_y_optional &harmony::relative_y() const {
  return this->relative_y_;
}

harmony::relative_y_optional &harmony::relative_y() {
  return this->relative_y_;
}

void harmony::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void harmony::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void harmony::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const harmony::font_family_optional &harmony::font_family() const {
  return this->font_family_;
}

harmony::font_family_optional &harmony::font_family() {
  return this->font_family_;
}

void harmony::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void harmony::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void harmony::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const harmony::font_style_optional &harmony::font_style() const {
  return this->font_style_;
}

harmony::font_style_optional &harmony::font_style() {
  return this->font_style_;
}

void harmony::font_style(const font_style_type &x) { this->font_style_.set(x); }

void harmony::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void harmony::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const harmony::font_size_optional &harmony::font_size() const {
  return this->font_size_;
}

harmony::font_size_optional &harmony::font_size() { return this->font_size_; }

void harmony::font_size(const font_size_type &x) { this->font_size_.set(x); }

void harmony::font_size(const font_size_optional &x) { this->font_size_ = x; }

void harmony::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const harmony::font_weight_optional &harmony::font_weight() const {
  return this->font_weight_;
}

harmony::font_weight_optional &harmony::font_weight() {
  return this->font_weight_;
}

void harmony::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void harmony::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void harmony::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const harmony::color_optional &harmony::color() const { return this->color_; }

harmony::color_optional &harmony::color() { return this->color_; }

void harmony::color(const color_type &x) { this->color_.set(x); }

void harmony::color(const color_optional &x) { this->color_ = x; }

void harmony::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const harmony::placement_optional &harmony::placement() const {
  return this->placement_;
}

harmony::placement_optional &harmony::placement() { return this->placement_; }

void harmony::placement(const placement_type &x) { this->placement_.set(x); }

void harmony::placement(const placement_optional &x) { this->placement_ = x; }

void harmony::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// harp_pedals
//

const harp_pedals::pedal_tuning_sequence &harp_pedals::pedal_tuning() const {
  return this->pedal_tuning_;
}

harp_pedals::pedal_tuning_sequence &harp_pedals::pedal_tuning() {
  return this->pedal_tuning_;
}

void harp_pedals::pedal_tuning(const pedal_tuning_sequence &s) {
  this->pedal_tuning_ = s;
}

const harp_pedals::default_x_optional &harp_pedals::default_x() const {
  return this->default_x_;
}

harp_pedals::default_x_optional &harp_pedals::default_x() {
  return this->default_x_;
}

void harp_pedals::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void harp_pedals::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void harp_pedals::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const harp_pedals::default_y_optional &harp_pedals::default_y() const {
  return this->default_y_;
}

harp_pedals::default_y_optional &harp_pedals::default_y() {
  return this->default_y_;
}

void harp_pedals::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void harp_pedals::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void harp_pedals::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const harp_pedals::relative_x_optional &harp_pedals::relative_x() const {
  return this->relative_x_;
}

harp_pedals::relative_x_optional &harp_pedals::relative_x() {
  return this->relative_x_;
}

void harp_pedals::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void harp_pedals::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void harp_pedals::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const harp_pedals::relative_y_optional &harp_pedals::relative_y() const {
  return this->relative_y_;
}

harp_pedals::relative_y_optional &harp_pedals::relative_y() {
  return this->relative_y_;
}

void harp_pedals::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void harp_pedals::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void harp_pedals::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const harp_pedals::font_family_optional &harp_pedals::font_family() const {
  return this->font_family_;
}

harp_pedals::font_family_optional &harp_pedals::font_family() {
  return this->font_family_;
}

void harp_pedals::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void harp_pedals::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void harp_pedals::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const harp_pedals::font_style_optional &harp_pedals::font_style() const {
  return this->font_style_;
}

harp_pedals::font_style_optional &harp_pedals::font_style() {
  return this->font_style_;
}

void harp_pedals::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void harp_pedals::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void harp_pedals::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const harp_pedals::font_size_optional &harp_pedals::font_size() const {
  return this->font_size_;
}

harp_pedals::font_size_optional &harp_pedals::font_size() {
  return this->font_size_;
}

void harp_pedals::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void harp_pedals::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void harp_pedals::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const harp_pedals::font_weight_optional &harp_pedals::font_weight() const {
  return this->font_weight_;
}

harp_pedals::font_weight_optional &harp_pedals::font_weight() {
  return this->font_weight_;
}

void harp_pedals::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void harp_pedals::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void harp_pedals::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const harp_pedals::color_optional &harp_pedals::color() const {
  return this->color_;
}

harp_pedals::color_optional &harp_pedals::color() { return this->color_; }

void harp_pedals::color(const color_type &x) { this->color_.set(x); }

void harp_pedals::color(const color_optional &x) { this->color_ = x; }

void harp_pedals::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const harp_pedals::halign_optional &harp_pedals::halign() const {
  return this->halign_;
}

harp_pedals::halign_optional &harp_pedals::halign() { return this->halign_; }

void harp_pedals::halign(const halign_type &x) { this->halign_.set(x); }

void harp_pedals::halign(const halign_optional &x) { this->halign_ = x; }

void harp_pedals::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const harp_pedals::valign_optional &harp_pedals::valign() const {
  return this->valign_;
}

harp_pedals::valign_optional &harp_pedals::valign() { return this->valign_; }

void harp_pedals::valign(const valign_type &x) { this->valign_.set(x); }

void harp_pedals::valign(const valign_optional &x) { this->valign_ = x; }

void harp_pedals::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// image
//

const image::source_type &image::source() const { return this->source_.get(); }

image::source_type &image::source() { return this->source_.get(); }

void image::source(const source_type &x) { this->source_.set(x); }

void image::source(::std::unique_ptr<source_type> x) {
  this->source_.set(std::move(x));
}

const image::type_type &image::type() const { return this->type_.get(); }

image::type_type &image::type() { return this->type_.get(); }

void image::type(const type_type &x) { this->type_.set(x); }

void image::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const image::default_x_optional &image::default_x() const {
  return this->default_x_;
}

image::default_x_optional &image::default_x() { return this->default_x_; }

void image::default_x(const default_x_type &x) { this->default_x_.set(x); }

void image::default_x(const default_x_optional &x) { this->default_x_ = x; }

void image::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const image::default_y_optional &image::default_y() const {
  return this->default_y_;
}

image::default_y_optional &image::default_y() { return this->default_y_; }

void image::default_y(const default_y_type &x) { this->default_y_.set(x); }

void image::default_y(const default_y_optional &x) { this->default_y_ = x; }

void image::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const image::relative_x_optional &image::relative_x() const {
  return this->relative_x_;
}

image::relative_x_optional &image::relative_x() { return this->relative_x_; }

void image::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void image::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void image::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const image::relative_y_optional &image::relative_y() const {
  return this->relative_y_;
}

image::relative_y_optional &image::relative_y() { return this->relative_y_; }

void image::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void image::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void image::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const image::halign_optional &image::halign() const { return this->halign_; }

image::halign_optional &image::halign() { return this->halign_; }

void image::halign(const halign_type &x) { this->halign_.set(x); }

void image::halign(const halign_optional &x) { this->halign_ = x; }

void image::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const image::valign_optional &image::valign() const { return this->valign_; }

image::valign_optional &image::valign() { return this->valign_; }

void image::valign(const valign_type &x) { this->valign_.set(x); }

void image::valign(const valign_optional &x) { this->valign_ = x; }

void image::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// inversion
//

const inversion::default_x_optional &inversion::default_x() const {
  return this->default_x_;
}

inversion::default_x_optional &inversion::default_x() {
  return this->default_x_;
}

void inversion::default_x(const default_x_type &x) { this->default_x_.set(x); }

void inversion::default_x(const default_x_optional &x) { this->default_x_ = x; }

void inversion::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const inversion::default_y_optional &inversion::default_y() const {
  return this->default_y_;
}

inversion::default_y_optional &inversion::default_y() {
  return this->default_y_;
}

void inversion::default_y(const default_y_type &x) { this->default_y_.set(x); }

void inversion::default_y(const default_y_optional &x) { this->default_y_ = x; }

void inversion::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const inversion::relative_x_optional &inversion::relative_x() const {
  return this->relative_x_;
}

inversion::relative_x_optional &inversion::relative_x() {
  return this->relative_x_;
}

void inversion::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void inversion::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void inversion::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const inversion::relative_y_optional &inversion::relative_y() const {
  return this->relative_y_;
}

inversion::relative_y_optional &inversion::relative_y() {
  return this->relative_y_;
}

void inversion::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void inversion::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void inversion::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const inversion::font_family_optional &inversion::font_family() const {
  return this->font_family_;
}

inversion::font_family_optional &inversion::font_family() {
  return this->font_family_;
}

void inversion::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void inversion::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void inversion::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const inversion::font_style_optional &inversion::font_style() const {
  return this->font_style_;
}

inversion::font_style_optional &inversion::font_style() {
  return this->font_style_;
}

void inversion::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void inversion::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void inversion::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const inversion::font_size_optional &inversion::font_size() const {
  return this->font_size_;
}

inversion::font_size_optional &inversion::font_size() {
  return this->font_size_;
}

void inversion::font_size(const font_size_type &x) { this->font_size_.set(x); }

void inversion::font_size(const font_size_optional &x) { this->font_size_ = x; }

void inversion::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const inversion::font_weight_optional &inversion::font_weight() const {
  return this->font_weight_;
}

inversion::font_weight_optional &inversion::font_weight() {
  return this->font_weight_;
}

void inversion::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void inversion::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void inversion::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const inversion::color_optional &inversion::color() const {
  return this->color_;
}

inversion::color_optional &inversion::color() { return this->color_; }

void inversion::color(const color_type &x) { this->color_.set(x); }

void inversion::color(const color_optional &x) { this->color_ = x; }

void inversion::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// kind
//

const kind::use_symbols_optional &kind::use_symbols() const {
  return this->use_symbols_;
}

kind::use_symbols_optional &kind::use_symbols() { return this->use_symbols_; }

void kind::use_symbols(const use_symbols_type &x) { this->use_symbols_.set(x); }

void kind::use_symbols(const use_symbols_optional &x) {
  this->use_symbols_ = x;
}

void kind::use_symbols(::std::unique_ptr<use_symbols_type> x) {
  this->use_symbols_.set(std::move(x));
}

const kind::text_optional &kind::text() const { return this->text_; }

kind::text_optional &kind::text() { return this->text_; }

void kind::text(const text_type &x) { this->text_.set(x); }

void kind::text(const text_optional &x) { this->text_ = x; }

void kind::text(::std::unique_ptr<text_type> x) {
  this->text_.set(std::move(x));
}

const kind::stack_degrees_optional &kind::stack_degrees() const {
  return this->stack_degrees_;
}

kind::stack_degrees_optional &kind::stack_degrees() {
  return this->stack_degrees_;
}

void kind::stack_degrees(const stack_degrees_type &x) {
  this->stack_degrees_.set(x);
}

void kind::stack_degrees(const stack_degrees_optional &x) {
  this->stack_degrees_ = x;
}

void kind::stack_degrees(::std::unique_ptr<stack_degrees_type> x) {
  this->stack_degrees_.set(std::move(x));
}

const kind::parentheses_degrees_optional &kind::parentheses_degrees() const {
  return this->parentheses_degrees_;
}

kind::parentheses_degrees_optional &kind::parentheses_degrees() {
  return this->parentheses_degrees_;
}

void kind::parentheses_degrees(const parentheses_degrees_type &x) {
  this->parentheses_degrees_.set(x);
}

void kind::parentheses_degrees(const parentheses_degrees_optional &x) {
  this->parentheses_degrees_ = x;
}

void kind::parentheses_degrees(::std::unique_ptr<parentheses_degrees_type> x) {
  this->parentheses_degrees_.set(std::move(x));
}

const kind::bracket_degrees_optional &kind::bracket_degrees() const {
  return this->bracket_degrees_;
}

kind::bracket_degrees_optional &kind::bracket_degrees() {
  return this->bracket_degrees_;
}

void kind::bracket_degrees(const bracket_degrees_type &x) {
  this->bracket_degrees_.set(x);
}

void kind::bracket_degrees(const bracket_degrees_optional &x) {
  this->bracket_degrees_ = x;
}

void kind::bracket_degrees(::std::unique_ptr<bracket_degrees_type> x) {
  this->bracket_degrees_.set(std::move(x));
}

const kind::default_x_optional &kind::default_x() const {
  return this->default_x_;
}

kind::default_x_optional &kind::default_x() { return this->default_x_; }

void kind::default_x(const default_x_type &x) { this->default_x_.set(x); }

void kind::default_x(const default_x_optional &x) { this->default_x_ = x; }

void kind::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const kind::default_y_optional &kind::default_y() const {
  return this->default_y_;
}

kind::default_y_optional &kind::default_y() { return this->default_y_; }

void kind::default_y(const default_y_type &x) { this->default_y_.set(x); }

void kind::default_y(const default_y_optional &x) { this->default_y_ = x; }

void kind::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const kind::relative_x_optional &kind::relative_x() const {
  return this->relative_x_;
}

kind::relative_x_optional &kind::relative_x() { return this->relative_x_; }

void kind::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void kind::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void kind::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const kind::relative_y_optional &kind::relative_y() const {
  return this->relative_y_;
}

kind::relative_y_optional &kind::relative_y() { return this->relative_y_; }

void kind::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void kind::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void kind::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const kind::font_family_optional &kind::font_family() const {
  return this->font_family_;
}

kind::font_family_optional &kind::font_family() { return this->font_family_; }

void kind::font_family(const font_family_type &x) { this->font_family_.set(x); }

void kind::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void kind::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const kind::font_style_optional &kind::font_style() const {
  return this->font_style_;
}

kind::font_style_optional &kind::font_style() { return this->font_style_; }

void kind::font_style(const font_style_type &x) { this->font_style_.set(x); }

void kind::font_style(const font_style_optional &x) { this->font_style_ = x; }

void kind::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const kind::font_size_optional &kind::font_size() const {
  return this->font_size_;
}

kind::font_size_optional &kind::font_size() { return this->font_size_; }

void kind::font_size(const font_size_type &x) { this->font_size_.set(x); }

void kind::font_size(const font_size_optional &x) { this->font_size_ = x; }

void kind::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const kind::font_weight_optional &kind::font_weight() const {
  return this->font_weight_;
}

kind::font_weight_optional &kind::font_weight() { return this->font_weight_; }

void kind::font_weight(const font_weight_type &x) { this->font_weight_.set(x); }

void kind::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void kind::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const kind::color_optional &kind::color() const { return this->color_; }

kind::color_optional &kind::color() { return this->color_; }

void kind::color(const color_type &x) { this->color_.set(x); }

void kind::color(const color_optional &x) { this->color_ = x; }

void kind::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const kind::halign_optional &kind::halign() const { return this->halign_; }

kind::halign_optional &kind::halign() { return this->halign_; }

void kind::halign(const halign_type &x) { this->halign_.set(x); }

void kind::halign(const halign_optional &x) { this->halign_ = x; }

void kind::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const kind::valign_optional &kind::valign() const { return this->valign_; }

kind::valign_optional &kind::valign() { return this->valign_; }

void kind::valign(const valign_type &x) { this->valign_.set(x); }

void kind::valign(const valign_optional &x) { this->valign_ = x; }

void kind::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// measure_numbering
//

const measure_numbering::default_x_optional &
measure_numbering::default_x() const {
  return this->default_x_;
}

measure_numbering::default_x_optional &measure_numbering::default_x() {
  return this->default_x_;
}

void measure_numbering::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void measure_numbering::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void measure_numbering::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const measure_numbering::default_y_optional &
measure_numbering::default_y() const {
  return this->default_y_;
}

measure_numbering::default_y_optional &measure_numbering::default_y() {
  return this->default_y_;
}

void measure_numbering::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void measure_numbering::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void measure_numbering::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const measure_numbering::relative_x_optional &
measure_numbering::relative_x() const {
  return this->relative_x_;
}

measure_numbering::relative_x_optional &measure_numbering::relative_x() {
  return this->relative_x_;
}

void measure_numbering::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void measure_numbering::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void measure_numbering::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const measure_numbering::relative_y_optional &
measure_numbering::relative_y() const {
  return this->relative_y_;
}

measure_numbering::relative_y_optional &measure_numbering::relative_y() {
  return this->relative_y_;
}

void measure_numbering::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void measure_numbering::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void measure_numbering::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const measure_numbering::font_family_optional &
measure_numbering::font_family() const {
  return this->font_family_;
}

measure_numbering::font_family_optional &measure_numbering::font_family() {
  return this->font_family_;
}

void measure_numbering::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void measure_numbering::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void measure_numbering::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const measure_numbering::font_style_optional &
measure_numbering::font_style() const {
  return this->font_style_;
}

measure_numbering::font_style_optional &measure_numbering::font_style() {
  return this->font_style_;
}

void measure_numbering::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void measure_numbering::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void measure_numbering::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const measure_numbering::font_size_optional &
measure_numbering::font_size() const {
  return this->font_size_;
}

measure_numbering::font_size_optional &measure_numbering::font_size() {
  return this->font_size_;
}

void measure_numbering::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void measure_numbering::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void measure_numbering::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const measure_numbering::font_weight_optional &
measure_numbering::font_weight() const {
  return this->font_weight_;
}

measure_numbering::font_weight_optional &measure_numbering::font_weight() {
  return this->font_weight_;
}

void measure_numbering::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void measure_numbering::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void measure_numbering::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const measure_numbering::color_optional &measure_numbering::color() const {
  return this->color_;
}

measure_numbering::color_optional &measure_numbering::color() {
  return this->color_;
}

void measure_numbering::color(const color_type &x) { this->color_.set(x); }

void measure_numbering::color(const color_optional &x) { this->color_ = x; }

void measure_numbering::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const measure_numbering::halign_optional &measure_numbering::halign() const {
  return this->halign_;
}

measure_numbering::halign_optional &measure_numbering::halign() {
  return this->halign_;
}

void measure_numbering::halign(const halign_type &x) { this->halign_.set(x); }

void measure_numbering::halign(const halign_optional &x) { this->halign_ = x; }

void measure_numbering::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const measure_numbering::valign_optional &measure_numbering::valign() const {
  return this->valign_;
}

measure_numbering::valign_optional &measure_numbering::valign() {
  return this->valign_;
}

void measure_numbering::valign(const valign_type &x) { this->valign_.set(x); }

void measure_numbering::valign(const valign_optional &x) { this->valign_ = x; }

void measure_numbering::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// metronome
//

const metronome::beat_unit_sequence &metronome::beat_unit() const {
  return this->beat_unit_;
}

metronome::beat_unit_sequence &metronome::beat_unit() {
  return this->beat_unit_;
}

void metronome::beat_unit(const beat_unit_sequence &s) { this->beat_unit_ = s; }

const metronome::beat_unit_dot_sequence &metronome::beat_unit_dot() const {
  return this->beat_unit_dot_;
}

metronome::beat_unit_dot_sequence &metronome::beat_unit_dot() {
  return this->beat_unit_dot_;
}

void metronome::beat_unit_dot(const beat_unit_dot_sequence &s) {
  this->beat_unit_dot_ = s;
}

const metronome::per_minute_optional &metronome::per_minute() const {
  return this->per_minute_;
}

metronome::per_minute_optional &metronome::per_minute() {
  return this->per_minute_;
}

void metronome::per_minute(const per_minute_type &x) {
  this->per_minute_.set(x);
}

void metronome::per_minute(const per_minute_optional &x) {
  this->per_minute_ = x;
}

void metronome::per_minute(::std::unique_ptr<per_minute_type> x) {
  this->per_minute_.set(std::move(x));
}

const metronome::metronome_note_sequence &metronome::metronome_note() const {
  return this->metronome_note_;
}

metronome::metronome_note_sequence &metronome::metronome_note() {
  return this->metronome_note_;
}

void metronome::metronome_note(const metronome_note_sequence &s) {
  this->metronome_note_ = s;
}

const metronome::metronome_relation_optional &
metronome::metronome_relation() const {
  return this->metronome_relation_;
}

metronome::metronome_relation_optional &metronome::metronome_relation() {
  return this->metronome_relation_;
}

void metronome::metronome_relation(const metronome_relation_type &x) {
  this->metronome_relation_.set(x);
}

void metronome::metronome_relation(const metronome_relation_optional &x) {
  this->metronome_relation_ = x;
}

void
metronome::metronome_relation(::std::unique_ptr<metronome_relation_type> x) {
  this->metronome_relation_.set(std::move(x));
}

const metronome::default_x_optional &metronome::default_x() const {
  return this->default_x_;
}

metronome::default_x_optional &metronome::default_x() {
  return this->default_x_;
}

void metronome::default_x(const default_x_type &x) { this->default_x_.set(x); }

void metronome::default_x(const default_x_optional &x) { this->default_x_ = x; }

void metronome::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const metronome::default_y_optional &metronome::default_y() const {
  return this->default_y_;
}

metronome::default_y_optional &metronome::default_y() {
  return this->default_y_;
}

void metronome::default_y(const default_y_type &x) { this->default_y_.set(x); }

void metronome::default_y(const default_y_optional &x) { this->default_y_ = x; }

void metronome::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const metronome::relative_x_optional &metronome::relative_x() const {
  return this->relative_x_;
}

metronome::relative_x_optional &metronome::relative_x() {
  return this->relative_x_;
}

void metronome::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void metronome::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void metronome::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const metronome::relative_y_optional &metronome::relative_y() const {
  return this->relative_y_;
}

metronome::relative_y_optional &metronome::relative_y() {
  return this->relative_y_;
}

void metronome::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void metronome::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void metronome::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const metronome::font_family_optional &metronome::font_family() const {
  return this->font_family_;
}

metronome::font_family_optional &metronome::font_family() {
  return this->font_family_;
}

void metronome::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void metronome::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void metronome::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const metronome::font_style_optional &metronome::font_style() const {
  return this->font_style_;
}

metronome::font_style_optional &metronome::font_style() {
  return this->font_style_;
}

void metronome::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void metronome::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void metronome::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const metronome::font_size_optional &metronome::font_size() const {
  return this->font_size_;
}

metronome::font_size_optional &metronome::font_size() {
  return this->font_size_;
}

void metronome::font_size(const font_size_type &x) { this->font_size_.set(x); }

void metronome::font_size(const font_size_optional &x) { this->font_size_ = x; }

void metronome::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const metronome::font_weight_optional &metronome::font_weight() const {
  return this->font_weight_;
}

metronome::font_weight_optional &metronome::font_weight() {
  return this->font_weight_;
}

void metronome::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void metronome::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void metronome::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const metronome::color_optional &metronome::color() const {
  return this->color_;
}

metronome::color_optional &metronome::color() { return this->color_; }

void metronome::color(const color_type &x) { this->color_.set(x); }

void metronome::color(const color_optional &x) { this->color_ = x; }

void metronome::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const metronome::halign_optional &metronome::halign() const {
  return this->halign_;
}

metronome::halign_optional &metronome::halign() { return this->halign_; }

void metronome::halign(const halign_type &x) { this->halign_.set(x); }

void metronome::halign(const halign_optional &x) { this->halign_ = x; }

void metronome::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const metronome::valign_optional &metronome::valign() const {
  return this->valign_;
}

metronome::valign_optional &metronome::valign() { return this->valign_; }

void metronome::valign(const valign_type &x) { this->valign_.set(x); }

void metronome::valign(const valign_optional &x) { this->valign_ = x; }

void metronome::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

const metronome::justify_optional &metronome::justify() const {
  return this->justify_;
}

metronome::justify_optional &metronome::justify() { return this->justify_; }

void metronome::justify(const justify_type &x) { this->justify_.set(x); }

void metronome::justify(const justify_optional &x) { this->justify_ = x; }

void metronome::justify(::std::unique_ptr<justify_type> x) {
  this->justify_.set(std::move(x));
}

const metronome::parentheses_optional &metronome::parentheses() const {
  return this->parentheses_;
}

metronome::parentheses_optional &metronome::parentheses() {
  return this->parentheses_;
}

void metronome::parentheses(const parentheses_type &x) {
  this->parentheses_.set(x);
}

void metronome::parentheses(const parentheses_optional &x) {
  this->parentheses_ = x;
}

void metronome::parentheses(::std::unique_ptr<parentheses_type> x) {
  this->parentheses_.set(std::move(x));
}

// metronome_beam
//

const metronome_beam::number_type &metronome_beam::number() const {
  return this->number_.get();
}

metronome_beam::number_type &metronome_beam::number() {
  return this->number_.get();
}

void metronome_beam::number(const number_type &x) { this->number_.set(x); }

void metronome_beam::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

metronome_beam::number_type metronome_beam::number_default_value() {
  return number_type(1ULL);
}

// metronome_note
//

const metronome_note::metronome_type_type &
metronome_note::metronome_type() const {
  return this->metronome_type_.get();
}

metronome_note::metronome_type_type &metronome_note::metronome_type() {
  return this->metronome_type_.get();
}

void metronome_note::metronome_type(const metronome_type_type &x) {
  this->metronome_type_.set(x);
}

void metronome_note::metronome_type(::std::unique_ptr<metronome_type_type> x) {
  this->metronome_type_.set(std::move(x));
}

const metronome_note::metronome_dot_sequence &
metronome_note::metronome_dot() const {
  return this->metronome_dot_;
}

metronome_note::metronome_dot_sequence &metronome_note::metronome_dot() {
  return this->metronome_dot_;
}

void metronome_note::metronome_dot(const metronome_dot_sequence &s) {
  this->metronome_dot_ = s;
}

const metronome_note::metronome_beam_sequence &
metronome_note::metronome_beam() const {
  return this->metronome_beam_;
}

metronome_note::metronome_beam_sequence &metronome_note::metronome_beam() {
  return this->metronome_beam_;
}

void metronome_note::metronome_beam(const metronome_beam_sequence &s) {
  this->metronome_beam_ = s;
}

const metronome_note::metronome_tuplet_optional &
metronome_note::metronome_tuplet() const {
  return this->metronome_tuplet_;
}

metronome_note::metronome_tuplet_optional &metronome_note::metronome_tuplet() {
  return this->metronome_tuplet_;
}

void metronome_note::metronome_tuplet(const metronome_tuplet_type &x) {
  this->metronome_tuplet_.set(x);
}

void metronome_note::metronome_tuplet(const metronome_tuplet_optional &x) {
  this->metronome_tuplet_ = x;
}

void
metronome_note::metronome_tuplet(::std::unique_ptr<metronome_tuplet_type> x) {
  this->metronome_tuplet_.set(std::move(x));
}

// time_modification
//

const time_modification::actual_notes_type &
time_modification::actual_notes() const {
  return this->actual_notes_.get();
}

time_modification::actual_notes_type &time_modification::actual_notes() {
  return this->actual_notes_.get();
}

void time_modification::actual_notes(const actual_notes_type &x) {
  this->actual_notes_.set(x);
}

const time_modification::normal_notes_type &
time_modification::normal_notes() const {
  return this->normal_notes_.get();
}

time_modification::normal_notes_type &time_modification::normal_notes() {
  return this->normal_notes_.get();
}

void time_modification::normal_notes(const normal_notes_type &x) {
  this->normal_notes_.set(x);
}

const time_modification::normal_type_optional &
time_modification::normal_type() const {
  return this->normal_type_;
}

time_modification::normal_type_optional &time_modification::normal_type() {
  return this->normal_type_;
}

void time_modification::normal_type(const normal_type_type &x) {
  this->normal_type_.set(x);
}

void time_modification::normal_type(const normal_type_optional &x) {
  this->normal_type_ = x;
}

void time_modification::normal_type(::std::unique_ptr<normal_type_type> x) {
  this->normal_type_.set(std::move(x));
}

const time_modification::normal_dot_sequence &
time_modification::normal_dot() const {
  return this->normal_dot_;
}

time_modification::normal_dot_sequence &time_modification::normal_dot() {
  return this->normal_dot_;
}

void time_modification::normal_dot(const normal_dot_sequence &s) {
  this->normal_dot_ = s;
}

// metronome_tuplet
//

const metronome_tuplet::type_type &metronome_tuplet::type() const {
  return this->type_.get();
}

metronome_tuplet::type_type &metronome_tuplet::type() {
  return this->type_.get();
}

void metronome_tuplet::type(const type_type &x) { this->type_.set(x); }

void metronome_tuplet::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const metronome_tuplet::bracket_optional &metronome_tuplet::bracket() const {
  return this->bracket_;
}

metronome_tuplet::bracket_optional &metronome_tuplet::bracket() {
  return this->bracket_;
}

void metronome_tuplet::bracket(const bracket_type &x) { this->bracket_.set(x); }

void metronome_tuplet::bracket(const bracket_optional &x) {
  this->bracket_ = x;
}

void metronome_tuplet::bracket(::std::unique_ptr<bracket_type> x) {
  this->bracket_.set(std::move(x));
}

const metronome_tuplet::show_number_optional &
metronome_tuplet::show_number() const {
  return this->show_number_;
}

metronome_tuplet::show_number_optional &metronome_tuplet::show_number() {
  return this->show_number_;
}

void metronome_tuplet::show_number(const show_number_type &x) {
  this->show_number_.set(x);
}

void metronome_tuplet::show_number(const show_number_optional &x) {
  this->show_number_ = x;
}

void metronome_tuplet::show_number(::std::unique_ptr<show_number_type> x) {
  this->show_number_.set(std::move(x));
}

// octave_shift
//

const octave_shift::type_type &octave_shift::type() const {
  return this->type_.get();
}

octave_shift::type_type &octave_shift::type() { return this->type_.get(); }

void octave_shift::type(const type_type &x) { this->type_.set(x); }

void octave_shift::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const octave_shift::number_optional &octave_shift::number() const {
  return this->number_;
}

octave_shift::number_optional &octave_shift::number() { return this->number_; }

void octave_shift::number(const number_type &x) { this->number_.set(x); }

void octave_shift::number(const number_optional &x) { this->number_ = x; }

void octave_shift::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const octave_shift::size_type &octave_shift::size() const {
  return this->size_.get();
}

octave_shift::size_type &octave_shift::size() { return this->size_.get(); }

void octave_shift::size(const size_type &x) { this->size_.set(x); }

octave_shift::size_type octave_shift::size_default_value() {
  return size_type(8ULL);
}

const octave_shift::dash_length_optional &octave_shift::dash_length() const {
  return this->dash_length_;
}

octave_shift::dash_length_optional &octave_shift::dash_length() {
  return this->dash_length_;
}

void octave_shift::dash_length(const dash_length_type &x) {
  this->dash_length_.set(x);
}

void octave_shift::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void octave_shift::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const octave_shift::space_length_optional &octave_shift::space_length() const {
  return this->space_length_;
}

octave_shift::space_length_optional &octave_shift::space_length() {
  return this->space_length_;
}

void octave_shift::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void octave_shift::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void octave_shift::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const octave_shift::default_x_optional &octave_shift::default_x() const {
  return this->default_x_;
}

octave_shift::default_x_optional &octave_shift::default_x() {
  return this->default_x_;
}

void octave_shift::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void octave_shift::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void octave_shift::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const octave_shift::default_y_optional &octave_shift::default_y() const {
  return this->default_y_;
}

octave_shift::default_y_optional &octave_shift::default_y() {
  return this->default_y_;
}

void octave_shift::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void octave_shift::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void octave_shift::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const octave_shift::relative_x_optional &octave_shift::relative_x() const {
  return this->relative_x_;
}

octave_shift::relative_x_optional &octave_shift::relative_x() {
  return this->relative_x_;
}

void octave_shift::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void octave_shift::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void octave_shift::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const octave_shift::relative_y_optional &octave_shift::relative_y() const {
  return this->relative_y_;
}

octave_shift::relative_y_optional &octave_shift::relative_y() {
  return this->relative_y_;
}

void octave_shift::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void octave_shift::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void octave_shift::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const octave_shift::font_family_optional &octave_shift::font_family() const {
  return this->font_family_;
}

octave_shift::font_family_optional &octave_shift::font_family() {
  return this->font_family_;
}

void octave_shift::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void octave_shift::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void octave_shift::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const octave_shift::font_style_optional &octave_shift::font_style() const {
  return this->font_style_;
}

octave_shift::font_style_optional &octave_shift::font_style() {
  return this->font_style_;
}

void octave_shift::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void octave_shift::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void octave_shift::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const octave_shift::font_size_optional &octave_shift::font_size() const {
  return this->font_size_;
}

octave_shift::font_size_optional &octave_shift::font_size() {
  return this->font_size_;
}

void octave_shift::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void octave_shift::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void octave_shift::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const octave_shift::font_weight_optional &octave_shift::font_weight() const {
  return this->font_weight_;
}

octave_shift::font_weight_optional &octave_shift::font_weight() {
  return this->font_weight_;
}

void octave_shift::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void octave_shift::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void octave_shift::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const octave_shift::color_optional &octave_shift::color() const {
  return this->color_;
}

octave_shift::color_optional &octave_shift::color() { return this->color_; }

void octave_shift::color(const color_type &x) { this->color_.set(x); }

void octave_shift::color(const color_optional &x) { this->color_ = x; }

void octave_shift::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// offset
//

const offset::sound_optional &offset::sound() const { return this->sound_; }

offset::sound_optional &offset::sound() { return this->sound_; }

void offset::sound(const sound_type &x) { this->sound_.set(x); }

void offset::sound(const sound_optional &x) { this->sound_ = x; }

void offset::sound(::std::unique_ptr<sound_type> x) {
  this->sound_.set(std::move(x));
}

// other_direction
//

const other_direction::print_object_optional &
other_direction::print_object() const {
  return this->print_object_;
}

other_direction::print_object_optional &other_direction::print_object() {
  return this->print_object_;
}

void other_direction::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void other_direction::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void other_direction::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const other_direction::default_x_optional &other_direction::default_x() const {
  return this->default_x_;
}

other_direction::default_x_optional &other_direction::default_x() {
  return this->default_x_;
}

void other_direction::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void other_direction::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void other_direction::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const other_direction::default_y_optional &other_direction::default_y() const {
  return this->default_y_;
}

other_direction::default_y_optional &other_direction::default_y() {
  return this->default_y_;
}

void other_direction::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void other_direction::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void other_direction::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const other_direction::relative_x_optional &
other_direction::relative_x() const {
  return this->relative_x_;
}

other_direction::relative_x_optional &other_direction::relative_x() {
  return this->relative_x_;
}

void other_direction::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void other_direction::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void other_direction::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const other_direction::relative_y_optional &
other_direction::relative_y() const {
  return this->relative_y_;
}

other_direction::relative_y_optional &other_direction::relative_y() {
  return this->relative_y_;
}

void other_direction::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void other_direction::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void other_direction::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const other_direction::font_family_optional &
other_direction::font_family() const {
  return this->font_family_;
}

other_direction::font_family_optional &other_direction::font_family() {
  return this->font_family_;
}

void other_direction::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void other_direction::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void other_direction::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const other_direction::font_style_optional &
other_direction::font_style() const {
  return this->font_style_;
}

other_direction::font_style_optional &other_direction::font_style() {
  return this->font_style_;
}

void other_direction::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void other_direction::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void other_direction::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const other_direction::font_size_optional &other_direction::font_size() const {
  return this->font_size_;
}

other_direction::font_size_optional &other_direction::font_size() {
  return this->font_size_;
}

void other_direction::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void other_direction::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void other_direction::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const other_direction::font_weight_optional &
other_direction::font_weight() const {
  return this->font_weight_;
}

other_direction::font_weight_optional &other_direction::font_weight() {
  return this->font_weight_;
}

void other_direction::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void other_direction::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void other_direction::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const other_direction::color_optional &other_direction::color() const {
  return this->color_;
}

other_direction::color_optional &other_direction::color() {
  return this->color_;
}

void other_direction::color(const color_type &x) { this->color_.set(x); }

void other_direction::color(const color_optional &x) { this->color_ = x; }

void other_direction::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const other_direction::halign_optional &other_direction::halign() const {
  return this->halign_;
}

other_direction::halign_optional &other_direction::halign() {
  return this->halign_;
}

void other_direction::halign(const halign_type &x) { this->halign_.set(x); }

void other_direction::halign(const halign_optional &x) { this->halign_ = x; }

void other_direction::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const other_direction::valign_optional &other_direction::valign() const {
  return this->valign_;
}

other_direction::valign_optional &other_direction::valign() {
  return this->valign_;
}

void other_direction::valign(const valign_type &x) { this->valign_.set(x); }

void other_direction::valign(const valign_optional &x) { this->valign_ = x; }

void other_direction::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// pedal
//

const pedal::type_type &pedal::type() const { return this->type_.get(); }

pedal::type_type &pedal::type() { return this->type_.get(); }

void pedal::type(const type_type &x) { this->type_.set(x); }

void pedal::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const pedal::line_optional &pedal::line() const { return this->line_; }

pedal::line_optional &pedal::line() { return this->line_; }

void pedal::line(const line_type &x) { this->line_.set(x); }

void pedal::line(const line_optional &x) { this->line_ = x; }

void pedal::line(::std::unique_ptr<line_type> x) {
  this->line_.set(std::move(x));
}

const pedal::sign_optional &pedal::sign() const { return this->sign_; }

pedal::sign_optional &pedal::sign() { return this->sign_; }

void pedal::sign(const sign_type &x) { this->sign_.set(x); }

void pedal::sign(const sign_optional &x) { this->sign_ = x; }

void pedal::sign(::std::unique_ptr<sign_type> x) {
  this->sign_.set(std::move(x));
}

const pedal::default_x_optional &pedal::default_x() const {
  return this->default_x_;
}

pedal::default_x_optional &pedal::default_x() { return this->default_x_; }

void pedal::default_x(const default_x_type &x) { this->default_x_.set(x); }

void pedal::default_x(const default_x_optional &x) { this->default_x_ = x; }

void pedal::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const pedal::default_y_optional &pedal::default_y() const {
  return this->default_y_;
}

pedal::default_y_optional &pedal::default_y() { return this->default_y_; }

void pedal::default_y(const default_y_type &x) { this->default_y_.set(x); }

void pedal::default_y(const default_y_optional &x) { this->default_y_ = x; }

void pedal::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const pedal::relative_x_optional &pedal::relative_x() const {
  return this->relative_x_;
}

pedal::relative_x_optional &pedal::relative_x() { return this->relative_x_; }

void pedal::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void pedal::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void pedal::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const pedal::relative_y_optional &pedal::relative_y() const {
  return this->relative_y_;
}

pedal::relative_y_optional &pedal::relative_y() { return this->relative_y_; }

void pedal::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void pedal::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void pedal::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const pedal::font_family_optional &pedal::font_family() const {
  return this->font_family_;
}

pedal::font_family_optional &pedal::font_family() { return this->font_family_; }

void pedal::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void pedal::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void pedal::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const pedal::font_style_optional &pedal::font_style() const {
  return this->font_style_;
}

pedal::font_style_optional &pedal::font_style() { return this->font_style_; }

void pedal::font_style(const font_style_type &x) { this->font_style_.set(x); }

void pedal::font_style(const font_style_optional &x) { this->font_style_ = x; }

void pedal::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const pedal::font_size_optional &pedal::font_size() const {
  return this->font_size_;
}

pedal::font_size_optional &pedal::font_size() { return this->font_size_; }

void pedal::font_size(const font_size_type &x) { this->font_size_.set(x); }

void pedal::font_size(const font_size_optional &x) { this->font_size_ = x; }

void pedal::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const pedal::font_weight_optional &pedal::font_weight() const {
  return this->font_weight_;
}

pedal::font_weight_optional &pedal::font_weight() { return this->font_weight_; }

void pedal::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void pedal::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void pedal::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const pedal::color_optional &pedal::color() const { return this->color_; }

pedal::color_optional &pedal::color() { return this->color_; }

void pedal::color(const color_type &x) { this->color_.set(x); }

void pedal::color(const color_optional &x) { this->color_ = x; }

void pedal::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const pedal::halign_optional &pedal::halign() const { return this->halign_; }

pedal::halign_optional &pedal::halign() { return this->halign_; }

void pedal::halign(const halign_type &x) { this->halign_.set(x); }

void pedal::halign(const halign_optional &x) { this->halign_ = x; }

void pedal::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const pedal::valign_optional &pedal::valign() const { return this->valign_; }

pedal::valign_optional &pedal::valign() { return this->valign_; }

void pedal::valign(const valign_type &x) { this->valign_.set(x); }

void pedal::valign(const valign_optional &x) { this->valign_ = x; }

void pedal::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// pedal_tuning
//

const pedal_tuning::pedal_step_type &pedal_tuning::pedal_step() const {
  return this->pedal_step_.get();
}

pedal_tuning::pedal_step_type &pedal_tuning::pedal_step() {
  return this->pedal_step_.get();
}

void pedal_tuning::pedal_step(const pedal_step_type &x) {
  this->pedal_step_.set(x);
}

void pedal_tuning::pedal_step(::std::unique_ptr<pedal_step_type> x) {
  this->pedal_step_.set(std::move(x));
}

const pedal_tuning::pedal_alter_type &pedal_tuning::pedal_alter() const {
  return this->pedal_alter_.get();
}

pedal_tuning::pedal_alter_type &pedal_tuning::pedal_alter() {
  return this->pedal_alter_.get();
}

void pedal_tuning::pedal_alter(const pedal_alter_type &x) {
  this->pedal_alter_.set(x);
}

void pedal_tuning::pedal_alter(::std::unique_ptr<pedal_alter_type> x) {
  this->pedal_alter_.set(std::move(x));
}

// per_minute
//

const per_minute::font_family_optional &per_minute::font_family() const {
  return this->font_family_;
}

per_minute::font_family_optional &per_minute::font_family() {
  return this->font_family_;
}

void per_minute::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void per_minute::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void per_minute::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const per_minute::font_style_optional &per_minute::font_style() const {
  return this->font_style_;
}

per_minute::font_style_optional &per_minute::font_style() {
  return this->font_style_;
}

void per_minute::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void per_minute::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void per_minute::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const per_minute::font_size_optional &per_minute::font_size() const {
  return this->font_size_;
}

per_minute::font_size_optional &per_minute::font_size() {
  return this->font_size_;
}

void per_minute::font_size(const font_size_type &x) { this->font_size_.set(x); }

void per_minute::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void per_minute::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const per_minute::font_weight_optional &per_minute::font_weight() const {
  return this->font_weight_;
}

per_minute::font_weight_optional &per_minute::font_weight() {
  return this->font_weight_;
}

void per_minute::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void per_minute::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void per_minute::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

// percussion
//

const percussion::glass_optional &percussion::glass() const {
  return this->glass_;
}

percussion::glass_optional &percussion::glass() { return this->glass_; }

void percussion::glass(const glass_type &x) { this->glass_.set(x); }

void percussion::glass(const glass_optional &x) { this->glass_ = x; }

void percussion::glass(::std::unique_ptr<glass_type> x) {
  this->glass_.set(std::move(x));
}

const percussion::metal_optional &percussion::metal() const {
  return this->metal_;
}

percussion::metal_optional &percussion::metal() { return this->metal_; }

void percussion::metal(const metal_type &x) { this->metal_.set(x); }

void percussion::metal(const metal_optional &x) { this->metal_ = x; }

void percussion::metal(::std::unique_ptr<metal_type> x) {
  this->metal_.set(std::move(x));
}

const percussion::wood_optional &percussion::wood() const {
  return this->wood_;
}

percussion::wood_optional &percussion::wood() { return this->wood_; }

void percussion::wood(const wood_type &x) { this->wood_.set(x); }

void percussion::wood(const wood_optional &x) { this->wood_ = x; }

void percussion::wood(::std::unique_ptr<wood_type> x) {
  this->wood_.set(std::move(x));
}

const percussion::pitched_optional &percussion::pitched() const {
  return this->pitched_;
}

percussion::pitched_optional &percussion::pitched() { return this->pitched_; }

void percussion::pitched(const pitched_type &x) { this->pitched_.set(x); }

void percussion::pitched(const pitched_optional &x) { this->pitched_ = x; }

void percussion::pitched(::std::unique_ptr<pitched_type> x) {
  this->pitched_.set(std::move(x));
}

const percussion::membrane_optional &percussion::membrane() const {
  return this->membrane_;
}

percussion::membrane_optional &percussion::membrane() {
  return this->membrane_;
}

void percussion::membrane(const membrane_type &x) { this->membrane_.set(x); }

void percussion::membrane(const membrane_optional &x) { this->membrane_ = x; }

void percussion::membrane(::std::unique_ptr<membrane_type> x) {
  this->membrane_.set(std::move(x));
}

const percussion::effect_optional &percussion::effect() const {
  return this->effect_;
}

percussion::effect_optional &percussion::effect() { return this->effect_; }

void percussion::effect(const effect_type &x) { this->effect_.set(x); }

void percussion::effect(const effect_optional &x) { this->effect_ = x; }

void percussion::effect(::std::unique_ptr<effect_type> x) {
  this->effect_.set(std::move(x));
}

const percussion::timpani_optional &percussion::timpani() const {
  return this->timpani_;
}

percussion::timpani_optional &percussion::timpani() { return this->timpani_; }

void percussion::timpani(const timpani_type &x) { this->timpani_.set(x); }

void percussion::timpani(const timpani_optional &x) { this->timpani_ = x; }

void percussion::timpani(::std::unique_ptr<timpani_type> x) {
  this->timpani_.set(std::move(x));
}

const percussion::beater_optional &percussion::beater() const {
  return this->beater_;
}

percussion::beater_optional &percussion::beater() { return this->beater_; }

void percussion::beater(const beater_type &x) { this->beater_.set(x); }

void percussion::beater(const beater_optional &x) { this->beater_ = x; }

void percussion::beater(::std::unique_ptr<beater_type> x) {
  this->beater_.set(std::move(x));
}

const percussion::stick_optional &percussion::stick() const {
  return this->stick_;
}

percussion::stick_optional &percussion::stick() { return this->stick_; }

void percussion::stick(const stick_type &x) { this->stick_.set(x); }

void percussion::stick(const stick_optional &x) { this->stick_ = x; }

void percussion::stick(::std::unique_ptr<stick_type> x) {
  this->stick_.set(std::move(x));
}

const percussion::stick_location_optional &percussion::stick_location() const {
  return this->stick_location_;
}

percussion::stick_location_optional &percussion::stick_location() {
  return this->stick_location_;
}

void percussion::stick_location(const stick_location_type &x) {
  this->stick_location_.set(x);
}

void percussion::stick_location(const stick_location_optional &x) {
  this->stick_location_ = x;
}

void percussion::stick_location(::std::unique_ptr<stick_location_type> x) {
  this->stick_location_.set(std::move(x));
}

const percussion::other_percussion_optional &
percussion::other_percussion() const {
  return this->other_percussion_;
}

percussion::other_percussion_optional &percussion::other_percussion() {
  return this->other_percussion_;
}

void percussion::other_percussion(const other_percussion_type &x) {
  this->other_percussion_.set(x);
}

void percussion::other_percussion(const other_percussion_optional &x) {
  this->other_percussion_ = x;
}

void percussion::other_percussion(::std::unique_ptr<other_percussion_type> x) {
  this->other_percussion_.set(std::move(x));
}

const percussion::default_x_optional &percussion::default_x() const {
  return this->default_x_;
}

percussion::default_x_optional &percussion::default_x() {
  return this->default_x_;
}

void percussion::default_x(const default_x_type &x) { this->default_x_.set(x); }

void percussion::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void percussion::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const percussion::default_y_optional &percussion::default_y() const {
  return this->default_y_;
}

percussion::default_y_optional &percussion::default_y() {
  return this->default_y_;
}

void percussion::default_y(const default_y_type &x) { this->default_y_.set(x); }

void percussion::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void percussion::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const percussion::relative_x_optional &percussion::relative_x() const {
  return this->relative_x_;
}

percussion::relative_x_optional &percussion::relative_x() {
  return this->relative_x_;
}

void percussion::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void percussion::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void percussion::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const percussion::relative_y_optional &percussion::relative_y() const {
  return this->relative_y_;
}

percussion::relative_y_optional &percussion::relative_y() {
  return this->relative_y_;
}

void percussion::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void percussion::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void percussion::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const percussion::font_family_optional &percussion::font_family() const {
  return this->font_family_;
}

percussion::font_family_optional &percussion::font_family() {
  return this->font_family_;
}

void percussion::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void percussion::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void percussion::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const percussion::font_style_optional &percussion::font_style() const {
  return this->font_style_;
}

percussion::font_style_optional &percussion::font_style() {
  return this->font_style_;
}

void percussion::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void percussion::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void percussion::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const percussion::font_size_optional &percussion::font_size() const {
  return this->font_size_;
}

percussion::font_size_optional &percussion::font_size() {
  return this->font_size_;
}

void percussion::font_size(const font_size_type &x) { this->font_size_.set(x); }

void percussion::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void percussion::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const percussion::font_weight_optional &percussion::font_weight() const {
  return this->font_weight_;
}

percussion::font_weight_optional &percussion::font_weight() {
  return this->font_weight_;
}

void percussion::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void percussion::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void percussion::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const percussion::color_optional &percussion::color() const {
  return this->color_;
}

percussion::color_optional &percussion::color() { return this->color_; }

void percussion::color(const color_type &x) { this->color_.set(x); }

void percussion::color(const color_optional &x) { this->color_ = x; }

void percussion::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const percussion::halign_optional &percussion::halign() const {
  return this->halign_;
}

percussion::halign_optional &percussion::halign() { return this->halign_; }

void percussion::halign(const halign_type &x) { this->halign_.set(x); }

void percussion::halign(const halign_optional &x) { this->halign_ = x; }

void percussion::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const percussion::valign_optional &percussion::valign() const {
  return this->valign_;
}

percussion::valign_optional &percussion::valign() { return this->valign_; }

void percussion::valign(const valign_type &x) { this->valign_.set(x); }

void percussion::valign(const valign_optional &x) { this->valign_ = x; }

void percussion::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

const percussion::enclosure_optional &percussion::enclosure() const {
  return this->enclosure_;
}

percussion::enclosure_optional &percussion::enclosure() {
  return this->enclosure_;
}

void percussion::enclosure(const enclosure_type &x) { this->enclosure_.set(x); }

void percussion::enclosure(const enclosure_optional &x) {
  this->enclosure_ = x;
}

void percussion::enclosure(::std::unique_ptr<enclosure_type> x) {
  this->enclosure_.set(std::move(x));
}

// principal_voice
//

const principal_voice::type_type &principal_voice::type() const {
  return this->type_.get();
}

principal_voice::type_type &principal_voice::type() {
  return this->type_.get();
}

void principal_voice::type(const type_type &x) { this->type_.set(x); }

void principal_voice::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const principal_voice::symbol_type &principal_voice::symbol() const {
  return this->symbol_.get();
}

principal_voice::symbol_type &principal_voice::symbol() {
  return this->symbol_.get();
}

void principal_voice::symbol(const symbol_type &x) { this->symbol_.set(x); }

void principal_voice::symbol(::std::unique_ptr<symbol_type> x) {
  this->symbol_.set(std::move(x));
}

const principal_voice::default_x_optional &principal_voice::default_x() const {
  return this->default_x_;
}

principal_voice::default_x_optional &principal_voice::default_x() {
  return this->default_x_;
}

void principal_voice::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void principal_voice::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void principal_voice::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const principal_voice::default_y_optional &principal_voice::default_y() const {
  return this->default_y_;
}

principal_voice::default_y_optional &principal_voice::default_y() {
  return this->default_y_;
}

void principal_voice::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void principal_voice::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void principal_voice::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const principal_voice::relative_x_optional &
principal_voice::relative_x() const {
  return this->relative_x_;
}

principal_voice::relative_x_optional &principal_voice::relative_x() {
  return this->relative_x_;
}

void principal_voice::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void principal_voice::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void principal_voice::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const principal_voice::relative_y_optional &
principal_voice::relative_y() const {
  return this->relative_y_;
}

principal_voice::relative_y_optional &principal_voice::relative_y() {
  return this->relative_y_;
}

void principal_voice::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void principal_voice::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void principal_voice::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const principal_voice::font_family_optional &
principal_voice::font_family() const {
  return this->font_family_;
}

principal_voice::font_family_optional &principal_voice::font_family() {
  return this->font_family_;
}

void principal_voice::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void principal_voice::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void principal_voice::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const principal_voice::font_style_optional &
principal_voice::font_style() const {
  return this->font_style_;
}

principal_voice::font_style_optional &principal_voice::font_style() {
  return this->font_style_;
}

void principal_voice::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void principal_voice::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void principal_voice::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const principal_voice::font_size_optional &principal_voice::font_size() const {
  return this->font_size_;
}

principal_voice::font_size_optional &principal_voice::font_size() {
  return this->font_size_;
}

void principal_voice::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void principal_voice::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void principal_voice::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const principal_voice::font_weight_optional &
principal_voice::font_weight() const {
  return this->font_weight_;
}

principal_voice::font_weight_optional &principal_voice::font_weight() {
  return this->font_weight_;
}

void principal_voice::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void principal_voice::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void principal_voice::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const principal_voice::color_optional &principal_voice::color() const {
  return this->color_;
}

principal_voice::color_optional &principal_voice::color() {
  return this->color_;
}

void principal_voice::color(const color_type &x) { this->color_.set(x); }

void principal_voice::color(const color_optional &x) { this->color_ = x; }

void principal_voice::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const principal_voice::halign_optional &principal_voice::halign() const {
  return this->halign_;
}

principal_voice::halign_optional &principal_voice::halign() {
  return this->halign_;
}

void principal_voice::halign(const halign_type &x) { this->halign_.set(x); }

void principal_voice::halign(const halign_optional &x) { this->halign_ = x; }

void principal_voice::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const principal_voice::valign_optional &principal_voice::valign() const {
  return this->valign_;
}

principal_voice::valign_optional &principal_voice::valign() {
  return this->valign_;
}

void principal_voice::valign(const valign_type &x) { this->valign_.set(x); }

void principal_voice::valign(const valign_optional &x) { this->valign_ = x; }

void principal_voice::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// print
//

const print::page_layout_optional &print::page_layout() const {
  return this->page_layout_;
}

print::page_layout_optional &print::page_layout() { return this->page_layout_; }

void print::page_layout(const page_layout_type &x) {
  this->page_layout_.set(x);
}

void print::page_layout(const page_layout_optional &x) {
  this->page_layout_ = x;
}

void print::page_layout(::std::unique_ptr<page_layout_type> x) {
  this->page_layout_.set(std::move(x));
}

const print::system_layout_optional &print::system_layout() const {
  return this->system_layout_;
}

print::system_layout_optional &print::system_layout() {
  return this->system_layout_;
}

void print::system_layout(const system_layout_type &x) {
  this->system_layout_.set(x);
}

void print::system_layout(const system_layout_optional &x) {
  this->system_layout_ = x;
}

void print::system_layout(::std::unique_ptr<system_layout_type> x) {
  this->system_layout_.set(std::move(x));
}

const print::staff_layout_sequence &print::staff_layout() const {
  return this->staff_layout_;
}

print::staff_layout_sequence &print::staff_layout() {
  return this->staff_layout_;
}

void print::staff_layout(const staff_layout_sequence &s) {
  this->staff_layout_ = s;
}

const print::measure_layout_optional &print::measure_layout() const {
  return this->measure_layout_;
}

print::measure_layout_optional &print::measure_layout() {
  return this->measure_layout_;
}

void print::measure_layout(const measure_layout_type &x) {
  this->measure_layout_.set(x);
}

void print::measure_layout(const measure_layout_optional &x) {
  this->measure_layout_ = x;
}

void print::measure_layout(::std::unique_ptr<measure_layout_type> x) {
  this->measure_layout_.set(std::move(x));
}

const print::measure_numbering_optional &print::measure_numbering() const {
  return this->measure_numbering_;
}

print::measure_numbering_optional &print::measure_numbering() {
  return this->measure_numbering_;
}

void print::measure_numbering(const measure_numbering_type &x) {
  this->measure_numbering_.set(x);
}

void print::measure_numbering(const measure_numbering_optional &x) {
  this->measure_numbering_ = x;
}

void print::measure_numbering(::std::unique_ptr<measure_numbering_type> x) {
  this->measure_numbering_.set(std::move(x));
}

const print::part_name_display_optional &print::part_name_display() const {
  return this->part_name_display_;
}

print::part_name_display_optional &print::part_name_display() {
  return this->part_name_display_;
}

void print::part_name_display(const part_name_display_type &x) {
  this->part_name_display_.set(x);
}

void print::part_name_display(const part_name_display_optional &x) {
  this->part_name_display_ = x;
}

void print::part_name_display(::std::unique_ptr<part_name_display_type> x) {
  this->part_name_display_.set(std::move(x));
}

const print::part_abbreviation_display_optional &
print::part_abbreviation_display() const {
  return this->part_abbreviation_display_;
}

print::part_abbreviation_display_optional &print::part_abbreviation_display() {
  return this->part_abbreviation_display_;
}

void print::part_abbreviation_display(const part_abbreviation_display_type &x) {
  this->part_abbreviation_display_.set(x);
}

void
print::part_abbreviation_display(const part_abbreviation_display_optional &x) {
  this->part_abbreviation_display_ = x;
}

void print::part_abbreviation_display(
  ::std::unique_ptr<part_abbreviation_display_type> x) {
  this->part_abbreviation_display_.set(std::move(x));
}

const print::staff_spacing_optional &print::staff_spacing() const {
  return this->staff_spacing_;
}

print::staff_spacing_optional &print::staff_spacing() {
  return this->staff_spacing_;
}

void print::staff_spacing(const staff_spacing_type &x) {
  this->staff_spacing_.set(x);
}

void print::staff_spacing(const staff_spacing_optional &x) {
  this->staff_spacing_ = x;
}

void print::staff_spacing(::std::unique_ptr<staff_spacing_type> x) {
  this->staff_spacing_.set(std::move(x));
}

const print::new_system_optional &print::new_system() const {
  return this->new_system_;
}

print::new_system_optional &print::new_system() { return this->new_system_; }

void print::new_system(const new_system_type &x) { this->new_system_.set(x); }

void print::new_system(const new_system_optional &x) { this->new_system_ = x; }

void print::new_system(::std::unique_ptr<new_system_type> x) {
  this->new_system_.set(std::move(x));
}

const print::new_page_optional &print::new_page() const {
  return this->new_page_;
}

print::new_page_optional &print::new_page() { return this->new_page_; }

void print::new_page(const new_page_type &x) { this->new_page_.set(x); }

void print::new_page(const new_page_optional &x) { this->new_page_ = x; }

void print::new_page(::std::unique_ptr<new_page_type> x) {
  this->new_page_.set(std::move(x));
}

const print::blank_page_optional &print::blank_page() const {
  return this->blank_page_;
}

print::blank_page_optional &print::blank_page() { return this->blank_page_; }

void print::blank_page(const blank_page_type &x) { this->blank_page_.set(x); }

void print::blank_page(const blank_page_optional &x) { this->blank_page_ = x; }

const print::page_number_optional &print::page_number() const {
  return this->page_number_;
}

print::page_number_optional &print::page_number() { return this->page_number_; }

void print::page_number(const page_number_type &x) {
  this->page_number_.set(x);
}

void print::page_number(const page_number_optional &x) {
  this->page_number_ = x;
}

void print::page_number(::std::unique_ptr<page_number_type> x) {
  this->page_number_.set(std::move(x));
}

// root
//

const root::root_step_type &root::root_step() const {
  return this->root_step_.get();
}

root::root_step_type &root::root_step() { return this->root_step_.get(); }

void root::root_step(const root_step_type &x) { this->root_step_.set(x); }

void root::root_step(::std::unique_ptr<root_step_type> x) {
  this->root_step_.set(std::move(x));
}

const root::root_alter_optional &root::root_alter() const {
  return this->root_alter_;
}

root::root_alter_optional &root::root_alter() { return this->root_alter_; }

void root::root_alter(const root_alter_type &x) { this->root_alter_.set(x); }

void root::root_alter(const root_alter_optional &x) { this->root_alter_ = x; }

void root::root_alter(::std::unique_ptr<root_alter_type> x) {
  this->root_alter_.set(std::move(x));
}

// root_alter
//

const root_alter::print_object_optional &root_alter::print_object() const {
  return this->print_object_;
}

root_alter::print_object_optional &root_alter::print_object() {
  return this->print_object_;
}

void root_alter::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void root_alter::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void root_alter::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const root_alter::default_x_optional &root_alter::default_x() const {
  return this->default_x_;
}

root_alter::default_x_optional &root_alter::default_x() {
  return this->default_x_;
}

void root_alter::default_x(const default_x_type &x) { this->default_x_.set(x); }

void root_alter::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void root_alter::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const root_alter::default_y_optional &root_alter::default_y() const {
  return this->default_y_;
}

root_alter::default_y_optional &root_alter::default_y() {
  return this->default_y_;
}

void root_alter::default_y(const default_y_type &x) { this->default_y_.set(x); }

void root_alter::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void root_alter::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const root_alter::relative_x_optional &root_alter::relative_x() const {
  return this->relative_x_;
}

root_alter::relative_x_optional &root_alter::relative_x() {
  return this->relative_x_;
}

void root_alter::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void root_alter::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void root_alter::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const root_alter::relative_y_optional &root_alter::relative_y() const {
  return this->relative_y_;
}

root_alter::relative_y_optional &root_alter::relative_y() {
  return this->relative_y_;
}

void root_alter::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void root_alter::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void root_alter::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const root_alter::font_family_optional &root_alter::font_family() const {
  return this->font_family_;
}

root_alter::font_family_optional &root_alter::font_family() {
  return this->font_family_;
}

void root_alter::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void root_alter::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void root_alter::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const root_alter::font_style_optional &root_alter::font_style() const {
  return this->font_style_;
}

root_alter::font_style_optional &root_alter::font_style() {
  return this->font_style_;
}

void root_alter::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void root_alter::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void root_alter::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const root_alter::font_size_optional &root_alter::font_size() const {
  return this->font_size_;
}

root_alter::font_size_optional &root_alter::font_size() {
  return this->font_size_;
}

void root_alter::font_size(const font_size_type &x) { this->font_size_.set(x); }

void root_alter::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void root_alter::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const root_alter::font_weight_optional &root_alter::font_weight() const {
  return this->font_weight_;
}

root_alter::font_weight_optional &root_alter::font_weight() {
  return this->font_weight_;
}

void root_alter::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void root_alter::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void root_alter::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const root_alter::color_optional &root_alter::color() const {
  return this->color_;
}

root_alter::color_optional &root_alter::color() { return this->color_; }

void root_alter::color(const color_type &x) { this->color_.set(x); }

void root_alter::color(const color_optional &x) { this->color_ = x; }

void root_alter::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const root_alter::location_optional &root_alter::location() const {
  return this->location_;
}

root_alter::location_optional &root_alter::location() {
  return this->location_;
}

void root_alter::location(const location_type &x) { this->location_.set(x); }

void root_alter::location(const location_optional &x) { this->location_ = x; }

void root_alter::location(::std::unique_ptr<location_type> x) {
  this->location_.set(std::move(x));
}

// root_step
//

const root_step::text_optional &root_step::text() const { return this->text_; }

root_step::text_optional &root_step::text() { return this->text_; }

void root_step::text(const text_type &x) { this->text_.set(x); }

void root_step::text(const text_optional &x) { this->text_ = x; }

void root_step::text(::std::unique_ptr<text_type> x) {
  this->text_.set(std::move(x));
}

const root_step::default_x_optional &root_step::default_x() const {
  return this->default_x_;
}

root_step::default_x_optional &root_step::default_x() {
  return this->default_x_;
}

void root_step::default_x(const default_x_type &x) { this->default_x_.set(x); }

void root_step::default_x(const default_x_optional &x) { this->default_x_ = x; }

void root_step::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const root_step::default_y_optional &root_step::default_y() const {
  return this->default_y_;
}

root_step::default_y_optional &root_step::default_y() {
  return this->default_y_;
}

void root_step::default_y(const default_y_type &x) { this->default_y_.set(x); }

void root_step::default_y(const default_y_optional &x) { this->default_y_ = x; }

void root_step::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const root_step::relative_x_optional &root_step::relative_x() const {
  return this->relative_x_;
}

root_step::relative_x_optional &root_step::relative_x() {
  return this->relative_x_;
}

void root_step::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void root_step::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void root_step::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const root_step::relative_y_optional &root_step::relative_y() const {
  return this->relative_y_;
}

root_step::relative_y_optional &root_step::relative_y() {
  return this->relative_y_;
}

void root_step::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void root_step::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void root_step::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const root_step::font_family_optional &root_step::font_family() const {
  return this->font_family_;
}

root_step::font_family_optional &root_step::font_family() {
  return this->font_family_;
}

void root_step::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void root_step::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void root_step::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const root_step::font_style_optional &root_step::font_style() const {
  return this->font_style_;
}

root_step::font_style_optional &root_step::font_style() {
  return this->font_style_;
}

void root_step::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void root_step::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void root_step::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const root_step::font_size_optional &root_step::font_size() const {
  return this->font_size_;
}

root_step::font_size_optional &root_step::font_size() {
  return this->font_size_;
}

void root_step::font_size(const font_size_type &x) { this->font_size_.set(x); }

void root_step::font_size(const font_size_optional &x) { this->font_size_ = x; }

void root_step::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const root_step::font_weight_optional &root_step::font_weight() const {
  return this->font_weight_;
}

root_step::font_weight_optional &root_step::font_weight() {
  return this->font_weight_;
}

void root_step::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void root_step::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void root_step::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const root_step::color_optional &root_step::color() const {
  return this->color_;
}

root_step::color_optional &root_step::color() { return this->color_; }

void root_step::color(const color_type &x) { this->color_.set(x); }

void root_step::color(const color_optional &x) { this->color_ = x; }

void root_step::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// scordatura
//

const scordatura::accord_sequence &scordatura::accord() const {
  return this->accord_;
}

scordatura::accord_sequence &scordatura::accord() { return this->accord_; }

void scordatura::accord(const accord_sequence &s) { this->accord_ = s; }

// sound
//

const sound::midi_device_sequence &sound::midi_device() const {
  return this->midi_device_;
}

sound::midi_device_sequence &sound::midi_device() { return this->midi_device_; }

void sound::midi_device(const midi_device_sequence &s) {
  this->midi_device_ = s;
}

const sound::midi_instrument_sequence &sound::midi_instrument() const {
  return this->midi_instrument_;
}

sound::midi_instrument_sequence &sound::midi_instrument() {
  return this->midi_instrument_;
}

void sound::midi_instrument(const midi_instrument_sequence &s) {
  this->midi_instrument_ = s;
}

const sound::play_sequence &sound::play() const { return this->play_; }

sound::play_sequence &sound::play() { return this->play_; }

void sound::play(const play_sequence &s) { this->play_ = s; }

const sound::offset_optional &sound::offset() const { return this->offset_; }

sound::offset_optional &sound::offset() { return this->offset_; }

void sound::offset(const offset_type &x) { this->offset_.set(x); }

void sound::offset(const offset_optional &x) { this->offset_ = x; }

void sound::offset(::std::unique_ptr<offset_type> x) {
  this->offset_.set(std::move(x));
}

const sound::tempo_optional &sound::tempo() const { return this->tempo_; }

sound::tempo_optional &sound::tempo() { return this->tempo_; }

void sound::tempo(const tempo_type &x) { this->tempo_.set(x); }

void sound::tempo(const tempo_optional &x) { this->tempo_ = x; }

void sound::tempo(::std::unique_ptr<tempo_type> x) {
  this->tempo_.set(std::move(x));
}

const sound::dynamics_optional &sound::dynamics() const {
  return this->dynamics_;
}

sound::dynamics_optional &sound::dynamics() { return this->dynamics_; }

void sound::dynamics(const dynamics_type &x) { this->dynamics_.set(x); }

void sound::dynamics(const dynamics_optional &x) { this->dynamics_ = x; }

void sound::dynamics(::std::unique_ptr<dynamics_type> x) {
  this->dynamics_.set(std::move(x));
}

const sound::dacapo_optional &sound::dacapo() const { return this->dacapo_; }

sound::dacapo_optional &sound::dacapo() { return this->dacapo_; }

void sound::dacapo(const dacapo_type &x) { this->dacapo_.set(x); }

void sound::dacapo(const dacapo_optional &x) { this->dacapo_ = x; }

void sound::dacapo(::std::unique_ptr<dacapo_type> x) {
  this->dacapo_.set(std::move(x));
}

const sound::segno_optional &sound::segno() const { return this->segno_; }

sound::segno_optional &sound::segno() { return this->segno_; }

void sound::segno(const segno_type &x) { this->segno_.set(x); }

void sound::segno(const segno_optional &x) { this->segno_ = x; }

void sound::segno(::std::unique_ptr<segno_type> x) {
  this->segno_.set(std::move(x));
}

const sound::dalsegno_optional &sound::dalsegno() const {
  return this->dalsegno_;
}

sound::dalsegno_optional &sound::dalsegno() { return this->dalsegno_; }

void sound::dalsegno(const dalsegno_type &x) { this->dalsegno_.set(x); }

void sound::dalsegno(const dalsegno_optional &x) { this->dalsegno_ = x; }

void sound::dalsegno(::std::unique_ptr<dalsegno_type> x) {
  this->dalsegno_.set(std::move(x));
}

const sound::coda_optional &sound::coda() const { return this->coda_; }

sound::coda_optional &sound::coda() { return this->coda_; }

void sound::coda(const coda_type &x) { this->coda_.set(x); }

void sound::coda(const coda_optional &x) { this->coda_ = x; }

void sound::coda(::std::unique_ptr<coda_type> x) {
  this->coda_.set(std::move(x));
}

const sound::tocoda_optional &sound::tocoda() const { return this->tocoda_; }

sound::tocoda_optional &sound::tocoda() { return this->tocoda_; }

void sound::tocoda(const tocoda_type &x) { this->tocoda_.set(x); }

void sound::tocoda(const tocoda_optional &x) { this->tocoda_ = x; }

void sound::tocoda(::std::unique_ptr<tocoda_type> x) {
  this->tocoda_.set(std::move(x));
}

const sound::divisions_optional &sound::divisions() const {
  return this->divisions_;
}

sound::divisions_optional &sound::divisions() { return this->divisions_; }

void sound::divisions(const divisions_type &x) { this->divisions_.set(x); }

void sound::divisions(const divisions_optional &x) { this->divisions_ = x; }

void sound::divisions(::std::unique_ptr<divisions_type> x) {
  this->divisions_.set(std::move(x));
}

const sound::forward_repeat_optional &sound::forward_repeat() const {
  return this->forward_repeat_;
}

sound::forward_repeat_optional &sound::forward_repeat() {
  return this->forward_repeat_;
}

void sound::forward_repeat(const forward_repeat_type &x) {
  this->forward_repeat_.set(x);
}

void sound::forward_repeat(const forward_repeat_optional &x) {
  this->forward_repeat_ = x;
}

void sound::forward_repeat(::std::unique_ptr<forward_repeat_type> x) {
  this->forward_repeat_.set(std::move(x));
}

const sound::fine_optional &sound::fine() const { return this->fine_; }

sound::fine_optional &sound::fine() { return this->fine_; }

void sound::fine(const fine_type &x) { this->fine_.set(x); }

void sound::fine(const fine_optional &x) { this->fine_ = x; }

void sound::fine(::std::unique_ptr<fine_type> x) {
  this->fine_.set(std::move(x));
}

const sound::time_only_optional &sound::time_only() const {
  return this->time_only_;
}

sound::time_only_optional &sound::time_only() { return this->time_only_; }

void sound::time_only(const time_only_type &x) { this->time_only_.set(x); }

void sound::time_only(const time_only_optional &x) { this->time_only_ = x; }

void sound::time_only(::std::unique_ptr<time_only_type> x) {
  this->time_only_.set(std::move(x));
}

const sound::pizzicato_optional &sound::pizzicato() const {
  return this->pizzicato_;
}

sound::pizzicato_optional &sound::pizzicato() { return this->pizzicato_; }

void sound::pizzicato(const pizzicato_type &x) { this->pizzicato_.set(x); }

void sound::pizzicato(const pizzicato_optional &x) { this->pizzicato_ = x; }

void sound::pizzicato(::std::unique_ptr<pizzicato_type> x) {
  this->pizzicato_.set(std::move(x));
}

const sound::pan_optional &sound::pan() const { return this->pan_; }

sound::pan_optional &sound::pan() { return this->pan_; }

void sound::pan(const pan_type &x) { this->pan_.set(x); }

void sound::pan(const pan_optional &x) { this->pan_ = x; }

void sound::pan(::std::unique_ptr<pan_type> x) { this->pan_.set(std::move(x)); }

const sound::elevation_optional &sound::elevation() const {
  return this->elevation_;
}

sound::elevation_optional &sound::elevation() { return this->elevation_; }

void sound::elevation(const elevation_type &x) { this->elevation_.set(x); }

void sound::elevation(const elevation_optional &x) { this->elevation_ = x; }

void sound::elevation(::std::unique_ptr<elevation_type> x) {
  this->elevation_.set(std::move(x));
}

const sound::damper_pedal_optional &sound::damper_pedal() const {
  return this->damper_pedal_;
}

sound::damper_pedal_optional &sound::damper_pedal() {
  return this->damper_pedal_;
}

void sound::damper_pedal(const damper_pedal_type &x) {
  this->damper_pedal_.set(x);
}

void sound::damper_pedal(const damper_pedal_optional &x) {
  this->damper_pedal_ = x;
}

void sound::damper_pedal(::std::unique_ptr<damper_pedal_type> x) {
  this->damper_pedal_.set(std::move(x));
}

const sound::soft_pedal_optional &sound::soft_pedal() const {
  return this->soft_pedal_;
}

sound::soft_pedal_optional &sound::soft_pedal() { return this->soft_pedal_; }

void sound::soft_pedal(const soft_pedal_type &x) { this->soft_pedal_.set(x); }

void sound::soft_pedal(const soft_pedal_optional &x) { this->soft_pedal_ = x; }

void sound::soft_pedal(::std::unique_ptr<soft_pedal_type> x) {
  this->soft_pedal_.set(std::move(x));
}

const sound::sostenuto_pedal_optional &sound::sostenuto_pedal() const {
  return this->sostenuto_pedal_;
}

sound::sostenuto_pedal_optional &sound::sostenuto_pedal() {
  return this->sostenuto_pedal_;
}

void sound::sostenuto_pedal(const sostenuto_pedal_type &x) {
  this->sostenuto_pedal_.set(x);
}

void sound::sostenuto_pedal(const sostenuto_pedal_optional &x) {
  this->sostenuto_pedal_ = x;
}

void sound::sostenuto_pedal(::std::unique_ptr<sostenuto_pedal_type> x) {
  this->sostenuto_pedal_.set(std::move(x));
}

// stick
//

const stick::stick_type_type &stick::stick_type() const {
  return this->stick_type_.get();
}

stick::stick_type_type &stick::stick_type() { return this->stick_type_.get(); }

void stick::stick_type(const stick_type_type &x) { this->stick_type_.set(x); }

void stick::stick_type(::std::unique_ptr<stick_type_type> x) {
  this->stick_type_.set(std::move(x));
}

const stick::stick_material_type &stick::stick_material() const {
  return this->stick_material_.get();
}

stick::stick_material_type &stick::stick_material() {
  return this->stick_material_.get();
}

void stick::stick_material(const stick_material_type &x) {
  this->stick_material_.set(x);
}

void stick::stick_material(::std::unique_ptr<stick_material_type> x) {
  this->stick_material_.set(std::move(x));
}

const stick::tip_optional &stick::tip() const { return this->tip_; }

stick::tip_optional &stick::tip() { return this->tip_; }

void stick::tip(const tip_type &x) { this->tip_.set(x); }

void stick::tip(const tip_optional &x) { this->tip_ = x; }

void stick::tip(::std::unique_ptr<tip_type> x) { this->tip_.set(std::move(x)); }

// string_mute
//

const string_mute::type_type &string_mute::type() const {
  return this->type_.get();
}

string_mute::type_type &string_mute::type() { return this->type_.get(); }

void string_mute::type(const type_type &x) { this->type_.set(x); }

void string_mute::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const string_mute::default_x_optional &string_mute::default_x() const {
  return this->default_x_;
}

string_mute::default_x_optional &string_mute::default_x() {
  return this->default_x_;
}

void string_mute::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void string_mute::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void string_mute::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const string_mute::default_y_optional &string_mute::default_y() const {
  return this->default_y_;
}

string_mute::default_y_optional &string_mute::default_y() {
  return this->default_y_;
}

void string_mute::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void string_mute::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void string_mute::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const string_mute::relative_x_optional &string_mute::relative_x() const {
  return this->relative_x_;
}

string_mute::relative_x_optional &string_mute::relative_x() {
  return this->relative_x_;
}

void string_mute::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void string_mute::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void string_mute::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const string_mute::relative_y_optional &string_mute::relative_y() const {
  return this->relative_y_;
}

string_mute::relative_y_optional &string_mute::relative_y() {
  return this->relative_y_;
}

void string_mute::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void string_mute::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void string_mute::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const string_mute::font_family_optional &string_mute::font_family() const {
  return this->font_family_;
}

string_mute::font_family_optional &string_mute::font_family() {
  return this->font_family_;
}

void string_mute::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void string_mute::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void string_mute::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const string_mute::font_style_optional &string_mute::font_style() const {
  return this->font_style_;
}

string_mute::font_style_optional &string_mute::font_style() {
  return this->font_style_;
}

void string_mute::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void string_mute::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void string_mute::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const string_mute::font_size_optional &string_mute::font_size() const {
  return this->font_size_;
}

string_mute::font_size_optional &string_mute::font_size() {
  return this->font_size_;
}

void string_mute::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void string_mute::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void string_mute::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const string_mute::font_weight_optional &string_mute::font_weight() const {
  return this->font_weight_;
}

string_mute::font_weight_optional &string_mute::font_weight() {
  return this->font_weight_;
}

void string_mute::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void string_mute::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void string_mute::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const string_mute::color_optional &string_mute::color() const {
  return this->color_;
}

string_mute::color_optional &string_mute::color() { return this->color_; }

void string_mute::color(const color_type &x) { this->color_.set(x); }

void string_mute::color(const color_optional &x) { this->color_ = x; }

void string_mute::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const string_mute::halign_optional &string_mute::halign() const {
  return this->halign_;
}

string_mute::halign_optional &string_mute::halign() { return this->halign_; }

void string_mute::halign(const halign_type &x) { this->halign_.set(x); }

void string_mute::halign(const halign_optional &x) { this->halign_ = x; }

void string_mute::halign(::std::unique_ptr<halign_type> x) {
  this->halign_.set(std::move(x));
}

const string_mute::valign_optional &string_mute::valign() const {
  return this->valign_;
}

string_mute::valign_optional &string_mute::valign() { return this->valign_; }

void string_mute::valign(const valign_type &x) { this->valign_.set(x); }

void string_mute::valign(const valign_optional &x) { this->valign_ = x; }

void string_mute::valign(::std::unique_ptr<valign_type> x) {
  this->valign_.set(std::move(x));
}

// wedge
//

const wedge::type_type &wedge::type() const { return this->type_.get(); }

wedge::type_type &wedge::type() { return this->type_.get(); }

void wedge::type(const type_type &x) { this->type_.set(x); }

void wedge::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const wedge::number_optional &wedge::number() const { return this->number_; }

wedge::number_optional &wedge::number() { return this->number_; }

void wedge::number(const number_type &x) { this->number_.set(x); }

void wedge::number(const number_optional &x) { this->number_ = x; }

void wedge::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const wedge::spread_optional &wedge::spread() const { return this->spread_; }

wedge::spread_optional &wedge::spread() { return this->spread_; }

void wedge::spread(const spread_type &x) { this->spread_.set(x); }

void wedge::spread(const spread_optional &x) { this->spread_ = x; }

void wedge::spread(::std::unique_ptr<spread_type> x) {
  this->spread_.set(std::move(x));
}

const wedge::niente_optional &wedge::niente() const { return this->niente_; }

wedge::niente_optional &wedge::niente() { return this->niente_; }

void wedge::niente(const niente_type &x) { this->niente_.set(x); }

void wedge::niente(const niente_optional &x) { this->niente_ = x; }

void wedge::niente(::std::unique_ptr<niente_type> x) {
  this->niente_.set(std::move(x));
}

const wedge::line_type_optional &wedge::line_type() const {
  return this->line_type_;
}

wedge::line_type_optional &wedge::line_type() { return this->line_type_; }

void wedge::line_type(const line_type_type &x) { this->line_type_.set(x); }

void wedge::line_type(const line_type_optional &x) { this->line_type_ = x; }

void wedge::line_type(::std::unique_ptr<line_type_type> x) {
  this->line_type_.set(std::move(x));
}

const wedge::dash_length_optional &wedge::dash_length() const {
  return this->dash_length_;
}

wedge::dash_length_optional &wedge::dash_length() { return this->dash_length_; }

void wedge::dash_length(const dash_length_type &x) {
  this->dash_length_.set(x);
}

void wedge::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void wedge::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const wedge::space_length_optional &wedge::space_length() const {
  return this->space_length_;
}

wedge::space_length_optional &wedge::space_length() {
  return this->space_length_;
}

void wedge::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void wedge::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void wedge::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const wedge::default_x_optional &wedge::default_x() const {
  return this->default_x_;
}

wedge::default_x_optional &wedge::default_x() { return this->default_x_; }

void wedge::default_x(const default_x_type &x) { this->default_x_.set(x); }

void wedge::default_x(const default_x_optional &x) { this->default_x_ = x; }

void wedge::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const wedge::default_y_optional &wedge::default_y() const {
  return this->default_y_;
}

wedge::default_y_optional &wedge::default_y() { return this->default_y_; }

void wedge::default_y(const default_y_type &x) { this->default_y_.set(x); }

void wedge::default_y(const default_y_optional &x) { this->default_y_ = x; }

void wedge::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const wedge::relative_x_optional &wedge::relative_x() const {
  return this->relative_x_;
}

wedge::relative_x_optional &wedge::relative_x() { return this->relative_x_; }

void wedge::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void wedge::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void wedge::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const wedge::relative_y_optional &wedge::relative_y() const {
  return this->relative_y_;
}

wedge::relative_y_optional &wedge::relative_y() { return this->relative_y_; }

void wedge::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void wedge::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void wedge::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const wedge::color_optional &wedge::color() const { return this->color_; }

wedge::color_optional &wedge::color() { return this->color_; }

void wedge::color(const color_type &x) { this->color_.set(x); }

void wedge::color(const color_optional &x) { this->color_ = x; }

void wedge::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// encoding
//

const encoding::encoding_date_sequence &encoding::encoding_date() const {
  return this->encoding_date_;
}

encoding::encoding_date_sequence &encoding::encoding_date() {
  return this->encoding_date_;
}

void encoding::encoding_date(const encoding_date_sequence &s) {
  this->encoding_date_ = s;
}

const encoding::encoder_sequence &encoding::encoder() const {
  return this->encoder_;
}

encoding::encoder_sequence &encoding::encoder() { return this->encoder_; }

void encoding::encoder(const encoder_sequence &s) { this->encoder_ = s; }

const encoding::software_sequence &encoding::software() const {
  return this->software_;
}

encoding::software_sequence &encoding::software() { return this->software_; }

void encoding::software(const software_sequence &s) { this->software_ = s; }

const encoding::encoding_description_sequence &
encoding::encoding_description() const {
  return this->encoding_description_;
}

encoding::encoding_description_sequence &encoding::encoding_description() {
  return this->encoding_description_;
}

void encoding::encoding_description(const encoding_description_sequence &s) {
  this->encoding_description_ = s;
}

const encoding::supports_sequence &encoding::supports() const {
  return this->supports_;
}

encoding::supports_sequence &encoding::supports() { return this->supports_; }

void encoding::supports(const supports_sequence &s) { this->supports_ = s; }

// identification
//

const identification::creator_sequence &identification::creator() const {
  return this->creator_;
}

identification::creator_sequence &identification::creator() {
  return this->creator_;
}

void identification::creator(const creator_sequence &s) { this->creator_ = s; }

const identification::rights_sequence &identification::rights() const {
  return this->rights_;
}

identification::rights_sequence &identification::rights() {
  return this->rights_;
}

void identification::rights(const rights_sequence &s) { this->rights_ = s; }

const identification::encoding_optional &identification::encoding() const {
  return this->encoding_;
}

identification::encoding_optional &identification::encoding() {
  return this->encoding_;
}

void identification::encoding(const encoding_type &x) {
  this->encoding_.set(x);
}

void identification::encoding(const encoding_optional &x) {
  this->encoding_ = x;
}

void identification::encoding(::std::unique_ptr<encoding_type> x) {
  this->encoding_.set(std::move(x));
}

const identification::source_optional &identification::source() const {
  return this->source_;
}

identification::source_optional &identification::source() {
  return this->source_;
}

void identification::source(const source_type &x) { this->source_.set(x); }

void identification::source(const source_optional &x) { this->source_ = x; }

void identification::source(::std::unique_ptr<source_type> x) {
  this->source_.set(std::move(x));
}

const identification::relation_sequence &identification::relation() const {
  return this->relation_;
}

identification::relation_sequence &identification::relation() {
  return this->relation_;
}

void identification::relation(const relation_sequence &s) {
  this->relation_ = s;
}

const identification::miscellaneous_optional &
identification::miscellaneous() const {
  return this->miscellaneous_;
}

identification::miscellaneous_optional &identification::miscellaneous() {
  return this->miscellaneous_;
}

void identification::miscellaneous(const miscellaneous_type &x) {
  this->miscellaneous_.set(x);
}

void identification::miscellaneous(const miscellaneous_optional &x) {
  this->miscellaneous_ = x;
}

void identification::miscellaneous(::std::unique_ptr<miscellaneous_type> x) {
  this->miscellaneous_.set(std::move(x));
}

// miscellaneous
//

const miscellaneous::miscellaneous_field_sequence &
miscellaneous::miscellaneous_field() const {
  return this->miscellaneous_field_;
}

miscellaneous::miscellaneous_field_sequence &
miscellaneous::miscellaneous_field() {
  return this->miscellaneous_field_;
}

void miscellaneous::miscellaneous_field(const miscellaneous_field_sequence &s) {
  this->miscellaneous_field_ = s;
}

// miscellaneous_field
//

const miscellaneous_field::name_type &miscellaneous_field::name() const {
  return this->name_.get();
}

miscellaneous_field::name_type &miscellaneous_field::name() {
  return this->name_.get();
}

void miscellaneous_field::name(const name_type &x) { this->name_.set(x); }

void miscellaneous_field::name(::std::unique_ptr<name_type> x) {
  this->name_.set(std::move(x));
}

// supports
//

const supports::type_type &supports::type() const { return this->type_.get(); }

supports::type_type &supports::type() { return this->type_.get(); }

void supports::type(const type_type &x) { this->type_.set(x); }

void supports::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const supports::element_type &supports::element() const {
  return this->element_.get();
}

supports::element_type &supports::element() { return this->element_.get(); }

void supports::element(const element_type &x) { this->element_.set(x); }

void supports::element(::std::unique_ptr<element_type> x) {
  this->element_.set(std::move(x));
}

const supports::attribute_optional &supports::attribute() const {
  return this->attribute_;
}

supports::attribute_optional &supports::attribute() { return this->attribute_; }

void supports::attribute(const attribute_type &x) { this->attribute_.set(x); }

void supports::attribute(const attribute_optional &x) { this->attribute_ = x; }

void supports::attribute(::std::unique_ptr<attribute_type> x) {
  this->attribute_.set(std::move(x));
}

const supports::value_optional &supports::value() const { return this->value_; }

supports::value_optional &supports::value() { return this->value_; }

void supports::value(const value_type &x) { this->value_.set(x); }

void supports::value(const value_optional &x) { this->value_ = x; }

void supports::value(::std::unique_ptr<value_type> x) {
  this->value_.set(std::move(x));
}

// appearance
//

const appearance::line_width_sequence &appearance::line_width() const {
  return this->line_width_;
}

appearance::line_width_sequence &appearance::line_width() {
  return this->line_width_;
}

void appearance::line_width(const line_width_sequence &s) {
  this->line_width_ = s;
}

const appearance::note_size_sequence &appearance::note_size() const {
  return this->note_size_;
}

appearance::note_size_sequence &appearance::note_size() {
  return this->note_size_;
}

void appearance::note_size(const note_size_sequence &s) {
  this->note_size_ = s;
}

const appearance::distance_sequence &appearance::distance() const {
  return this->distance_;
}

appearance::distance_sequence &appearance::distance() {
  return this->distance_;
}

void appearance::distance(const distance_sequence &s) { this->distance_ = s; }

const appearance::other_appearance_sequence &
appearance::other_appearance() const {
  return this->other_appearance_;
}

appearance::other_appearance_sequence &appearance::other_appearance() {
  return this->other_appearance_;
}

void appearance::other_appearance(const other_appearance_sequence &s) {
  this->other_appearance_ = s;
}

// distance
//

const distance::type_type &distance::type() const { return this->type_.get(); }

distance::type_type &distance::type() { return this->type_.get(); }

void distance::type(const type_type &x) { this->type_.set(x); }

void distance::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

// line_width
//

const line_width::type_type &line_width::type() const {
  return this->type_.get();
}

line_width::type_type &line_width::type() { return this->type_.get(); }

void line_width::type(const type_type &x) { this->type_.set(x); }

void line_width::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

// measure_layout
//

const measure_layout::measure_distance_optional &
measure_layout::measure_distance() const {
  return this->measure_distance_;
}

measure_layout::measure_distance_optional &measure_layout::measure_distance() {
  return this->measure_distance_;
}

void measure_layout::measure_distance(const measure_distance_type &x) {
  this->measure_distance_.set(x);
}

void measure_layout::measure_distance(const measure_distance_optional &x) {
  this->measure_distance_ = x;
}

void
measure_layout::measure_distance(::std::unique_ptr<measure_distance_type> x) {
  this->measure_distance_.set(std::move(x));
}

// note_size
//

const note_size::type_type &note_size::type() const {
  return this->type_.get();
}

note_size::type_type &note_size::type() { return this->type_.get(); }

void note_size::type(const type_type &x) { this->type_.set(x); }

void note_size::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

// other_appearance
//

const other_appearance::type_type &other_appearance::type() const {
  return this->type_.get();
}

other_appearance::type_type &other_appearance::type() {
  return this->type_.get();
}

void other_appearance::type(const type_type &x) { this->type_.set(x); }

void other_appearance::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

// page_layout
//

const page_layout::page_height_optional &page_layout::page_height() const {
  return this->page_height_;
}

page_layout::page_height_optional &page_layout::page_height() {
  return this->page_height_;
}

void page_layout::page_height(const page_height_type &x) {
  this->page_height_.set(x);
}

void page_layout::page_height(const page_height_optional &x) {
  this->page_height_ = x;
}

void page_layout::page_height(::std::unique_ptr<page_height_type> x) {
  this->page_height_.set(std::move(x));
}

const page_layout::page_width_optional &page_layout::page_width() const {
  return this->page_width_;
}

page_layout::page_width_optional &page_layout::page_width() {
  return this->page_width_;
}

void page_layout::page_width(const page_width_type &x) {
  this->page_width_.set(x);
}

void page_layout::page_width(const page_width_optional &x) {
  this->page_width_ = x;
}

void page_layout::page_width(::std::unique_ptr<page_width_type> x) {
  this->page_width_.set(std::move(x));
}

const page_layout::page_margins_sequence &page_layout::page_margins() const {
  return this->page_margins_;
}

page_layout::page_margins_sequence &page_layout::page_margins() {
  return this->page_margins_;
}

void page_layout::page_margins(const page_margins_sequence &s) {
  this->page_margins_ = s;
}

// page_margins
//

const page_margins::left_margin_type &page_margins::left_margin() const {
  return this->left_margin_.get();
}

page_margins::left_margin_type &page_margins::left_margin() {
  return this->left_margin_.get();
}

void page_margins::left_margin(const left_margin_type &x) {
  this->left_margin_.set(x);
}

void page_margins::left_margin(::std::unique_ptr<left_margin_type> x) {
  this->left_margin_.set(std::move(x));
}

const page_margins::right_margin_type &page_margins::right_margin() const {
  return this->right_margin_.get();
}

page_margins::right_margin_type &page_margins::right_margin() {
  return this->right_margin_.get();
}

void page_margins::right_margin(const right_margin_type &x) {
  this->right_margin_.set(x);
}

void page_margins::right_margin(::std::unique_ptr<right_margin_type> x) {
  this->right_margin_.set(std::move(x));
}

const page_margins::top_margin_type &page_margins::top_margin() const {
  return this->top_margin_.get();
}

page_margins::top_margin_type &page_margins::top_margin() {
  return this->top_margin_.get();
}

void page_margins::top_margin(const top_margin_type &x) {
  this->top_margin_.set(x);
}

void page_margins::top_margin(::std::unique_ptr<top_margin_type> x) {
  this->top_margin_.set(std::move(x));
}

const page_margins::bottom_margin_type &page_margins::bottom_margin() const {
  return this->bottom_margin_.get();
}

page_margins::bottom_margin_type &page_margins::bottom_margin() {
  return this->bottom_margin_.get();
}

void page_margins::bottom_margin(const bottom_margin_type &x) {
  this->bottom_margin_.set(x);
}

void page_margins::bottom_margin(::std::unique_ptr<bottom_margin_type> x) {
  this->bottom_margin_.set(std::move(x));
}

const page_margins::type_optional &page_margins::type() const {
  return this->type_;
}

page_margins::type_optional &page_margins::type() { return this->type_; }

void page_margins::type(const type_type &x) { this->type_.set(x); }

void page_margins::type(const type_optional &x) { this->type_ = x; }

void page_margins::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

// scaling
//

const scaling::millimeters_type &scaling::millimeters() const {
  return this->millimeters_.get();
}

scaling::millimeters_type &scaling::millimeters() {
  return this->millimeters_.get();
}

void scaling::millimeters(const millimeters_type &x) {
  this->millimeters_.set(x);
}

void scaling::millimeters(::std::unique_ptr<millimeters_type> x) {
  this->millimeters_.set(std::move(x));
}

const scaling::tenths_type &scaling::tenths() const {
  return this->tenths_.get();
}

scaling::tenths_type &scaling::tenths() { return this->tenths_.get(); }

void scaling::tenths(const tenths_type &x) { this->tenths_.set(x); }

void scaling::tenths(::std::unique_ptr<tenths_type> x) {
  this->tenths_.set(std::move(x));
}

// staff_layout
//

const staff_layout::staff_distance_optional &
staff_layout::staff_distance() const {
  return this->staff_distance_;
}

staff_layout::staff_distance_optional &staff_layout::staff_distance() {
  return this->staff_distance_;
}

void staff_layout::staff_distance(const staff_distance_type &x) {
  this->staff_distance_.set(x);
}

void staff_layout::staff_distance(const staff_distance_optional &x) {
  this->staff_distance_ = x;
}

void staff_layout::staff_distance(::std::unique_ptr<staff_distance_type> x) {
  this->staff_distance_.set(std::move(x));
}

const staff_layout::number_optional &staff_layout::number() const {
  return this->number_;
}

staff_layout::number_optional &staff_layout::number() { return this->number_; }

void staff_layout::number(const number_type &x) { this->number_.set(x); }

void staff_layout::number(const number_optional &x) { this->number_ = x; }

void staff_layout::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

// system_dividers
//

const system_dividers::left_divider_type &
system_dividers::left_divider() const {
  return this->left_divider_.get();
}

system_dividers::left_divider_type &system_dividers::left_divider() {
  return this->left_divider_.get();
}

void system_dividers::left_divider(const left_divider_type &x) {
  this->left_divider_.set(x);
}

void system_dividers::left_divider(::std::unique_ptr<left_divider_type> x) {
  this->left_divider_.set(std::move(x));
}

const system_dividers::right_divider_type &
system_dividers::right_divider() const {
  return this->right_divider_.get();
}

system_dividers::right_divider_type &system_dividers::right_divider() {
  return this->right_divider_.get();
}

void system_dividers::right_divider(const right_divider_type &x) {
  this->right_divider_.set(x);
}

void system_dividers::right_divider(::std::unique_ptr<right_divider_type> x) {
  this->right_divider_.set(std::move(x));
}

// system_layout
//

const system_layout::system_margins_optional &
system_layout::system_margins() const {
  return this->system_margins_;
}

system_layout::system_margins_optional &system_layout::system_margins() {
  return this->system_margins_;
}

void system_layout::system_margins(const system_margins_type &x) {
  this->system_margins_.set(x);
}

void system_layout::system_margins(const system_margins_optional &x) {
  this->system_margins_ = x;
}

void system_layout::system_margins(::std::unique_ptr<system_margins_type> x) {
  this->system_margins_.set(std::move(x));
}

const system_layout::system_distance_optional &
system_layout::system_distance() const {
  return this->system_distance_;
}

system_layout::system_distance_optional &system_layout::system_distance() {
  return this->system_distance_;
}

void system_layout::system_distance(const system_distance_type &x) {
  this->system_distance_.set(x);
}

void system_layout::system_distance(const system_distance_optional &x) {
  this->system_distance_ = x;
}

void system_layout::system_distance(::std::unique_ptr<system_distance_type> x) {
  this->system_distance_.set(std::move(x));
}

const system_layout::top_system_distance_optional &
system_layout::top_system_distance() const {
  return this->top_system_distance_;
}

system_layout::top_system_distance_optional &
system_layout::top_system_distance() {
  return this->top_system_distance_;
}

void system_layout::top_system_distance(const top_system_distance_type &x) {
  this->top_system_distance_.set(x);
}

void system_layout::top_system_distance(const top_system_distance_optional &x) {
  this->top_system_distance_ = x;
}

void system_layout::top_system_distance(
  ::std::unique_ptr<top_system_distance_type> x) {
  this->top_system_distance_.set(std::move(x));
}

const system_layout::system_dividers_optional &
system_layout::system_dividers() const {
  return this->system_dividers_;
}

system_layout::system_dividers_optional &system_layout::system_dividers() {
  return this->system_dividers_;
}

void system_layout::system_dividers(const system_dividers_type &x) {
  this->system_dividers_.set(x);
}

void system_layout::system_dividers(const system_dividers_optional &x) {
  this->system_dividers_ = x;
}

void system_layout::system_dividers(::std::unique_ptr<system_dividers_type> x) {
  this->system_dividers_.set(std::move(x));
}

// system_margins
//

const system_margins::left_margin_type &system_margins::left_margin() const {
  return this->left_margin_.get();
}

system_margins::left_margin_type &system_margins::left_margin() {
  return this->left_margin_.get();
}

void system_margins::left_margin(const left_margin_type &x) {
  this->left_margin_.set(x);
}

void system_margins::left_margin(::std::unique_ptr<left_margin_type> x) {
  this->left_margin_.set(std::move(x));
}

const system_margins::right_margin_type &system_margins::right_margin() const {
  return this->right_margin_.get();
}

system_margins::right_margin_type &system_margins::right_margin() {
  return this->right_margin_.get();
}

void system_margins::right_margin(const right_margin_type &x) {
  this->right_margin_.set(x);
}

void system_margins::right_margin(::std::unique_ptr<right_margin_type> x) {
  this->right_margin_.set(std::move(x));
}

// bookmark
//

const bookmark::id_type &bookmark::id() const { return this->id_.get(); }

bookmark::id_type &bookmark::id() { return this->id_.get(); }

void bookmark::id(const id_type &x) { this->id_.set(x); }

void bookmark::id(::std::unique_ptr<id_type> x) { this->id_.set(std::move(x)); }

const bookmark::name_optional &bookmark::name() const { return this->name_; }

bookmark::name_optional &bookmark::name() { return this->name_; }

void bookmark::name(const name_type &x) { this->name_.set(x); }

void bookmark::name(const name_optional &x) { this->name_ = x; }

void bookmark::name(::std::unique_ptr<name_type> x) {
  this->name_.set(std::move(x));
}

const bookmark::element_optional &bookmark::element() const {
  return this->element_;
}

bookmark::element_optional &bookmark::element() { return this->element_; }

void bookmark::element(const element_type &x) { this->element_.set(x); }

void bookmark::element(const element_optional &x) { this->element_ = x; }

void bookmark::element(::std::unique_ptr<element_type> x) {
  this->element_.set(std::move(x));
}

const bookmark::position_optional &bookmark::position() const {
  return this->position_;
}

bookmark::position_optional &bookmark::position() { return this->position_; }

void bookmark::position(const position_type &x) { this->position_.set(x); }

void bookmark::position(const position_optional &x) { this->position_ = x; }

// link
//

const link::href_type &link::href() const { return this->href_.get(); }

link::href_type &link::href() { return this->href_.get(); }

void link::href(const href_type &x) { this->href_.set(x); }

void link::href(::std::unique_ptr<href_type> x) {
  this->href_.set(std::move(x));
}

const link::type_type &link::type() const { return this->type_.get(); }

const link::type_type &link::type_default_value() {
  return type_default_value_;
}

const link::role_optional &link::role() const { return this->role_; }

link::role_optional &link::role() { return this->role_; }

void link::role(const role_type &x) { this->role_.set(x); }

void link::role(const role_optional &x) { this->role_ = x; }

void link::role(::std::unique_ptr<role_type> x) {
  this->role_.set(std::move(x));
}

const link::title_optional &link::title() const { return this->title_; }

link::title_optional &link::title() { return this->title_; }

void link::title(const title_type &x) { this->title_.set(x); }

void link::title(const title_optional &x) { this->title_ = x; }

void link::title(::std::unique_ptr<title_type> x) {
  this->title_.set(std::move(x));
}

const link::show_type &link::show() const { return this->show_.get(); }

link::show_type &link::show() { return this->show_.get(); }

void link::show(const show_type &x) { this->show_.set(x); }

void link::show(::std::unique_ptr<show_type> x) {
  this->show_.set(std::move(x));
}

const link::show_type &link::show_default_value() {
  return show_default_value_;
}

const link::actuate_type &link::actuate() const { return this->actuate_.get(); }

link::actuate_type &link::actuate() { return this->actuate_.get(); }

void link::actuate(const actuate_type &x) { this->actuate_.set(x); }

void link::actuate(::std::unique_ptr<actuate_type> x) {
  this->actuate_.set(std::move(x));
}

const link::actuate_type &link::actuate_default_value() {
  return actuate_default_value_;
}

const link::name_optional &link::name() const { return this->name_; }

link::name_optional &link::name() { return this->name_; }

void link::name(const name_type &x) { this->name_.set(x); }

void link::name(const name_optional &x) { this->name_ = x; }

void link::name(::std::unique_ptr<name_type> x) {
  this->name_.set(std::move(x));
}

const link::element_optional &link::element() const { return this->element_; }

link::element_optional &link::element() { return this->element_; }

void link::element(const element_type &x) { this->element_.set(x); }

void link::element(const element_optional &x) { this->element_ = x; }

void link::element(::std::unique_ptr<element_type> x) {
  this->element_.set(std::move(x));
}

const link::position_optional &link::position() const {
  return this->position_;
}

link::position_optional &link::position() { return this->position_; }

void link::position(const position_type &x) { this->position_.set(x); }

void link::position(const position_optional &x) { this->position_ = x; }

const link::default_x_optional &link::default_x() const {
  return this->default_x_;
}

link::default_x_optional &link::default_x() { return this->default_x_; }

void link::default_x(const default_x_type &x) { this->default_x_.set(x); }

void link::default_x(const default_x_optional &x) { this->default_x_ = x; }

void link::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const link::default_y_optional &link::default_y() const {
  return this->default_y_;
}

link::default_y_optional &link::default_y() { return this->default_y_; }

void link::default_y(const default_y_type &x) { this->default_y_.set(x); }

void link::default_y(const default_y_optional &x) { this->default_y_ = x; }

void link::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const link::relative_x_optional &link::relative_x() const {
  return this->relative_x_;
}

link::relative_x_optional &link::relative_x() { return this->relative_x_; }

void link::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void link::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void link::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const link::relative_y_optional &link::relative_y() const {
  return this->relative_y_;
}

link::relative_y_optional &link::relative_y() { return this->relative_y_; }

void link::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void link::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void link::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

// accidental
//

const accidental::cautionary_optional &accidental::cautionary() const {
  return this->cautionary_;
}

accidental::cautionary_optional &accidental::cautionary() {
  return this->cautionary_;
}

void accidental::cautionary(const cautionary_type &x) {
  this->cautionary_.set(x);
}

void accidental::cautionary(const cautionary_optional &x) {
  this->cautionary_ = x;
}

void accidental::cautionary(::std::unique_ptr<cautionary_type> x) {
  this->cautionary_.set(std::move(x));
}

const accidental::editorial_optional &accidental::editorial() const {
  return this->editorial_;
}

accidental::editorial_optional &accidental::editorial() {
  return this->editorial_;
}

void accidental::editorial(const editorial_type &x) { this->editorial_.set(x); }

void accidental::editorial(const editorial_optional &x) {
  this->editorial_ = x;
}

void accidental::editorial(::std::unique_ptr<editorial_type> x) {
  this->editorial_.set(std::move(x));
}

const accidental::parentheses_optional &accidental::parentheses() const {
  return this->parentheses_;
}

accidental::parentheses_optional &accidental::parentheses() {
  return this->parentheses_;
}

void accidental::parentheses(const parentheses_type &x) {
  this->parentheses_.set(x);
}

void accidental::parentheses(const parentheses_optional &x) {
  this->parentheses_ = x;
}

void accidental::parentheses(::std::unique_ptr<parentheses_type> x) {
  this->parentheses_.set(std::move(x));
}

const accidental::bracket_optional &accidental::bracket() const {
  return this->bracket_;
}

accidental::bracket_optional &accidental::bracket() { return this->bracket_; }

void accidental::bracket(const bracket_type &x) { this->bracket_.set(x); }

void accidental::bracket(const bracket_optional &x) { this->bracket_ = x; }

void accidental::bracket(::std::unique_ptr<bracket_type> x) {
  this->bracket_.set(std::move(x));
}

const accidental::size_optional &accidental::size() const {
  return this->size_;
}

accidental::size_optional &accidental::size() { return this->size_; }

void accidental::size(const size_type &x) { this->size_.set(x); }

void accidental::size(const size_optional &x) { this->size_ = x; }

void accidental::size(::std::unique_ptr<size_type> x) {
  this->size_.set(std::move(x));
}

const accidental::default_x_optional &accidental::default_x() const {
  return this->default_x_;
}

accidental::default_x_optional &accidental::default_x() {
  return this->default_x_;
}

void accidental::default_x(const default_x_type &x) { this->default_x_.set(x); }

void accidental::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void accidental::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const accidental::default_y_optional &accidental::default_y() const {
  return this->default_y_;
}

accidental::default_y_optional &accidental::default_y() {
  return this->default_y_;
}

void accidental::default_y(const default_y_type &x) { this->default_y_.set(x); }

void accidental::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void accidental::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const accidental::relative_x_optional &accidental::relative_x() const {
  return this->relative_x_;
}

accidental::relative_x_optional &accidental::relative_x() {
  return this->relative_x_;
}

void accidental::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void accidental::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void accidental::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const accidental::relative_y_optional &accidental::relative_y() const {
  return this->relative_y_;
}

accidental::relative_y_optional &accidental::relative_y() {
  return this->relative_y_;
}

void accidental::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void accidental::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void accidental::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const accidental::font_family_optional &accidental::font_family() const {
  return this->font_family_;
}

accidental::font_family_optional &accidental::font_family() {
  return this->font_family_;
}

void accidental::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void accidental::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void accidental::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const accidental::font_style_optional &accidental::font_style() const {
  return this->font_style_;
}

accidental::font_style_optional &accidental::font_style() {
  return this->font_style_;
}

void accidental::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void accidental::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void accidental::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const accidental::font_size_optional &accidental::font_size() const {
  return this->font_size_;
}

accidental::font_size_optional &accidental::font_size() {
  return this->font_size_;
}

void accidental::font_size(const font_size_type &x) { this->font_size_.set(x); }

void accidental::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void accidental::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const accidental::font_weight_optional &accidental::font_weight() const {
  return this->font_weight_;
}

accidental::font_weight_optional &accidental::font_weight() {
  return this->font_weight_;
}

void accidental::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void accidental::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void accidental::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const accidental::color_optional &accidental::color() const {
  return this->color_;
}

accidental::color_optional &accidental::color() { return this->color_; }

void accidental::color(const color_type &x) { this->color_.set(x); }

void accidental::color(const color_optional &x) { this->color_ = x; }

void accidental::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// accidental_mark
//

const accidental_mark::default_x_optional &accidental_mark::default_x() const {
  return this->default_x_;
}

accidental_mark::default_x_optional &accidental_mark::default_x() {
  return this->default_x_;
}

void accidental_mark::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void accidental_mark::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void accidental_mark::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const accidental_mark::default_y_optional &accidental_mark::default_y() const {
  return this->default_y_;
}

accidental_mark::default_y_optional &accidental_mark::default_y() {
  return this->default_y_;
}

void accidental_mark::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void accidental_mark::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void accidental_mark::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const accidental_mark::relative_x_optional &
accidental_mark::relative_x() const {
  return this->relative_x_;
}

accidental_mark::relative_x_optional &accidental_mark::relative_x() {
  return this->relative_x_;
}

void accidental_mark::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void accidental_mark::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void accidental_mark::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const accidental_mark::relative_y_optional &
accidental_mark::relative_y() const {
  return this->relative_y_;
}

accidental_mark::relative_y_optional &accidental_mark::relative_y() {
  return this->relative_y_;
}

void accidental_mark::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void accidental_mark::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void accidental_mark::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const accidental_mark::font_family_optional &
accidental_mark::font_family() const {
  return this->font_family_;
}

accidental_mark::font_family_optional &accidental_mark::font_family() {
  return this->font_family_;
}

void accidental_mark::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void accidental_mark::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void accidental_mark::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const accidental_mark::font_style_optional &
accidental_mark::font_style() const {
  return this->font_style_;
}

accidental_mark::font_style_optional &accidental_mark::font_style() {
  return this->font_style_;
}

void accidental_mark::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void accidental_mark::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void accidental_mark::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const accidental_mark::font_size_optional &accidental_mark::font_size() const {
  return this->font_size_;
}

accidental_mark::font_size_optional &accidental_mark::font_size() {
  return this->font_size_;
}

void accidental_mark::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void accidental_mark::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void accidental_mark::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const accidental_mark::font_weight_optional &
accidental_mark::font_weight() const {
  return this->font_weight_;
}

accidental_mark::font_weight_optional &accidental_mark::font_weight() {
  return this->font_weight_;
}

void accidental_mark::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void accidental_mark::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void accidental_mark::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const accidental_mark::color_optional &accidental_mark::color() const {
  return this->color_;
}

accidental_mark::color_optional &accidental_mark::color() {
  return this->color_;
}

void accidental_mark::color(const color_type &x) { this->color_.set(x); }

void accidental_mark::color(const color_optional &x) { this->color_ = x; }

void accidental_mark::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const accidental_mark::placement_optional &accidental_mark::placement() const {
  return this->placement_;
}

accidental_mark::placement_optional &accidental_mark::placement() {
  return this->placement_;
}

void accidental_mark::placement(const placement_type &x) {
  this->placement_.set(x);
}

void accidental_mark::placement(const placement_optional &x) {
  this->placement_ = x;
}

void accidental_mark::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// arpeggiate
//

const arpeggiate::number_optional &arpeggiate::number() const {
  return this->number_;
}

arpeggiate::number_optional &arpeggiate::number() { return this->number_; }

void arpeggiate::number(const number_type &x) { this->number_.set(x); }

void arpeggiate::number(const number_optional &x) { this->number_ = x; }

void arpeggiate::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const arpeggiate::direction_optional &arpeggiate::direction() const {
  return this->direction_;
}

arpeggiate::direction_optional &arpeggiate::direction() {
  return this->direction_;
}

void arpeggiate::direction(const direction_type &x) { this->direction_.set(x); }

void arpeggiate::direction(const direction_optional &x) {
  this->direction_ = x;
}

void arpeggiate::direction(::std::unique_ptr<direction_type> x) {
  this->direction_.set(std::move(x));
}

const arpeggiate::default_x_optional &arpeggiate::default_x() const {
  return this->default_x_;
}

arpeggiate::default_x_optional &arpeggiate::default_x() {
  return this->default_x_;
}

void arpeggiate::default_x(const default_x_type &x) { this->default_x_.set(x); }

void arpeggiate::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void arpeggiate::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const arpeggiate::default_y_optional &arpeggiate::default_y() const {
  return this->default_y_;
}

arpeggiate::default_y_optional &arpeggiate::default_y() {
  return this->default_y_;
}

void arpeggiate::default_y(const default_y_type &x) { this->default_y_.set(x); }

void arpeggiate::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void arpeggiate::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const arpeggiate::relative_x_optional &arpeggiate::relative_x() const {
  return this->relative_x_;
}

arpeggiate::relative_x_optional &arpeggiate::relative_x() {
  return this->relative_x_;
}

void arpeggiate::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void arpeggiate::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void arpeggiate::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const arpeggiate::relative_y_optional &arpeggiate::relative_y() const {
  return this->relative_y_;
}

arpeggiate::relative_y_optional &arpeggiate::relative_y() {
  return this->relative_y_;
}

void arpeggiate::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void arpeggiate::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void arpeggiate::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const arpeggiate::placement_optional &arpeggiate::placement() const {
  return this->placement_;
}

arpeggiate::placement_optional &arpeggiate::placement() {
  return this->placement_;
}

void arpeggiate::placement(const placement_type &x) { this->placement_.set(x); }

void arpeggiate::placement(const placement_optional &x) {
  this->placement_ = x;
}

void arpeggiate::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const arpeggiate::color_optional &arpeggiate::color() const {
  return this->color_;
}

arpeggiate::color_optional &arpeggiate::color() { return this->color_; }

void arpeggiate::color(const color_type &x) { this->color_.set(x); }

void arpeggiate::color(const color_optional &x) { this->color_ = x; }

void arpeggiate::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// articulations
//

const articulations::accent_sequence &articulations::accent() const {
  return this->accent_;
}

articulations::accent_sequence &articulations::accent() {
  return this->accent_;
}

void articulations::accent(const accent_sequence &s) { this->accent_ = s; }

const articulations::strong_accent_sequence &
articulations::strong_accent() const {
  return this->strong_accent_;
}

articulations::strong_accent_sequence &articulations::strong_accent() {
  return this->strong_accent_;
}

void articulations::strong_accent(const strong_accent_sequence &s) {
  this->strong_accent_ = s;
}

const articulations::staccato_sequence &articulations::staccato() const {
  return this->staccato_;
}

articulations::staccato_sequence &articulations::staccato() {
  return this->staccato_;
}

void articulations::staccato(const staccato_sequence &s) {
  this->staccato_ = s;
}

const articulations::tenuto_sequence &articulations::tenuto() const {
  return this->tenuto_;
}

articulations::tenuto_sequence &articulations::tenuto() {
  return this->tenuto_;
}

void articulations::tenuto(const tenuto_sequence &s) { this->tenuto_ = s; }

const articulations::detached_legato_sequence &
articulations::detached_legato() const {
  return this->detached_legato_;
}

articulations::detached_legato_sequence &articulations::detached_legato() {
  return this->detached_legato_;
}

void articulations::detached_legato(const detached_legato_sequence &s) {
  this->detached_legato_ = s;
}

const articulations::staccatissimo_sequence &
articulations::staccatissimo() const {
  return this->staccatissimo_;
}

articulations::staccatissimo_sequence &articulations::staccatissimo() {
  return this->staccatissimo_;
}

void articulations::staccatissimo(const staccatissimo_sequence &s) {
  this->staccatissimo_ = s;
}

const articulations::spiccato_sequence &articulations::spiccato() const {
  return this->spiccato_;
}

articulations::spiccato_sequence &articulations::spiccato() {
  return this->spiccato_;
}

void articulations::spiccato(const spiccato_sequence &s) {
  this->spiccato_ = s;
}

const articulations::scoop_sequence &articulations::scoop() const {
  return this->scoop_;
}

articulations::scoop_sequence &articulations::scoop() { return this->scoop_; }

void articulations::scoop(const scoop_sequence &s) { this->scoop_ = s; }

const articulations::plop_sequence &articulations::plop() const {
  return this->plop_;
}

articulations::plop_sequence &articulations::plop() { return this->plop_; }

void articulations::plop(const plop_sequence &s) { this->plop_ = s; }

const articulations::doit_sequence &articulations::doit() const {
  return this->doit_;
}

articulations::doit_sequence &articulations::doit() { return this->doit_; }

void articulations::doit(const doit_sequence &s) { this->doit_ = s; }

const articulations::falloff_sequence &articulations::falloff() const {
  return this->falloff_;
}

articulations::falloff_sequence &articulations::falloff() {
  return this->falloff_;
}

void articulations::falloff(const falloff_sequence &s) { this->falloff_ = s; }

const articulations::breath_mark_sequence &articulations::breath_mark() const {
  return this->breath_mark_;
}

articulations::breath_mark_sequence &articulations::breath_mark() {
  return this->breath_mark_;
}

void articulations::breath_mark(const breath_mark_sequence &s) {
  this->breath_mark_ = s;
}

const articulations::caesura_sequence &articulations::caesura() const {
  return this->caesura_;
}

articulations::caesura_sequence &articulations::caesura() {
  return this->caesura_;
}

void articulations::caesura(const caesura_sequence &s) { this->caesura_ = s; }

const articulations::stress_sequence &articulations::stress() const {
  return this->stress_;
}

articulations::stress_sequence &articulations::stress() {
  return this->stress_;
}

void articulations::stress(const stress_sequence &s) { this->stress_ = s; }

const articulations::unstress_sequence &articulations::unstress() const {
  return this->unstress_;
}

articulations::unstress_sequence &articulations::unstress() {
  return this->unstress_;
}

void articulations::unstress(const unstress_sequence &s) {
  this->unstress_ = s;
}

const articulations::other_articulation_sequence &
articulations::other_articulation() const {
  return this->other_articulation_;
}

articulations::other_articulation_sequence &
articulations::other_articulation() {
  return this->other_articulation_;
}

void articulations::other_articulation(const other_articulation_sequence &s) {
  this->other_articulation_ = s;
}

// arrow
//

const arrow::arrow_direction_optional &arrow::arrow_direction() const {
  return this->arrow_direction_;
}

arrow::arrow_direction_optional &arrow::arrow_direction() {
  return this->arrow_direction_;
}

void arrow::arrow_direction(const arrow_direction_type &x) {
  this->arrow_direction_.set(x);
}

void arrow::arrow_direction(const arrow_direction_optional &x) {
  this->arrow_direction_ = x;
}

void arrow::arrow_direction(::std::unique_ptr<arrow_direction_type> x) {
  this->arrow_direction_.set(std::move(x));
}

const arrow::arrow_style_optional &arrow::arrow_style() const {
  return this->arrow_style_;
}

arrow::arrow_style_optional &arrow::arrow_style() { return this->arrow_style_; }

void arrow::arrow_style(const arrow_style_type &x) {
  this->arrow_style_.set(x);
}

void arrow::arrow_style(const arrow_style_optional &x) {
  this->arrow_style_ = x;
}

void arrow::arrow_style(::std::unique_ptr<arrow_style_type> x) {
  this->arrow_style_.set(std::move(x));
}

const arrow::circular_arrow_optional &arrow::circular_arrow() const {
  return this->circular_arrow_;
}

arrow::circular_arrow_optional &arrow::circular_arrow() {
  return this->circular_arrow_;
}

void arrow::circular_arrow(const circular_arrow_type &x) {
  this->circular_arrow_.set(x);
}

void arrow::circular_arrow(const circular_arrow_optional &x) {
  this->circular_arrow_ = x;
}

void arrow::circular_arrow(::std::unique_ptr<circular_arrow_type> x) {
  this->circular_arrow_.set(std::move(x));
}

const arrow::default_x_optional &arrow::default_x() const {
  return this->default_x_;
}

arrow::default_x_optional &arrow::default_x() { return this->default_x_; }

void arrow::default_x(const default_x_type &x) { this->default_x_.set(x); }

void arrow::default_x(const default_x_optional &x) { this->default_x_ = x; }

void arrow::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const arrow::default_y_optional &arrow::default_y() const {
  return this->default_y_;
}

arrow::default_y_optional &arrow::default_y() { return this->default_y_; }

void arrow::default_y(const default_y_type &x) { this->default_y_.set(x); }

void arrow::default_y(const default_y_optional &x) { this->default_y_ = x; }

void arrow::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const arrow::relative_x_optional &arrow::relative_x() const {
  return this->relative_x_;
}

arrow::relative_x_optional &arrow::relative_x() { return this->relative_x_; }

void arrow::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void arrow::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void arrow::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const arrow::relative_y_optional &arrow::relative_y() const {
  return this->relative_y_;
}

arrow::relative_y_optional &arrow::relative_y() { return this->relative_y_; }

void arrow::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void arrow::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void arrow::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const arrow::font_family_optional &arrow::font_family() const {
  return this->font_family_;
}

arrow::font_family_optional &arrow::font_family() { return this->font_family_; }

void arrow::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void arrow::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void arrow::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const arrow::font_style_optional &arrow::font_style() const {
  return this->font_style_;
}

arrow::font_style_optional &arrow::font_style() { return this->font_style_; }

void arrow::font_style(const font_style_type &x) { this->font_style_.set(x); }

void arrow::font_style(const font_style_optional &x) { this->font_style_ = x; }

void arrow::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const arrow::font_size_optional &arrow::font_size() const {
  return this->font_size_;
}

arrow::font_size_optional &arrow::font_size() { return this->font_size_; }

void arrow::font_size(const font_size_type &x) { this->font_size_.set(x); }

void arrow::font_size(const font_size_optional &x) { this->font_size_ = x; }

void arrow::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const arrow::font_weight_optional &arrow::font_weight() const {
  return this->font_weight_;
}

arrow::font_weight_optional &arrow::font_weight() { return this->font_weight_; }

void arrow::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void arrow::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void arrow::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const arrow::color_optional &arrow::color() const { return this->color_; }

arrow::color_optional &arrow::color() { return this->color_; }

void arrow::color(const color_type &x) { this->color_.set(x); }

void arrow::color(const color_optional &x) { this->color_ = x; }

void arrow::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const arrow::placement_optional &arrow::placement() const {
  return this->placement_;
}

arrow::placement_optional &arrow::placement() { return this->placement_; }

void arrow::placement(const placement_type &x) { this->placement_.set(x); }

void arrow::placement(const placement_optional &x) { this->placement_ = x; }

void arrow::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// backup
//

const backup::duration_type &backup::duration() const {
  return this->duration_.get();
}

backup::duration_type &backup::duration() { return this->duration_.get(); }

void backup::duration(const duration_type &x) { this->duration_.set(x); }

void backup::duration(::std::unique_ptr<duration_type> x) {
  this->duration_.set(std::move(x));
}

const backup::footnote_optional &backup::footnote() const {
  return this->footnote_;
}

backup::footnote_optional &backup::footnote() { return this->footnote_; }

void backup::footnote(const footnote_type &x) { this->footnote_.set(x); }

void backup::footnote(const footnote_optional &x) { this->footnote_ = x; }

void backup::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const backup::level_optional &backup::level() const { return this->level_; }

backup::level_optional &backup::level() { return this->level_; }

void backup::level(const level_type &x) { this->level_.set(x); }

void backup::level(const level_optional &x) { this->level_ = x; }

void backup::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

// beam
//

const beam::number_type &beam::number() const { return this->number_.get(); }

beam::number_type &beam::number() { return this->number_.get(); }

void beam::number(const number_type &x) { this->number_.set(x); }

void beam::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

beam::number_type beam::number_default_value() { return number_type(1ULL); }

const beam::repeater_optional &beam::repeater() const {
  return this->repeater_;
}

beam::repeater_optional &beam::repeater() { return this->repeater_; }

void beam::repeater(const repeater_type &x) { this->repeater_.set(x); }

void beam::repeater(const repeater_optional &x) { this->repeater_ = x; }

void beam::repeater(::std::unique_ptr<repeater_type> x) {
  this->repeater_.set(std::move(x));
}

const beam::fan_optional &beam::fan() const { return this->fan_; }

beam::fan_optional &beam::fan() { return this->fan_; }

void beam::fan(const fan_type &x) { this->fan_.set(x); }

void beam::fan(const fan_optional &x) { this->fan_ = x; }

void beam::fan(::std::unique_ptr<fan_type> x) { this->fan_.set(std::move(x)); }

const beam::color_optional &beam::color() const { return this->color_; }

beam::color_optional &beam::color() { return this->color_; }

void beam::color(const color_type &x) { this->color_.set(x); }

void beam::color(const color_optional &x) { this->color_ = x; }

void beam::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// bend
//

const bend::bend_alter_type &bend::bend_alter() const {
  return this->bend_alter_.get();
}

bend::bend_alter_type &bend::bend_alter() { return this->bend_alter_.get(); }

void bend::bend_alter(const bend_alter_type &x) { this->bend_alter_.set(x); }

void bend::bend_alter(::std::unique_ptr<bend_alter_type> x) {
  this->bend_alter_.set(std::move(x));
}

const bend::pre_bend_optional &bend::pre_bend() const {
  return this->pre_bend_;
}

bend::pre_bend_optional &bend::pre_bend() { return this->pre_bend_; }

void bend::pre_bend(const pre_bend_type &x) { this->pre_bend_.set(x); }

void bend::pre_bend(const pre_bend_optional &x) { this->pre_bend_ = x; }

void bend::pre_bend(::std::unique_ptr<pre_bend_type> x) {
  this->pre_bend_.set(std::move(x));
}

const bend::release_optional &bend::release() const { return this->release_; }

bend::release_optional &bend::release() { return this->release_; }

void bend::release(const release_type &x) { this->release_.set(x); }

void bend::release(const release_optional &x) { this->release_ = x; }

void bend::release(::std::unique_ptr<release_type> x) {
  this->release_.set(std::move(x));
}

const bend::with_bar_optional &bend::with_bar() const {
  return this->with_bar_;
}

bend::with_bar_optional &bend::with_bar() { return this->with_bar_; }

void bend::with_bar(const with_bar_type &x) { this->with_bar_.set(x); }

void bend::with_bar(const with_bar_optional &x) { this->with_bar_ = x; }

void bend::with_bar(::std::unique_ptr<with_bar_type> x) {
  this->with_bar_.set(std::move(x));
}

const bend::default_x_optional &bend::default_x() const {
  return this->default_x_;
}

bend::default_x_optional &bend::default_x() { return this->default_x_; }

void bend::default_x(const default_x_type &x) { this->default_x_.set(x); }

void bend::default_x(const default_x_optional &x) { this->default_x_ = x; }

void bend::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const bend::default_y_optional &bend::default_y() const {
  return this->default_y_;
}

bend::default_y_optional &bend::default_y() { return this->default_y_; }

void bend::default_y(const default_y_type &x) { this->default_y_.set(x); }

void bend::default_y(const default_y_optional &x) { this->default_y_ = x; }

void bend::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const bend::relative_x_optional &bend::relative_x() const {
  return this->relative_x_;
}

bend::relative_x_optional &bend::relative_x() { return this->relative_x_; }

void bend::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void bend::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void bend::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const bend::relative_y_optional &bend::relative_y() const {
  return this->relative_y_;
}

bend::relative_y_optional &bend::relative_y() { return this->relative_y_; }

void bend::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void bend::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void bend::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const bend::font_family_optional &bend::font_family() const {
  return this->font_family_;
}

bend::font_family_optional &bend::font_family() { return this->font_family_; }

void bend::font_family(const font_family_type &x) { this->font_family_.set(x); }

void bend::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void bend::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const bend::font_style_optional &bend::font_style() const {
  return this->font_style_;
}

bend::font_style_optional &bend::font_style() { return this->font_style_; }

void bend::font_style(const font_style_type &x) { this->font_style_.set(x); }

void bend::font_style(const font_style_optional &x) { this->font_style_ = x; }

void bend::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const bend::font_size_optional &bend::font_size() const {
  return this->font_size_;
}

bend::font_size_optional &bend::font_size() { return this->font_size_; }

void bend::font_size(const font_size_type &x) { this->font_size_.set(x); }

void bend::font_size(const font_size_optional &x) { this->font_size_ = x; }

void bend::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const bend::font_weight_optional &bend::font_weight() const {
  return this->font_weight_;
}

bend::font_weight_optional &bend::font_weight() { return this->font_weight_; }

void bend::font_weight(const font_weight_type &x) { this->font_weight_.set(x); }

void bend::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void bend::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const bend::color_optional &bend::color() const { return this->color_; }

bend::color_optional &bend::color() { return this->color_; }

void bend::color(const color_type &x) { this->color_.set(x); }

void bend::color(const color_optional &x) { this->color_ = x; }

void bend::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const bend::accelerate_optional &bend::accelerate() const {
  return this->accelerate_;
}

bend::accelerate_optional &bend::accelerate() { return this->accelerate_; }

void bend::accelerate(const accelerate_type &x) { this->accelerate_.set(x); }

void bend::accelerate(const accelerate_optional &x) { this->accelerate_ = x; }

void bend::accelerate(::std::unique_ptr<accelerate_type> x) {
  this->accelerate_.set(std::move(x));
}

const bend::beats_optional &bend::beats() const { return this->beats_; }

bend::beats_optional &bend::beats() { return this->beats_; }

void bend::beats(const beats_type &x) { this->beats_.set(x); }

void bend::beats(const beats_optional &x) { this->beats_ = x; }

void bend::beats(::std::unique_ptr<beats_type> x) {
  this->beats_.set(std::move(x));
}

const bend::first_beat_optional &bend::first_beat() const {
  return this->first_beat_;
}

bend::first_beat_optional &bend::first_beat() { return this->first_beat_; }

void bend::first_beat(const first_beat_type &x) { this->first_beat_.set(x); }

void bend::first_beat(const first_beat_optional &x) { this->first_beat_ = x; }

void bend::first_beat(::std::unique_ptr<first_beat_type> x) {
  this->first_beat_.set(std::move(x));
}

const bend::last_beat_optional &bend::last_beat() const {
  return this->last_beat_;
}

bend::last_beat_optional &bend::last_beat() { return this->last_beat_; }

void bend::last_beat(const last_beat_type &x) { this->last_beat_.set(x); }

void bend::last_beat(const last_beat_optional &x) { this->last_beat_ = x; }

void bend::last_beat(::std::unique_ptr<last_beat_type> x) {
  this->last_beat_.set(std::move(x));
}

// breath_mark
//

const breath_mark::default_x_optional &breath_mark::default_x() const {
  return this->default_x_;
}

breath_mark::default_x_optional &breath_mark::default_x() {
  return this->default_x_;
}

void breath_mark::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void breath_mark::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void breath_mark::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const breath_mark::default_y_optional &breath_mark::default_y() const {
  return this->default_y_;
}

breath_mark::default_y_optional &breath_mark::default_y() {
  return this->default_y_;
}

void breath_mark::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void breath_mark::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void breath_mark::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const breath_mark::relative_x_optional &breath_mark::relative_x() const {
  return this->relative_x_;
}

breath_mark::relative_x_optional &breath_mark::relative_x() {
  return this->relative_x_;
}

void breath_mark::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void breath_mark::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void breath_mark::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const breath_mark::relative_y_optional &breath_mark::relative_y() const {
  return this->relative_y_;
}

breath_mark::relative_y_optional &breath_mark::relative_y() {
  return this->relative_y_;
}

void breath_mark::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void breath_mark::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void breath_mark::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const breath_mark::font_family_optional &breath_mark::font_family() const {
  return this->font_family_;
}

breath_mark::font_family_optional &breath_mark::font_family() {
  return this->font_family_;
}

void breath_mark::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void breath_mark::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void breath_mark::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const breath_mark::font_style_optional &breath_mark::font_style() const {
  return this->font_style_;
}

breath_mark::font_style_optional &breath_mark::font_style() {
  return this->font_style_;
}

void breath_mark::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void breath_mark::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void breath_mark::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const breath_mark::font_size_optional &breath_mark::font_size() const {
  return this->font_size_;
}

breath_mark::font_size_optional &breath_mark::font_size() {
  return this->font_size_;
}

void breath_mark::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void breath_mark::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void breath_mark::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const breath_mark::font_weight_optional &breath_mark::font_weight() const {
  return this->font_weight_;
}

breath_mark::font_weight_optional &breath_mark::font_weight() {
  return this->font_weight_;
}

void breath_mark::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void breath_mark::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void breath_mark::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const breath_mark::color_optional &breath_mark::color() const {
  return this->color_;
}

breath_mark::color_optional &breath_mark::color() { return this->color_; }

void breath_mark::color(const color_type &x) { this->color_.set(x); }

void breath_mark::color(const color_optional &x) { this->color_ = x; }

void breath_mark::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const breath_mark::placement_optional &breath_mark::placement() const {
  return this->placement_;
}

breath_mark::placement_optional &breath_mark::placement() {
  return this->placement_;
}

void breath_mark::placement(const placement_type &x) {
  this->placement_.set(x);
}

void breath_mark::placement(const placement_optional &x) {
  this->placement_ = x;
}

void breath_mark::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// empty_line
//

const empty_line::line_shape_optional &empty_line::line_shape() const {
  return this->line_shape_;
}

empty_line::line_shape_optional &empty_line::line_shape() {
  return this->line_shape_;
}

void empty_line::line_shape(const line_shape_type &x) {
  this->line_shape_.set(x);
}

void empty_line::line_shape(const line_shape_optional &x) {
  this->line_shape_ = x;
}

void empty_line::line_shape(::std::unique_ptr<line_shape_type> x) {
  this->line_shape_.set(std::move(x));
}

const empty_line::line_type_optional &empty_line::line_type() const {
  return this->line_type_;
}

empty_line::line_type_optional &empty_line::line_type() {
  return this->line_type_;
}

void empty_line::line_type(const line_type_type &x) { this->line_type_.set(x); }

void empty_line::line_type(const line_type_optional &x) {
  this->line_type_ = x;
}

void empty_line::line_type(::std::unique_ptr<line_type_type> x) {
  this->line_type_.set(std::move(x));
}

const empty_line::dash_length_optional &empty_line::dash_length() const {
  return this->dash_length_;
}

empty_line::dash_length_optional &empty_line::dash_length() {
  return this->dash_length_;
}

void empty_line::dash_length(const dash_length_type &x) {
  this->dash_length_.set(x);
}

void empty_line::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void empty_line::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const empty_line::space_length_optional &empty_line::space_length() const {
  return this->space_length_;
}

empty_line::space_length_optional &empty_line::space_length() {
  return this->space_length_;
}

void empty_line::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void empty_line::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void empty_line::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const empty_line::default_x_optional &empty_line::default_x() const {
  return this->default_x_;
}

empty_line::default_x_optional &empty_line::default_x() {
  return this->default_x_;
}

void empty_line::default_x(const default_x_type &x) { this->default_x_.set(x); }

void empty_line::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void empty_line::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const empty_line::default_y_optional &empty_line::default_y() const {
  return this->default_y_;
}

empty_line::default_y_optional &empty_line::default_y() {
  return this->default_y_;
}

void empty_line::default_y(const default_y_type &x) { this->default_y_.set(x); }

void empty_line::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void empty_line::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const empty_line::relative_x_optional &empty_line::relative_x() const {
  return this->relative_x_;
}

empty_line::relative_x_optional &empty_line::relative_x() {
  return this->relative_x_;
}

void empty_line::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void empty_line::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void empty_line::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const empty_line::relative_y_optional &empty_line::relative_y() const {
  return this->relative_y_;
}

empty_line::relative_y_optional &empty_line::relative_y() {
  return this->relative_y_;
}

void empty_line::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void empty_line::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void empty_line::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const empty_line::font_family_optional &empty_line::font_family() const {
  return this->font_family_;
}

empty_line::font_family_optional &empty_line::font_family() {
  return this->font_family_;
}

void empty_line::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void empty_line::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void empty_line::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const empty_line::font_style_optional &empty_line::font_style() const {
  return this->font_style_;
}

empty_line::font_style_optional &empty_line::font_style() {
  return this->font_style_;
}

void empty_line::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void empty_line::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void empty_line::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const empty_line::font_size_optional &empty_line::font_size() const {
  return this->font_size_;
}

empty_line::font_size_optional &empty_line::font_size() {
  return this->font_size_;
}

void empty_line::font_size(const font_size_type &x) { this->font_size_.set(x); }

void empty_line::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void empty_line::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const empty_line::font_weight_optional &empty_line::font_weight() const {
  return this->font_weight_;
}

empty_line::font_weight_optional &empty_line::font_weight() {
  return this->font_weight_;
}

void empty_line::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void empty_line::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void empty_line::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const empty_line::color_optional &empty_line::color() const {
  return this->color_;
}

empty_line::color_optional &empty_line::color() { return this->color_; }

void empty_line::color(const color_type &x) { this->color_.set(x); }

void empty_line::color(const color_optional &x) { this->color_ = x; }

void empty_line::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const empty_line::placement_optional &empty_line::placement() const {
  return this->placement_;
}

empty_line::placement_optional &empty_line::placement() {
  return this->placement_;
}

void empty_line::placement(const placement_type &x) { this->placement_.set(x); }

void empty_line::placement(const placement_optional &x) {
  this->placement_ = x;
}

void empty_line::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// extend
//

const extend::type_optional &extend::type() const { return this->type_; }

extend::type_optional &extend::type() { return this->type_; }

void extend::type(const type_type &x) { this->type_.set(x); }

void extend::type(const type_optional &x) { this->type_ = x; }

void extend::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const extend::default_x_optional &extend::default_x() const {
  return this->default_x_;
}

extend::default_x_optional &extend::default_x() { return this->default_x_; }

void extend::default_x(const default_x_type &x) { this->default_x_.set(x); }

void extend::default_x(const default_x_optional &x) { this->default_x_ = x; }

void extend::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const extend::default_y_optional &extend::default_y() const {
  return this->default_y_;
}

extend::default_y_optional &extend::default_y() { return this->default_y_; }

void extend::default_y(const default_y_type &x) { this->default_y_.set(x); }

void extend::default_y(const default_y_optional &x) { this->default_y_ = x; }

void extend::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const extend::relative_x_optional &extend::relative_x() const {
  return this->relative_x_;
}

extend::relative_x_optional &extend::relative_x() { return this->relative_x_; }

void extend::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void extend::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void extend::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const extend::relative_y_optional &extend::relative_y() const {
  return this->relative_y_;
}

extend::relative_y_optional &extend::relative_y() { return this->relative_y_; }

void extend::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void extend::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void extend::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const extend::font_family_optional &extend::font_family() const {
  return this->font_family_;
}

extend::font_family_optional &extend::font_family() {
  return this->font_family_;
}

void extend::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void extend::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void extend::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const extend::font_style_optional &extend::font_style() const {
  return this->font_style_;
}

extend::font_style_optional &extend::font_style() { return this->font_style_; }

void extend::font_style(const font_style_type &x) { this->font_style_.set(x); }

void extend::font_style(const font_style_optional &x) { this->font_style_ = x; }

void extend::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const extend::font_size_optional &extend::font_size() const {
  return this->font_size_;
}

extend::font_size_optional &extend::font_size() { return this->font_size_; }

void extend::font_size(const font_size_type &x) { this->font_size_.set(x); }

void extend::font_size(const font_size_optional &x) { this->font_size_ = x; }

void extend::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const extend::font_weight_optional &extend::font_weight() const {
  return this->font_weight_;
}

extend::font_weight_optional &extend::font_weight() {
  return this->font_weight_;
}

void extend::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void extend::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void extend::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const extend::color_optional &extend::color() const { return this->color_; }

extend::color_optional &extend::color() { return this->color_; }

void extend::color(const color_type &x) { this->color_.set(x); }

void extend::color(const color_optional &x) { this->color_ = x; }

void extend::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// figure
//

const figure::prefix_optional &figure::prefix() const { return this->prefix_; }

figure::prefix_optional &figure::prefix() { return this->prefix_; }

void figure::prefix(const prefix_type &x) { this->prefix_.set(x); }

void figure::prefix(const prefix_optional &x) { this->prefix_ = x; }

void figure::prefix(::std::unique_ptr<prefix_type> x) {
  this->prefix_.set(std::move(x));
}

const figure::figure_number_optional &figure::figure_number() const {
  return this->figure_number_;
}

figure::figure_number_optional &figure::figure_number() {
  return this->figure_number_;
}

void figure::figure_number(const figure_number_type &x) {
  this->figure_number_.set(x);
}

void figure::figure_number(const figure_number_optional &x) {
  this->figure_number_ = x;
}

void figure::figure_number(::std::unique_ptr<figure_number_type> x) {
  this->figure_number_.set(std::move(x));
}

const figure::suffix_optional &figure::suffix() const { return this->suffix_; }

figure::suffix_optional &figure::suffix() { return this->suffix_; }

void figure::suffix(const suffix_type &x) { this->suffix_.set(x); }

void figure::suffix(const suffix_optional &x) { this->suffix_ = x; }

void figure::suffix(::std::unique_ptr<suffix_type> x) {
  this->suffix_.set(std::move(x));
}

const figure::extend_optional &figure::extend() const { return this->extend_; }

figure::extend_optional &figure::extend() { return this->extend_; }

void figure::extend(const extend_type &x) { this->extend_.set(x); }

void figure::extend(const extend_optional &x) { this->extend_ = x; }

void figure::extend(::std::unique_ptr<extend_type> x) {
  this->extend_.set(std::move(x));
}

// figured_bass
//

const figured_bass::figure_sequence &figured_bass::figure() const {
  return this->figure_;
}

figured_bass::figure_sequence &figured_bass::figure() { return this->figure_; }

void figured_bass::figure(const figure_sequence &s) { this->figure_ = s; }

const figured_bass::duration_optional &figured_bass::duration() const {
  return this->duration_;
}

figured_bass::duration_optional &figured_bass::duration() {
  return this->duration_;
}

void figured_bass::duration(const duration_type &x) { this->duration_.set(x); }

void figured_bass::duration(const duration_optional &x) { this->duration_ = x; }

void figured_bass::duration(::std::unique_ptr<duration_type> x) {
  this->duration_.set(std::move(x));
}

const figured_bass::footnote_optional &figured_bass::footnote() const {
  return this->footnote_;
}

figured_bass::footnote_optional &figured_bass::footnote() {
  return this->footnote_;
}

void figured_bass::footnote(const footnote_type &x) { this->footnote_.set(x); }

void figured_bass::footnote(const footnote_optional &x) { this->footnote_ = x; }

void figured_bass::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const figured_bass::level_optional &figured_bass::level() const {
  return this->level_;
}

figured_bass::level_optional &figured_bass::level() { return this->level_; }

void figured_bass::level(const level_type &x) { this->level_.set(x); }

void figured_bass::level(const level_optional &x) { this->level_ = x; }

void figured_bass::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const figured_bass::default_x_optional &figured_bass::default_x() const {
  return this->default_x_;
}

figured_bass::default_x_optional &figured_bass::default_x() {
  return this->default_x_;
}

void figured_bass::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void figured_bass::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void figured_bass::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const figured_bass::default_y_optional &figured_bass::default_y() const {
  return this->default_y_;
}

figured_bass::default_y_optional &figured_bass::default_y() {
  return this->default_y_;
}

void figured_bass::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void figured_bass::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void figured_bass::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const figured_bass::relative_x_optional &figured_bass::relative_x() const {
  return this->relative_x_;
}

figured_bass::relative_x_optional &figured_bass::relative_x() {
  return this->relative_x_;
}

void figured_bass::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void figured_bass::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void figured_bass::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const figured_bass::relative_y_optional &figured_bass::relative_y() const {
  return this->relative_y_;
}

figured_bass::relative_y_optional &figured_bass::relative_y() {
  return this->relative_y_;
}

void figured_bass::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void figured_bass::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void figured_bass::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const figured_bass::font_family_optional &figured_bass::font_family() const {
  return this->font_family_;
}

figured_bass::font_family_optional &figured_bass::font_family() {
  return this->font_family_;
}

void figured_bass::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void figured_bass::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void figured_bass::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const figured_bass::font_style_optional &figured_bass::font_style() const {
  return this->font_style_;
}

figured_bass::font_style_optional &figured_bass::font_style() {
  return this->font_style_;
}

void figured_bass::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void figured_bass::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void figured_bass::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const figured_bass::font_size_optional &figured_bass::font_size() const {
  return this->font_size_;
}

figured_bass::font_size_optional &figured_bass::font_size() {
  return this->font_size_;
}

void figured_bass::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void figured_bass::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void figured_bass::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const figured_bass::font_weight_optional &figured_bass::font_weight() const {
  return this->font_weight_;
}

figured_bass::font_weight_optional &figured_bass::font_weight() {
  return this->font_weight_;
}

void figured_bass::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void figured_bass::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void figured_bass::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const figured_bass::color_optional &figured_bass::color() const {
  return this->color_;
}

figured_bass::color_optional &figured_bass::color() { return this->color_; }

void figured_bass::color(const color_type &x) { this->color_.set(x); }

void figured_bass::color(const color_optional &x) { this->color_ = x; }

void figured_bass::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const figured_bass::print_object_optional &figured_bass::print_object() const {
  return this->print_object_;
}

figured_bass::print_object_optional &figured_bass::print_object() {
  return this->print_object_;
}

void figured_bass::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void figured_bass::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void figured_bass::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const figured_bass::print_dot_optional &figured_bass::print_dot() const {
  return this->print_dot_;
}

figured_bass::print_dot_optional &figured_bass::print_dot() {
  return this->print_dot_;
}

void figured_bass::print_dot(const print_dot_type &x) {
  this->print_dot_.set(x);
}

void figured_bass::print_dot(const print_dot_optional &x) {
  this->print_dot_ = x;
}

void figured_bass::print_dot(::std::unique_ptr<print_dot_type> x) {
  this->print_dot_.set(std::move(x));
}

const figured_bass::print_spacing_optional &
figured_bass::print_spacing() const {
  return this->print_spacing_;
}

figured_bass::print_spacing_optional &figured_bass::print_spacing() {
  return this->print_spacing_;
}

void figured_bass::print_spacing(const print_spacing_type &x) {
  this->print_spacing_.set(x);
}

void figured_bass::print_spacing(const print_spacing_optional &x) {
  this->print_spacing_ = x;
}

void figured_bass::print_spacing(::std::unique_ptr<print_spacing_type> x) {
  this->print_spacing_.set(std::move(x));
}

const figured_bass::print_lyric_optional &figured_bass::print_lyric() const {
  return this->print_lyric_;
}

figured_bass::print_lyric_optional &figured_bass::print_lyric() {
  return this->print_lyric_;
}

void figured_bass::print_lyric(const print_lyric_type &x) {
  this->print_lyric_.set(x);
}

void figured_bass::print_lyric(const print_lyric_optional &x) {
  this->print_lyric_ = x;
}

void figured_bass::print_lyric(::std::unique_ptr<print_lyric_type> x) {
  this->print_lyric_.set(std::move(x));
}

const figured_bass::parentheses_optional &figured_bass::parentheses() const {
  return this->parentheses_;
}

figured_bass::parentheses_optional &figured_bass::parentheses() {
  return this->parentheses_;
}

void figured_bass::parentheses(const parentheses_type &x) {
  this->parentheses_.set(x);
}

void figured_bass::parentheses(const parentheses_optional &x) {
  this->parentheses_ = x;
}

void figured_bass::parentheses(::std::unique_ptr<parentheses_type> x) {
  this->parentheses_.set(std::move(x));
}

// forward
//

const forward::duration_type &forward::duration() const {
  return this->duration_.get();
}

forward::duration_type &forward::duration() { return this->duration_.get(); }

void forward::duration(const duration_type &x) { this->duration_.set(x); }

void forward::duration(::std::unique_ptr<duration_type> x) {
  this->duration_.set(std::move(x));
}

const forward::footnote_optional &forward::footnote() const {
  return this->footnote_;
}

forward::footnote_optional &forward::footnote() { return this->footnote_; }

void forward::footnote(const footnote_type &x) { this->footnote_.set(x); }

void forward::footnote(const footnote_optional &x) { this->footnote_ = x; }

void forward::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const forward::level_optional &forward::level() const { return this->level_; }

forward::level_optional &forward::level() { return this->level_; }

void forward::level(const level_type &x) { this->level_.set(x); }

void forward::level(const level_optional &x) { this->level_ = x; }

void forward::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const forward::voice_optional &forward::voice() const { return this->voice_; }

forward::voice_optional &forward::voice() { return this->voice_; }

void forward::voice(const voice_type &x) { this->voice_.set(x); }

void forward::voice(const voice_optional &x) { this->voice_ = x; }

void forward::voice(::std::unique_ptr<voice_type> x) {
  this->voice_.set(std::move(x));
}

const forward::staff_optional &forward::staff() const { return this->staff_; }

forward::staff_optional &forward::staff() { return this->staff_; }

void forward::staff(const staff_type &x) { this->staff_.set(x); }

void forward::staff(const staff_optional &x) { this->staff_ = x; }

// glissando
//

const glissando::type_type &glissando::type() const {
  return this->type_.get();
}

glissando::type_type &glissando::type() { return this->type_.get(); }

void glissando::type(const type_type &x) { this->type_.set(x); }

void glissando::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const glissando::number_type &glissando::number() const {
  return this->number_.get();
}

glissando::number_type &glissando::number() { return this->number_.get(); }

void glissando::number(const number_type &x) { this->number_.set(x); }

void glissando::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

glissando::number_type glissando::number_default_value() {
  return number_type(1ULL);
}

const glissando::line_type_optional &glissando::line_type() const {
  return this->line_type_;
}

glissando::line_type_optional &glissando::line_type() {
  return this->line_type_;
}

void glissando::line_type(const line_type_type &x) { this->line_type_.set(x); }

void glissando::line_type(const line_type_optional &x) { this->line_type_ = x; }

void glissando::line_type(::std::unique_ptr<line_type_type> x) {
  this->line_type_.set(std::move(x));
}

const glissando::dash_length_optional &glissando::dash_length() const {
  return this->dash_length_;
}

glissando::dash_length_optional &glissando::dash_length() {
  return this->dash_length_;
}

void glissando::dash_length(const dash_length_type &x) {
  this->dash_length_.set(x);
}

void glissando::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void glissando::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const glissando::space_length_optional &glissando::space_length() const {
  return this->space_length_;
}

glissando::space_length_optional &glissando::space_length() {
  return this->space_length_;
}

void glissando::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void glissando::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void glissando::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const glissando::default_x_optional &glissando::default_x() const {
  return this->default_x_;
}

glissando::default_x_optional &glissando::default_x() {
  return this->default_x_;
}

void glissando::default_x(const default_x_type &x) { this->default_x_.set(x); }

void glissando::default_x(const default_x_optional &x) { this->default_x_ = x; }

void glissando::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const glissando::default_y_optional &glissando::default_y() const {
  return this->default_y_;
}

glissando::default_y_optional &glissando::default_y() {
  return this->default_y_;
}

void glissando::default_y(const default_y_type &x) { this->default_y_.set(x); }

void glissando::default_y(const default_y_optional &x) { this->default_y_ = x; }

void glissando::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const glissando::relative_x_optional &glissando::relative_x() const {
  return this->relative_x_;
}

glissando::relative_x_optional &glissando::relative_x() {
  return this->relative_x_;
}

void glissando::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void glissando::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void glissando::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const glissando::relative_y_optional &glissando::relative_y() const {
  return this->relative_y_;
}

glissando::relative_y_optional &glissando::relative_y() {
  return this->relative_y_;
}

void glissando::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void glissando::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void glissando::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const glissando::font_family_optional &glissando::font_family() const {
  return this->font_family_;
}

glissando::font_family_optional &glissando::font_family() {
  return this->font_family_;
}

void glissando::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void glissando::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void glissando::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const glissando::font_style_optional &glissando::font_style() const {
  return this->font_style_;
}

glissando::font_style_optional &glissando::font_style() {
  return this->font_style_;
}

void glissando::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void glissando::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void glissando::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const glissando::font_size_optional &glissando::font_size() const {
  return this->font_size_;
}

glissando::font_size_optional &glissando::font_size() {
  return this->font_size_;
}

void glissando::font_size(const font_size_type &x) { this->font_size_.set(x); }

void glissando::font_size(const font_size_optional &x) { this->font_size_ = x; }

void glissando::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const glissando::font_weight_optional &glissando::font_weight() const {
  return this->font_weight_;
}

glissando::font_weight_optional &glissando::font_weight() {
  return this->font_weight_;
}

void glissando::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void glissando::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void glissando::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const glissando::color_optional &glissando::color() const {
  return this->color_;
}

glissando::color_optional &glissando::color() { return this->color_; }

void glissando::color(const color_type &x) { this->color_.set(x); }

void glissando::color(const color_optional &x) { this->color_ = x; }

void glissando::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// grace
//

const grace::steal_time_previous_optional &grace::steal_time_previous() const {
  return this->steal_time_previous_;
}

grace::steal_time_previous_optional &grace::steal_time_previous() {
  return this->steal_time_previous_;
}

void grace::steal_time_previous(const steal_time_previous_type &x) {
  this->steal_time_previous_.set(x);
}

void grace::steal_time_previous(const steal_time_previous_optional &x) {
  this->steal_time_previous_ = x;
}

void grace::steal_time_previous(::std::unique_ptr<steal_time_previous_type> x) {
  this->steal_time_previous_.set(std::move(x));
}

const grace::steal_time_following_optional &
grace::steal_time_following() const {
  return this->steal_time_following_;
}

grace::steal_time_following_optional &grace::steal_time_following() {
  return this->steal_time_following_;
}

void grace::steal_time_following(const steal_time_following_type &x) {
  this->steal_time_following_.set(x);
}

void grace::steal_time_following(const steal_time_following_optional &x) {
  this->steal_time_following_ = x;
}

void
grace::steal_time_following(::std::unique_ptr<steal_time_following_type> x) {
  this->steal_time_following_.set(std::move(x));
}

const grace::make_time_optional &grace::make_time() const {
  return this->make_time_;
}

grace::make_time_optional &grace::make_time() { return this->make_time_; }

void grace::make_time(const make_time_type &x) { this->make_time_.set(x); }

void grace::make_time(const make_time_optional &x) { this->make_time_ = x; }

void grace::make_time(::std::unique_ptr<make_time_type> x) {
  this->make_time_.set(std::move(x));
}

const grace::slash_optional &grace::slash() const { return this->slash_; }

grace::slash_optional &grace::slash() { return this->slash_; }

void grace::slash(const slash_type &x) { this->slash_.set(x); }

void grace::slash(const slash_optional &x) { this->slash_ = x; }

void grace::slash(::std::unique_ptr<slash_type> x) {
  this->slash_.set(std::move(x));
}

// hammer_on_pull_off
//

const hammer_on_pull_off::type_type &hammer_on_pull_off::type() const {
  return this->type_.get();
}

hammer_on_pull_off::type_type &hammer_on_pull_off::type() {
  return this->type_.get();
}

void hammer_on_pull_off::type(const type_type &x) { this->type_.set(x); }

void hammer_on_pull_off::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const hammer_on_pull_off::number_type &hammer_on_pull_off::number() const {
  return this->number_.get();
}

hammer_on_pull_off::number_type &hammer_on_pull_off::number() {
  return this->number_.get();
}

void hammer_on_pull_off::number(const number_type &x) { this->number_.set(x); }

void hammer_on_pull_off::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

hammer_on_pull_off::number_type hammer_on_pull_off::number_default_value() {
  return number_type(1ULL);
}

const hammer_on_pull_off::default_x_optional &
hammer_on_pull_off::default_x() const {
  return this->default_x_;
}

hammer_on_pull_off::default_x_optional &hammer_on_pull_off::default_x() {
  return this->default_x_;
}

void hammer_on_pull_off::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void hammer_on_pull_off::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void hammer_on_pull_off::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const hammer_on_pull_off::default_y_optional &
hammer_on_pull_off::default_y() const {
  return this->default_y_;
}

hammer_on_pull_off::default_y_optional &hammer_on_pull_off::default_y() {
  return this->default_y_;
}

void hammer_on_pull_off::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void hammer_on_pull_off::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void hammer_on_pull_off::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const hammer_on_pull_off::relative_x_optional &
hammer_on_pull_off::relative_x() const {
  return this->relative_x_;
}

hammer_on_pull_off::relative_x_optional &hammer_on_pull_off::relative_x() {
  return this->relative_x_;
}

void hammer_on_pull_off::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void hammer_on_pull_off::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void hammer_on_pull_off::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const hammer_on_pull_off::relative_y_optional &
hammer_on_pull_off::relative_y() const {
  return this->relative_y_;
}

hammer_on_pull_off::relative_y_optional &hammer_on_pull_off::relative_y() {
  return this->relative_y_;
}

void hammer_on_pull_off::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void hammer_on_pull_off::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void hammer_on_pull_off::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const hammer_on_pull_off::font_family_optional &
hammer_on_pull_off::font_family() const {
  return this->font_family_;
}

hammer_on_pull_off::font_family_optional &hammer_on_pull_off::font_family() {
  return this->font_family_;
}

void hammer_on_pull_off::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void hammer_on_pull_off::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void hammer_on_pull_off::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const hammer_on_pull_off::font_style_optional &
hammer_on_pull_off::font_style() const {
  return this->font_style_;
}

hammer_on_pull_off::font_style_optional &hammer_on_pull_off::font_style() {
  return this->font_style_;
}

void hammer_on_pull_off::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void hammer_on_pull_off::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void hammer_on_pull_off::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const hammer_on_pull_off::font_size_optional &
hammer_on_pull_off::font_size() const {
  return this->font_size_;
}

hammer_on_pull_off::font_size_optional &hammer_on_pull_off::font_size() {
  return this->font_size_;
}

void hammer_on_pull_off::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void hammer_on_pull_off::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void hammer_on_pull_off::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const hammer_on_pull_off::font_weight_optional &
hammer_on_pull_off::font_weight() const {
  return this->font_weight_;
}

hammer_on_pull_off::font_weight_optional &hammer_on_pull_off::font_weight() {
  return this->font_weight_;
}

void hammer_on_pull_off::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void hammer_on_pull_off::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void hammer_on_pull_off::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const hammer_on_pull_off::color_optional &hammer_on_pull_off::color() const {
  return this->color_;
}

hammer_on_pull_off::color_optional &hammer_on_pull_off::color() {
  return this->color_;
}

void hammer_on_pull_off::color(const color_type &x) { this->color_.set(x); }

void hammer_on_pull_off::color(const color_optional &x) { this->color_ = x; }

void hammer_on_pull_off::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const hammer_on_pull_off::placement_optional &
hammer_on_pull_off::placement() const {
  return this->placement_;
}

hammer_on_pull_off::placement_optional &hammer_on_pull_off::placement() {
  return this->placement_;
}

void hammer_on_pull_off::placement(const placement_type &x) {
  this->placement_.set(x);
}

void hammer_on_pull_off::placement(const placement_optional &x) {
  this->placement_ = x;
}

void hammer_on_pull_off::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// handbell
//

const handbell::default_x_optional &handbell::default_x() const {
  return this->default_x_;
}

handbell::default_x_optional &handbell::default_x() { return this->default_x_; }

void handbell::default_x(const default_x_type &x) { this->default_x_.set(x); }

void handbell::default_x(const default_x_optional &x) { this->default_x_ = x; }

void handbell::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const handbell::default_y_optional &handbell::default_y() const {
  return this->default_y_;
}

handbell::default_y_optional &handbell::default_y() { return this->default_y_; }

void handbell::default_y(const default_y_type &x) { this->default_y_.set(x); }

void handbell::default_y(const default_y_optional &x) { this->default_y_ = x; }

void handbell::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const handbell::relative_x_optional &handbell::relative_x() const {
  return this->relative_x_;
}

handbell::relative_x_optional &handbell::relative_x() {
  return this->relative_x_;
}

void handbell::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void handbell::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void handbell::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const handbell::relative_y_optional &handbell::relative_y() const {
  return this->relative_y_;
}

handbell::relative_y_optional &handbell::relative_y() {
  return this->relative_y_;
}

void handbell::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void handbell::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void handbell::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const handbell::font_family_optional &handbell::font_family() const {
  return this->font_family_;
}

handbell::font_family_optional &handbell::font_family() {
  return this->font_family_;
}

void handbell::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void handbell::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void handbell::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const handbell::font_style_optional &handbell::font_style() const {
  return this->font_style_;
}

handbell::font_style_optional &handbell::font_style() {
  return this->font_style_;
}

void handbell::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void handbell::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void handbell::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const handbell::font_size_optional &handbell::font_size() const {
  return this->font_size_;
}

handbell::font_size_optional &handbell::font_size() { return this->font_size_; }

void handbell::font_size(const font_size_type &x) { this->font_size_.set(x); }

void handbell::font_size(const font_size_optional &x) { this->font_size_ = x; }

void handbell::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const handbell::font_weight_optional &handbell::font_weight() const {
  return this->font_weight_;
}

handbell::font_weight_optional &handbell::font_weight() {
  return this->font_weight_;
}

void handbell::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void handbell::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void handbell::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const handbell::color_optional &handbell::color() const { return this->color_; }

handbell::color_optional &handbell::color() { return this->color_; }

void handbell::color(const color_type &x) { this->color_.set(x); }

void handbell::color(const color_optional &x) { this->color_ = x; }

void handbell::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const handbell::placement_optional &handbell::placement() const {
  return this->placement_;
}

handbell::placement_optional &handbell::placement() { return this->placement_; }

void handbell::placement(const placement_type &x) { this->placement_.set(x); }

void handbell::placement(const placement_optional &x) { this->placement_ = x; }

void handbell::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// harmonic
//

const harmonic::natural_optional &harmonic::natural() const {
  return this->natural_;
}

harmonic::natural_optional &harmonic::natural() { return this->natural_; }

void harmonic::natural(const natural_type &x) { this->natural_.set(x); }

void harmonic::natural(const natural_optional &x) { this->natural_ = x; }

void harmonic::natural(::std::unique_ptr<natural_type> x) {
  this->natural_.set(std::move(x));
}

const harmonic::artificial_optional &harmonic::artificial() const {
  return this->artificial_;
}

harmonic::artificial_optional &harmonic::artificial() {
  return this->artificial_;
}

void harmonic::artificial(const artificial_type &x) {
  this->artificial_.set(x);
}

void harmonic::artificial(const artificial_optional &x) {
  this->artificial_ = x;
}

void harmonic::artificial(::std::unique_ptr<artificial_type> x) {
  this->artificial_.set(std::move(x));
}

const harmonic::base_pitch_optional &harmonic::base_pitch() const {
  return this->base_pitch_;
}

harmonic::base_pitch_optional &harmonic::base_pitch() {
  return this->base_pitch_;
}

void harmonic::base_pitch(const base_pitch_type &x) {
  this->base_pitch_.set(x);
}

void harmonic::base_pitch(const base_pitch_optional &x) {
  this->base_pitch_ = x;
}

void harmonic::base_pitch(::std::unique_ptr<base_pitch_type> x) {
  this->base_pitch_.set(std::move(x));
}

const harmonic::touching_pitch_optional &harmonic::touching_pitch() const {
  return this->touching_pitch_;
}

harmonic::touching_pitch_optional &harmonic::touching_pitch() {
  return this->touching_pitch_;
}

void harmonic::touching_pitch(const touching_pitch_type &x) {
  this->touching_pitch_.set(x);
}

void harmonic::touching_pitch(const touching_pitch_optional &x) {
  this->touching_pitch_ = x;
}

void harmonic::touching_pitch(::std::unique_ptr<touching_pitch_type> x) {
  this->touching_pitch_.set(std::move(x));
}

const harmonic::sounding_pitch_optional &harmonic::sounding_pitch() const {
  return this->sounding_pitch_;
}

harmonic::sounding_pitch_optional &harmonic::sounding_pitch() {
  return this->sounding_pitch_;
}

void harmonic::sounding_pitch(const sounding_pitch_type &x) {
  this->sounding_pitch_.set(x);
}

void harmonic::sounding_pitch(const sounding_pitch_optional &x) {
  this->sounding_pitch_ = x;
}

void harmonic::sounding_pitch(::std::unique_ptr<sounding_pitch_type> x) {
  this->sounding_pitch_.set(std::move(x));
}

const harmonic::print_object_optional &harmonic::print_object() const {
  return this->print_object_;
}

harmonic::print_object_optional &harmonic::print_object() {
  return this->print_object_;
}

void harmonic::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void harmonic::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void harmonic::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const harmonic::default_x_optional &harmonic::default_x() const {
  return this->default_x_;
}

harmonic::default_x_optional &harmonic::default_x() { return this->default_x_; }

void harmonic::default_x(const default_x_type &x) { this->default_x_.set(x); }

void harmonic::default_x(const default_x_optional &x) { this->default_x_ = x; }

void harmonic::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const harmonic::default_y_optional &harmonic::default_y() const {
  return this->default_y_;
}

harmonic::default_y_optional &harmonic::default_y() { return this->default_y_; }

void harmonic::default_y(const default_y_type &x) { this->default_y_.set(x); }

void harmonic::default_y(const default_y_optional &x) { this->default_y_ = x; }

void harmonic::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const harmonic::relative_x_optional &harmonic::relative_x() const {
  return this->relative_x_;
}

harmonic::relative_x_optional &harmonic::relative_x() {
  return this->relative_x_;
}

void harmonic::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void harmonic::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void harmonic::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const harmonic::relative_y_optional &harmonic::relative_y() const {
  return this->relative_y_;
}

harmonic::relative_y_optional &harmonic::relative_y() {
  return this->relative_y_;
}

void harmonic::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void harmonic::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void harmonic::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const harmonic::font_family_optional &harmonic::font_family() const {
  return this->font_family_;
}

harmonic::font_family_optional &harmonic::font_family() {
  return this->font_family_;
}

void harmonic::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void harmonic::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void harmonic::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const harmonic::font_style_optional &harmonic::font_style() const {
  return this->font_style_;
}

harmonic::font_style_optional &harmonic::font_style() {
  return this->font_style_;
}

void harmonic::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void harmonic::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void harmonic::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const harmonic::font_size_optional &harmonic::font_size() const {
  return this->font_size_;
}

harmonic::font_size_optional &harmonic::font_size() { return this->font_size_; }

void harmonic::font_size(const font_size_type &x) { this->font_size_.set(x); }

void harmonic::font_size(const font_size_optional &x) { this->font_size_ = x; }

void harmonic::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const harmonic::font_weight_optional &harmonic::font_weight() const {
  return this->font_weight_;
}

harmonic::font_weight_optional &harmonic::font_weight() {
  return this->font_weight_;
}

void harmonic::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void harmonic::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void harmonic::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const harmonic::color_optional &harmonic::color() const { return this->color_; }

harmonic::color_optional &harmonic::color() { return this->color_; }

void harmonic::color(const color_type &x) { this->color_.set(x); }

void harmonic::color(const color_optional &x) { this->color_ = x; }

void harmonic::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const harmonic::placement_optional &harmonic::placement() const {
  return this->placement_;
}

harmonic::placement_optional &harmonic::placement() { return this->placement_; }

void harmonic::placement(const placement_type &x) { this->placement_.set(x); }

void harmonic::placement(const placement_optional &x) { this->placement_ = x; }

void harmonic::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// heel_toe
//

const heel_toe::substitution_optional &heel_toe::substitution() const {
  return this->substitution_;
}

heel_toe::substitution_optional &heel_toe::substitution() {
  return this->substitution_;
}

void heel_toe::substitution(const substitution_type &x) {
  this->substitution_.set(x);
}

void heel_toe::substitution(const substitution_optional &x) {
  this->substitution_ = x;
}

void heel_toe::substitution(::std::unique_ptr<substitution_type> x) {
  this->substitution_.set(std::move(x));
}

// hole
//

const hole::hole_type_optional &hole::hole_type() const {
  return this->hole_type_;
}

hole::hole_type_optional &hole::hole_type() { return this->hole_type_; }

void hole::hole_type(const hole_type_type &x) { this->hole_type_.set(x); }

void hole::hole_type(const hole_type_optional &x) { this->hole_type_ = x; }

void hole::hole_type(::std::unique_ptr<hole_type_type> x) {
  this->hole_type_.set(std::move(x));
}

const hole::hole_closed_type &hole::hole_closed() const {
  return this->hole_closed_.get();
}

hole::hole_closed_type &hole::hole_closed() { return this->hole_closed_.get(); }

void hole::hole_closed(const hole_closed_type &x) { this->hole_closed_.set(x); }

void hole::hole_closed(::std::unique_ptr<hole_closed_type> x) {
  this->hole_closed_.set(std::move(x));
}

const hole::hole_shape_optional &hole::hole_shape() const {
  return this->hole_shape_;
}

hole::hole_shape_optional &hole::hole_shape() { return this->hole_shape_; }

void hole::hole_shape(const hole_shape_type &x) { this->hole_shape_.set(x); }

void hole::hole_shape(const hole_shape_optional &x) { this->hole_shape_ = x; }

void hole::hole_shape(::std::unique_ptr<hole_shape_type> x) {
  this->hole_shape_.set(std::move(x));
}

const hole::default_x_optional &hole::default_x() const {
  return this->default_x_;
}

hole::default_x_optional &hole::default_x() { return this->default_x_; }

void hole::default_x(const default_x_type &x) { this->default_x_.set(x); }

void hole::default_x(const default_x_optional &x) { this->default_x_ = x; }

void hole::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const hole::default_y_optional &hole::default_y() const {
  return this->default_y_;
}

hole::default_y_optional &hole::default_y() { return this->default_y_; }

void hole::default_y(const default_y_type &x) { this->default_y_.set(x); }

void hole::default_y(const default_y_optional &x) { this->default_y_ = x; }

void hole::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const hole::relative_x_optional &hole::relative_x() const {
  return this->relative_x_;
}

hole::relative_x_optional &hole::relative_x() { return this->relative_x_; }

void hole::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void hole::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void hole::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const hole::relative_y_optional &hole::relative_y() const {
  return this->relative_y_;
}

hole::relative_y_optional &hole::relative_y() { return this->relative_y_; }

void hole::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void hole::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void hole::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const hole::font_family_optional &hole::font_family() const {
  return this->font_family_;
}

hole::font_family_optional &hole::font_family() { return this->font_family_; }

void hole::font_family(const font_family_type &x) { this->font_family_.set(x); }

void hole::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void hole::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const hole::font_style_optional &hole::font_style() const {
  return this->font_style_;
}

hole::font_style_optional &hole::font_style() { return this->font_style_; }

void hole::font_style(const font_style_type &x) { this->font_style_.set(x); }

void hole::font_style(const font_style_optional &x) { this->font_style_ = x; }

void hole::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const hole::font_size_optional &hole::font_size() const {
  return this->font_size_;
}

hole::font_size_optional &hole::font_size() { return this->font_size_; }

void hole::font_size(const font_size_type &x) { this->font_size_.set(x); }

void hole::font_size(const font_size_optional &x) { this->font_size_ = x; }

void hole::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const hole::font_weight_optional &hole::font_weight() const {
  return this->font_weight_;
}

hole::font_weight_optional &hole::font_weight() { return this->font_weight_; }

void hole::font_weight(const font_weight_type &x) { this->font_weight_.set(x); }

void hole::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void hole::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const hole::color_optional &hole::color() const { return this->color_; }

hole::color_optional &hole::color() { return this->color_; }

void hole::color(const color_type &x) { this->color_.set(x); }

void hole::color(const color_optional &x) { this->color_ = x; }

void hole::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const hole::placement_optional &hole::placement() const {
  return this->placement_;
}

hole::placement_optional &hole::placement() { return this->placement_; }

void hole::placement(const placement_type &x) { this->placement_.set(x); }

void hole::placement(const placement_optional &x) { this->placement_ = x; }

void hole::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// hole_closed
//

const hole_closed::location_optional &hole_closed::location() const {
  return this->location_;
}

hole_closed::location_optional &hole_closed::location() {
  return this->location_;
}

void hole_closed::location(const location_type &x) { this->location_.set(x); }

void hole_closed::location(const location_optional &x) { this->location_ = x; }

void hole_closed::location(::std::unique_ptr<location_type> x) {
  this->location_.set(std::move(x));
}

// instrument
//

const instrument::id_type &instrument::id() const { return this->id_.get(); }

instrument::id_type &instrument::id() { return this->id_.get(); }

void instrument::id(const id_type &x) { this->id_.set(x); }

void instrument::id(::std::unique_ptr<id_type> x) {
  this->id_.set(std::move(x));
}

// lyric
//

const lyric::syllabic_sequence &lyric::syllabic() const {
  return this->syllabic_;
}

lyric::syllabic_sequence &lyric::syllabic() { return this->syllabic_; }

void lyric::syllabic(const syllabic_sequence &s) { this->syllabic_ = s; }

const lyric::text_sequence &lyric::text() const { return this->text_; }

lyric::text_sequence &lyric::text() { return this->text_; }

void lyric::text(const text_sequence &s) { this->text_ = s; }

const lyric::elision_sequence &lyric::elision() const { return this->elision_; }

lyric::elision_sequence &lyric::elision() { return this->elision_; }

void lyric::elision(const elision_sequence &s) { this->elision_ = s; }

const lyric::extend_optional &lyric::extend() const { return this->extend_; }

lyric::extend_optional &lyric::extend() { return this->extend_; }

void lyric::extend(const extend_type &x) { this->extend_.set(x); }

void lyric::extend(const extend_optional &x) { this->extend_ = x; }

void lyric::extend(::std::unique_ptr<extend_type> x) {
  this->extend_.set(std::move(x));
}

const lyric::laughing_optional &lyric::laughing() const {
  return this->laughing_;
}

lyric::laughing_optional &lyric::laughing() { return this->laughing_; }

void lyric::laughing(const laughing_type &x) { this->laughing_.set(x); }

void lyric::laughing(const laughing_optional &x) { this->laughing_ = x; }

void lyric::laughing(::std::unique_ptr<laughing_type> x) {
  this->laughing_.set(std::move(x));
}

const lyric::humming_optional &lyric::humming() const { return this->humming_; }

lyric::humming_optional &lyric::humming() { return this->humming_; }

void lyric::humming(const humming_type &x) { this->humming_.set(x); }

void lyric::humming(const humming_optional &x) { this->humming_ = x; }

void lyric::humming(::std::unique_ptr<humming_type> x) {
  this->humming_.set(std::move(x));
}

const lyric::end_line_optional &lyric::end_line() const {
  return this->end_line_;
}

lyric::end_line_optional &lyric::end_line() { return this->end_line_; }

void lyric::end_line(const end_line_type &x) { this->end_line_.set(x); }

void lyric::end_line(const end_line_optional &x) { this->end_line_ = x; }

void lyric::end_line(::std::unique_ptr<end_line_type> x) {
  this->end_line_.set(std::move(x));
}

const lyric::end_paragraph_optional &lyric::end_paragraph() const {
  return this->end_paragraph_;
}

lyric::end_paragraph_optional &lyric::end_paragraph() {
  return this->end_paragraph_;
}

void lyric::end_paragraph(const end_paragraph_type &x) {
  this->end_paragraph_.set(x);
}

void lyric::end_paragraph(const end_paragraph_optional &x) {
  this->end_paragraph_ = x;
}

void lyric::end_paragraph(::std::unique_ptr<end_paragraph_type> x) {
  this->end_paragraph_.set(std::move(x));
}

const lyric::footnote_optional &lyric::footnote() const {
  return this->footnote_;
}

lyric::footnote_optional &lyric::footnote() { return this->footnote_; }

void lyric::footnote(const footnote_type &x) { this->footnote_.set(x); }

void lyric::footnote(const footnote_optional &x) { this->footnote_ = x; }

void lyric::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const lyric::level_optional &lyric::level() const { return this->level_; }

lyric::level_optional &lyric::level() { return this->level_; }

void lyric::level(const level_type &x) { this->level_.set(x); }

void lyric::level(const level_optional &x) { this->level_ = x; }

void lyric::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const lyric::number_optional &lyric::number() const { return this->number_; }

lyric::number_optional &lyric::number() { return this->number_; }

void lyric::number(const number_type &x) { this->number_.set(x); }

void lyric::number(const number_optional &x) { this->number_ = x; }

void lyric::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const lyric::name_optional &lyric::name() const { return this->name_; }

lyric::name_optional &lyric::name() { return this->name_; }

void lyric::name(const name_type &x) { this->name_.set(x); }

void lyric::name(const name_optional &x) { this->name_ = x; }

void lyric::name(::std::unique_ptr<name_type> x) {
  this->name_.set(std::move(x));
}

const lyric::justify_optional &lyric::justify() const { return this->justify_; }

lyric::justify_optional &lyric::justify() { return this->justify_; }

void lyric::justify(const justify_type &x) { this->justify_.set(x); }

void lyric::justify(const justify_optional &x) { this->justify_ = x; }

void lyric::justify(::std::unique_ptr<justify_type> x) {
  this->justify_.set(std::move(x));
}

const lyric::default_x_optional &lyric::default_x() const {
  return this->default_x_;
}

lyric::default_x_optional &lyric::default_x() { return this->default_x_; }

void lyric::default_x(const default_x_type &x) { this->default_x_.set(x); }

void lyric::default_x(const default_x_optional &x) { this->default_x_ = x; }

void lyric::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const lyric::default_y_optional &lyric::default_y() const {
  return this->default_y_;
}

lyric::default_y_optional &lyric::default_y() { return this->default_y_; }

void lyric::default_y(const default_y_type &x) { this->default_y_.set(x); }

void lyric::default_y(const default_y_optional &x) { this->default_y_ = x; }

void lyric::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const lyric::relative_x_optional &lyric::relative_x() const {
  return this->relative_x_;
}

lyric::relative_x_optional &lyric::relative_x() { return this->relative_x_; }

void lyric::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void lyric::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void lyric::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const lyric::relative_y_optional &lyric::relative_y() const {
  return this->relative_y_;
}

lyric::relative_y_optional &lyric::relative_y() { return this->relative_y_; }

void lyric::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void lyric::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void lyric::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const lyric::placement_optional &lyric::placement() const {
  return this->placement_;
}

lyric::placement_optional &lyric::placement() { return this->placement_; }

void lyric::placement(const placement_type &x) { this->placement_.set(x); }

void lyric::placement(const placement_optional &x) { this->placement_ = x; }

void lyric::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const lyric::color_optional &lyric::color() const { return this->color_; }

lyric::color_optional &lyric::color() { return this->color_; }

void lyric::color(const color_type &x) { this->color_.set(x); }

void lyric::color(const color_optional &x) { this->color_ = x; }

void lyric::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const lyric::print_object_optional &lyric::print_object() const {
  return this->print_object_;
}

lyric::print_object_optional &lyric::print_object() {
  return this->print_object_;
}

void lyric::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void lyric::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void lyric::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

// mordent
//

const mordent::long_optional &mordent::long_() const { return this->long__; }

mordent::long_optional &mordent::long_() { return this->long__; }

void mordent::long_(const long_type &x) { this->long__.set(x); }

void mordent::long_(const long_optional &x) { this->long__ = x; }

void mordent::long_(::std::unique_ptr<long_type> x) {
  this->long__.set(std::move(x));
}

const mordent::approach_optional &mordent::approach() const {
  return this->approach_;
}

mordent::approach_optional &mordent::approach() { return this->approach_; }

void mordent::approach(const approach_type &x) { this->approach_.set(x); }

void mordent::approach(const approach_optional &x) { this->approach_ = x; }

void mordent::approach(::std::unique_ptr<approach_type> x) {
  this->approach_.set(std::move(x));
}

const mordent::departure_optional &mordent::departure() const {
  return this->departure_;
}

mordent::departure_optional &mordent::departure() { return this->departure_; }

void mordent::departure(const departure_type &x) { this->departure_.set(x); }

void mordent::departure(const departure_optional &x) { this->departure_ = x; }

void mordent::departure(::std::unique_ptr<departure_type> x) {
  this->departure_.set(std::move(x));
}

// non_arpeggiate
//

const non_arpeggiate::type_type &non_arpeggiate::type() const {
  return this->type_.get();
}

non_arpeggiate::type_type &non_arpeggiate::type() { return this->type_.get(); }

void non_arpeggiate::type(const type_type &x) { this->type_.set(x); }

void non_arpeggiate::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const non_arpeggiate::number_optional &non_arpeggiate::number() const {
  return this->number_;
}

non_arpeggiate::number_optional &non_arpeggiate::number() {
  return this->number_;
}

void non_arpeggiate::number(const number_type &x) { this->number_.set(x); }

void non_arpeggiate::number(const number_optional &x) { this->number_ = x; }

void non_arpeggiate::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const non_arpeggiate::default_x_optional &non_arpeggiate::default_x() const {
  return this->default_x_;
}

non_arpeggiate::default_x_optional &non_arpeggiate::default_x() {
  return this->default_x_;
}

void non_arpeggiate::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void non_arpeggiate::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void non_arpeggiate::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const non_arpeggiate::default_y_optional &non_arpeggiate::default_y() const {
  return this->default_y_;
}

non_arpeggiate::default_y_optional &non_arpeggiate::default_y() {
  return this->default_y_;
}

void non_arpeggiate::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void non_arpeggiate::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void non_arpeggiate::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const non_arpeggiate::relative_x_optional &non_arpeggiate::relative_x() const {
  return this->relative_x_;
}

non_arpeggiate::relative_x_optional &non_arpeggiate::relative_x() {
  return this->relative_x_;
}

void non_arpeggiate::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void non_arpeggiate::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void non_arpeggiate::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const non_arpeggiate::relative_y_optional &non_arpeggiate::relative_y() const {
  return this->relative_y_;
}

non_arpeggiate::relative_y_optional &non_arpeggiate::relative_y() {
  return this->relative_y_;
}

void non_arpeggiate::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void non_arpeggiate::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void non_arpeggiate::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const non_arpeggiate::placement_optional &non_arpeggiate::placement() const {
  return this->placement_;
}

non_arpeggiate::placement_optional &non_arpeggiate::placement() {
  return this->placement_;
}

void non_arpeggiate::placement(const placement_type &x) {
  this->placement_.set(x);
}

void non_arpeggiate::placement(const placement_optional &x) {
  this->placement_ = x;
}

void non_arpeggiate::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const non_arpeggiate::color_optional &non_arpeggiate::color() const {
  return this->color_;
}

non_arpeggiate::color_optional &non_arpeggiate::color() { return this->color_; }

void non_arpeggiate::color(const color_type &x) { this->color_.set(x); }

void non_arpeggiate::color(const color_optional &x) { this->color_ = x; }

void non_arpeggiate::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// notations
//

const notations::footnote_optional &notations::footnote() const {
  return this->footnote_;
}

notations::footnote_optional &notations::footnote() { return this->footnote_; }

void notations::footnote(const footnote_type &x) { this->footnote_.set(x); }

void notations::footnote(const footnote_optional &x) { this->footnote_ = x; }

void notations::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const notations::level_optional &notations::level() const {
  return this->level_;
}

notations::level_optional &notations::level() { return this->level_; }

void notations::level(const level_type &x) { this->level_.set(x); }

void notations::level(const level_optional &x) { this->level_ = x; }

void notations::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const notations::tied_sequence &notations::tied() const { return this->tied_; }

notations::tied_sequence &notations::tied() { return this->tied_; }

void notations::tied(const tied_sequence &s) { this->tied_ = s; }

const notations::slur_sequence &notations::slur() const { return this->slur_; }

notations::slur_sequence &notations::slur() { return this->slur_; }

void notations::slur(const slur_sequence &s) { this->slur_ = s; }

const notations::tuplet_sequence &notations::tuplet() const {
  return this->tuplet_;
}

notations::tuplet_sequence &notations::tuplet() { return this->tuplet_; }

void notations::tuplet(const tuplet_sequence &s) { this->tuplet_ = s; }

const notations::glissando_sequence &notations::glissando() const {
  return this->glissando_;
}

notations::glissando_sequence &notations::glissando() {
  return this->glissando_;
}

void notations::glissando(const glissando_sequence &s) { this->glissando_ = s; }

const notations::slide_sequence &notations::slide() const {
  return this->slide_;
}

notations::slide_sequence &notations::slide() { return this->slide_; }

void notations::slide(const slide_sequence &s) { this->slide_ = s; }

const notations::ornaments_sequence &notations::ornaments() const {
  return this->ornaments_;
}

notations::ornaments_sequence &notations::ornaments() {
  return this->ornaments_;
}

void notations::ornaments(const ornaments_sequence &s) { this->ornaments_ = s; }

const notations::technical_sequence &notations::technical() const {
  return this->technical_;
}

notations::technical_sequence &notations::technical() {
  return this->technical_;
}

void notations::technical(const technical_sequence &s) { this->technical_ = s; }

const notations::articulations_sequence &notations::articulations() const {
  return this->articulations_;
}

notations::articulations_sequence &notations::articulations() {
  return this->articulations_;
}

void notations::articulations(const articulations_sequence &s) {
  this->articulations_ = s;
}

const notations::dynamics_sequence &notations::dynamics() const {
  return this->dynamics_;
}

notations::dynamics_sequence &notations::dynamics() { return this->dynamics_; }

void notations::dynamics(const dynamics_sequence &s) { this->dynamics_ = s; }

const notations::fermata_sequence &notations::fermata() const {
  return this->fermata_;
}

notations::fermata_sequence &notations::fermata() { return this->fermata_; }

void notations::fermata(const fermata_sequence &s) { this->fermata_ = s; }

const notations::arpeggiate_sequence &notations::arpeggiate() const {
  return this->arpeggiate_;
}

notations::arpeggiate_sequence &notations::arpeggiate() {
  return this->arpeggiate_;
}

void notations::arpeggiate(const arpeggiate_sequence &s) {
  this->arpeggiate_ = s;
}

const notations::non_arpeggiate_sequence &notations::non_arpeggiate() const {
  return this->non_arpeggiate_;
}

notations::non_arpeggiate_sequence &notations::non_arpeggiate() {
  return this->non_arpeggiate_;
}

void notations::non_arpeggiate(const non_arpeggiate_sequence &s) {
  this->non_arpeggiate_ = s;
}

const notations::accidental_mark_sequence &notations::accidental_mark() const {
  return this->accidental_mark_;
}

notations::accidental_mark_sequence &notations::accidental_mark() {
  return this->accidental_mark_;
}

void notations::accidental_mark(const accidental_mark_sequence &s) {
  this->accidental_mark_ = s;
}

const notations::other_notation_sequence &notations::other_notation() const {
  return this->other_notation_;
}

notations::other_notation_sequence &notations::other_notation() {
  return this->other_notation_;
}

void notations::other_notation(const other_notation_sequence &s) {
  this->other_notation_ = s;
}

const notations::print_object_optional &notations::print_object() const {
  return this->print_object_;
}

notations::print_object_optional &notations::print_object() {
  return this->print_object_;
}

void notations::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void notations::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void notations::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

// note
//

const note::grace_optional &note::grace() const { return this->grace_; }

note::grace_optional &note::grace() { return this->grace_; }

void note::grace(const grace_type &x) { this->grace_.set(x); }

void note::grace(const grace_optional &x) { this->grace_ = x; }

void note::grace(::std::unique_ptr<grace_type> x) {
  this->grace_.set(std::move(x));
}

const note::chord_optional &note::chord() const { return this->chord_; }

note::chord_optional &note::chord() { return this->chord_; }

void note::chord(const chord_type &x) { this->chord_.set(x); }

void note::chord(const chord_optional &x) { this->chord_ = x; }

void note::chord(::std::unique_ptr<chord_type> x) {
  this->chord_.set(std::move(x));
}

const note::pitch_optional &note::pitch() const { return this->pitch_; }

note::pitch_optional &note::pitch() { return this->pitch_; }

void note::pitch(const pitch_type &x) { this->pitch_.set(x); }

void note::pitch(const pitch_optional &x) { this->pitch_ = x; }

void note::pitch(::std::unique_ptr<pitch_type> x) {
  this->pitch_.set(std::move(x));
}

const note::unpitched_optional &note::unpitched() const {
  return this->unpitched_;
}

note::unpitched_optional &note::unpitched() { return this->unpitched_; }

void note::unpitched(const unpitched_type &x) { this->unpitched_.set(x); }

void note::unpitched(const unpitched_optional &x) { this->unpitched_ = x; }

void note::unpitched(::std::unique_ptr<unpitched_type> x) {
  this->unpitched_.set(std::move(x));
}

const note::rest_optional &note::rest() const { return this->rest_; }

note::rest_optional &note::rest() { return this->rest_; }

void note::rest(const rest_type &x) { this->rest_.set(x); }

void note::rest(const rest_optional &x) { this->rest_ = x; }

void note::rest(::std::unique_ptr<rest_type> x) {
  this->rest_.set(std::move(x));
}

const note::tie_sequence &note::tie() const { return this->tie_; }

note::tie_sequence &note::tie() { return this->tie_; }

void note::tie(const tie_sequence &s) { this->tie_ = s; }

const note::cue_optional &note::cue() const { return this->cue_; }

note::cue_optional &note::cue() { return this->cue_; }

void note::cue(const cue_type &x) { this->cue_.set(x); }

void note::cue(const cue_optional &x) { this->cue_ = x; }

void note::cue(::std::unique_ptr<cue_type> x) { this->cue_.set(std::move(x)); }

const note::duration_optional &note::duration() const {
  return this->duration_;
}

note::duration_optional &note::duration() { return this->duration_; }

void note::duration(const duration_type &x) { this->duration_.set(x); }

void note::duration(const duration_optional &x) { this->duration_ = x; }

void note::duration(::std::unique_ptr<duration_type> x) {
  this->duration_.set(std::move(x));
}

const note::instrument_optional &note::instrument() const {
  return this->instrument_;
}

note::instrument_optional &note::instrument() { return this->instrument_; }

void note::instrument(const instrument_type &x) { this->instrument_.set(x); }

void note::instrument(const instrument_optional &x) { this->instrument_ = x; }

void note::instrument(::std::unique_ptr<instrument_type> x) {
  this->instrument_.set(std::move(x));
}

const note::footnote_optional &note::footnote() const {
  return this->footnote_;
}

note::footnote_optional &note::footnote() { return this->footnote_; }

void note::footnote(const footnote_type &x) { this->footnote_.set(x); }

void note::footnote(const footnote_optional &x) { this->footnote_ = x; }

void note::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const note::level_optional &note::level() const { return this->level_; }

note::level_optional &note::level() { return this->level_; }

void note::level(const level_type &x) { this->level_.set(x); }

void note::level(const level_optional &x) { this->level_ = x; }

void note::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const note::voice_optional &note::voice() const { return this->voice_; }

note::voice_optional &note::voice() { return this->voice_; }

void note::voice(const voice_type &x) { this->voice_.set(x); }

void note::voice(const voice_optional &x) { this->voice_ = x; }

void note::voice(::std::unique_ptr<voice_type> x) {
  this->voice_.set(std::move(x));
}

const note::type_optional &note::type() const { return this->type_; }

note::type_optional &note::type() { return this->type_; }

void note::type(const type_type &x) { this->type_.set(x); }

void note::type(const type_optional &x) { this->type_ = x; }

void note::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const note::dot_sequence &note::dot() const { return this->dot_; }

note::dot_sequence &note::dot() { return this->dot_; }

void note::dot(const dot_sequence &s) { this->dot_ = s; }

const note::accidental_optional &note::accidental() const {
  return this->accidental_;
}

note::accidental_optional &note::accidental() { return this->accidental_; }

void note::accidental(const accidental_type &x) { this->accidental_.set(x); }

void note::accidental(const accidental_optional &x) { this->accidental_ = x; }

void note::accidental(::std::unique_ptr<accidental_type> x) {
  this->accidental_.set(std::move(x));
}

const note::time_modification_optional &note::time_modification() const {
  return this->time_modification_;
}

note::time_modification_optional &note::time_modification() {
  return this->time_modification_;
}

void note::time_modification(const time_modification_type &x) {
  this->time_modification_.set(x);
}

void note::time_modification(const time_modification_optional &x) {
  this->time_modification_ = x;
}

void note::time_modification(::std::unique_ptr<time_modification_type> x) {
  this->time_modification_.set(std::move(x));
}

const note::stem_optional &note::stem() const { return this->stem_; }

note::stem_optional &note::stem() { return this->stem_; }

void note::stem(const stem_type &x) { this->stem_.set(x); }

void note::stem(const stem_optional &x) { this->stem_ = x; }

void note::stem(::std::unique_ptr<stem_type> x) {
  this->stem_.set(std::move(x));
}

const note::notehead_optional &note::notehead() const {
  return this->notehead_;
}

note::notehead_optional &note::notehead() { return this->notehead_; }

void note::notehead(const notehead_type &x) { this->notehead_.set(x); }

void note::notehead(const notehead_optional &x) { this->notehead_ = x; }

void note::notehead(::std::unique_ptr<notehead_type> x) {
  this->notehead_.set(std::move(x));
}

const note::notehead_text_optional &note::notehead_text() const {
  return this->notehead_text_;
}

note::notehead_text_optional &note::notehead_text() {
  return this->notehead_text_;
}

void note::notehead_text(const notehead_text_type &x) {
  this->notehead_text_.set(x);
}

void note::notehead_text(const notehead_text_optional &x) {
  this->notehead_text_ = x;
}

void note::notehead_text(::std::unique_ptr<notehead_text_type> x) {
  this->notehead_text_.set(std::move(x));
}

const note::staff_optional &note::staff() const { return this->staff_; }

note::staff_optional &note::staff() { return this->staff_; }

void note::staff(const staff_type &x) { this->staff_.set(x); }

void note::staff(const staff_optional &x) { this->staff_ = x; }

const note::beam_sequence &note::beam() const { return this->beam_; }

note::beam_sequence &note::beam() { return this->beam_; }

void note::beam(const beam_sequence &s) { this->beam_ = s; }

const note::notations_sequence &note::notations() const {
  return this->notations_;
}

note::notations_sequence &note::notations() { return this->notations_; }

void note::notations(const notations_sequence &s) { this->notations_ = s; }

const note::lyric_sequence &note::lyric() const { return this->lyric_; }

note::lyric_sequence &note::lyric() { return this->lyric_; }

void note::lyric(const lyric_sequence &s) { this->lyric_ = s; }

const note::play_optional &note::play() const { return this->play_; }

note::play_optional &note::play() { return this->play_; }

void note::play(const play_type &x) { this->play_.set(x); }

void note::play(const play_optional &x) { this->play_ = x; }

void note::play(::std::unique_ptr<play_type> x) {
  this->play_.set(std::move(x));
}

const note::default_x_optional &note::default_x() const {
  return this->default_x_;
}

note::default_x_optional &note::default_x() { return this->default_x_; }

void note::default_x(const default_x_type &x) { this->default_x_.set(x); }

void note::default_x(const default_x_optional &x) { this->default_x_ = x; }

void note::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const note::default_y_optional &note::default_y() const {
  return this->default_y_;
}

note::default_y_optional &note::default_y() { return this->default_y_; }

void note::default_y(const default_y_type &x) { this->default_y_.set(x); }

void note::default_y(const default_y_optional &x) { this->default_y_ = x; }

void note::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const note::relative_x_optional &note::relative_x() const {
  return this->relative_x_;
}

note::relative_x_optional &note::relative_x() { return this->relative_x_; }

void note::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void note::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void note::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const note::relative_y_optional &note::relative_y() const {
  return this->relative_y_;
}

note::relative_y_optional &note::relative_y() { return this->relative_y_; }

void note::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void note::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void note::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const note::font_family_optional &note::font_family() const {
  return this->font_family_;
}

note::font_family_optional &note::font_family() { return this->font_family_; }

void note::font_family(const font_family_type &x) { this->font_family_.set(x); }

void note::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void note::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const note::font_style_optional &note::font_style() const {
  return this->font_style_;
}

note::font_style_optional &note::font_style() { return this->font_style_; }

void note::font_style(const font_style_type &x) { this->font_style_.set(x); }

void note::font_style(const font_style_optional &x) { this->font_style_ = x; }

void note::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const note::font_size_optional &note::font_size() const {
  return this->font_size_;
}

note::font_size_optional &note::font_size() { return this->font_size_; }

void note::font_size(const font_size_type &x) { this->font_size_.set(x); }

void note::font_size(const font_size_optional &x) { this->font_size_ = x; }

void note::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const note::font_weight_optional &note::font_weight() const {
  return this->font_weight_;
}

note::font_weight_optional &note::font_weight() { return this->font_weight_; }

void note::font_weight(const font_weight_type &x) { this->font_weight_.set(x); }

void note::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void note::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const note::color_optional &note::color() const { return this->color_; }

note::color_optional &note::color() { return this->color_; }

void note::color(const color_type &x) { this->color_.set(x); }

void note::color(const color_optional &x) { this->color_ = x; }

void note::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const note::print_object_optional &note::print_object() const {
  return this->print_object_;
}

note::print_object_optional &note::print_object() {
  return this->print_object_;
}

void note::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void note::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void note::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const note::print_dot_optional &note::print_dot() const {
  return this->print_dot_;
}

note::print_dot_optional &note::print_dot() { return this->print_dot_; }

void note::print_dot(const print_dot_type &x) { this->print_dot_.set(x); }

void note::print_dot(const print_dot_optional &x) { this->print_dot_ = x; }

void note::print_dot(::std::unique_ptr<print_dot_type> x) {
  this->print_dot_.set(std::move(x));
}

const note::print_spacing_optional &note::print_spacing() const {
  return this->print_spacing_;
}

note::print_spacing_optional &note::print_spacing() {
  return this->print_spacing_;
}

void note::print_spacing(const print_spacing_type &x) {
  this->print_spacing_.set(x);
}

void note::print_spacing(const print_spacing_optional &x) {
  this->print_spacing_ = x;
}

void note::print_spacing(::std::unique_ptr<print_spacing_type> x) {
  this->print_spacing_.set(std::move(x));
}

const note::print_lyric_optional &note::print_lyric() const {
  return this->print_lyric_;
}

note::print_lyric_optional &note::print_lyric() { return this->print_lyric_; }

void note::print_lyric(const print_lyric_type &x) { this->print_lyric_.set(x); }

void note::print_lyric(const print_lyric_optional &x) {
  this->print_lyric_ = x;
}

void note::print_lyric(::std::unique_ptr<print_lyric_type> x) {
  this->print_lyric_.set(std::move(x));
}

const note::dynamics_optional &note::dynamics() const {
  return this->dynamics_;
}

note::dynamics_optional &note::dynamics() { return this->dynamics_; }

void note::dynamics(const dynamics_type &x) { this->dynamics_.set(x); }

void note::dynamics(const dynamics_optional &x) { this->dynamics_ = x; }

void note::dynamics(::std::unique_ptr<dynamics_type> x) {
  this->dynamics_.set(std::move(x));
}

const note::end_dynamics_optional &note::end_dynamics() const {
  return this->end_dynamics_;
}

note::end_dynamics_optional &note::end_dynamics() {
  return this->end_dynamics_;
}

void note::end_dynamics(const end_dynamics_type &x) {
  this->end_dynamics_.set(x);
}

void note::end_dynamics(const end_dynamics_optional &x) {
  this->end_dynamics_ = x;
}

void note::end_dynamics(::std::unique_ptr<end_dynamics_type> x) {
  this->end_dynamics_.set(std::move(x));
}

const note::attack_optional &note::attack() const { return this->attack_; }

note::attack_optional &note::attack() { return this->attack_; }

void note::attack(const attack_type &x) { this->attack_.set(x); }

void note::attack(const attack_optional &x) { this->attack_ = x; }

void note::attack(::std::unique_ptr<attack_type> x) {
  this->attack_.set(std::move(x));
}

const note::release_optional &note::release() const { return this->release_; }

note::release_optional &note::release() { return this->release_; }

void note::release(const release_type &x) { this->release_.set(x); }

void note::release(const release_optional &x) { this->release_ = x; }

void note::release(::std::unique_ptr<release_type> x) {
  this->release_.set(std::move(x));
}

const note::time_only_optional &note::time_only() const {
  return this->time_only_;
}

note::time_only_optional &note::time_only() { return this->time_only_; }

void note::time_only(const time_only_type &x) { this->time_only_.set(x); }

void note::time_only(const time_only_optional &x) { this->time_only_ = x; }

void note::time_only(::std::unique_ptr<time_only_type> x) {
  this->time_only_.set(std::move(x));
}

const note::pizzicato_optional &note::pizzicato() const {
  return this->pizzicato_;
}

note::pizzicato_optional &note::pizzicato() { return this->pizzicato_; }

void note::pizzicato(const pizzicato_type &x) { this->pizzicato_.set(x); }

void note::pizzicato(const pizzicato_optional &x) { this->pizzicato_ = x; }

void note::pizzicato(::std::unique_ptr<pizzicato_type> x) {
  this->pizzicato_.set(std::move(x));
}

// note_type
//

const note_type::size_optional &note_type::size() const { return this->size_; }

note_type::size_optional &note_type::size() { return this->size_; }

void note_type::size(const size_type &x) { this->size_.set(x); }

void note_type::size(const size_optional &x) { this->size_ = x; }

void note_type::size(::std::unique_ptr<size_type> x) {
  this->size_.set(std::move(x));
}

// notehead
//

const notehead::filled_optional &notehead::filled() const {
  return this->filled_;
}

notehead::filled_optional &notehead::filled() { return this->filled_; }

void notehead::filled(const filled_type &x) { this->filled_.set(x); }

void notehead::filled(const filled_optional &x) { this->filled_ = x; }

void notehead::filled(::std::unique_ptr<filled_type> x) {
  this->filled_.set(std::move(x));
}

const notehead::parentheses_optional &notehead::parentheses() const {
  return this->parentheses_;
}

notehead::parentheses_optional &notehead::parentheses() {
  return this->parentheses_;
}

void notehead::parentheses(const parentheses_type &x) {
  this->parentheses_.set(x);
}

void notehead::parentheses(const parentheses_optional &x) {
  this->parentheses_ = x;
}

void notehead::parentheses(::std::unique_ptr<parentheses_type> x) {
  this->parentheses_.set(std::move(x));
}

const notehead::font_family_optional &notehead::font_family() const {
  return this->font_family_;
}

notehead::font_family_optional &notehead::font_family() {
  return this->font_family_;
}

void notehead::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void notehead::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void notehead::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const notehead::font_style_optional &notehead::font_style() const {
  return this->font_style_;
}

notehead::font_style_optional &notehead::font_style() {
  return this->font_style_;
}

void notehead::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void notehead::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void notehead::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const notehead::font_size_optional &notehead::font_size() const {
  return this->font_size_;
}

notehead::font_size_optional &notehead::font_size() { return this->font_size_; }

void notehead::font_size(const font_size_type &x) { this->font_size_.set(x); }

void notehead::font_size(const font_size_optional &x) { this->font_size_ = x; }

void notehead::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const notehead::font_weight_optional &notehead::font_weight() const {
  return this->font_weight_;
}

notehead::font_weight_optional &notehead::font_weight() {
  return this->font_weight_;
}

void notehead::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void notehead::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void notehead::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const notehead::color_optional &notehead::color() const { return this->color_; }

notehead::color_optional &notehead::color() { return this->color_; }

void notehead::color(const color_type &x) { this->color_.set(x); }

void notehead::color(const color_optional &x) { this->color_ = x; }

void notehead::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// notehead_text
//

const notehead_text::display_text_sequence &
notehead_text::display_text() const {
  return this->display_text_;
}

notehead_text::display_text_sequence &notehead_text::display_text() {
  return this->display_text_;
}

void notehead_text::display_text(const display_text_sequence &s) {
  this->display_text_ = s;
}

const notehead_text::accidental_text_sequence &
notehead_text::accidental_text() const {
  return this->accidental_text_;
}

notehead_text::accidental_text_sequence &notehead_text::accidental_text() {
  return this->accidental_text_;
}

void notehead_text::accidental_text(const accidental_text_sequence &s) {
  this->accidental_text_ = s;
}

// ornaments
//

const ornaments::trill_mark_sequence &ornaments::trill_mark() const {
  return this->trill_mark_;
}

ornaments::trill_mark_sequence &ornaments::trill_mark() {
  return this->trill_mark_;
}

void ornaments::trill_mark(const trill_mark_sequence &s) {
  this->trill_mark_ = s;
}

const ornaments::turn_sequence &ornaments::turn() const { return this->turn_; }

ornaments::turn_sequence &ornaments::turn() { return this->turn_; }

void ornaments::turn(const turn_sequence &s) { this->turn_ = s; }

const ornaments::delayed_turn_sequence &ornaments::delayed_turn() const {
  return this->delayed_turn_;
}

ornaments::delayed_turn_sequence &ornaments::delayed_turn() {
  return this->delayed_turn_;
}

void ornaments::delayed_turn(const delayed_turn_sequence &s) {
  this->delayed_turn_ = s;
}

const ornaments::inverted_turn_sequence &ornaments::inverted_turn() const {
  return this->inverted_turn_;
}

ornaments::inverted_turn_sequence &ornaments::inverted_turn() {
  return this->inverted_turn_;
}

void ornaments::inverted_turn(const inverted_turn_sequence &s) {
  this->inverted_turn_ = s;
}

const ornaments::delayed_inverted_turn_sequence &
ornaments::delayed_inverted_turn() const {
  return this->delayed_inverted_turn_;
}

ornaments::delayed_inverted_turn_sequence &ornaments::delayed_inverted_turn() {
  return this->delayed_inverted_turn_;
}

void ornaments::delayed_inverted_turn(const delayed_inverted_turn_sequence &s) {
  this->delayed_inverted_turn_ = s;
}

const ornaments::vertical_turn_sequence &ornaments::vertical_turn() const {
  return this->vertical_turn_;
}

ornaments::vertical_turn_sequence &ornaments::vertical_turn() {
  return this->vertical_turn_;
}

void ornaments::vertical_turn(const vertical_turn_sequence &s) {
  this->vertical_turn_ = s;
}

const ornaments::shake_sequence &ornaments::shake() const {
  return this->shake_;
}

ornaments::shake_sequence &ornaments::shake() { return this->shake_; }

void ornaments::shake(const shake_sequence &s) { this->shake_ = s; }

const ornaments::wavy_line_sequence &ornaments::wavy_line() const {
  return this->wavy_line_;
}

ornaments::wavy_line_sequence &ornaments::wavy_line() {
  return this->wavy_line_;
}

void ornaments::wavy_line(const wavy_line_sequence &s) { this->wavy_line_ = s; }

const ornaments::mordent_sequence &ornaments::mordent() const {
  return this->mordent_;
}

ornaments::mordent_sequence &ornaments::mordent() { return this->mordent_; }

void ornaments::mordent(const mordent_sequence &s) { this->mordent_ = s; }

const ornaments::inverted_mordent_sequence &
ornaments::inverted_mordent() const {
  return this->inverted_mordent_;
}

ornaments::inverted_mordent_sequence &ornaments::inverted_mordent() {
  return this->inverted_mordent_;
}

void ornaments::inverted_mordent(const inverted_mordent_sequence &s) {
  this->inverted_mordent_ = s;
}

const ornaments::schleifer_sequence &ornaments::schleifer() const {
  return this->schleifer_;
}

ornaments::schleifer_sequence &ornaments::schleifer() {
  return this->schleifer_;
}

void ornaments::schleifer(const schleifer_sequence &s) { this->schleifer_ = s; }

const ornaments::tremolo_sequence &ornaments::tremolo() const {
  return this->tremolo_;
}

ornaments::tremolo_sequence &ornaments::tremolo() { return this->tremolo_; }

void ornaments::tremolo(const tremolo_sequence &s) { this->tremolo_ = s; }

const ornaments::other_ornament_sequence &ornaments::other_ornament() const {
  return this->other_ornament_;
}

ornaments::other_ornament_sequence &ornaments::other_ornament() {
  return this->other_ornament_;
}

void ornaments::other_ornament(const other_ornament_sequence &s) {
  this->other_ornament_ = s;
}

const ornaments::accidental_mark_sequence &ornaments::accidental_mark() const {
  return this->accidental_mark_;
}

ornaments::accidental_mark_sequence &ornaments::accidental_mark() {
  return this->accidental_mark_;
}

void ornaments::accidental_mark(const accidental_mark_sequence &s) {
  this->accidental_mark_ = s;
}

// other_notation
//

const other_notation::type_type &other_notation::type() const {
  return this->type_.get();
}

other_notation::type_type &other_notation::type() { return this->type_.get(); }

void other_notation::type(const type_type &x) { this->type_.set(x); }

void other_notation::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const other_notation::number_type &other_notation::number() const {
  return this->number_.get();
}

other_notation::number_type &other_notation::number() {
  return this->number_.get();
}

void other_notation::number(const number_type &x) { this->number_.set(x); }

void other_notation::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

other_notation::number_type other_notation::number_default_value() {
  return number_type(1ULL);
}

const other_notation::print_object_optional &
other_notation::print_object() const {
  return this->print_object_;
}

other_notation::print_object_optional &other_notation::print_object() {
  return this->print_object_;
}

void other_notation::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void other_notation::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void other_notation::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const other_notation::default_x_optional &other_notation::default_x() const {
  return this->default_x_;
}

other_notation::default_x_optional &other_notation::default_x() {
  return this->default_x_;
}

void other_notation::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void other_notation::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void other_notation::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const other_notation::default_y_optional &other_notation::default_y() const {
  return this->default_y_;
}

other_notation::default_y_optional &other_notation::default_y() {
  return this->default_y_;
}

void other_notation::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void other_notation::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void other_notation::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const other_notation::relative_x_optional &other_notation::relative_x() const {
  return this->relative_x_;
}

other_notation::relative_x_optional &other_notation::relative_x() {
  return this->relative_x_;
}

void other_notation::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void other_notation::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void other_notation::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const other_notation::relative_y_optional &other_notation::relative_y() const {
  return this->relative_y_;
}

other_notation::relative_y_optional &other_notation::relative_y() {
  return this->relative_y_;
}

void other_notation::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void other_notation::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void other_notation::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const other_notation::font_family_optional &
other_notation::font_family() const {
  return this->font_family_;
}

other_notation::font_family_optional &other_notation::font_family() {
  return this->font_family_;
}

void other_notation::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void other_notation::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void other_notation::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const other_notation::font_style_optional &other_notation::font_style() const {
  return this->font_style_;
}

other_notation::font_style_optional &other_notation::font_style() {
  return this->font_style_;
}

void other_notation::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void other_notation::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void other_notation::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const other_notation::font_size_optional &other_notation::font_size() const {
  return this->font_size_;
}

other_notation::font_size_optional &other_notation::font_size() {
  return this->font_size_;
}

void other_notation::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void other_notation::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void other_notation::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const other_notation::font_weight_optional &
other_notation::font_weight() const {
  return this->font_weight_;
}

other_notation::font_weight_optional &other_notation::font_weight() {
  return this->font_weight_;
}

void other_notation::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void other_notation::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void other_notation::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const other_notation::color_optional &other_notation::color() const {
  return this->color_;
}

other_notation::color_optional &other_notation::color() { return this->color_; }

void other_notation::color(const color_type &x) { this->color_.set(x); }

void other_notation::color(const color_optional &x) { this->color_ = x; }

void other_notation::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const other_notation::placement_optional &other_notation::placement() const {
  return this->placement_;
}

other_notation::placement_optional &other_notation::placement() {
  return this->placement_;
}

void other_notation::placement(const placement_type &x) {
  this->placement_.set(x);
}

void other_notation::placement(const placement_optional &x) {
  this->placement_ = x;
}

void other_notation::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// pitch
//

const pitch::step_type &pitch::step() const { return this->step_.get(); }

pitch::step_type &pitch::step() { return this->step_.get(); }

void pitch::step(const step_type &x) { this->step_.set(x); }

void pitch::step(::std::unique_ptr<step_type> x) {
  this->step_.set(std::move(x));
}

const pitch::alter_optional &pitch::alter() const { return this->alter_; }

pitch::alter_optional &pitch::alter() { return this->alter_; }

void pitch::alter(const alter_type &x) { this->alter_.set(x); }

void pitch::alter(const alter_optional &x) { this->alter_ = x; }

void pitch::alter(::std::unique_ptr<alter_type> x) {
  this->alter_.set(std::move(x));
}

const pitch::octave_type &pitch::octave() const { return this->octave_.get(); }

pitch::octave_type &pitch::octave() { return this->octave_.get(); }

void pitch::octave(const octave_type &x) { this->octave_.set(x); }

void pitch::octave(::std::unique_ptr<octave_type> x) {
  this->octave_.set(std::move(x));
}

// placement_text
//

const placement_text::default_x_optional &placement_text::default_x() const {
  return this->default_x_;
}

placement_text::default_x_optional &placement_text::default_x() {
  return this->default_x_;
}

void placement_text::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void placement_text::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void placement_text::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const placement_text::default_y_optional &placement_text::default_y() const {
  return this->default_y_;
}

placement_text::default_y_optional &placement_text::default_y() {
  return this->default_y_;
}

void placement_text::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void placement_text::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void placement_text::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const placement_text::relative_x_optional &placement_text::relative_x() const {
  return this->relative_x_;
}

placement_text::relative_x_optional &placement_text::relative_x() {
  return this->relative_x_;
}

void placement_text::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void placement_text::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void placement_text::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const placement_text::relative_y_optional &placement_text::relative_y() const {
  return this->relative_y_;
}

placement_text::relative_y_optional &placement_text::relative_y() {
  return this->relative_y_;
}

void placement_text::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void placement_text::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void placement_text::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const placement_text::font_family_optional &
placement_text::font_family() const {
  return this->font_family_;
}

placement_text::font_family_optional &placement_text::font_family() {
  return this->font_family_;
}

void placement_text::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void placement_text::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void placement_text::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const placement_text::font_style_optional &placement_text::font_style() const {
  return this->font_style_;
}

placement_text::font_style_optional &placement_text::font_style() {
  return this->font_style_;
}

void placement_text::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void placement_text::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void placement_text::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const placement_text::font_size_optional &placement_text::font_size() const {
  return this->font_size_;
}

placement_text::font_size_optional &placement_text::font_size() {
  return this->font_size_;
}

void placement_text::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void placement_text::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void placement_text::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const placement_text::font_weight_optional &
placement_text::font_weight() const {
  return this->font_weight_;
}

placement_text::font_weight_optional &placement_text::font_weight() {
  return this->font_weight_;
}

void placement_text::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void placement_text::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void placement_text::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const placement_text::color_optional &placement_text::color() const {
  return this->color_;
}

placement_text::color_optional &placement_text::color() { return this->color_; }

void placement_text::color(const color_type &x) { this->color_.set(x); }

void placement_text::color(const color_optional &x) { this->color_ = x; }

void placement_text::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const placement_text::placement_optional &placement_text::placement() const {
  return this->placement_;
}

placement_text::placement_optional &placement_text::placement() {
  return this->placement_;
}

void placement_text::placement(const placement_type &x) {
  this->placement_.set(x);
}

void placement_text::placement(const placement_optional &x) {
  this->placement_ = x;
}

void placement_text::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// rest
//

const rest::display_step_optional &rest::display_step() const {
  return this->display_step_;
}

rest::display_step_optional &rest::display_step() {
  return this->display_step_;
}

void rest::display_step(const display_step_type &x) {
  this->display_step_.set(x);
}

void rest::display_step(const display_step_optional &x) {
  this->display_step_ = x;
}

void rest::display_step(::std::unique_ptr<display_step_type> x) {
  this->display_step_.set(std::move(x));
}

const rest::display_octave_optional &rest::display_octave() const {
  return this->display_octave_;
}

rest::display_octave_optional &rest::display_octave() {
  return this->display_octave_;
}

void rest::display_octave(const display_octave_type &x) {
  this->display_octave_.set(x);
}

void rest::display_octave(const display_octave_optional &x) {
  this->display_octave_ = x;
}

void rest::display_octave(::std::unique_ptr<display_octave_type> x) {
  this->display_octave_.set(std::move(x));
}

const rest::measure_optional &rest::measure() const { return this->measure_; }

rest::measure_optional &rest::measure() { return this->measure_; }

void rest::measure(const measure_type &x) { this->measure_.set(x); }

void rest::measure(const measure_optional &x) { this->measure_ = x; }

void rest::measure(::std::unique_ptr<measure_type> x) {
  this->measure_.set(std::move(x));
}

// slide
//

const slide::type_type &slide::type() const { return this->type_.get(); }

slide::type_type &slide::type() { return this->type_.get(); }

void slide::type(const type_type &x) { this->type_.set(x); }

void slide::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const slide::number_type &slide::number() const { return this->number_.get(); }

slide::number_type &slide::number() { return this->number_.get(); }

void slide::number(const number_type &x) { this->number_.set(x); }

void slide::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

slide::number_type slide::number_default_value() { return number_type(1ULL); }

const slide::line_type_optional &slide::line_type() const {
  return this->line_type_;
}

slide::line_type_optional &slide::line_type() { return this->line_type_; }

void slide::line_type(const line_type_type &x) { this->line_type_.set(x); }

void slide::line_type(const line_type_optional &x) { this->line_type_ = x; }

void slide::line_type(::std::unique_ptr<line_type_type> x) {
  this->line_type_.set(std::move(x));
}

const slide::dash_length_optional &slide::dash_length() const {
  return this->dash_length_;
}

slide::dash_length_optional &slide::dash_length() { return this->dash_length_; }

void slide::dash_length(const dash_length_type &x) {
  this->dash_length_.set(x);
}

void slide::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void slide::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const slide::space_length_optional &slide::space_length() const {
  return this->space_length_;
}

slide::space_length_optional &slide::space_length() {
  return this->space_length_;
}

void slide::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void slide::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void slide::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const slide::default_x_optional &slide::default_x() const {
  return this->default_x_;
}

slide::default_x_optional &slide::default_x() { return this->default_x_; }

void slide::default_x(const default_x_type &x) { this->default_x_.set(x); }

void slide::default_x(const default_x_optional &x) { this->default_x_ = x; }

void slide::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const slide::default_y_optional &slide::default_y() const {
  return this->default_y_;
}

slide::default_y_optional &slide::default_y() { return this->default_y_; }

void slide::default_y(const default_y_type &x) { this->default_y_.set(x); }

void slide::default_y(const default_y_optional &x) { this->default_y_ = x; }

void slide::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const slide::relative_x_optional &slide::relative_x() const {
  return this->relative_x_;
}

slide::relative_x_optional &slide::relative_x() { return this->relative_x_; }

void slide::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void slide::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void slide::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const slide::relative_y_optional &slide::relative_y() const {
  return this->relative_y_;
}

slide::relative_y_optional &slide::relative_y() { return this->relative_y_; }

void slide::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void slide::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void slide::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const slide::font_family_optional &slide::font_family() const {
  return this->font_family_;
}

slide::font_family_optional &slide::font_family() { return this->font_family_; }

void slide::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void slide::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void slide::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const slide::font_style_optional &slide::font_style() const {
  return this->font_style_;
}

slide::font_style_optional &slide::font_style() { return this->font_style_; }

void slide::font_style(const font_style_type &x) { this->font_style_.set(x); }

void slide::font_style(const font_style_optional &x) { this->font_style_ = x; }

void slide::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const slide::font_size_optional &slide::font_size() const {
  return this->font_size_;
}

slide::font_size_optional &slide::font_size() { return this->font_size_; }

void slide::font_size(const font_size_type &x) { this->font_size_.set(x); }

void slide::font_size(const font_size_optional &x) { this->font_size_ = x; }

void slide::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const slide::font_weight_optional &slide::font_weight() const {
  return this->font_weight_;
}

slide::font_weight_optional &slide::font_weight() { return this->font_weight_; }

void slide::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void slide::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void slide::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const slide::color_optional &slide::color() const { return this->color_; }

slide::color_optional &slide::color() { return this->color_; }

void slide::color(const color_type &x) { this->color_.set(x); }

void slide::color(const color_optional &x) { this->color_ = x; }

void slide::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const slide::accelerate_optional &slide::accelerate() const {
  return this->accelerate_;
}

slide::accelerate_optional &slide::accelerate() { return this->accelerate_; }

void slide::accelerate(const accelerate_type &x) { this->accelerate_.set(x); }

void slide::accelerate(const accelerate_optional &x) { this->accelerate_ = x; }

void slide::accelerate(::std::unique_ptr<accelerate_type> x) {
  this->accelerate_.set(std::move(x));
}

const slide::beats_optional &slide::beats() const { return this->beats_; }

slide::beats_optional &slide::beats() { return this->beats_; }

void slide::beats(const beats_type &x) { this->beats_.set(x); }

void slide::beats(const beats_optional &x) { this->beats_ = x; }

void slide::beats(::std::unique_ptr<beats_type> x) {
  this->beats_.set(std::move(x));
}

const slide::first_beat_optional &slide::first_beat() const {
  return this->first_beat_;
}

slide::first_beat_optional &slide::first_beat() { return this->first_beat_; }

void slide::first_beat(const first_beat_type &x) { this->first_beat_.set(x); }

void slide::first_beat(const first_beat_optional &x) { this->first_beat_ = x; }

void slide::first_beat(::std::unique_ptr<first_beat_type> x) {
  this->first_beat_.set(std::move(x));
}

const slide::last_beat_optional &slide::last_beat() const {
  return this->last_beat_;
}

slide::last_beat_optional &slide::last_beat() { return this->last_beat_; }

void slide::last_beat(const last_beat_type &x) { this->last_beat_.set(x); }

void slide::last_beat(const last_beat_optional &x) { this->last_beat_ = x; }

void slide::last_beat(::std::unique_ptr<last_beat_type> x) {
  this->last_beat_.set(std::move(x));
}

// slur
//

const slur::type_type &slur::type() const { return this->type_.get(); }

slur::type_type &slur::type() { return this->type_.get(); }

void slur::type(const type_type &x) { this->type_.set(x); }

void slur::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const slur::number_type &slur::number() const { return this->number_.get(); }

slur::number_type &slur::number() { return this->number_.get(); }

void slur::number(const number_type &x) { this->number_.set(x); }

void slur::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

slur::number_type slur::number_default_value() { return number_type(1ULL); }

const slur::line_type_optional &slur::line_type() const {
  return this->line_type_;
}

slur::line_type_optional &slur::line_type() { return this->line_type_; }

void slur::line_type(const line_type_type &x) { this->line_type_.set(x); }

void slur::line_type(const line_type_optional &x) { this->line_type_ = x; }

void slur::line_type(::std::unique_ptr<line_type_type> x) {
  this->line_type_.set(std::move(x));
}

const slur::dash_length_optional &slur::dash_length() const {
  return this->dash_length_;
}

slur::dash_length_optional &slur::dash_length() { return this->dash_length_; }

void slur::dash_length(const dash_length_type &x) { this->dash_length_.set(x); }

void slur::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void slur::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const slur::space_length_optional &slur::space_length() const {
  return this->space_length_;
}

slur::space_length_optional &slur::space_length() {
  return this->space_length_;
}

void slur::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void slur::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void slur::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const slur::default_x_optional &slur::default_x() const {
  return this->default_x_;
}

slur::default_x_optional &slur::default_x() { return this->default_x_; }

void slur::default_x(const default_x_type &x) { this->default_x_.set(x); }

void slur::default_x(const default_x_optional &x) { this->default_x_ = x; }

void slur::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const slur::default_y_optional &slur::default_y() const {
  return this->default_y_;
}

slur::default_y_optional &slur::default_y() { return this->default_y_; }

void slur::default_y(const default_y_type &x) { this->default_y_.set(x); }

void slur::default_y(const default_y_optional &x) { this->default_y_ = x; }

void slur::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const slur::relative_x_optional &slur::relative_x() const {
  return this->relative_x_;
}

slur::relative_x_optional &slur::relative_x() { return this->relative_x_; }

void slur::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void slur::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void slur::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const slur::relative_y_optional &slur::relative_y() const {
  return this->relative_y_;
}

slur::relative_y_optional &slur::relative_y() { return this->relative_y_; }

void slur::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void slur::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void slur::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const slur::placement_optional &slur::placement() const {
  return this->placement_;
}

slur::placement_optional &slur::placement() { return this->placement_; }

void slur::placement(const placement_type &x) { this->placement_.set(x); }

void slur::placement(const placement_optional &x) { this->placement_ = x; }

void slur::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const slur::orientation_optional &slur::orientation() const {
  return this->orientation_;
}

slur::orientation_optional &slur::orientation() { return this->orientation_; }

void slur::orientation(const orientation_type &x) { this->orientation_.set(x); }

void slur::orientation(const orientation_optional &x) {
  this->orientation_ = x;
}

void slur::orientation(::std::unique_ptr<orientation_type> x) {
  this->orientation_.set(std::move(x));
}

const slur::bezier_offset_optional &slur::bezier_offset() const {
  return this->bezier_offset_;
}

slur::bezier_offset_optional &slur::bezier_offset() {
  return this->bezier_offset_;
}

void slur::bezier_offset(const bezier_offset_type &x) {
  this->bezier_offset_.set(x);
}

void slur::bezier_offset(const bezier_offset_optional &x) {
  this->bezier_offset_ = x;
}

void slur::bezier_offset(::std::unique_ptr<bezier_offset_type> x) {
  this->bezier_offset_.set(std::move(x));
}

const slur::bezier_offset2_optional &slur::bezier_offset2() const {
  return this->bezier_offset2_;
}

slur::bezier_offset2_optional &slur::bezier_offset2() {
  return this->bezier_offset2_;
}

void slur::bezier_offset2(const bezier_offset2_type &x) {
  this->bezier_offset2_.set(x);
}

void slur::bezier_offset2(const bezier_offset2_optional &x) {
  this->bezier_offset2_ = x;
}

void slur::bezier_offset2(::std::unique_ptr<bezier_offset2_type> x) {
  this->bezier_offset2_.set(std::move(x));
}

const slur::bezier_x_optional &slur::bezier_x() const {
  return this->bezier_x_;
}

slur::bezier_x_optional &slur::bezier_x() { return this->bezier_x_; }

void slur::bezier_x(const bezier_x_type &x) { this->bezier_x_.set(x); }

void slur::bezier_x(const bezier_x_optional &x) { this->bezier_x_ = x; }

void slur::bezier_x(::std::unique_ptr<bezier_x_type> x) {
  this->bezier_x_.set(std::move(x));
}

const slur::bezier_y_optional &slur::bezier_y() const {
  return this->bezier_y_;
}

slur::bezier_y_optional &slur::bezier_y() { return this->bezier_y_; }

void slur::bezier_y(const bezier_y_type &x) { this->bezier_y_.set(x); }

void slur::bezier_y(const bezier_y_optional &x) { this->bezier_y_ = x; }

void slur::bezier_y(::std::unique_ptr<bezier_y_type> x) {
  this->bezier_y_.set(std::move(x));
}

const slur::bezier_x2_optional &slur::bezier_x2() const {
  return this->bezier_x2_;
}

slur::bezier_x2_optional &slur::bezier_x2() { return this->bezier_x2_; }

void slur::bezier_x2(const bezier_x2_type &x) { this->bezier_x2_.set(x); }

void slur::bezier_x2(const bezier_x2_optional &x) { this->bezier_x2_ = x; }

void slur::bezier_x2(::std::unique_ptr<bezier_x2_type> x) {
  this->bezier_x2_.set(std::move(x));
}

const slur::bezier_y2_optional &slur::bezier_y2() const {
  return this->bezier_y2_;
}

slur::bezier_y2_optional &slur::bezier_y2() { return this->bezier_y2_; }

void slur::bezier_y2(const bezier_y2_type &x) { this->bezier_y2_.set(x); }

void slur::bezier_y2(const bezier_y2_optional &x) { this->bezier_y2_ = x; }

void slur::bezier_y2(::std::unique_ptr<bezier_y2_type> x) {
  this->bezier_y2_.set(std::move(x));
}

const slur::color_optional &slur::color() const { return this->color_; }

slur::color_optional &slur::color() { return this->color_; }

void slur::color(const color_type &x) { this->color_.set(x); }

void slur::color(const color_optional &x) { this->color_ = x; }

void slur::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// stem
//

const stem::default_x_optional &stem::default_x() const {
  return this->default_x_;
}

stem::default_x_optional &stem::default_x() { return this->default_x_; }

void stem::default_x(const default_x_type &x) { this->default_x_.set(x); }

void stem::default_x(const default_x_optional &x) { this->default_x_ = x; }

void stem::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const stem::default_y_optional &stem::default_y() const {
  return this->default_y_;
}

stem::default_y_optional &stem::default_y() { return this->default_y_; }

void stem::default_y(const default_y_type &x) { this->default_y_.set(x); }

void stem::default_y(const default_y_optional &x) { this->default_y_ = x; }

void stem::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const stem::relative_x_optional &stem::relative_x() const {
  return this->relative_x_;
}

stem::relative_x_optional &stem::relative_x() { return this->relative_x_; }

void stem::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void stem::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void stem::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const stem::relative_y_optional &stem::relative_y() const {
  return this->relative_y_;
}

stem::relative_y_optional &stem::relative_y() { return this->relative_y_; }

void stem::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void stem::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void stem::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const stem::color_optional &stem::color() const { return this->color_; }

stem::color_optional &stem::color() { return this->color_; }

void stem::color(const color_type &x) { this->color_.set(x); }

void stem::color(const color_optional &x) { this->color_ = x; }

void stem::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// strong_accent
//

const strong_accent::type_type &strong_accent::type() const {
  return this->type_.get();
}

strong_accent::type_type &strong_accent::type() { return this->type_.get(); }

void strong_accent::type(const type_type &x) { this->type_.set(x); }

void strong_accent::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const strong_accent::type_type &strong_accent::type_default_value() {
  return type_default_value_;
}

// style_text
//

const style_text::default_x_optional &style_text::default_x() const {
  return this->default_x_;
}

style_text::default_x_optional &style_text::default_x() {
  return this->default_x_;
}

void style_text::default_x(const default_x_type &x) { this->default_x_.set(x); }

void style_text::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void style_text::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const style_text::default_y_optional &style_text::default_y() const {
  return this->default_y_;
}

style_text::default_y_optional &style_text::default_y() {
  return this->default_y_;
}

void style_text::default_y(const default_y_type &x) { this->default_y_.set(x); }

void style_text::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void style_text::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const style_text::relative_x_optional &style_text::relative_x() const {
  return this->relative_x_;
}

style_text::relative_x_optional &style_text::relative_x() {
  return this->relative_x_;
}

void style_text::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void style_text::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void style_text::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const style_text::relative_y_optional &style_text::relative_y() const {
  return this->relative_y_;
}

style_text::relative_y_optional &style_text::relative_y() {
  return this->relative_y_;
}

void style_text::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void style_text::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void style_text::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const style_text::font_family_optional &style_text::font_family() const {
  return this->font_family_;
}

style_text::font_family_optional &style_text::font_family() {
  return this->font_family_;
}

void style_text::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void style_text::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void style_text::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const style_text::font_style_optional &style_text::font_style() const {
  return this->font_style_;
}

style_text::font_style_optional &style_text::font_style() {
  return this->font_style_;
}

void style_text::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void style_text::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void style_text::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const style_text::font_size_optional &style_text::font_size() const {
  return this->font_size_;
}

style_text::font_size_optional &style_text::font_size() {
  return this->font_size_;
}

void style_text::font_size(const font_size_type &x) { this->font_size_.set(x); }

void style_text::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void style_text::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const style_text::font_weight_optional &style_text::font_weight() const {
  return this->font_weight_;
}

style_text::font_weight_optional &style_text::font_weight() {
  return this->font_weight_;
}

void style_text::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void style_text::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void style_text::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const style_text::color_optional &style_text::color() const {
  return this->color_;
}

style_text::color_optional &style_text::color() { return this->color_; }

void style_text::color(const color_type &x) { this->color_.set(x); }

void style_text::color(const color_optional &x) { this->color_ = x; }

void style_text::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// technical
//

const technical::up_bow_sequence &technical::up_bow() const {
  return this->up_bow_;
}

technical::up_bow_sequence &technical::up_bow() { return this->up_bow_; }

void technical::up_bow(const up_bow_sequence &s) { this->up_bow_ = s; }

const technical::down_bow_sequence &technical::down_bow() const {
  return this->down_bow_;
}

technical::down_bow_sequence &technical::down_bow() { return this->down_bow_; }

void technical::down_bow(const down_bow_sequence &s) { this->down_bow_ = s; }

const technical::harmonic_sequence &technical::harmonic() const {
  return this->harmonic_;
}

technical::harmonic_sequence &technical::harmonic() { return this->harmonic_; }

void technical::harmonic(const harmonic_sequence &s) { this->harmonic_ = s; }

const technical::open_string_sequence &technical::open_string() const {
  return this->open_string_;
}

technical::open_string_sequence &technical::open_string() {
  return this->open_string_;
}

void technical::open_string(const open_string_sequence &s) {
  this->open_string_ = s;
}

const technical::thumb_position_sequence &technical::thumb_position() const {
  return this->thumb_position_;
}

technical::thumb_position_sequence &technical::thumb_position() {
  return this->thumb_position_;
}

void technical::thumb_position(const thumb_position_sequence &s) {
  this->thumb_position_ = s;
}

const technical::fingering_sequence &technical::fingering() const {
  return this->fingering_;
}

technical::fingering_sequence &technical::fingering() {
  return this->fingering_;
}

void technical::fingering(const fingering_sequence &s) { this->fingering_ = s; }

const technical::pluck_sequence &technical::pluck() const {
  return this->pluck_;
}

technical::pluck_sequence &technical::pluck() { return this->pluck_; }

void technical::pluck(const pluck_sequence &s) { this->pluck_ = s; }

const technical::double_tongue_sequence &technical::double_tongue() const {
  return this->double_tongue_;
}

technical::double_tongue_sequence &technical::double_tongue() {
  return this->double_tongue_;
}

void technical::double_tongue(const double_tongue_sequence &s) {
  this->double_tongue_ = s;
}

const technical::triple_tongue_sequence &technical::triple_tongue() const {
  return this->triple_tongue_;
}

technical::triple_tongue_sequence &technical::triple_tongue() {
  return this->triple_tongue_;
}

void technical::triple_tongue(const triple_tongue_sequence &s) {
  this->triple_tongue_ = s;
}

const technical::stopped_sequence &technical::stopped() const {
  return this->stopped_;
}

technical::stopped_sequence &technical::stopped() { return this->stopped_; }

void technical::stopped(const stopped_sequence &s) { this->stopped_ = s; }

const technical::snap_pizzicato_sequence &technical::snap_pizzicato() const {
  return this->snap_pizzicato_;
}

technical::snap_pizzicato_sequence &technical::snap_pizzicato() {
  return this->snap_pizzicato_;
}

void technical::snap_pizzicato(const snap_pizzicato_sequence &s) {
  this->snap_pizzicato_ = s;
}

const technical::fret_sequence &technical::fret() const { return this->fret_; }

technical::fret_sequence &technical::fret() { return this->fret_; }

void technical::fret(const fret_sequence &s) { this->fret_ = s; }

const technical::string_sequence &technical::string() const {
  return this->string_;
}

technical::string_sequence &technical::string() { return this->string_; }

void technical::string(const string_sequence &s) { this->string_ = s; }

const technical::hammer_on_sequence &technical::hammer_on() const {
  return this->hammer_on_;
}

technical::hammer_on_sequence &technical::hammer_on() {
  return this->hammer_on_;
}

void technical::hammer_on(const hammer_on_sequence &s) { this->hammer_on_ = s; }

const technical::pull_off_sequence &technical::pull_off() const {
  return this->pull_off_;
}

technical::pull_off_sequence &technical::pull_off() { return this->pull_off_; }

void technical::pull_off(const pull_off_sequence &s) { this->pull_off_ = s; }

const technical::bend_sequence &technical::bend() const { return this->bend_; }

technical::bend_sequence &technical::bend() { return this->bend_; }

void technical::bend(const bend_sequence &s) { this->bend_ = s; }

const technical::tap_sequence &technical::tap() const { return this->tap_; }

technical::tap_sequence &technical::tap() { return this->tap_; }

void technical::tap(const tap_sequence &s) { this->tap_ = s; }

const technical::heel_sequence &technical::heel() const { return this->heel_; }

technical::heel_sequence &technical::heel() { return this->heel_; }

void technical::heel(const heel_sequence &s) { this->heel_ = s; }

const technical::toe_sequence &technical::toe() const { return this->toe_; }

technical::toe_sequence &technical::toe() { return this->toe_; }

void technical::toe(const toe_sequence &s) { this->toe_ = s; }

const technical::fingernails_sequence &technical::fingernails() const {
  return this->fingernails_;
}

technical::fingernails_sequence &technical::fingernails() {
  return this->fingernails_;
}

void technical::fingernails(const fingernails_sequence &s) {
  this->fingernails_ = s;
}

const technical::hole_sequence &technical::hole() const { return this->hole_; }

technical::hole_sequence &technical::hole() { return this->hole_; }

void technical::hole(const hole_sequence &s) { this->hole_ = s; }

const technical::arrow_sequence &technical::arrow() const {
  return this->arrow_;
}

technical::arrow_sequence &technical::arrow() { return this->arrow_; }

void technical::arrow(const arrow_sequence &s) { this->arrow_ = s; }

const technical::handbell_sequence &technical::handbell() const {
  return this->handbell_;
}

technical::handbell_sequence &technical::handbell() { return this->handbell_; }

void technical::handbell(const handbell_sequence &s) { this->handbell_ = s; }

const technical::other_technical_sequence &technical::other_technical() const {
  return this->other_technical_;
}

technical::other_technical_sequence &technical::other_technical() {
  return this->other_technical_;
}

void technical::other_technical(const other_technical_sequence &s) {
  this->other_technical_ = s;
}

// text_element_data
//

const text_element_data::font_family_optional &
text_element_data::font_family() const {
  return this->font_family_;
}

text_element_data::font_family_optional &text_element_data::font_family() {
  return this->font_family_;
}

void text_element_data::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void text_element_data::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void text_element_data::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const text_element_data::font_style_optional &
text_element_data::font_style() const {
  return this->font_style_;
}

text_element_data::font_style_optional &text_element_data::font_style() {
  return this->font_style_;
}

void text_element_data::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void text_element_data::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void text_element_data::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const text_element_data::font_size_optional &
text_element_data::font_size() const {
  return this->font_size_;
}

text_element_data::font_size_optional &text_element_data::font_size() {
  return this->font_size_;
}

void text_element_data::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void text_element_data::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void text_element_data::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const text_element_data::font_weight_optional &
text_element_data::font_weight() const {
  return this->font_weight_;
}

text_element_data::font_weight_optional &text_element_data::font_weight() {
  return this->font_weight_;
}

void text_element_data::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void text_element_data::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void text_element_data::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const text_element_data::color_optional &text_element_data::color() const {
  return this->color_;
}

text_element_data::color_optional &text_element_data::color() {
  return this->color_;
}

void text_element_data::color(const color_type &x) { this->color_.set(x); }

void text_element_data::color(const color_optional &x) { this->color_ = x; }

void text_element_data::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const text_element_data::underline_optional &
text_element_data::underline() const {
  return this->underline_;
}

text_element_data::underline_optional &text_element_data::underline() {
  return this->underline_;
}

void text_element_data::underline(const underline_type &x) {
  this->underline_.set(x);
}

void text_element_data::underline(const underline_optional &x) {
  this->underline_ = x;
}

void text_element_data::underline(::std::unique_ptr<underline_type> x) {
  this->underline_.set(std::move(x));
}

const text_element_data::overline_optional &
text_element_data::overline() const {
  return this->overline_;
}

text_element_data::overline_optional &text_element_data::overline() {
  return this->overline_;
}

void text_element_data::overline(const overline_type &x) {
  this->overline_.set(x);
}

void text_element_data::overline(const overline_optional &x) {
  this->overline_ = x;
}

void text_element_data::overline(::std::unique_ptr<overline_type> x) {
  this->overline_.set(std::move(x));
}

const text_element_data::line_through_optional &
text_element_data::line_through() const {
  return this->line_through_;
}

text_element_data::line_through_optional &text_element_data::line_through() {
  return this->line_through_;
}

void text_element_data::line_through(const line_through_type &x) {
  this->line_through_.set(x);
}

void text_element_data::line_through(const line_through_optional &x) {
  this->line_through_ = x;
}

void text_element_data::line_through(::std::unique_ptr<line_through_type> x) {
  this->line_through_.set(std::move(x));
}

const text_element_data::rotation_optional &
text_element_data::rotation() const {
  return this->rotation_;
}

text_element_data::rotation_optional &text_element_data::rotation() {
  return this->rotation_;
}

void text_element_data::rotation(const rotation_type &x) {
  this->rotation_.set(x);
}

void text_element_data::rotation(const rotation_optional &x) {
  this->rotation_ = x;
}

void text_element_data::rotation(::std::unique_ptr<rotation_type> x) {
  this->rotation_.set(std::move(x));
}

const text_element_data::letter_spacing_optional &
text_element_data::letter_spacing() const {
  return this->letter_spacing_;
}

text_element_data::letter_spacing_optional &
text_element_data::letter_spacing() {
  return this->letter_spacing_;
}

void text_element_data::letter_spacing(const letter_spacing_type &x) {
  this->letter_spacing_.set(x);
}

void text_element_data::letter_spacing(const letter_spacing_optional &x) {
  this->letter_spacing_ = x;
}

void
text_element_data::letter_spacing(::std::unique_ptr<letter_spacing_type> x) {
  this->letter_spacing_.set(std::move(x));
}

const text_element_data::lang_optional &text_element_data::lang() const {
  return this->lang_;
}

text_element_data::lang_optional &text_element_data::lang() {
  return this->lang_;
}

void text_element_data::lang(const lang_type &x) { this->lang_.set(x); }

void text_element_data::lang(const lang_optional &x) { this->lang_ = x; }

void text_element_data::lang(::std::unique_ptr<lang_type> x) {
  this->lang_.set(std::move(x));
}

const text_element_data::dir_optional &text_element_data::dir() const {
  return this->dir_;
}

text_element_data::dir_optional &text_element_data::dir() { return this->dir_; }

void text_element_data::dir(const dir_type &x) { this->dir_.set(x); }

void text_element_data::dir(const dir_optional &x) { this->dir_ = x; }

void text_element_data::dir(::std::unique_ptr<dir_type> x) {
  this->dir_.set(std::move(x));
}

// text_font_color
//

const text_font_color::font_family_optional &
text_font_color::font_family() const {
  return this->font_family_;
}

text_font_color::font_family_optional &text_font_color::font_family() {
  return this->font_family_;
}

void text_font_color::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void text_font_color::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void text_font_color::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const text_font_color::font_style_optional &
text_font_color::font_style() const {
  return this->font_style_;
}

text_font_color::font_style_optional &text_font_color::font_style() {
  return this->font_style_;
}

void text_font_color::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void text_font_color::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void text_font_color::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const text_font_color::font_size_optional &text_font_color::font_size() const {
  return this->font_size_;
}

text_font_color::font_size_optional &text_font_color::font_size() {
  return this->font_size_;
}

void text_font_color::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void text_font_color::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void text_font_color::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const text_font_color::font_weight_optional &
text_font_color::font_weight() const {
  return this->font_weight_;
}

text_font_color::font_weight_optional &text_font_color::font_weight() {
  return this->font_weight_;
}

void text_font_color::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void text_font_color::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void text_font_color::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const text_font_color::color_optional &text_font_color::color() const {
  return this->color_;
}

text_font_color::color_optional &text_font_color::color() {
  return this->color_;
}

void text_font_color::color(const color_type &x) { this->color_.set(x); }

void text_font_color::color(const color_optional &x) { this->color_ = x; }

void text_font_color::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const text_font_color::underline_optional &text_font_color::underline() const {
  return this->underline_;
}

text_font_color::underline_optional &text_font_color::underline() {
  return this->underline_;
}

void text_font_color::underline(const underline_type &x) {
  this->underline_.set(x);
}

void text_font_color::underline(const underline_optional &x) {
  this->underline_ = x;
}

void text_font_color::underline(::std::unique_ptr<underline_type> x) {
  this->underline_.set(std::move(x));
}

const text_font_color::overline_optional &text_font_color::overline() const {
  return this->overline_;
}

text_font_color::overline_optional &text_font_color::overline() {
  return this->overline_;
}

void text_font_color::overline(const overline_type &x) {
  this->overline_.set(x);
}

void text_font_color::overline(const overline_optional &x) {
  this->overline_ = x;
}

void text_font_color::overline(::std::unique_ptr<overline_type> x) {
  this->overline_.set(std::move(x));
}

const text_font_color::line_through_optional &
text_font_color::line_through() const {
  return this->line_through_;
}

text_font_color::line_through_optional &text_font_color::line_through() {
  return this->line_through_;
}

void text_font_color::line_through(const line_through_type &x) {
  this->line_through_.set(x);
}

void text_font_color::line_through(const line_through_optional &x) {
  this->line_through_ = x;
}

void text_font_color::line_through(::std::unique_ptr<line_through_type> x) {
  this->line_through_.set(std::move(x));
}

const text_font_color::rotation_optional &text_font_color::rotation() const {
  return this->rotation_;
}

text_font_color::rotation_optional &text_font_color::rotation() {
  return this->rotation_;
}

void text_font_color::rotation(const rotation_type &x) {
  this->rotation_.set(x);
}

void text_font_color::rotation(const rotation_optional &x) {
  this->rotation_ = x;
}

void text_font_color::rotation(::std::unique_ptr<rotation_type> x) {
  this->rotation_.set(std::move(x));
}

const text_font_color::letter_spacing_optional &
text_font_color::letter_spacing() const {
  return this->letter_spacing_;
}

text_font_color::letter_spacing_optional &text_font_color::letter_spacing() {
  return this->letter_spacing_;
}

void text_font_color::letter_spacing(const letter_spacing_type &x) {
  this->letter_spacing_.set(x);
}

void text_font_color::letter_spacing(const letter_spacing_optional &x) {
  this->letter_spacing_ = x;
}

void text_font_color::letter_spacing(::std::unique_ptr<letter_spacing_type> x) {
  this->letter_spacing_.set(std::move(x));
}

const text_font_color::lang_optional &text_font_color::lang() const {
  return this->lang_;
}

text_font_color::lang_optional &text_font_color::lang() { return this->lang_; }

void text_font_color::lang(const lang_type &x) { this->lang_.set(x); }

void text_font_color::lang(const lang_optional &x) { this->lang_ = x; }

void text_font_color::lang(::std::unique_ptr<lang_type> x) {
  this->lang_.set(std::move(x));
}

const text_font_color::dir_optional &text_font_color::dir() const {
  return this->dir_;
}

text_font_color::dir_optional &text_font_color::dir() { return this->dir_; }

void text_font_color::dir(const dir_type &x) { this->dir_.set(x); }

void text_font_color::dir(const dir_optional &x) { this->dir_ = x; }

void text_font_color::dir(::std::unique_ptr<dir_type> x) {
  this->dir_.set(std::move(x));
}

// tie
//

const tie::type_type &tie::type() const { return this->type_.get(); }

tie::type_type &tie::type() { return this->type_.get(); }

void tie::type(const type_type &x) { this->type_.set(x); }

void tie::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const tie::time_only_optional &tie::time_only() const {
  return this->time_only_;
}

tie::time_only_optional &tie::time_only() { return this->time_only_; }

void tie::time_only(const time_only_type &x) { this->time_only_.set(x); }

void tie::time_only(const time_only_optional &x) { this->time_only_ = x; }

void tie::time_only(::std::unique_ptr<time_only_type> x) {
  this->time_only_.set(std::move(x));
}

// tied
//

const tied::type_type &tied::type() const { return this->type_.get(); }

tied::type_type &tied::type() { return this->type_.get(); }

void tied::type(const type_type &x) { this->type_.set(x); }

void tied::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const tied::number_optional &tied::number() const { return this->number_; }

tied::number_optional &tied::number() { return this->number_; }

void tied::number(const number_type &x) { this->number_.set(x); }

void tied::number(const number_optional &x) { this->number_ = x; }

void tied::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const tied::line_type_optional &tied::line_type() const {
  return this->line_type_;
}

tied::line_type_optional &tied::line_type() { return this->line_type_; }

void tied::line_type(const line_type_type &x) { this->line_type_.set(x); }

void tied::line_type(const line_type_optional &x) { this->line_type_ = x; }

void tied::line_type(::std::unique_ptr<line_type_type> x) {
  this->line_type_.set(std::move(x));
}

const tied::dash_length_optional &tied::dash_length() const {
  return this->dash_length_;
}

tied::dash_length_optional &tied::dash_length() { return this->dash_length_; }

void tied::dash_length(const dash_length_type &x) { this->dash_length_.set(x); }

void tied::dash_length(const dash_length_optional &x) {
  this->dash_length_ = x;
}

void tied::dash_length(::std::unique_ptr<dash_length_type> x) {
  this->dash_length_.set(std::move(x));
}

const tied::space_length_optional &tied::space_length() const {
  return this->space_length_;
}

tied::space_length_optional &tied::space_length() {
  return this->space_length_;
}

void tied::space_length(const space_length_type &x) {
  this->space_length_.set(x);
}

void tied::space_length(const space_length_optional &x) {
  this->space_length_ = x;
}

void tied::space_length(::std::unique_ptr<space_length_type> x) {
  this->space_length_.set(std::move(x));
}

const tied::default_x_optional &tied::default_x() const {
  return this->default_x_;
}

tied::default_x_optional &tied::default_x() { return this->default_x_; }

void tied::default_x(const default_x_type &x) { this->default_x_.set(x); }

void tied::default_x(const default_x_optional &x) { this->default_x_ = x; }

void tied::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const tied::default_y_optional &tied::default_y() const {
  return this->default_y_;
}

tied::default_y_optional &tied::default_y() { return this->default_y_; }

void tied::default_y(const default_y_type &x) { this->default_y_.set(x); }

void tied::default_y(const default_y_optional &x) { this->default_y_ = x; }

void tied::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const tied::relative_x_optional &tied::relative_x() const {
  return this->relative_x_;
}

tied::relative_x_optional &tied::relative_x() { return this->relative_x_; }

void tied::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void tied::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void tied::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const tied::relative_y_optional &tied::relative_y() const {
  return this->relative_y_;
}

tied::relative_y_optional &tied::relative_y() { return this->relative_y_; }

void tied::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void tied::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void tied::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const tied::placement_optional &tied::placement() const {
  return this->placement_;
}

tied::placement_optional &tied::placement() { return this->placement_; }

void tied::placement(const placement_type &x) { this->placement_.set(x); }

void tied::placement(const placement_optional &x) { this->placement_ = x; }

void tied::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

const tied::orientation_optional &tied::orientation() const {
  return this->orientation_;
}

tied::orientation_optional &tied::orientation() { return this->orientation_; }

void tied::orientation(const orientation_type &x) { this->orientation_.set(x); }

void tied::orientation(const orientation_optional &x) {
  this->orientation_ = x;
}

void tied::orientation(::std::unique_ptr<orientation_type> x) {
  this->orientation_.set(std::move(x));
}

const tied::bezier_offset_optional &tied::bezier_offset() const {
  return this->bezier_offset_;
}

tied::bezier_offset_optional &tied::bezier_offset() {
  return this->bezier_offset_;
}

void tied::bezier_offset(const bezier_offset_type &x) {
  this->bezier_offset_.set(x);
}

void tied::bezier_offset(const bezier_offset_optional &x) {
  this->bezier_offset_ = x;
}

void tied::bezier_offset(::std::unique_ptr<bezier_offset_type> x) {
  this->bezier_offset_.set(std::move(x));
}

const tied::bezier_offset2_optional &tied::bezier_offset2() const {
  return this->bezier_offset2_;
}

tied::bezier_offset2_optional &tied::bezier_offset2() {
  return this->bezier_offset2_;
}

void tied::bezier_offset2(const bezier_offset2_type &x) {
  this->bezier_offset2_.set(x);
}

void tied::bezier_offset2(const bezier_offset2_optional &x) {
  this->bezier_offset2_ = x;
}

void tied::bezier_offset2(::std::unique_ptr<bezier_offset2_type> x) {
  this->bezier_offset2_.set(std::move(x));
}

const tied::bezier_x_optional &tied::bezier_x() const {
  return this->bezier_x_;
}

tied::bezier_x_optional &tied::bezier_x() { return this->bezier_x_; }

void tied::bezier_x(const bezier_x_type &x) { this->bezier_x_.set(x); }

void tied::bezier_x(const bezier_x_optional &x) { this->bezier_x_ = x; }

void tied::bezier_x(::std::unique_ptr<bezier_x_type> x) {
  this->bezier_x_.set(std::move(x));
}

const tied::bezier_y_optional &tied::bezier_y() const {
  return this->bezier_y_;
}

tied::bezier_y_optional &tied::bezier_y() { return this->bezier_y_; }

void tied::bezier_y(const bezier_y_type &x) { this->bezier_y_.set(x); }

void tied::bezier_y(const bezier_y_optional &x) { this->bezier_y_ = x; }

void tied::bezier_y(::std::unique_ptr<bezier_y_type> x) {
  this->bezier_y_.set(std::move(x));
}

const tied::bezier_x2_optional &tied::bezier_x2() const {
  return this->bezier_x2_;
}

tied::bezier_x2_optional &tied::bezier_x2() { return this->bezier_x2_; }

void tied::bezier_x2(const bezier_x2_type &x) { this->bezier_x2_.set(x); }

void tied::bezier_x2(const bezier_x2_optional &x) { this->bezier_x2_ = x; }

void tied::bezier_x2(::std::unique_ptr<bezier_x2_type> x) {
  this->bezier_x2_.set(std::move(x));
}

const tied::bezier_y2_optional &tied::bezier_y2() const {
  return this->bezier_y2_;
}

tied::bezier_y2_optional &tied::bezier_y2() { return this->bezier_y2_; }

void tied::bezier_y2(const bezier_y2_type &x) { this->bezier_y2_.set(x); }

void tied::bezier_y2(const bezier_y2_optional &x) { this->bezier_y2_ = x; }

void tied::bezier_y2(::std::unique_ptr<bezier_y2_type> x) {
  this->bezier_y2_.set(std::move(x));
}

const tied::color_optional &tied::color() const { return this->color_; }

tied::color_optional &tied::color() { return this->color_; }

void tied::color(const color_type &x) { this->color_.set(x); }

void tied::color(const color_optional &x) { this->color_ = x; }

void tied::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// tremolo
//

const tremolo::type_type &tremolo::type() const { return this->type_.get(); }

tremolo::type_type &tremolo::type() { return this->type_.get(); }

void tremolo::type(const type_type &x) { this->type_.set(x); }

void tremolo::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const tremolo::type_type &tremolo::type_default_value() {
  return type_default_value_;
}

const tremolo::default_x_optional &tremolo::default_x() const {
  return this->default_x_;
}

tremolo::default_x_optional &tremolo::default_x() { return this->default_x_; }

void tremolo::default_x(const default_x_type &x) { this->default_x_.set(x); }

void tremolo::default_x(const default_x_optional &x) { this->default_x_ = x; }

void tremolo::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const tremolo::default_y_optional &tremolo::default_y() const {
  return this->default_y_;
}

tremolo::default_y_optional &tremolo::default_y() { return this->default_y_; }

void tremolo::default_y(const default_y_type &x) { this->default_y_.set(x); }

void tremolo::default_y(const default_y_optional &x) { this->default_y_ = x; }

void tremolo::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const tremolo::relative_x_optional &tremolo::relative_x() const {
  return this->relative_x_;
}

tremolo::relative_x_optional &tremolo::relative_x() {
  return this->relative_x_;
}

void tremolo::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void tremolo::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void tremolo::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const tremolo::relative_y_optional &tremolo::relative_y() const {
  return this->relative_y_;
}

tremolo::relative_y_optional &tremolo::relative_y() {
  return this->relative_y_;
}

void tremolo::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void tremolo::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void tremolo::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const tremolo::font_family_optional &tremolo::font_family() const {
  return this->font_family_;
}

tremolo::font_family_optional &tremolo::font_family() {
  return this->font_family_;
}

void tremolo::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void tremolo::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void tremolo::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const tremolo::font_style_optional &tremolo::font_style() const {
  return this->font_style_;
}

tremolo::font_style_optional &tremolo::font_style() {
  return this->font_style_;
}

void tremolo::font_style(const font_style_type &x) { this->font_style_.set(x); }

void tremolo::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void tremolo::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const tremolo::font_size_optional &tremolo::font_size() const {
  return this->font_size_;
}

tremolo::font_size_optional &tremolo::font_size() { return this->font_size_; }

void tremolo::font_size(const font_size_type &x) { this->font_size_.set(x); }

void tremolo::font_size(const font_size_optional &x) { this->font_size_ = x; }

void tremolo::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const tremolo::font_weight_optional &tremolo::font_weight() const {
  return this->font_weight_;
}

tremolo::font_weight_optional &tremolo::font_weight() {
  return this->font_weight_;
}

void tremolo::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void tremolo::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void tremolo::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const tremolo::color_optional &tremolo::color() const { return this->color_; }

tremolo::color_optional &tremolo::color() { return this->color_; }

void tremolo::color(const color_type &x) { this->color_.set(x); }

void tremolo::color(const color_optional &x) { this->color_ = x; }

void tremolo::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const tremolo::placement_optional &tremolo::placement() const {
  return this->placement_;
}

tremolo::placement_optional &tremolo::placement() { return this->placement_; }

void tremolo::placement(const placement_type &x) { this->placement_.set(x); }

void tremolo::placement(const placement_optional &x) { this->placement_ = x; }

void tremolo::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// tuplet
//

const tuplet::tuplet_actual_optional &tuplet::tuplet_actual() const {
  return this->tuplet_actual_;
}

tuplet::tuplet_actual_optional &tuplet::tuplet_actual() {
  return this->tuplet_actual_;
}

void tuplet::tuplet_actual(const tuplet_actual_type &x) {
  this->tuplet_actual_.set(x);
}

void tuplet::tuplet_actual(const tuplet_actual_optional &x) {
  this->tuplet_actual_ = x;
}

void tuplet::tuplet_actual(::std::unique_ptr<tuplet_actual_type> x) {
  this->tuplet_actual_.set(std::move(x));
}

const tuplet::tuplet_normal_optional &tuplet::tuplet_normal() const {
  return this->tuplet_normal_;
}

tuplet::tuplet_normal_optional &tuplet::tuplet_normal() {
  return this->tuplet_normal_;
}

void tuplet::tuplet_normal(const tuplet_normal_type &x) {
  this->tuplet_normal_.set(x);
}

void tuplet::tuplet_normal(const tuplet_normal_optional &x) {
  this->tuplet_normal_ = x;
}

void tuplet::tuplet_normal(::std::unique_ptr<tuplet_normal_type> x) {
  this->tuplet_normal_.set(std::move(x));
}

const tuplet::type_type &tuplet::type() const { return this->type_.get(); }

tuplet::type_type &tuplet::type() { return this->type_.get(); }

void tuplet::type(const type_type &x) { this->type_.set(x); }

void tuplet::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const tuplet::number_optional &tuplet::number() const { return this->number_; }

tuplet::number_optional &tuplet::number() { return this->number_; }

void tuplet::number(const number_type &x) { this->number_.set(x); }

void tuplet::number(const number_optional &x) { this->number_ = x; }

void tuplet::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const tuplet::bracket_optional &tuplet::bracket() const {
  return this->bracket_;
}

tuplet::bracket_optional &tuplet::bracket() { return this->bracket_; }

void tuplet::bracket(const bracket_type &x) { this->bracket_.set(x); }

void tuplet::bracket(const bracket_optional &x) { this->bracket_ = x; }

void tuplet::bracket(::std::unique_ptr<bracket_type> x) {
  this->bracket_.set(std::move(x));
}

const tuplet::show_number_optional &tuplet::show_number() const {
  return this->show_number_;
}

tuplet::show_number_optional &tuplet::show_number() {
  return this->show_number_;
}

void tuplet::show_number(const show_number_type &x) {
  this->show_number_.set(x);
}

void tuplet::show_number(const show_number_optional &x) {
  this->show_number_ = x;
}

void tuplet::show_number(::std::unique_ptr<show_number_type> x) {
  this->show_number_.set(std::move(x));
}

const tuplet::show_type_optional &tuplet::show_type() const {
  return this->show_type_;
}

tuplet::show_type_optional &tuplet::show_type() { return this->show_type_; }

void tuplet::show_type(const show_type_type &x) { this->show_type_.set(x); }

void tuplet::show_type(const show_type_optional &x) { this->show_type_ = x; }

void tuplet::show_type(::std::unique_ptr<show_type_type> x) {
  this->show_type_.set(std::move(x));
}

const tuplet::line_shape_optional &tuplet::line_shape() const {
  return this->line_shape_;
}

tuplet::line_shape_optional &tuplet::line_shape() { return this->line_shape_; }

void tuplet::line_shape(const line_shape_type &x) { this->line_shape_.set(x); }

void tuplet::line_shape(const line_shape_optional &x) { this->line_shape_ = x; }

void tuplet::line_shape(::std::unique_ptr<line_shape_type> x) {
  this->line_shape_.set(std::move(x));
}

const tuplet::default_x_optional &tuplet::default_x() const {
  return this->default_x_;
}

tuplet::default_x_optional &tuplet::default_x() { return this->default_x_; }

void tuplet::default_x(const default_x_type &x) { this->default_x_.set(x); }

void tuplet::default_x(const default_x_optional &x) { this->default_x_ = x; }

void tuplet::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const tuplet::default_y_optional &tuplet::default_y() const {
  return this->default_y_;
}

tuplet::default_y_optional &tuplet::default_y() { return this->default_y_; }

void tuplet::default_y(const default_y_type &x) { this->default_y_.set(x); }

void tuplet::default_y(const default_y_optional &x) { this->default_y_ = x; }

void tuplet::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const tuplet::relative_x_optional &tuplet::relative_x() const {
  return this->relative_x_;
}

tuplet::relative_x_optional &tuplet::relative_x() { return this->relative_x_; }

void tuplet::relative_x(const relative_x_type &x) { this->relative_x_.set(x); }

void tuplet::relative_x(const relative_x_optional &x) { this->relative_x_ = x; }

void tuplet::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const tuplet::relative_y_optional &tuplet::relative_y() const {
  return this->relative_y_;
}

tuplet::relative_y_optional &tuplet::relative_y() { return this->relative_y_; }

void tuplet::relative_y(const relative_y_type &x) { this->relative_y_.set(x); }

void tuplet::relative_y(const relative_y_optional &x) { this->relative_y_ = x; }

void tuplet::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const tuplet::placement_optional &tuplet::placement() const {
  return this->placement_;
}

tuplet::placement_optional &tuplet::placement() { return this->placement_; }

void tuplet::placement(const placement_type &x) { this->placement_.set(x); }

void tuplet::placement(const placement_optional &x) { this->placement_ = x; }

void tuplet::placement(::std::unique_ptr<placement_type> x) {
  this->placement_.set(std::move(x));
}

// tuplet_dot
//

const tuplet_dot::font_family_optional &tuplet_dot::font_family() const {
  return this->font_family_;
}

tuplet_dot::font_family_optional &tuplet_dot::font_family() {
  return this->font_family_;
}

void tuplet_dot::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void tuplet_dot::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void tuplet_dot::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const tuplet_dot::font_style_optional &tuplet_dot::font_style() const {
  return this->font_style_;
}

tuplet_dot::font_style_optional &tuplet_dot::font_style() {
  return this->font_style_;
}

void tuplet_dot::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void tuplet_dot::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void tuplet_dot::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const tuplet_dot::font_size_optional &tuplet_dot::font_size() const {
  return this->font_size_;
}

tuplet_dot::font_size_optional &tuplet_dot::font_size() {
  return this->font_size_;
}

void tuplet_dot::font_size(const font_size_type &x) { this->font_size_.set(x); }

void tuplet_dot::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void tuplet_dot::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const tuplet_dot::font_weight_optional &tuplet_dot::font_weight() const {
  return this->font_weight_;
}

tuplet_dot::font_weight_optional &tuplet_dot::font_weight() {
  return this->font_weight_;
}

void tuplet_dot::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void tuplet_dot::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void tuplet_dot::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const tuplet_dot::color_optional &tuplet_dot::color() const {
  return this->color_;
}

tuplet_dot::color_optional &tuplet_dot::color() { return this->color_; }

void tuplet_dot::color(const color_type &x) { this->color_.set(x); }

void tuplet_dot::color(const color_optional &x) { this->color_ = x; }

void tuplet_dot::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// tuplet_number
//

const tuplet_number::font_family_optional &tuplet_number::font_family() const {
  return this->font_family_;
}

tuplet_number::font_family_optional &tuplet_number::font_family() {
  return this->font_family_;
}

void tuplet_number::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void tuplet_number::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void tuplet_number::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const tuplet_number::font_style_optional &tuplet_number::font_style() const {
  return this->font_style_;
}

tuplet_number::font_style_optional &tuplet_number::font_style() {
  return this->font_style_;
}

void tuplet_number::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void tuplet_number::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void tuplet_number::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const tuplet_number::font_size_optional &tuplet_number::font_size() const {
  return this->font_size_;
}

tuplet_number::font_size_optional &tuplet_number::font_size() {
  return this->font_size_;
}

void tuplet_number::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void tuplet_number::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void tuplet_number::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const tuplet_number::font_weight_optional &tuplet_number::font_weight() const {
  return this->font_weight_;
}

tuplet_number::font_weight_optional &tuplet_number::font_weight() {
  return this->font_weight_;
}

void tuplet_number::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void tuplet_number::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void tuplet_number::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const tuplet_number::color_optional &tuplet_number::color() const {
  return this->color_;
}

tuplet_number::color_optional &tuplet_number::color() { return this->color_; }

void tuplet_number::color(const color_type &x) { this->color_.set(x); }

void tuplet_number::color(const color_optional &x) { this->color_ = x; }

void tuplet_number::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// tuplet_portion
//

const tuplet_portion::tuplet_number_optional &
tuplet_portion::tuplet_number() const {
  return this->tuplet_number_;
}

tuplet_portion::tuplet_number_optional &tuplet_portion::tuplet_number() {
  return this->tuplet_number_;
}

void tuplet_portion::tuplet_number(const tuplet_number_type &x) {
  this->tuplet_number_.set(x);
}

void tuplet_portion::tuplet_number(const tuplet_number_optional &x) {
  this->tuplet_number_ = x;
}

void tuplet_portion::tuplet_number(::std::unique_ptr<tuplet_number_type> x) {
  this->tuplet_number_.set(std::move(x));
}

const tuplet_portion::tuplet_type_optional &
tuplet_portion::tuplet_type() const {
  return this->tuplet_type_;
}

tuplet_portion::tuplet_type_optional &tuplet_portion::tuplet_type() {
  return this->tuplet_type_;
}

void tuplet_portion::tuplet_type(const tuplet_type_type &x) {
  this->tuplet_type_.set(x);
}

void tuplet_portion::tuplet_type(const tuplet_type_optional &x) {
  this->tuplet_type_ = x;
}

void tuplet_portion::tuplet_type(::std::unique_ptr<tuplet_type_type> x) {
  this->tuplet_type_.set(std::move(x));
}

const tuplet_portion::tuplet_dot_sequence &tuplet_portion::tuplet_dot() const {
  return this->tuplet_dot_;
}

tuplet_portion::tuplet_dot_sequence &tuplet_portion::tuplet_dot() {
  return this->tuplet_dot_;
}

void tuplet_portion::tuplet_dot(const tuplet_dot_sequence &s) {
  this->tuplet_dot_ = s;
}

// tuplet_type
//

const tuplet_type::font_family_optional &tuplet_type::font_family() const {
  return this->font_family_;
}

tuplet_type::font_family_optional &tuplet_type::font_family() {
  return this->font_family_;
}

void tuplet_type::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void tuplet_type::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void tuplet_type::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const tuplet_type::font_style_optional &tuplet_type::font_style() const {
  return this->font_style_;
}

tuplet_type::font_style_optional &tuplet_type::font_style() {
  return this->font_style_;
}

void tuplet_type::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void tuplet_type::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void tuplet_type::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const tuplet_type::font_size_optional &tuplet_type::font_size() const {
  return this->font_size_;
}

tuplet_type::font_size_optional &tuplet_type::font_size() {
  return this->font_size_;
}

void tuplet_type::font_size(const font_size_type &x) {
  this->font_size_.set(x);
}

void tuplet_type::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void tuplet_type::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const tuplet_type::font_weight_optional &tuplet_type::font_weight() const {
  return this->font_weight_;
}

tuplet_type::font_weight_optional &tuplet_type::font_weight() {
  return this->font_weight_;
}

void tuplet_type::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void tuplet_type::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void tuplet_type::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const tuplet_type::color_optional &tuplet_type::color() const {
  return this->color_;
}

tuplet_type::color_optional &tuplet_type::color() { return this->color_; }

void tuplet_type::color(const color_type &x) { this->color_.set(x); }

void tuplet_type::color(const color_optional &x) { this->color_ = x; }

void tuplet_type::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// unpitched
//

const unpitched::display_step_optional &unpitched::display_step() const {
  return this->display_step_;
}

unpitched::display_step_optional &unpitched::display_step() {
  return this->display_step_;
}

void unpitched::display_step(const display_step_type &x) {
  this->display_step_.set(x);
}

void unpitched::display_step(const display_step_optional &x) {
  this->display_step_ = x;
}

void unpitched::display_step(::std::unique_ptr<display_step_type> x) {
  this->display_step_.set(std::move(x));
}

const unpitched::display_octave_optional &unpitched::display_octave() const {
  return this->display_octave_;
}

unpitched::display_octave_optional &unpitched::display_octave() {
  return this->display_octave_;
}

void unpitched::display_octave(const display_octave_type &x) {
  this->display_octave_.set(x);
}

void unpitched::display_octave(const display_octave_optional &x) {
  this->display_octave_ = x;
}

void unpitched::display_octave(::std::unique_ptr<display_octave_type> x) {
  this->display_octave_.set(std::move(x));
}

// credit
//

const credit::credit_type_sequence &credit::credit_type() const {
  return this->credit_type_;
}

credit::credit_type_sequence &credit::credit_type() {
  return this->credit_type_;
}

void credit::credit_type(const credit_type_sequence &s) {
  this->credit_type_ = s;
}

const credit::link_sequence &credit::link() const { return this->link_; }

credit::link_sequence &credit::link() { return this->link_; }

void credit::link(const link_sequence &s) { this->link_ = s; }

const credit::bookmark_sequence &credit::bookmark() const {
  return this->bookmark_;
}

credit::bookmark_sequence &credit::bookmark() { return this->bookmark_; }

void credit::bookmark(const bookmark_sequence &s) { this->bookmark_ = s; }

const credit::credit_image_optional &credit::credit_image() const {
  return this->credit_image_;
}

credit::credit_image_optional &credit::credit_image() {
  return this->credit_image_;
}

void credit::credit_image(const credit_image_type &x) {
  this->credit_image_.set(x);
}

void credit::credit_image(const credit_image_optional &x) {
  this->credit_image_ = x;
}

void credit::credit_image(::std::unique_ptr<credit_image_type> x) {
  this->credit_image_.set(std::move(x));
}

const credit::credit_words_sequence &credit::credit_words() const {
  return this->credit_words_;
}

credit::credit_words_sequence &credit::credit_words() {
  return this->credit_words_;
}

void credit::credit_words(const credit_words_sequence &s) {
  this->credit_words_ = s;
}

const credit::page_optional &credit::page() const { return this->page_; }

credit::page_optional &credit::page() { return this->page_; }

void credit::page(const page_type &x) { this->page_.set(x); }

void credit::page(const page_optional &x) { this->page_ = x; }

// defaults
//

const defaults::scaling_optional &defaults::scaling() const {
  return this->scaling_;
}

defaults::scaling_optional &defaults::scaling() { return this->scaling_; }

void defaults::scaling(const scaling_type &x) { this->scaling_.set(x); }

void defaults::scaling(const scaling_optional &x) { this->scaling_ = x; }

void defaults::scaling(::std::unique_ptr<scaling_type> x) {
  this->scaling_.set(std::move(x));
}

const defaults::page_layout_optional &defaults::page_layout() const {
  return this->page_layout_;
}

defaults::page_layout_optional &defaults::page_layout() {
  return this->page_layout_;
}

void defaults::page_layout(const page_layout_type &x) {
  this->page_layout_.set(x);
}

void defaults::page_layout(const page_layout_optional &x) {
  this->page_layout_ = x;
}

void defaults::page_layout(::std::unique_ptr<page_layout_type> x) {
  this->page_layout_.set(std::move(x));
}

const defaults::system_layout_optional &defaults::system_layout() const {
  return this->system_layout_;
}

defaults::system_layout_optional &defaults::system_layout() {
  return this->system_layout_;
}

void defaults::system_layout(const system_layout_type &x) {
  this->system_layout_.set(x);
}

void defaults::system_layout(const system_layout_optional &x) {
  this->system_layout_ = x;
}

void defaults::system_layout(::std::unique_ptr<system_layout_type> x) {
  this->system_layout_.set(std::move(x));
}

const defaults::staff_layout_sequence &defaults::staff_layout() const {
  return this->staff_layout_;
}

defaults::staff_layout_sequence &defaults::staff_layout() {
  return this->staff_layout_;
}

void defaults::staff_layout(const staff_layout_sequence &s) {
  this->staff_layout_ = s;
}

const defaults::appearance_optional &defaults::appearance() const {
  return this->appearance_;
}

defaults::appearance_optional &defaults::appearance() {
  return this->appearance_;
}

void defaults::appearance(const appearance_type &x) {
  this->appearance_.set(x);
}

void defaults::appearance(const appearance_optional &x) {
  this->appearance_ = x;
}

void defaults::appearance(::std::unique_ptr<appearance_type> x) {
  this->appearance_.set(std::move(x));
}

const defaults::music_font_optional &defaults::music_font() const {
  return this->music_font_;
}

defaults::music_font_optional &defaults::music_font() {
  return this->music_font_;
}

void defaults::music_font(const music_font_type &x) {
  this->music_font_.set(x);
}

void defaults::music_font(const music_font_optional &x) {
  this->music_font_ = x;
}

void defaults::music_font(::std::unique_ptr<music_font_type> x) {
  this->music_font_.set(std::move(x));
}

const defaults::word_font_optional &defaults::word_font() const {
  return this->word_font_;
}

defaults::word_font_optional &defaults::word_font() { return this->word_font_; }

void defaults::word_font(const word_font_type &x) { this->word_font_.set(x); }

void defaults::word_font(const word_font_optional &x) { this->word_font_ = x; }

void defaults::word_font(::std::unique_ptr<word_font_type> x) {
  this->word_font_.set(std::move(x));
}

const defaults::lyric_font_sequence &defaults::lyric_font() const {
  return this->lyric_font_;
}

defaults::lyric_font_sequence &defaults::lyric_font() {
  return this->lyric_font_;
}

void defaults::lyric_font(const lyric_font_sequence &s) {
  this->lyric_font_ = s;
}

const defaults::lyric_language_sequence &defaults::lyric_language() const {
  return this->lyric_language_;
}

defaults::lyric_language_sequence &defaults::lyric_language() {
  return this->lyric_language_;
}

void defaults::lyric_language(const lyric_language_sequence &s) {
  this->lyric_language_ = s;
}

// empty_font
//

const empty_font::font_family_optional &empty_font::font_family() const {
  return this->font_family_;
}

empty_font::font_family_optional &empty_font::font_family() {
  return this->font_family_;
}

void empty_font::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void empty_font::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void empty_font::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const empty_font::font_style_optional &empty_font::font_style() const {
  return this->font_style_;
}

empty_font::font_style_optional &empty_font::font_style() {
  return this->font_style_;
}

void empty_font::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void empty_font::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void empty_font::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const empty_font::font_size_optional &empty_font::font_size() const {
  return this->font_size_;
}

empty_font::font_size_optional &empty_font::font_size() {
  return this->font_size_;
}

void empty_font::font_size(const font_size_type &x) { this->font_size_.set(x); }

void empty_font::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void empty_font::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const empty_font::font_weight_optional &empty_font::font_weight() const {
  return this->font_weight_;
}

empty_font::font_weight_optional &empty_font::font_weight() {
  return this->font_weight_;
}

void empty_font::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void empty_font::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void empty_font::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

// group_barline
//

const group_barline::color_optional &group_barline::color() const {
  return this->color_;
}

group_barline::color_optional &group_barline::color() { return this->color_; }

void group_barline::color(const color_type &x) { this->color_.set(x); }

void group_barline::color(const color_optional &x) { this->color_ = x; }

void group_barline::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// group_name
//

const group_name::default_x_optional &group_name::default_x() const {
  return this->default_x_;
}

group_name::default_x_optional &group_name::default_x() {
  return this->default_x_;
}

void group_name::default_x(const default_x_type &x) { this->default_x_.set(x); }

void group_name::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void group_name::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const group_name::default_y_optional &group_name::default_y() const {
  return this->default_y_;
}

group_name::default_y_optional &group_name::default_y() {
  return this->default_y_;
}

void group_name::default_y(const default_y_type &x) { this->default_y_.set(x); }

void group_name::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void group_name::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const group_name::relative_x_optional &group_name::relative_x() const {
  return this->relative_x_;
}

group_name::relative_x_optional &group_name::relative_x() {
  return this->relative_x_;
}

void group_name::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void group_name::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void group_name::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const group_name::relative_y_optional &group_name::relative_y() const {
  return this->relative_y_;
}

group_name::relative_y_optional &group_name::relative_y() {
  return this->relative_y_;
}

void group_name::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void group_name::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void group_name::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const group_name::font_family_optional &group_name::font_family() const {
  return this->font_family_;
}

group_name::font_family_optional &group_name::font_family() {
  return this->font_family_;
}

void group_name::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void group_name::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void group_name::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const group_name::font_style_optional &group_name::font_style() const {
  return this->font_style_;
}

group_name::font_style_optional &group_name::font_style() {
  return this->font_style_;
}

void group_name::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void group_name::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void group_name::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const group_name::font_size_optional &group_name::font_size() const {
  return this->font_size_;
}

group_name::font_size_optional &group_name::font_size() {
  return this->font_size_;
}

void group_name::font_size(const font_size_type &x) { this->font_size_.set(x); }

void group_name::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void group_name::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const group_name::font_weight_optional &group_name::font_weight() const {
  return this->font_weight_;
}

group_name::font_weight_optional &group_name::font_weight() {
  return this->font_weight_;
}

void group_name::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void group_name::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void group_name::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const group_name::color_optional &group_name::color() const {
  return this->color_;
}

group_name::color_optional &group_name::color() { return this->color_; }

void group_name::color(const color_type &x) { this->color_.set(x); }

void group_name::color(const color_optional &x) { this->color_ = x; }

void group_name::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const group_name::justify_optional &group_name::justify() const {
  return this->justify_;
}

group_name::justify_optional &group_name::justify() { return this->justify_; }

void group_name::justify(const justify_type &x) { this->justify_.set(x); }

void group_name::justify(const justify_optional &x) { this->justify_ = x; }

void group_name::justify(::std::unique_ptr<justify_type> x) {
  this->justify_.set(std::move(x));
}

// group_symbol
//

const group_symbol::default_x_optional &group_symbol::default_x() const {
  return this->default_x_;
}

group_symbol::default_x_optional &group_symbol::default_x() {
  return this->default_x_;
}

void group_symbol::default_x(const default_x_type &x) {
  this->default_x_.set(x);
}

void group_symbol::default_x(const default_x_optional &x) {
  this->default_x_ = x;
}

void group_symbol::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const group_symbol::default_y_optional &group_symbol::default_y() const {
  return this->default_y_;
}

group_symbol::default_y_optional &group_symbol::default_y() {
  return this->default_y_;
}

void group_symbol::default_y(const default_y_type &x) {
  this->default_y_.set(x);
}

void group_symbol::default_y(const default_y_optional &x) {
  this->default_y_ = x;
}

void group_symbol::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const group_symbol::relative_x_optional &group_symbol::relative_x() const {
  return this->relative_x_;
}

group_symbol::relative_x_optional &group_symbol::relative_x() {
  return this->relative_x_;
}

void group_symbol::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void group_symbol::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void group_symbol::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const group_symbol::relative_y_optional &group_symbol::relative_y() const {
  return this->relative_y_;
}

group_symbol::relative_y_optional &group_symbol::relative_y() {
  return this->relative_y_;
}

void group_symbol::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void group_symbol::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void group_symbol::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const group_symbol::color_optional &group_symbol::color() const {
  return this->color_;
}

group_symbol::color_optional &group_symbol::color() { return this->color_; }

void group_symbol::color(const color_type &x) { this->color_.set(x); }

void group_symbol::color(const color_optional &x) { this->color_ = x; }

void group_symbol::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

// lyric_font
//

const lyric_font::number_optional &lyric_font::number() const {
  return this->number_;
}

lyric_font::number_optional &lyric_font::number() { return this->number_; }

void lyric_font::number(const number_type &x) { this->number_.set(x); }

void lyric_font::number(const number_optional &x) { this->number_ = x; }

void lyric_font::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const lyric_font::name_optional &lyric_font::name() const {
  return this->name_;
}

lyric_font::name_optional &lyric_font::name() { return this->name_; }

void lyric_font::name(const name_type &x) { this->name_.set(x); }

void lyric_font::name(const name_optional &x) { this->name_ = x; }

void lyric_font::name(::std::unique_ptr<name_type> x) {
  this->name_.set(std::move(x));
}

const lyric_font::font_family_optional &lyric_font::font_family() const {
  return this->font_family_;
}

lyric_font::font_family_optional &lyric_font::font_family() {
  return this->font_family_;
}

void lyric_font::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void lyric_font::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void lyric_font::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const lyric_font::font_style_optional &lyric_font::font_style() const {
  return this->font_style_;
}

lyric_font::font_style_optional &lyric_font::font_style() {
  return this->font_style_;
}

void lyric_font::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void lyric_font::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void lyric_font::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const lyric_font::font_size_optional &lyric_font::font_size() const {
  return this->font_size_;
}

lyric_font::font_size_optional &lyric_font::font_size() {
  return this->font_size_;
}

void lyric_font::font_size(const font_size_type &x) { this->font_size_.set(x); }

void lyric_font::font_size(const font_size_optional &x) {
  this->font_size_ = x;
}

void lyric_font::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const lyric_font::font_weight_optional &lyric_font::font_weight() const {
  return this->font_weight_;
}

lyric_font::font_weight_optional &lyric_font::font_weight() {
  return this->font_weight_;
}

void lyric_font::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void lyric_font::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void lyric_font::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

// lyric_language
//

const lyric_language::number_optional &lyric_language::number() const {
  return this->number_;
}

lyric_language::number_optional &lyric_language::number() {
  return this->number_;
}

void lyric_language::number(const number_type &x) { this->number_.set(x); }

void lyric_language::number(const number_optional &x) { this->number_ = x; }

void lyric_language::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const lyric_language::name_optional &lyric_language::name() const {
  return this->name_;
}

lyric_language::name_optional &lyric_language::name() { return this->name_; }

void lyric_language::name(const name_type &x) { this->name_.set(x); }

void lyric_language::name(const name_optional &x) { this->name_ = x; }

void lyric_language::name(::std::unique_ptr<name_type> x) {
  this->name_.set(std::move(x));
}

const lyric_language::lang_type &lyric_language::lang() const {
  return this->lang_.get();
}

lyric_language::lang_type &lyric_language::lang() { return this->lang_.get(); }

void lyric_language::lang(const lang_type &x) { this->lang_.set(x); }

void lyric_language::lang(::std::unique_ptr<lang_type> x) {
  this->lang_.set(std::move(x));
}

// opus
//

const opus::href_type &opus::href() const { return this->href_.get(); }

opus::href_type &opus::href() { return this->href_.get(); }

void opus::href(const href_type &x) { this->href_.set(x); }

void opus::href(::std::unique_ptr<href_type> x) {
  this->href_.set(std::move(x));
}

const opus::type_type &opus::type() const { return this->type_.get(); }

const opus::type_type &opus::type_default_value() {
  return type_default_value_;
}

const opus::role_optional &opus::role() const { return this->role_; }

opus::role_optional &opus::role() { return this->role_; }

void opus::role(const role_type &x) { this->role_.set(x); }

void opus::role(const role_optional &x) { this->role_ = x; }

void opus::role(::std::unique_ptr<role_type> x) {
  this->role_.set(std::move(x));
}

const opus::title_optional &opus::title() const { return this->title_; }

opus::title_optional &opus::title() { return this->title_; }

void opus::title(const title_type &x) { this->title_.set(x); }

void opus::title(const title_optional &x) { this->title_ = x; }

void opus::title(::std::unique_ptr<title_type> x) {
  this->title_.set(std::move(x));
}

const opus::show_type &opus::show() const { return this->show_.get(); }

opus::show_type &opus::show() { return this->show_.get(); }

void opus::show(const show_type &x) { this->show_.set(x); }

void opus::show(::std::unique_ptr<show_type> x) {
  this->show_.set(std::move(x));
}

const opus::show_type &opus::show_default_value() {
  return show_default_value_;
}

const opus::actuate_type &opus::actuate() const { return this->actuate_.get(); }

opus::actuate_type &opus::actuate() { return this->actuate_.get(); }

void opus::actuate(const actuate_type &x) { this->actuate_.set(x); }

void opus::actuate(::std::unique_ptr<actuate_type> x) {
  this->actuate_.set(std::move(x));
}

const opus::actuate_type &opus::actuate_default_value() {
  return actuate_default_value_;
}

// part_group
//

const part_group::group_name_optional &part_group::group_name() const {
  return this->group_name_;
}

part_group::group_name_optional &part_group::group_name() {
  return this->group_name_;
}

void part_group::group_name(const group_name_type &x) {
  this->group_name_.set(x);
}

void part_group::group_name(const group_name_optional &x) {
  this->group_name_ = x;
}

void part_group::group_name(::std::unique_ptr<group_name_type> x) {
  this->group_name_.set(std::move(x));
}

const part_group::group_name_display_optional &
part_group::group_name_display() const {
  return this->group_name_display_;
}

part_group::group_name_display_optional &part_group::group_name_display() {
  return this->group_name_display_;
}

void part_group::group_name_display(const group_name_display_type &x) {
  this->group_name_display_.set(x);
}

void part_group::group_name_display(const group_name_display_optional &x) {
  this->group_name_display_ = x;
}

void
part_group::group_name_display(::std::unique_ptr<group_name_display_type> x) {
  this->group_name_display_.set(std::move(x));
}

const part_group::group_abbreviation_optional &
part_group::group_abbreviation() const {
  return this->group_abbreviation_;
}

part_group::group_abbreviation_optional &part_group::group_abbreviation() {
  return this->group_abbreviation_;
}

void part_group::group_abbreviation(const group_abbreviation_type &x) {
  this->group_abbreviation_.set(x);
}

void part_group::group_abbreviation(const group_abbreviation_optional &x) {
  this->group_abbreviation_ = x;
}

void
part_group::group_abbreviation(::std::unique_ptr<group_abbreviation_type> x) {
  this->group_abbreviation_.set(std::move(x));
}

const part_group::group_abbreviation_display_optional &
part_group::group_abbreviation_display() const {
  return this->group_abbreviation_display_;
}

part_group::group_abbreviation_display_optional &
part_group::group_abbreviation_display() {
  return this->group_abbreviation_display_;
}

void part_group::group_abbreviation_display(
  const group_abbreviation_display_type &x) {
  this->group_abbreviation_display_.set(x);
}

void part_group::group_abbreviation_display(
  const group_abbreviation_display_optional &x) {
  this->group_abbreviation_display_ = x;
}

void part_group::group_abbreviation_display(
  ::std::unique_ptr<group_abbreviation_display_type> x) {
  this->group_abbreviation_display_.set(std::move(x));
}

const part_group::group_symbol_optional &part_group::group_symbol() const {
  return this->group_symbol_;
}

part_group::group_symbol_optional &part_group::group_symbol() {
  return this->group_symbol_;
}

void part_group::group_symbol(const group_symbol_type &x) {
  this->group_symbol_.set(x);
}

void part_group::group_symbol(const group_symbol_optional &x) {
  this->group_symbol_ = x;
}

void part_group::group_symbol(::std::unique_ptr<group_symbol_type> x) {
  this->group_symbol_.set(std::move(x));
}

const part_group::group_barline_optional &part_group::group_barline() const {
  return this->group_barline_;
}

part_group::group_barline_optional &part_group::group_barline() {
  return this->group_barline_;
}

void part_group::group_barline(const group_barline_type &x) {
  this->group_barline_.set(x);
}

void part_group::group_barline(const group_barline_optional &x) {
  this->group_barline_ = x;
}

void part_group::group_barline(::std::unique_ptr<group_barline_type> x) {
  this->group_barline_.set(std::move(x));
}

const part_group::group_time_optional &part_group::group_time() const {
  return this->group_time_;
}

part_group::group_time_optional &part_group::group_time() {
  return this->group_time_;
}

void part_group::group_time(const group_time_type &x) {
  this->group_time_.set(x);
}

void part_group::group_time(const group_time_optional &x) {
  this->group_time_ = x;
}

void part_group::group_time(::std::unique_ptr<group_time_type> x) {
  this->group_time_.set(std::move(x));
}

const part_group::footnote_optional &part_group::footnote() const {
  return this->footnote_;
}

part_group::footnote_optional &part_group::footnote() {
  return this->footnote_;
}

void part_group::footnote(const footnote_type &x) { this->footnote_.set(x); }

void part_group::footnote(const footnote_optional &x) { this->footnote_ = x; }

void part_group::footnote(::std::unique_ptr<footnote_type> x) {
  this->footnote_.set(std::move(x));
}

const part_group::level_optional &part_group::level() const {
  return this->level_;
}

part_group::level_optional &part_group::level() { return this->level_; }

void part_group::level(const level_type &x) { this->level_.set(x); }

void part_group::level(const level_optional &x) { this->level_ = x; }

void part_group::level(::std::unique_ptr<level_type> x) {
  this->level_.set(std::move(x));
}

const part_group::type_type &part_group::type() const {
  return this->type_.get();
}

part_group::type_type &part_group::type() { return this->type_.get(); }

void part_group::type(const type_type &x) { this->type_.set(x); }

void part_group::type(::std::unique_ptr<type_type> x) {
  this->type_.set(std::move(x));
}

const part_group::number_type &part_group::number() const {
  return this->number_.get();
}

part_group::number_type &part_group::number() { return this->number_.get(); }

void part_group::number(const number_type &x) { this->number_.set(x); }

void part_group::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const part_group::number_type &part_group::number_default_value() {
  return number_default_value_;
}

// part_list
//

const part_list::part_group_sequence &part_list::part_group() const {
  return this->part_group_;
}

part_list::part_group_sequence &part_list::part_group() {
  return this->part_group_;
}

void part_list::part_group(const part_group_sequence &s) {
  this->part_group_ = s;
}

const part_list::score_part_sequence &part_list::score_part() const {
  return this->score_part_;
}

part_list::score_part_sequence &part_list::score_part() {
  return this->score_part_;
}

void part_list::score_part(const score_part_sequence &s) {
  this->score_part_ = s;
}

// part_name
//

const part_name::default_x_optional &part_name::default_x() const {
  return this->default_x_;
}

part_name::default_x_optional &part_name::default_x() {
  return this->default_x_;
}

void part_name::default_x(const default_x_type &x) { this->default_x_.set(x); }

void part_name::default_x(const default_x_optional &x) { this->default_x_ = x; }

void part_name::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const part_name::default_y_optional &part_name::default_y() const {
  return this->default_y_;
}

part_name::default_y_optional &part_name::default_y() {
  return this->default_y_;
}

void part_name::default_y(const default_y_type &x) { this->default_y_.set(x); }

void part_name::default_y(const default_y_optional &x) { this->default_y_ = x; }

void part_name::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const part_name::relative_x_optional &part_name::relative_x() const {
  return this->relative_x_;
}

part_name::relative_x_optional &part_name::relative_x() {
  return this->relative_x_;
}

void part_name::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void part_name::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void part_name::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const part_name::relative_y_optional &part_name::relative_y() const {
  return this->relative_y_;
}

part_name::relative_y_optional &part_name::relative_y() {
  return this->relative_y_;
}

void part_name::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void part_name::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void part_name::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const part_name::font_family_optional &part_name::font_family() const {
  return this->font_family_;
}

part_name::font_family_optional &part_name::font_family() {
  return this->font_family_;
}

void part_name::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void part_name::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void part_name::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const part_name::font_style_optional &part_name::font_style() const {
  return this->font_style_;
}

part_name::font_style_optional &part_name::font_style() {
  return this->font_style_;
}

void part_name::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void part_name::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void part_name::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const part_name::font_size_optional &part_name::font_size() const {
  return this->font_size_;
}

part_name::font_size_optional &part_name::font_size() {
  return this->font_size_;
}

void part_name::font_size(const font_size_type &x) { this->font_size_.set(x); }

void part_name::font_size(const font_size_optional &x) { this->font_size_ = x; }

void part_name::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const part_name::font_weight_optional &part_name::font_weight() const {
  return this->font_weight_;
}

part_name::font_weight_optional &part_name::font_weight() {
  return this->font_weight_;
}

void part_name::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void part_name::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void part_name::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const part_name::color_optional &part_name::color() const {
  return this->color_;
}

part_name::color_optional &part_name::color() { return this->color_; }

void part_name::color(const color_type &x) { this->color_.set(x); }

void part_name::color(const color_optional &x) { this->color_ = x; }

void part_name::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const part_name::print_object_optional &part_name::print_object() const {
  return this->print_object_;
}

part_name::print_object_optional &part_name::print_object() {
  return this->print_object_;
}

void part_name::print_object(const print_object_type &x) {
  this->print_object_.set(x);
}

void part_name::print_object(const print_object_optional &x) {
  this->print_object_ = x;
}

void part_name::print_object(::std::unique_ptr<print_object_type> x) {
  this->print_object_.set(std::move(x));
}

const part_name::justify_optional &part_name::justify() const {
  return this->justify_;
}

part_name::justify_optional &part_name::justify() { return this->justify_; }

void part_name::justify(const justify_type &x) { this->justify_.set(x); }

void part_name::justify(const justify_optional &x) { this->justify_ = x; }

void part_name::justify(::std::unique_ptr<justify_type> x) {
  this->justify_.set(std::move(x));
}

// score_instrument
//

const score_instrument::instrument_name_type &
score_instrument::instrument_name() const {
  return this->instrument_name_.get();
}

score_instrument::instrument_name_type &score_instrument::instrument_name() {
  return this->instrument_name_.get();
}

void score_instrument::instrument_name(const instrument_name_type &x) {
  this->instrument_name_.set(x);
}

void
score_instrument::instrument_name(::std::unique_ptr<instrument_name_type> x) {
  this->instrument_name_.set(std::move(x));
}

const score_instrument::instrument_abbreviation_optional &
score_instrument::instrument_abbreviation() const {
  return this->instrument_abbreviation_;
}

score_instrument::instrument_abbreviation_optional &
score_instrument::instrument_abbreviation() {
  return this->instrument_abbreviation_;
}

void score_instrument::instrument_abbreviation(
  const instrument_abbreviation_type &x) {
  this->instrument_abbreviation_.set(x);
}

void score_instrument::instrument_abbreviation(
  const instrument_abbreviation_optional &x) {
  this->instrument_abbreviation_ = x;
}

void score_instrument::instrument_abbreviation(
  ::std::unique_ptr<instrument_abbreviation_type> x) {
  this->instrument_abbreviation_.set(std::move(x));
}

const score_instrument::instrument_sound_optional &
score_instrument::instrument_sound() const {
  return this->instrument_sound_;
}

score_instrument::instrument_sound_optional &
score_instrument::instrument_sound() {
  return this->instrument_sound_;
}

void score_instrument::instrument_sound(const instrument_sound_type &x) {
  this->instrument_sound_.set(x);
}

void score_instrument::instrument_sound(const instrument_sound_optional &x) {
  this->instrument_sound_ = x;
}

void
score_instrument::instrument_sound(::std::unique_ptr<instrument_sound_type> x) {
  this->instrument_sound_.set(std::move(x));
}

const score_instrument::solo_optional &score_instrument::solo() const {
  return this->solo_;
}

score_instrument::solo_optional &score_instrument::solo() {
  return this->solo_;
}

void score_instrument::solo(const solo_type &x) { this->solo_.set(x); }

void score_instrument::solo(const solo_optional &x) { this->solo_ = x; }

void score_instrument::solo(::std::unique_ptr<solo_type> x) {
  this->solo_.set(std::move(x));
}

const score_instrument::ensemble_optional &score_instrument::ensemble() const {
  return this->ensemble_;
}

score_instrument::ensemble_optional &score_instrument::ensemble() {
  return this->ensemble_;
}

void score_instrument::ensemble(const ensemble_type &x) {
  this->ensemble_.set(x);
}

void score_instrument::ensemble(const ensemble_optional &x) {
  this->ensemble_ = x;
}

void score_instrument::ensemble(::std::unique_ptr<ensemble_type> x) {
  this->ensemble_.set(std::move(x));
}

const score_instrument::virtual_instrument_optional &
score_instrument::virtual_instrument() const {
  return this->virtual_instrument_;
}

score_instrument::virtual_instrument_optional &
score_instrument::virtual_instrument() {
  return this->virtual_instrument_;
}

void score_instrument::virtual_instrument(const virtual_instrument_type &x) {
  this->virtual_instrument_.set(x);
}

void
score_instrument::virtual_instrument(const virtual_instrument_optional &x) {
  this->virtual_instrument_ = x;
}

void score_instrument::virtual_instrument(
  ::std::unique_ptr<virtual_instrument_type> x) {
  this->virtual_instrument_.set(std::move(x));
}

const score_instrument::id_type &score_instrument::id() const {
  return this->id_.get();
}

score_instrument::id_type &score_instrument::id() { return this->id_.get(); }

void score_instrument::id(const id_type &x) { this->id_.set(x); }

void score_instrument::id(::std::unique_ptr<id_type> x) {
  this->id_.set(std::move(x));
}

// score_part
//

const score_part::identification_optional &score_part::identification() const {
  return this->identification_;
}

score_part::identification_optional &score_part::identification() {
  return this->identification_;
}

void score_part::identification(const identification_type &x) {
  this->identification_.set(x);
}

void score_part::identification(const identification_optional &x) {
  this->identification_ = x;
}

void score_part::identification(::std::unique_ptr<identification_type> x) {
  this->identification_.set(std::move(x));
}

const score_part::part_name_type &score_part::part_name() const {
  return this->part_name_.get();
}

score_part::part_name_type &score_part::part_name() {
  return this->part_name_.get();
}

void score_part::part_name(const part_name_type &x) { this->part_name_.set(x); }

void score_part::part_name(::std::unique_ptr<part_name_type> x) {
  this->part_name_.set(std::move(x));
}

const score_part::part_name_display_optional &
score_part::part_name_display() const {
  return this->part_name_display_;
}

score_part::part_name_display_optional &score_part::part_name_display() {
  return this->part_name_display_;
}

void score_part::part_name_display(const part_name_display_type &x) {
  this->part_name_display_.set(x);
}

void score_part::part_name_display(const part_name_display_optional &x) {
  this->part_name_display_ = x;
}

void
score_part::part_name_display(::std::unique_ptr<part_name_display_type> x) {
  this->part_name_display_.set(std::move(x));
}

const score_part::part_abbreviation_optional &
score_part::part_abbreviation() const {
  return this->part_abbreviation_;
}

score_part::part_abbreviation_optional &score_part::part_abbreviation() {
  return this->part_abbreviation_;
}

void score_part::part_abbreviation(const part_abbreviation_type &x) {
  this->part_abbreviation_.set(x);
}

void score_part::part_abbreviation(const part_abbreviation_optional &x) {
  this->part_abbreviation_ = x;
}

void
score_part::part_abbreviation(::std::unique_ptr<part_abbreviation_type> x) {
  this->part_abbreviation_.set(std::move(x));
}

const score_part::part_abbreviation_display_optional &
score_part::part_abbreviation_display() const {
  return this->part_abbreviation_display_;
}

score_part::part_abbreviation_display_optional &
score_part::part_abbreviation_display() {
  return this->part_abbreviation_display_;
}

void
score_part::part_abbreviation_display(const part_abbreviation_display_type &x) {
  this->part_abbreviation_display_.set(x);
}

void score_part::part_abbreviation_display(
  const part_abbreviation_display_optional &x) {
  this->part_abbreviation_display_ = x;
}

void score_part::part_abbreviation_display(
  ::std::unique_ptr<part_abbreviation_display_type> x) {
  this->part_abbreviation_display_.set(std::move(x));
}

const score_part::group_sequence &score_part::group() const {
  return this->group_;
}

score_part::group_sequence &score_part::group() { return this->group_; }

void score_part::group(const group_sequence &s) { this->group_ = s; }

const score_part::score_instrument_sequence &
score_part::score_instrument() const {
  return this->score_instrument_;
}

score_part::score_instrument_sequence &score_part::score_instrument() {
  return this->score_instrument_;
}

void score_part::score_instrument(const score_instrument_sequence &s) {
  this->score_instrument_ = s;
}

const score_part::midi_device_sequence &score_part::midi_device() const {
  return this->midi_device_;
}

score_part::midi_device_sequence &score_part::midi_device() {
  return this->midi_device_;
}

void score_part::midi_device(const midi_device_sequence &s) {
  this->midi_device_ = s;
}

const score_part::midi_instrument_sequence &
score_part::midi_instrument() const {
  return this->midi_instrument_;
}

score_part::midi_instrument_sequence &score_part::midi_instrument() {
  return this->midi_instrument_;
}

void score_part::midi_instrument(const midi_instrument_sequence &s) {
  this->midi_instrument_ = s;
}

const score_part::id_type &score_part::id() const { return this->id_.get(); }

score_part::id_type &score_part::id() { return this->id_.get(); }

void score_part::id(const id_type &x) { this->id_.set(x); }

void score_part::id(::std::unique_ptr<id_type> x) {
  this->id_.set(std::move(x));
}

// virtual_instrument
//

const virtual_instrument::virtual_library_optional &
virtual_instrument::virtual_library() const {
  return this->virtual_library_;
}

virtual_instrument::virtual_library_optional &
virtual_instrument::virtual_library() {
  return this->virtual_library_;
}

void virtual_instrument::virtual_library(const virtual_library_type &x) {
  this->virtual_library_.set(x);
}

void virtual_instrument::virtual_library(const virtual_library_optional &x) {
  this->virtual_library_ = x;
}

void
virtual_instrument::virtual_library(::std::unique_ptr<virtual_library_type> x) {
  this->virtual_library_.set(std::move(x));
}

const virtual_instrument::virtual_name_optional &
virtual_instrument::virtual_name() const {
  return this->virtual_name_;
}

virtual_instrument::virtual_name_optional &virtual_instrument::virtual_name() {
  return this->virtual_name_;
}

void virtual_instrument::virtual_name(const virtual_name_type &x) {
  this->virtual_name_.set(x);
}

void virtual_instrument::virtual_name(const virtual_name_optional &x) {
  this->virtual_name_ = x;
}

void virtual_instrument::virtual_name(::std::unique_ptr<virtual_name_type> x) {
  this->virtual_name_.set(std::move(x));
}

// work
//

const work::work_number_optional &work::work_number() const {
  return this->work_number_;
}

work::work_number_optional &work::work_number() { return this->work_number_; }

void work::work_number(const work_number_type &x) { this->work_number_.set(x); }

void work::work_number(const work_number_optional &x) {
  this->work_number_ = x;
}

void work::work_number(::std::unique_ptr<work_number_type> x) {
  this->work_number_.set(std::move(x));
}

const work::work_title_optional &work::work_title() const {
  return this->work_title_;
}

work::work_title_optional &work::work_title() { return this->work_title_; }

void work::work_title(const work_title_type &x) { this->work_title_.set(x); }

void work::work_title(const work_title_optional &x) { this->work_title_ = x; }

void work::work_title(::std::unique_ptr<work_title_type> x) {
  this->work_title_.set(std::move(x));
}

const work::opus_optional &work::opus() const { return this->opus_; }

work::opus_optional &work::opus() { return this->opus_; }

void work::opus(const opus_type &x) { this->opus_.set(x); }

void work::opus(const opus_optional &x) { this->opus_ = x; }

void work::opus(::std::unique_ptr<opus_type> x) {
  this->opus_.set(std::move(x));
}

// number_or_normal_member
//

number_or_normal_member::number_or_normal_member(value v)
: ::xml_schema::token(_xsd_number_or_normal_member_literals_[v]) {}

number_or_normal_member::number_or_normal_member(const char *v)
: ::xml_schema::token(v) {}

number_or_normal_member::number_or_normal_member(const ::std::string &v)
: ::xml_schema::token(v) {}

number_or_normal_member::number_or_normal_member(const ::xml_schema::token &v)
: ::xml_schema::token(v) {}

number_or_normal_member::number_or_normal_member(
  const number_or_normal_member &v, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::token(v, f, c) {}

number_or_normal_member &number_or_normal_member::operator=(value v) {
  static_cast<::xml_schema::token &>(*this) =
    ::xml_schema::token(_xsd_number_or_normal_member_literals_[v]);

  return *this;
}

// positive_integer_or_empty_member
//

positive_integer_or_empty_member::positive_integer_or_empty_member(value v)
: ::xml_schema::string(_xsd_positive_integer_or_empty_member_literals_[v]) {}

positive_integer_or_empty_member::positive_integer_or_empty_member(
  const char *v)
: ::xml_schema::string(v) {}

positive_integer_or_empty_member::positive_integer_or_empty_member(
  const ::std::string &v)
: ::xml_schema::string(v) {}

positive_integer_or_empty_member::positive_integer_or_empty_member(
  const ::xml_schema::string &v)
: ::xml_schema::string(v) {}

positive_integer_or_empty_member::positive_integer_or_empty_member(
  const positive_integer_or_empty_member &v, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(v, f, c) {}

positive_integer_or_empty_member &positive_integer_or_empty_member::
operator=(value v) {
  static_cast<::xml_schema::string &>(*this) =
    ::xml_schema::string(_xsd_positive_integer_or_empty_member_literals_[v]);

  return *this;
}

// directive
//

const directive::default_x_optional &directive::default_x() const {
  return this->default_x_;
}

directive::default_x_optional &directive::default_x() {
  return this->default_x_;
}

void directive::default_x(const default_x_type &x) { this->default_x_.set(x); }

void directive::default_x(const default_x_optional &x) { this->default_x_ = x; }

void directive::default_x(::std::unique_ptr<default_x_type> x) {
  this->default_x_.set(std::move(x));
}

const directive::default_y_optional &directive::default_y() const {
  return this->default_y_;
}

directive::default_y_optional &directive::default_y() {
  return this->default_y_;
}

void directive::default_y(const default_y_type &x) { this->default_y_.set(x); }

void directive::default_y(const default_y_optional &x) { this->default_y_ = x; }

void directive::default_y(::std::unique_ptr<default_y_type> x) {
  this->default_y_.set(std::move(x));
}

const directive::relative_x_optional &directive::relative_x() const {
  return this->relative_x_;
}

directive::relative_x_optional &directive::relative_x() {
  return this->relative_x_;
}

void directive::relative_x(const relative_x_type &x) {
  this->relative_x_.set(x);
}

void directive::relative_x(const relative_x_optional &x) {
  this->relative_x_ = x;
}

void directive::relative_x(::std::unique_ptr<relative_x_type> x) {
  this->relative_x_.set(std::move(x));
}

const directive::relative_y_optional &directive::relative_y() const {
  return this->relative_y_;
}

directive::relative_y_optional &directive::relative_y() {
  return this->relative_y_;
}

void directive::relative_y(const relative_y_type &x) {
  this->relative_y_.set(x);
}

void directive::relative_y(const relative_y_optional &x) {
  this->relative_y_ = x;
}

void directive::relative_y(::std::unique_ptr<relative_y_type> x) {
  this->relative_y_.set(std::move(x));
}

const directive::font_family_optional &directive::font_family() const {
  return this->font_family_;
}

directive::font_family_optional &directive::font_family() {
  return this->font_family_;
}

void directive::font_family(const font_family_type &x) {
  this->font_family_.set(x);
}

void directive::font_family(const font_family_optional &x) {
  this->font_family_ = x;
}

void directive::font_family(::std::unique_ptr<font_family_type> x) {
  this->font_family_.set(std::move(x));
}

const directive::font_style_optional &directive::font_style() const {
  return this->font_style_;
}

directive::font_style_optional &directive::font_style() {
  return this->font_style_;
}

void directive::font_style(const font_style_type &x) {
  this->font_style_.set(x);
}

void directive::font_style(const font_style_optional &x) {
  this->font_style_ = x;
}

void directive::font_style(::std::unique_ptr<font_style_type> x) {
  this->font_style_.set(std::move(x));
}

const directive::font_size_optional &directive::font_size() const {
  return this->font_size_;
}

directive::font_size_optional &directive::font_size() {
  return this->font_size_;
}

void directive::font_size(const font_size_type &x) { this->font_size_.set(x); }

void directive::font_size(const font_size_optional &x) { this->font_size_ = x; }

void directive::font_size(::std::unique_ptr<font_size_type> x) {
  this->font_size_.set(std::move(x));
}

const directive::font_weight_optional &directive::font_weight() const {
  return this->font_weight_;
}

directive::font_weight_optional &directive::font_weight() {
  return this->font_weight_;
}

void directive::font_weight(const font_weight_type &x) {
  this->font_weight_.set(x);
}

void directive::font_weight(const font_weight_optional &x) {
  this->font_weight_ = x;
}

void directive::font_weight(::std::unique_ptr<font_weight_type> x) {
  this->font_weight_.set(std::move(x));
}

const directive::color_optional &directive::color() const {
  return this->color_;
}

directive::color_optional &directive::color() { return this->color_; }

void directive::color(const color_type &x) { this->color_.set(x); }

void directive::color(const color_optional &x) { this->color_ = x; }

void directive::color(::std::unique_ptr<color_type> x) {
  this->color_.set(std::move(x));
}

const directive::lang_optional &directive::lang() const { return this->lang_; }

directive::lang_optional &directive::lang() { return this->lang_; }

void directive::lang(const lang_type &x) { this->lang_.set(x); }

void directive::lang(const lang_optional &x) { this->lang_ = x; }

void directive::lang(::std::unique_ptr<lang_type> x) {
  this->lang_.set(std::move(x));
}

// score_partwise
//

const score_partwise::work_optional &score_partwise::work() const {
  return this->work_;
}

score_partwise::work_optional &score_partwise::work() { return this->work_; }

void score_partwise::work(const work_type &x) { this->work_.set(x); }

void score_partwise::work(const work_optional &x) { this->work_ = x; }

void score_partwise::work(::std::unique_ptr<work_type> x) {
  this->work_.set(std::move(x));
}

const score_partwise::movement_number_optional &
score_partwise::movement_number() const {
  return this->movement_number_;
}

score_partwise::movement_number_optional &score_partwise::movement_number() {
  return this->movement_number_;
}

void score_partwise::movement_number(const movement_number_type &x) {
  this->movement_number_.set(x);
}

void score_partwise::movement_number(const movement_number_optional &x) {
  this->movement_number_ = x;
}

void
score_partwise::movement_number(::std::unique_ptr<movement_number_type> x) {
  this->movement_number_.set(std::move(x));
}

const score_partwise::movement_title_optional &
score_partwise::movement_title() const {
  return this->movement_title_;
}

score_partwise::movement_title_optional &score_partwise::movement_title() {
  return this->movement_title_;
}

void score_partwise::movement_title(const movement_title_type &x) {
  this->movement_title_.set(x);
}

void score_partwise::movement_title(const movement_title_optional &x) {
  this->movement_title_ = x;
}

void score_partwise::movement_title(::std::unique_ptr<movement_title_type> x) {
  this->movement_title_.set(std::move(x));
}

const score_partwise::identification_optional &
score_partwise::identification() const {
  return this->identification_;
}

score_partwise::identification_optional &score_partwise::identification() {
  return this->identification_;
}

void score_partwise::identification(const identification_type &x) {
  this->identification_.set(x);
}

void score_partwise::identification(const identification_optional &x) {
  this->identification_ = x;
}

void score_partwise::identification(::std::unique_ptr<identification_type> x) {
  this->identification_.set(std::move(x));
}

const score_partwise::defaults_optional &score_partwise::defaults() const {
  return this->defaults_;
}

score_partwise::defaults_optional &score_partwise::defaults() {
  return this->defaults_;
}

void score_partwise::defaults(const defaults_type &x) {
  this->defaults_.set(x);
}

void score_partwise::defaults(const defaults_optional &x) {
  this->defaults_ = x;
}

void score_partwise::defaults(::std::unique_ptr<defaults_type> x) {
  this->defaults_.set(std::move(x));
}

const score_partwise::credit_sequence &score_partwise::credit() const {
  return this->credit_;
}

score_partwise::credit_sequence &score_partwise::credit() {
  return this->credit_;
}

void score_partwise::credit(const credit_sequence &s) { this->credit_ = s; }

const score_partwise::part_list_type &score_partwise::part_list() const {
  return this->part_list_.get();
}

score_partwise::part_list_type &score_partwise::part_list() {
  return this->part_list_.get();
}

void score_partwise::part_list(const part_list_type &x) {
  this->part_list_.set(x);
}

void score_partwise::part_list(::std::unique_ptr<part_list_type> x) {
  this->part_list_.set(std::move(x));
}

const score_partwise::part_sequence &score_partwise::part() const {
  return this->part_;
}

score_partwise::part_sequence &score_partwise::part() { return this->part_; }

void score_partwise::part(const part_sequence &s) { this->part_ = s; }

const score_partwise::version_type &score_partwise::version() const {
  return this->version_.get();
}

score_partwise::version_type &score_partwise::version() {
  return this->version_.get();
}

void score_partwise::version(const version_type &x) { this->version_.set(x); }

void score_partwise::version(::std::unique_ptr<version_type> x) {
  this->version_.set(std::move(x));
}

const score_partwise::version_type &score_partwise::version_default_value() {
  return version_default_value_;
}

// score_timewise
//

const score_timewise::work_optional &score_timewise::work() const {
  return this->work_;
}

score_timewise::work_optional &score_timewise::work() { return this->work_; }

void score_timewise::work(const work_type &x) { this->work_.set(x); }

void score_timewise::work(const work_optional &x) { this->work_ = x; }

void score_timewise::work(::std::unique_ptr<work_type> x) {
  this->work_.set(std::move(x));
}

const score_timewise::movement_number_optional &
score_timewise::movement_number() const {
  return this->movement_number_;
}

score_timewise::movement_number_optional &score_timewise::movement_number() {
  return this->movement_number_;
}

void score_timewise::movement_number(const movement_number_type &x) {
  this->movement_number_.set(x);
}

void score_timewise::movement_number(const movement_number_optional &x) {
  this->movement_number_ = x;
}

void
score_timewise::movement_number(::std::unique_ptr<movement_number_type> x) {
  this->movement_number_.set(std::move(x));
}

const score_timewise::movement_title_optional &
score_timewise::movement_title() const {
  return this->movement_title_;
}

score_timewise::movement_title_optional &score_timewise::movement_title() {
  return this->movement_title_;
}

void score_timewise::movement_title(const movement_title_type &x) {
  this->movement_title_.set(x);
}

void score_timewise::movement_title(const movement_title_optional &x) {
  this->movement_title_ = x;
}

void score_timewise::movement_title(::std::unique_ptr<movement_title_type> x) {
  this->movement_title_.set(std::move(x));
}

const score_timewise::identification_optional &
score_timewise::identification() const {
  return this->identification_;
}

score_timewise::identification_optional &score_timewise::identification() {
  return this->identification_;
}

void score_timewise::identification(const identification_type &x) {
  this->identification_.set(x);
}

void score_timewise::identification(const identification_optional &x) {
  this->identification_ = x;
}

void score_timewise::identification(::std::unique_ptr<identification_type> x) {
  this->identification_.set(std::move(x));
}

const score_timewise::defaults_optional &score_timewise::defaults() const {
  return this->defaults_;
}

score_timewise::defaults_optional &score_timewise::defaults() {
  return this->defaults_;
}

void score_timewise::defaults(const defaults_type &x) {
  this->defaults_.set(x);
}

void score_timewise::defaults(const defaults_optional &x) {
  this->defaults_ = x;
}

void score_timewise::defaults(::std::unique_ptr<defaults_type> x) {
  this->defaults_.set(std::move(x));
}

const score_timewise::credit_sequence &score_timewise::credit() const {
  return this->credit_;
}

score_timewise::credit_sequence &score_timewise::credit() {
  return this->credit_;
}

void score_timewise::credit(const credit_sequence &s) { this->credit_ = s; }

const score_timewise::part_list_type &score_timewise::part_list() const {
  return this->part_list_.get();
}

score_timewise::part_list_type &score_timewise::part_list() {
  return this->part_list_.get();
}

void score_timewise::part_list(const part_list_type &x) {
  this->part_list_.set(x);
}

void score_timewise::part_list(::std::unique_ptr<part_list_type> x) {
  this->part_list_.set(std::move(x));
}

const score_timewise::measure_sequence &score_timewise::measure() const {
  return this->measure_;
}

score_timewise::measure_sequence &score_timewise::measure() {
  return this->measure_;
}

void score_timewise::measure(const measure_sequence &s) { this->measure_ = s; }

const score_timewise::version_type &score_timewise::version() const {
  return this->version_.get();
}

score_timewise::version_type &score_timewise::version() {
  return this->version_.get();
}

void score_timewise::version(const version_type &x) { this->version_.set(x); }

void score_timewise::version(::std::unique_ptr<version_type> x) {
  this->version_.set(std::move(x));
}

const score_timewise::version_type &score_timewise::version_default_value() {
  return version_default_value_;
}

// part
//

const part::measure_sequence &part::measure() const { return this->measure_; }

part::measure_sequence &part::measure() { return this->measure_; }

void part::measure(const measure_sequence &s) { this->measure_ = s; }

const part::id_type &part::id() const { return this->id_.get(); }

part::id_type &part::id() { return this->id_.get(); }

void part::id(const id_type &x) { this->id_.set(x); }

void part::id(::std::unique_ptr<id_type> x) { this->id_.set(std::move(x)); }

// measure
//

const measure::part_sequence &measure::part() const { return this->part_; }

measure::part_sequence &measure::part() { return this->part_; }

void measure::part(const part_sequence &s) { this->part_ = s; }

const measure::number_type &measure::number() const {
  return this->number_.get();
}

measure::number_type &measure::number() { return this->number_.get(); }

void measure::number(const number_type &x) { this->number_.set(x); }

void measure::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const measure::implicit_optional &measure::implicit() const {
  return this->implicit_;
}

measure::implicit_optional &measure::implicit() { return this->implicit_; }

void measure::implicit(const implicit_type &x) { this->implicit_.set(x); }

void measure::implicit(const implicit_optional &x) { this->implicit_ = x; }

void measure::implicit(::std::unique_ptr<implicit_type> x) {
  this->implicit_.set(std::move(x));
}

const measure::non_controlling_optional &measure::non_controlling() const {
  return this->non_controlling_;
}

measure::non_controlling_optional &measure::non_controlling() {
  return this->non_controlling_;
}

void measure::non_controlling(const non_controlling_type &x) {
  this->non_controlling_.set(x);
}

void measure::non_controlling(const non_controlling_optional &x) {
  this->non_controlling_ = x;
}

void measure::non_controlling(::std::unique_ptr<non_controlling_type> x) {
  this->non_controlling_.set(std::move(x));
}

const measure::width_optional &measure::width() const { return this->width_; }

measure::width_optional &measure::width() { return this->width_; }

void measure::width(const width_type &x) { this->width_.set(x); }

void measure::width(const width_optional &x) { this->width_ = x; }

void measure::width(::std::unique_ptr<width_type> x) {
  this->width_.set(std::move(x));
}

// measure1
//

const measure1::note_sequence &measure1::note() const { return this->note_; }

measure1::note_sequence &measure1::note() { return this->note_; }

void measure1::note(const note_sequence &s) { this->note_ = s; }

const measure1::backup_sequence &measure1::backup() const {
  return this->backup_;
}

measure1::backup_sequence &measure1::backup() { return this->backup_; }

void measure1::backup(const backup_sequence &s) { this->backup_ = s; }

const measure1::forward_sequence &measure1::forward() const {
  return this->forward_;
}

measure1::forward_sequence &measure1::forward() { return this->forward_; }

void measure1::forward(const forward_sequence &s) { this->forward_ = s; }

const measure1::direction_sequence &measure1::direction() const {
  return this->direction_;
}

measure1::direction_sequence &measure1::direction() { return this->direction_; }

void measure1::direction(const direction_sequence &s) { this->direction_ = s; }

const measure1::attributes_sequence &measure1::attributes() const {
  return this->attributes_;
}

measure1::attributes_sequence &measure1::attributes() {
  return this->attributes_;
}

void measure1::attributes(const attributes_sequence &s) {
  this->attributes_ = s;
}

const measure1::harmony_sequence &measure1::harmony() const {
  return this->harmony_;
}

measure1::harmony_sequence &measure1::harmony() { return this->harmony_; }

void measure1::harmony(const harmony_sequence &s) { this->harmony_ = s; }

const measure1::figured_bass_sequence &measure1::figured_bass() const {
  return this->figured_bass_;
}

measure1::figured_bass_sequence &measure1::figured_bass() {
  return this->figured_bass_;
}

void measure1::figured_bass(const figured_bass_sequence &s) {
  this->figured_bass_ = s;
}

const measure1::print_sequence &measure1::print() const { return this->print_; }

measure1::print_sequence &measure1::print() { return this->print_; }

void measure1::print(const print_sequence &s) { this->print_ = s; }

const measure1::sound_sequence &measure1::sound() const { return this->sound_; }

measure1::sound_sequence &measure1::sound() { return this->sound_; }

void measure1::sound(const sound_sequence &s) { this->sound_ = s; }

const measure1::barline_sequence &measure1::barline() const {
  return this->barline_;
}

measure1::barline_sequence &measure1::barline() { return this->barline_; }

void measure1::barline(const barline_sequence &s) { this->barline_ = s; }

const measure1::grouping_sequence &measure1::grouping() const {
  return this->grouping_;
}

measure1::grouping_sequence &measure1::grouping() { return this->grouping_; }

void measure1::grouping(const grouping_sequence &s) { this->grouping_ = s; }

const measure1::link_sequence &measure1::link() const { return this->link_; }

measure1::link_sequence &measure1::link() { return this->link_; }

void measure1::link(const link_sequence &s) { this->link_ = s; }

const measure1::bookmark_sequence &measure1::bookmark() const {
  return this->bookmark_;
}

measure1::bookmark_sequence &measure1::bookmark() { return this->bookmark_; }

void measure1::bookmark(const bookmark_sequence &s) { this->bookmark_ = s; }

const measure1::number_type &measure1::number() const {
  return this->number_.get();
}

measure1::number_type &measure1::number() { return this->number_.get(); }

void measure1::number(const number_type &x) { this->number_.set(x); }

void measure1::number(::std::unique_ptr<number_type> x) {
  this->number_.set(std::move(x));
}

const measure1::implicit_optional &measure1::implicit() const {
  return this->implicit_;
}

measure1::implicit_optional &measure1::implicit() { return this->implicit_; }

void measure1::implicit(const implicit_type &x) { this->implicit_.set(x); }

void measure1::implicit(const implicit_optional &x) { this->implicit_ = x; }

void measure1::implicit(::std::unique_ptr<implicit_type> x) {
  this->implicit_.set(std::move(x));
}

const measure1::non_controlling_optional &measure1::non_controlling() const {
  return this->non_controlling_;
}

measure1::non_controlling_optional &measure1::non_controlling() {
  return this->non_controlling_;
}

void measure1::non_controlling(const non_controlling_type &x) {
  this->non_controlling_.set(x);
}

void measure1::non_controlling(const non_controlling_optional &x) {
  this->non_controlling_ = x;
}

void measure1::non_controlling(::std::unique_ptr<non_controlling_type> x) {
  this->non_controlling_.set(std::move(x));
}

const measure1::width_optional &measure1::width() const { return this->width_; }

measure1::width_optional &measure1::width() { return this->width_; }

void measure1::width(const width_type &x) { this->width_.set(x); }

void measure1::width(const width_optional &x) { this->width_ = x; }

void measure1::width(::std::unique_ptr<width_type> x) {
  this->width_.set(std::move(x));
}

const measure1::content_order_sequence &measure1::content_order() const {
  return this->content_order_;
}

measure1::content_order_sequence &measure1::content_order() {
  return this->content_order_;
}

void measure1::content_order(const content_order_sequence &s) {
  this->content_order_ = s;
}

// part1
//

const part1::note_sequence &part1::note() const { return this->note_; }

part1::note_sequence &part1::note() { return this->note_; }

void part1::note(const note_sequence &s) { this->note_ = s; }

const part1::backup_sequence &part1::backup() const { return this->backup_; }

part1::backup_sequence &part1::backup() { return this->backup_; }

void part1::backup(const backup_sequence &s) { this->backup_ = s; }

const part1::forward_sequence &part1::forward() const { return this->forward_; }

part1::forward_sequence &part1::forward() { return this->forward_; }

void part1::forward(const forward_sequence &s) { this->forward_ = s; }

const part1::direction_sequence &part1::direction() const {
  return this->direction_;
}

part1::direction_sequence &part1::direction() { return this->direction_; }

void part1::direction(const direction_sequence &s) { this->direction_ = s; }

const part1::attributes_sequence &part1::attributes() const {
  return this->attributes_;
}

part1::attributes_sequence &part1::attributes() { return this->attributes_; }

void part1::attributes(const attributes_sequence &s) { this->attributes_ = s; }

const part1::harmony_sequence &part1::harmony() const { return this->harmony_; }

part1::harmony_sequence &part1::harmony() { return this->harmony_; }

void part1::harmony(const harmony_sequence &s) { this->harmony_ = s; }

const part1::figured_bass_sequence &part1::figured_bass() const {
  return this->figured_bass_;
}

part1::figured_bass_sequence &part1::figured_bass() {
  return this->figured_bass_;
}

void part1::figured_bass(const figured_bass_sequence &s) {
  this->figured_bass_ = s;
}

const part1::print_sequence &part1::print() const { return this->print_; }

part1::print_sequence &part1::print() { return this->print_; }

void part1::print(const print_sequence &s) { this->print_ = s; }

const part1::sound_sequence &part1::sound() const { return this->sound_; }

part1::sound_sequence &part1::sound() { return this->sound_; }

void part1::sound(const sound_sequence &s) { this->sound_ = s; }

const part1::barline_sequence &part1::barline() const { return this->barline_; }

part1::barline_sequence &part1::barline() { return this->barline_; }

void part1::barline(const barline_sequence &s) { this->barline_ = s; }

const part1::grouping_sequence &part1::grouping() const {
  return this->grouping_;
}

part1::grouping_sequence &part1::grouping() { return this->grouping_; }

void part1::grouping(const grouping_sequence &s) { this->grouping_ = s; }

const part1::link_sequence &part1::link() const { return this->link_; }

part1::link_sequence &part1::link() { return this->link_; }

void part1::link(const link_sequence &s) { this->link_ = s; }

const part1::bookmark_sequence &part1::bookmark() const {
  return this->bookmark_;
}

part1::bookmark_sequence &part1::bookmark() { return this->bookmark_; }

void part1::bookmark(const bookmark_sequence &s) { this->bookmark_ = s; }

const part1::id_type &part1::id() const { return this->id_.get(); }

part1::id_type &part1::id() { return this->id_.get(); }

void part1::id(const id_type &x) { this->id_.set(x); }

void part1::id(::std::unique_ptr<id_type> x) { this->id_.set(std::move(x)); }

const part1::content_order_sequence &part1::content_order() const {
  return this->content_order_;
}

part1::content_order_sequence &part1::content_order() {
  return this->content_order_;
}

void part1::content_order(const content_order_sequence &s) {
  this->content_order_ = s;
}
} // namespace musicxml

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace musicxml {
// above_below
//

above_below::above_below(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_above_below_convert();
}

above_below::above_below(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_above_below_convert();
}

above_below::above_below(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_above_below_convert();
}

above_below *above_below::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class above_below(*this, f, c);
}

above_below::value above_below::_xsd_above_below_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_above_below_literals_);
  const value *i(::std::lower_bound(_xsd_above_below_indexes_,
                                    _xsd_above_below_indexes_ + 2, *this, c));

  if (i == _xsd_above_below_indexes_ + 2 ||
      _xsd_above_below_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const above_below::_xsd_above_below_literals_[2] = {"above",
                                                                "below"};

const above_below::value above_below::_xsd_above_below_indexes_[2] = {
  ::musicxml::above_below::above, ::musicxml::above_below::below};

// beam_level
//

beam_level::beam_level(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base) {}

beam_level::beam_level(const beam_level &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

beam_level::beam_level(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

beam_level::beam_level(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

beam_level::beam_level(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

beam_level *beam_level::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class beam_level(*this, f, c);
}

beam_level::~beam_level() {}

// color
//

color::color() : ::xml_schema::token() {}

color::color(const char *_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

color::color(const ::std::string &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

color::color(const ::xml_schema::token &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

color::color(const color &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(x, f, c) {}

color::color(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {}

color::color(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {}

color::color(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {}

color *color::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class color(*this, f, c);
}

color::~color() {}

// comma_separated_text
//

comma_separated_text::comma_separated_text() : ::xml_schema::token() {}

comma_separated_text::comma_separated_text(const char *_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

comma_separated_text::comma_separated_text(const ::std::string &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

comma_separated_text::comma_separated_text(
  const ::xml_schema::token &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

comma_separated_text::comma_separated_text(const comma_separated_text &x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xml_schema::token(x, f, c) {}

comma_separated_text::comma_separated_text(const ::xercesc::DOMElement &e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {}

comma_separated_text::comma_separated_text(const ::xercesc::DOMAttr &a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {}

comma_separated_text::comma_separated_text(const ::std::string &s,
                                           const ::xercesc::DOMElement *e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {}

comma_separated_text *
comma_separated_text::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class comma_separated_text(*this, f, c);
}

comma_separated_text::~comma_separated_text() {}

// css_font_size
//

css_font_size::css_font_size(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_css_font_size_convert();
}

css_font_size::css_font_size(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_css_font_size_convert();
}

css_font_size::css_font_size(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_css_font_size_convert();
}

css_font_size *css_font_size::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class css_font_size(*this, f, c);
}

css_font_size::value css_font_size::_xsd_css_font_size_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_css_font_size_literals_);
  const value *i(::std::lower_bound(_xsd_css_font_size_indexes_,
                                    _xsd_css_font_size_indexes_ + 7, *this, c));

  if (i == _xsd_css_font_size_indexes_ + 7 ||
      _xsd_css_font_size_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const css_font_size::_xsd_css_font_size_literals_[7] = {
  "xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large"};

const css_font_size::value css_font_size::_xsd_css_font_size_indexes_[7] = {
  ::musicxml::css_font_size::large,   ::musicxml::css_font_size::medium,
  ::musicxml::css_font_size::small,   ::musicxml::css_font_size::x_large,
  ::musicxml::css_font_size::x_small, ::musicxml::css_font_size::xx_large,
  ::musicxml::css_font_size::xx_small};

// divisions
//

divisions::divisions(const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

divisions::divisions(const divisions &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

divisions::divisions(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

divisions::divisions(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

divisions::divisions(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

divisions *divisions::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class divisions(*this, f, c);
}

divisions::~divisions() {}

// enclosure_shape
//

enclosure_shape::enclosure_shape(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_enclosure_shape_convert();
}

enclosure_shape::enclosure_shape(const ::xercesc::DOMAttr &a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_enclosure_shape_convert();
}

enclosure_shape::enclosure_shape(const ::std::string &s,
                                 const ::xercesc::DOMElement *e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_enclosure_shape_convert();
}

enclosure_shape *enclosure_shape::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class enclosure_shape(*this, f, c);
}

enclosure_shape::value enclosure_shape::_xsd_enclosure_shape_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_enclosure_shape_literals_);
  const value *i(::std::lower_bound(_xsd_enclosure_shape_indexes_,
                                    _xsd_enclosure_shape_indexes_ + 8, *this,
                                    c));

  if (i == _xsd_enclosure_shape_indexes_ + 8 ||
      _xsd_enclosure_shape_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const enclosure_shape::_xsd_enclosure_shape_literals_[8] = {
  "rectangle", "square",   "oval",    "circle",
  "bracket",   "triangle", "diamond", "none"};

const enclosure_shape::value enclosure_shape::_xsd_enclosure_shape_indexes_[8] =
  {::musicxml::enclosure_shape::bracket, ::musicxml::enclosure_shape::circle,
   ::musicxml::enclosure_shape::diamond, ::musicxml::enclosure_shape::none,
   ::musicxml::enclosure_shape::oval,    ::musicxml::enclosure_shape::rectangle,
   ::musicxml::enclosure_shape::square,  ::musicxml::enclosure_shape::triangle};

// fermata_shape
//

fermata_shape::fermata_shape(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_fermata_shape_convert();
}

fermata_shape::fermata_shape(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_fermata_shape_convert();
}

fermata_shape::fermata_shape(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_fermata_shape_convert();
}

fermata_shape *fermata_shape::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class fermata_shape(*this, f, c);
}

fermata_shape::value fermata_shape::_xsd_fermata_shape_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_fermata_shape_literals_);
  const value *i(::std::lower_bound(_xsd_fermata_shape_indexes_,
                                    _xsd_fermata_shape_indexes_ + 4, *this, c));

  if (i == _xsd_fermata_shape_indexes_ + 4 ||
      _xsd_fermata_shape_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const fermata_shape::_xsd_fermata_shape_literals_[4] = {
  "normal", "angled", "square", ""};

const fermata_shape::value fermata_shape::_xsd_fermata_shape_indexes_[4] = {
  ::musicxml::fermata_shape::empty, ::musicxml::fermata_shape::angled,
  ::musicxml::fermata_shape::normal, ::musicxml::fermata_shape::square};

// font_size
//

font_size::font_size(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {}

font_size::font_size(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {}

font_size::font_size(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {}

font_size *font_size::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class font_size(*this, f, c);
}

// font_style
//

font_style::font_style(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_font_style_convert();
}

font_style::font_style(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_font_style_convert();
}

font_style::font_style(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_font_style_convert();
}

font_style *font_style::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class font_style(*this, f, c);
}

font_style::value font_style::_xsd_font_style_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_font_style_literals_);
  const value *i(::std::lower_bound(_xsd_font_style_indexes_,
                                    _xsd_font_style_indexes_ + 2, *this, c));

  if (i == _xsd_font_style_indexes_ + 2 ||
      _xsd_font_style_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const font_style::_xsd_font_style_literals_[2] = {"normal",
                                                              "italic"};

const font_style::value font_style::_xsd_font_style_indexes_[2] = {
  ::musicxml::font_style::italic, ::musicxml::font_style::normal};

// font_weight
//

font_weight::font_weight(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_font_weight_convert();
}

font_weight::font_weight(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_font_weight_convert();
}

font_weight::font_weight(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_font_weight_convert();
}

font_weight *font_weight::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class font_weight(*this, f, c);
}

font_weight::value font_weight::_xsd_font_weight_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_font_weight_literals_);
  const value *i(::std::lower_bound(_xsd_font_weight_indexes_,
                                    _xsd_font_weight_indexes_ + 2, *this, c));

  if (i == _xsd_font_weight_indexes_ + 2 ||
      _xsd_font_weight_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const font_weight::_xsd_font_weight_literals_[2] = {"normal",
                                                                "bold"};

const font_weight::value font_weight::_xsd_font_weight_indexes_[2] = {
  ::musicxml::font_weight::bold, ::musicxml::font_weight::normal};

// left_center_right
//

left_center_right::left_center_right(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_left_center_right_convert();
}

left_center_right::left_center_right(const ::xercesc::DOMAttr &a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_left_center_right_convert();
}

left_center_right::left_center_right(const ::std::string &s,
                                     const ::xercesc::DOMElement *e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_left_center_right_convert();
}

left_center_right *left_center_right::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class left_center_right(*this, f, c);
}

left_center_right::value
left_center_right::_xsd_left_center_right_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_left_center_right_literals_);
  const value *i(::std::lower_bound(_xsd_left_center_right_indexes_,
                                    _xsd_left_center_right_indexes_ + 3, *this,
                                    c));

  if (i == _xsd_left_center_right_indexes_ + 3 ||
      _xsd_left_center_right_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const left_center_right::_xsd_left_center_right_literals_[3] = {
  "left", "center", "right"};

const left_center_right::value
  left_center_right::_xsd_left_center_right_indexes_[3] = {
    ::musicxml::left_center_right::center, ::musicxml::left_center_right::left,
    ::musicxml::left_center_right::right};

// left_right
//

left_right::left_right(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_left_right_convert();
}

left_right::left_right(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_left_right_convert();
}

left_right::left_right(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_left_right_convert();
}

left_right *left_right::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class left_right(*this, f, c);
}

left_right::value left_right::_xsd_left_right_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_left_right_literals_);
  const value *i(::std::lower_bound(_xsd_left_right_indexes_,
                                    _xsd_left_right_indexes_ + 2, *this, c));

  if (i == _xsd_left_right_indexes_ + 2 ||
      _xsd_left_right_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const left_right::_xsd_left_right_literals_[2] = {"left", "right"};

const left_right::value left_right::_xsd_left_right_indexes_[2] = {
  ::musicxml::left_right::left, ::musicxml::left_right::right};

// line_shape
//

line_shape::line_shape(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_line_shape_convert();
}

line_shape::line_shape(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_line_shape_convert();
}

line_shape::line_shape(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_line_shape_convert();
}

line_shape *line_shape::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class line_shape(*this, f, c);
}

line_shape::value line_shape::_xsd_line_shape_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_line_shape_literals_);
  const value *i(::std::lower_bound(_xsd_line_shape_indexes_,
                                    _xsd_line_shape_indexes_ + 2, *this, c));

  if (i == _xsd_line_shape_indexes_ + 2 ||
      _xsd_line_shape_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const line_shape::_xsd_line_shape_literals_[2] = {"straight",
                                                              "curved"};

const line_shape::value line_shape::_xsd_line_shape_indexes_[2] = {
  ::musicxml::line_shape::curved, ::musicxml::line_shape::straight};

// line_type
//

line_type::line_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_line_type_convert();
}

line_type::line_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_line_type_convert();
}

line_type::line_type(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_line_type_convert();
}

line_type *line_type::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class line_type(*this, f, c);
}

line_type::value line_type::_xsd_line_type_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_line_type_literals_);
  const value *i(::std::lower_bound(_xsd_line_type_indexes_,
                                    _xsd_line_type_indexes_ + 4, *this, c));

  if (i == _xsd_line_type_indexes_ + 4 ||
      _xsd_line_type_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const line_type::_xsd_line_type_literals_[4] = {"solid", "dashed",
                                                            "dotted", "wavy"};

const line_type::value line_type::_xsd_line_type_indexes_[4] = {
  ::musicxml::line_type::dashed, ::musicxml::line_type::dotted,
  ::musicxml::line_type::solid, ::musicxml::line_type::wavy};

// midi_16
//

midi_16::midi_16(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base) {}

midi_16::midi_16(const midi_16 &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

midi_16::midi_16(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

midi_16::midi_16(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

midi_16::midi_16(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

midi_16 *midi_16::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class midi_16(*this, f, c);
}

midi_16::~midi_16() {}

// midi_128
//

midi_128::midi_128(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base) {}

midi_128::midi_128(const midi_128 &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

midi_128::midi_128(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

midi_128::midi_128(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

midi_128::midi_128(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

midi_128 *midi_128::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class midi_128(*this, f, c);
}

midi_128::~midi_128() {}

// midi_16384
//

midi_16384::midi_16384(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base) {}

midi_16384::midi_16384(const midi_16384 &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

midi_16384::midi_16384(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

midi_16384::midi_16384(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

midi_16384::midi_16384(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

midi_16384 *midi_16384::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class midi_16384(*this, f, c);
}

midi_16384::~midi_16384() {}

// mute
//

mute::mute(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_mute_convert();
}

mute::mute(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_mute_convert();
}

mute::mute(const ::std::string &s, const ::xercesc::DOMElement *e,
           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_mute_convert();
}

mute *mute::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class mute(*this, f, c);
}

mute::value mute::_xsd_mute_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_mute_literals_);
  const value *i(
    ::std::lower_bound(_xsd_mute_indexes_, _xsd_mute_indexes_ + 15, *this, c));

  if (i == _xsd_mute_indexes_ + 15 || _xsd_mute_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const mute::_xsd_mute_literals_[15] = {
  "on",          "off",       "straight",  "cup",  "harmon-no-stem",
  "harmon-stem", "bucket",    "plunger",   "hat",  "solotone",
  "practice",    "stop-mute", "stop-hand", "echo", "palm"};

const mute::value mute::_xsd_mute_indexes_[15] = {
  ::musicxml::mute::bucket,      ::musicxml::mute::cup,
  ::musicxml::mute::echo,        ::musicxml::mute::harmon_no_stem,
  ::musicxml::mute::harmon_stem, ::musicxml::mute::hat,
  ::musicxml::mute::off,         ::musicxml::mute::on,
  ::musicxml::mute::palm,        ::musicxml::mute::plunger,
  ::musicxml::mute::practice,    ::musicxml::mute::solotone,
  ::musicxml::mute::stop_hand,   ::musicxml::mute::stop_mute,
  ::musicxml::mute::straight};

// non_negative_decimal
//

non_negative_decimal::non_negative_decimal(
  const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

non_negative_decimal::non_negative_decimal(const non_negative_decimal &x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

non_negative_decimal::non_negative_decimal(const ::xercesc::DOMElement &e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

non_negative_decimal::non_negative_decimal(const ::xercesc::DOMAttr &a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

non_negative_decimal::non_negative_decimal(const ::std::string &s,
                                           const ::xercesc::DOMElement *e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

non_negative_decimal *
non_negative_decimal::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class non_negative_decimal(*this, f, c);
}

non_negative_decimal::~non_negative_decimal() {}

// number_level
//

number_level::number_level(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base) {}

number_level::number_level(const number_level &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

number_level::number_level(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

number_level::number_level(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

number_level::number_level(const ::std::string &s,
                           const ::xercesc::DOMElement *e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

number_level *number_level::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class number_level(*this, f, c);
}

number_level::~number_level() {}

// number_of_lines
//

number_of_lines::number_of_lines(
  const ::xml_schema::non_negative_integer &_xsd_non_negative_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_non_negative_integer_base) {}

number_of_lines::number_of_lines(const number_of_lines &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

number_of_lines::number_of_lines(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

number_of_lines::number_of_lines(const ::xercesc::DOMAttr &a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

number_of_lines::number_of_lines(const ::std::string &s,
                                 const ::xercesc::DOMElement *e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

number_of_lines *number_of_lines::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class number_of_lines(*this, f, c);
}

number_of_lines::~number_of_lines() {}

// number_or_normal
//

number_or_normal::number_or_normal(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {}

number_or_normal::number_or_normal(const ::xercesc::DOMAttr &a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {}

number_or_normal::number_or_normal(const ::std::string &s,
                                   const ::xercesc::DOMElement *e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {}

number_or_normal *number_or_normal::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class number_or_normal(*this, f, c);
}

// over_under
//

over_under::over_under(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_over_under_convert();
}

over_under::over_under(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_over_under_convert();
}

over_under::over_under(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_over_under_convert();
}

over_under *over_under::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class over_under(*this, f, c);
}

over_under::value over_under::_xsd_over_under_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_over_under_literals_);
  const value *i(::std::lower_bound(_xsd_over_under_indexes_,
                                    _xsd_over_under_indexes_ + 2, *this, c));

  if (i == _xsd_over_under_indexes_ + 2 ||
      _xsd_over_under_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const over_under::_xsd_over_under_literals_[2] = {"over", "under"};

const over_under::value over_under::_xsd_over_under_indexes_[2] = {
  ::musicxml::over_under::over, ::musicxml::over_under::under};

// percent
//

percent::percent(const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

percent::percent(const percent &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

percent::percent(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

percent::percent(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

percent::percent(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

percent *percent::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class percent(*this, f, c);
}

percent::~percent() {}

// positive_decimal
//

positive_decimal::positive_decimal(
  const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

positive_decimal::positive_decimal(const positive_decimal &x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

positive_decimal::positive_decimal(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

positive_decimal::positive_decimal(const ::xercesc::DOMAttr &a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

positive_decimal::positive_decimal(const ::std::string &s,
                                   const ::xercesc::DOMElement *e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

positive_decimal *positive_decimal::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class positive_decimal(*this, f, c);
}

positive_decimal::~positive_decimal() {}

// positive_divisions
//

positive_divisions::positive_divisions(
  const ::xml_schema::decimal &_xsd_decimal_base)
: ::musicxml::divisions(_xsd_decimal_base) {}

positive_divisions::positive_divisions(const positive_divisions &x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::musicxml::divisions(x, f, c) {}

positive_divisions::positive_divisions(const ::xercesc::DOMElement &e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::musicxml::divisions(e, f, c) {}

positive_divisions::positive_divisions(const ::xercesc::DOMAttr &a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::musicxml::divisions(a, f, c) {}

positive_divisions::positive_divisions(const ::std::string &s,
                                       const ::xercesc::DOMElement *e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::musicxml::divisions(s, e, f, c) {}

positive_divisions *
positive_divisions::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class positive_divisions(*this, f, c);
}

positive_divisions::~positive_divisions() {}

// positive_integer_or_empty
//

positive_integer_or_empty::positive_integer_or_empty(
  const ::xercesc::DOMElement &e, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {}

positive_integer_or_empty::positive_integer_or_empty(
  const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {}

positive_integer_or_empty::positive_integer_or_empty(
  const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {}

positive_integer_or_empty *
positive_integer_or_empty::_clone(::xml_schema::flags f,
                                  ::xml_schema::container *c) const {
  return new class positive_integer_or_empty(*this, f, c);
}

// rotation_degrees
//

rotation_degrees::rotation_degrees(
  const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

rotation_degrees::rotation_degrees(const rotation_degrees &x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

rotation_degrees::rotation_degrees(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

rotation_degrees::rotation_degrees(const ::xercesc::DOMAttr &a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

rotation_degrees::rotation_degrees(const ::std::string &s,
                                   const ::xercesc::DOMElement *e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

rotation_degrees *rotation_degrees::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class rotation_degrees(*this, f, c);
}

rotation_degrees::~rotation_degrees() {}

// semi_pitched
//

semi_pitched::semi_pitched(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_semi_pitched_convert();
}

semi_pitched::semi_pitched(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_semi_pitched_convert();
}

semi_pitched::semi_pitched(const ::std::string &s,
                           const ::xercesc::DOMElement *e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_semi_pitched_convert();
}

semi_pitched *semi_pitched::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class semi_pitched(*this, f, c);
}

semi_pitched::value semi_pitched::_xsd_semi_pitched_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_semi_pitched_literals_);
  const value *i(::std::lower_bound(_xsd_semi_pitched_indexes_,
                                    _xsd_semi_pitched_indexes_ + 6, *this, c));

  if (i == _xsd_semi_pitched_indexes_ + 6 ||
      _xsd_semi_pitched_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const semi_pitched::_xsd_semi_pitched_literals_[6] = {
  "high", "medium-high", "medium", "medium-low", "low", "very-low"};

const semi_pitched::value semi_pitched::_xsd_semi_pitched_indexes_[6] = {
  ::musicxml::semi_pitched::high,       ::musicxml::semi_pitched::low,
  ::musicxml::semi_pitched::medium,     ::musicxml::semi_pitched::medium_high,
  ::musicxml::semi_pitched::medium_low, ::musicxml::semi_pitched::very_low};

// start_note
//

start_note::start_note(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_start_note_convert();
}

start_note::start_note(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_start_note_convert();
}

start_note::start_note(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_start_note_convert();
}

start_note *start_note::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class start_note(*this, f, c);
}

start_note::value start_note::_xsd_start_note_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_start_note_literals_);
  const value *i(::std::lower_bound(_xsd_start_note_indexes_,
                                    _xsd_start_note_indexes_ + 3, *this, c));

  if (i == _xsd_start_note_indexes_ + 3 ||
      _xsd_start_note_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const start_note::_xsd_start_note_literals_[3] = {"upper", "main",
                                                              "below"};

const start_note::value start_note::_xsd_start_note_indexes_[3] = {
  ::musicxml::start_note::below, ::musicxml::start_note::main,
  ::musicxml::start_note::upper};

// start_stop
//

start_stop::start_stop(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_start_stop_convert();
}

start_stop::start_stop(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_start_stop_convert();
}

start_stop::start_stop(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_start_stop_convert();
}

start_stop *start_stop::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class start_stop(*this, f, c);
}

start_stop::value start_stop::_xsd_start_stop_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_start_stop_literals_);
  const value *i(::std::lower_bound(_xsd_start_stop_indexes_,
                                    _xsd_start_stop_indexes_ + 2, *this, c));

  if (i == _xsd_start_stop_indexes_ + 2 ||
      _xsd_start_stop_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const start_stop::_xsd_start_stop_literals_[2] = {"start", "stop"};

const start_stop::value start_stop::_xsd_start_stop_indexes_[2] = {
  ::musicxml::start_stop::start, ::musicxml::start_stop::stop};

// start_stop_continue
//

start_stop_continue::start_stop_continue(const ::xercesc::DOMElement &e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_start_stop_continue_convert();
}

start_stop_continue::start_stop_continue(const ::xercesc::DOMAttr &a,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_start_stop_continue_convert();
}

start_stop_continue::start_stop_continue(const ::std::string &s,
                                         const ::xercesc::DOMElement *e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_start_stop_continue_convert();
}

start_stop_continue *
start_stop_continue::_clone(::xml_schema::flags f,
                            ::xml_schema::container *c) const {
  return new class start_stop_continue(*this, f, c);
}

start_stop_continue::value
start_stop_continue::_xsd_start_stop_continue_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_start_stop_continue_literals_);
  const value *i(::std::lower_bound(_xsd_start_stop_continue_indexes_,
                                    _xsd_start_stop_continue_indexes_ + 3,
                                    *this, c));

  if (i == _xsd_start_stop_continue_indexes_ + 3 ||
      _xsd_start_stop_continue_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const start_stop_continue::_xsd_start_stop_continue_literals_[3] = {
  "start", "stop", "continue"};

const start_stop_continue::value
  start_stop_continue::_xsd_start_stop_continue_indexes_[3] = {
    ::musicxml::start_stop_continue::continue_,
    ::musicxml::start_stop_continue::start,
    ::musicxml::start_stop_continue::stop};

// start_stop_single
//

start_stop_single::start_stop_single(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_start_stop_single_convert();
}

start_stop_single::start_stop_single(const ::xercesc::DOMAttr &a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_start_stop_single_convert();
}

start_stop_single::start_stop_single(const ::std::string &s,
                                     const ::xercesc::DOMElement *e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_start_stop_single_convert();
}

start_stop_single *start_stop_single::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class start_stop_single(*this, f, c);
}

start_stop_single::value
start_stop_single::_xsd_start_stop_single_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_start_stop_single_literals_);
  const value *i(::std::lower_bound(_xsd_start_stop_single_indexes_,
                                    _xsd_start_stop_single_indexes_ + 3, *this,
                                    c));

  if (i == _xsd_start_stop_single_indexes_ + 3 ||
      _xsd_start_stop_single_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const start_stop_single::_xsd_start_stop_single_literals_[3] = {
  "start", "stop", "single"};

const start_stop_single::value
  start_stop_single::_xsd_start_stop_single_indexes_[3] = {
    ::musicxml::start_stop_single::single, ::musicxml::start_stop_single::start,
    ::musicxml::start_stop_single::stop};

// string_number
//

string_number::string_number(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base) {}

string_number::string_number(const string_number &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

string_number::string_number(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

string_number::string_number(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

string_number::string_number(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

string_number *string_number::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class string_number(*this, f, c);
}

string_number::~string_number() {}

// symbol_size
//

symbol_size::symbol_size(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_symbol_size_convert();
}

symbol_size::symbol_size(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_symbol_size_convert();
}

symbol_size::symbol_size(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_symbol_size_convert();
}

symbol_size *symbol_size::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class symbol_size(*this, f, c);
}

symbol_size::value symbol_size::_xsd_symbol_size_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_symbol_size_literals_);
  const value *i(::std::lower_bound(_xsd_symbol_size_indexes_,
                                    _xsd_symbol_size_indexes_ + 3, *this, c));

  if (i == _xsd_symbol_size_indexes_ + 3 ||
      _xsd_symbol_size_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const symbol_size::_xsd_symbol_size_literals_[3] = {"full", "cue",
                                                                "large"};

const symbol_size::value symbol_size::_xsd_symbol_size_indexes_[3] = {
  ::musicxml::symbol_size::cue, ::musicxml::symbol_size::full,
  ::musicxml::symbol_size::large};

// tenths
//

tenths::tenths(const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

tenths::tenths(const tenths &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

tenths::tenths(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

tenths::tenths(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

tenths::tenths(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

tenths *tenths::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class tenths(*this, f, c);
}

tenths::~tenths() {}

// text_direction
//

text_direction::text_direction(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_text_direction_convert();
}

text_direction::text_direction(const ::xercesc::DOMAttr &a,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_text_direction_convert();
}

text_direction::text_direction(const ::std::string &s,
                               const ::xercesc::DOMElement *e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_text_direction_convert();
}

text_direction *text_direction::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class text_direction(*this, f, c);
}

text_direction::value text_direction::_xsd_text_direction_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_text_direction_literals_);
  const value *i(::std::lower_bound(
    _xsd_text_direction_indexes_, _xsd_text_direction_indexes_ + 4, *this, c));

  if (i == _xsd_text_direction_indexes_ + 4 ||
      _xsd_text_direction_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const text_direction::_xsd_text_direction_literals_[4] = {
  "ltr", "rtl", "lro", "rlo"};

const text_direction::value text_direction::_xsd_text_direction_indexes_[4] = {
  ::musicxml::text_direction::lro, ::musicxml::text_direction::ltr,
  ::musicxml::text_direction::rlo, ::musicxml::text_direction::rtl};

// time_only
//

time_only::time_only() : ::xml_schema::token() {}

time_only::time_only(const char *_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

time_only::time_only(const ::std::string &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

time_only::time_only(const ::xml_schema::token &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

time_only::time_only(const time_only &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::token(x, f, c) {}

time_only::time_only(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {}

time_only::time_only(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {}

time_only::time_only(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {}

time_only *time_only::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class time_only(*this, f, c);
}

time_only::~time_only() {}

// top_bottom
//

top_bottom::top_bottom(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_top_bottom_convert();
}

top_bottom::top_bottom(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_top_bottom_convert();
}

top_bottom::top_bottom(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_top_bottom_convert();
}

top_bottom *top_bottom::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class top_bottom(*this, f, c);
}

top_bottom::value top_bottom::_xsd_top_bottom_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_top_bottom_literals_);
  const value *i(::std::lower_bound(_xsd_top_bottom_indexes_,
                                    _xsd_top_bottom_indexes_ + 2, *this, c));

  if (i == _xsd_top_bottom_indexes_ + 2 ||
      _xsd_top_bottom_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const top_bottom::_xsd_top_bottom_literals_[2] = {"top", "bottom"};

const top_bottom::value top_bottom::_xsd_top_bottom_indexes_[2] = {
  ::musicxml::top_bottom::bottom, ::musicxml::top_bottom::top};

// trill_beats
//

trill_beats::trill_beats(const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

trill_beats::trill_beats(const trill_beats &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

trill_beats::trill_beats(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

trill_beats::trill_beats(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

trill_beats::trill_beats(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

trill_beats *trill_beats::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class trill_beats(*this, f, c);
}

trill_beats::~trill_beats() {}

// trill_step
//

trill_step::trill_step(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_trill_step_convert();
}

trill_step::trill_step(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_trill_step_convert();
}

trill_step::trill_step(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_trill_step_convert();
}

trill_step *trill_step::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class trill_step(*this, f, c);
}

trill_step::value trill_step::_xsd_trill_step_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_trill_step_literals_);
  const value *i(::std::lower_bound(_xsd_trill_step_indexes_,
                                    _xsd_trill_step_indexes_ + 3, *this, c));

  if (i == _xsd_trill_step_indexes_ + 3 ||
      _xsd_trill_step_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const trill_step::_xsd_trill_step_literals_[3] = {"whole", "half",
                                                              "unison"};

const trill_step::value trill_step::_xsd_trill_step_indexes_[3] = {
  ::musicxml::trill_step::half, ::musicxml::trill_step::unison,
  ::musicxml::trill_step::whole};

// two_note_turn
//

two_note_turn::two_note_turn(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_two_note_turn_convert();
}

two_note_turn::two_note_turn(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_two_note_turn_convert();
}

two_note_turn::two_note_turn(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_two_note_turn_convert();
}

two_note_turn *two_note_turn::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class two_note_turn(*this, f, c);
}

two_note_turn::value two_note_turn::_xsd_two_note_turn_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_two_note_turn_literals_);
  const value *i(::std::lower_bound(_xsd_two_note_turn_indexes_,
                                    _xsd_two_note_turn_indexes_ + 3, *this, c));

  if (i == _xsd_two_note_turn_indexes_ + 3 ||
      _xsd_two_note_turn_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const two_note_turn::_xsd_two_note_turn_literals_[3] = {
  "whole", "half", "none"};

const two_note_turn::value two_note_turn::_xsd_two_note_turn_indexes_[3] = {
  ::musicxml::two_note_turn::half, ::musicxml::two_note_turn::none,
  ::musicxml::two_note_turn::whole};

// up_down
//

up_down::up_down(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_up_down_convert();
}

up_down::up_down(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_up_down_convert();
}

up_down::up_down(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_up_down_convert();
}

up_down *up_down::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class up_down(*this, f, c);
}

up_down::value up_down::_xsd_up_down_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_up_down_literals_);
  const value *i(::std::lower_bound(_xsd_up_down_indexes_,
                                    _xsd_up_down_indexes_ + 2, *this, c));

  if (i == _xsd_up_down_indexes_ + 2 || _xsd_up_down_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const up_down::_xsd_up_down_literals_[2] = {"up", "down"};

const up_down::value up_down::_xsd_up_down_indexes_[2] = {
  ::musicxml::up_down::down, ::musicxml::up_down::up};

// upright_inverted
//

upright_inverted::upright_inverted(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_upright_inverted_convert();
}

upright_inverted::upright_inverted(const ::xercesc::DOMAttr &a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_upright_inverted_convert();
}

upright_inverted::upright_inverted(const ::std::string &s,
                                   const ::xercesc::DOMElement *e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_upright_inverted_convert();
}

upright_inverted *upright_inverted::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class upright_inverted(*this, f, c);
}

upright_inverted::value
upright_inverted::_xsd_upright_inverted_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_upright_inverted_literals_);
  const value *i(::std::lower_bound(_xsd_upright_inverted_indexes_,
                                    _xsd_upright_inverted_indexes_ + 2, *this,
                                    c));

  if (i == _xsd_upright_inverted_indexes_ + 2 ||
      _xsd_upright_inverted_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const upright_inverted::_xsd_upright_inverted_literals_[2] = {
  "upright", "inverted"};

const upright_inverted::value
  upright_inverted::_xsd_upright_inverted_indexes_[2] = {
    ::musicxml::upright_inverted::inverted,
    ::musicxml::upright_inverted::upright};

// valign
//

valign::valign(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_valign_convert();
}

valign::valign(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_valign_convert();
}

valign::valign(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_valign_convert();
}

valign *valign::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class valign(*this, f, c);
}

valign::value valign::_xsd_valign_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_valign_literals_);
  const value *i(::std::lower_bound(_xsd_valign_indexes_,
                                    _xsd_valign_indexes_ + 4, *this, c));

  if (i == _xsd_valign_indexes_ + 4 || _xsd_valign_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const valign::_xsd_valign_literals_[4] = {"top", "middle", "bottom",
                                                      "baseline"};

const valign::value valign::_xsd_valign_indexes_[4] = {
  ::musicxml::valign::baseline, ::musicxml::valign::bottom,
  ::musicxml::valign::middle, ::musicxml::valign::top};

// valign_image
//

valign_image::valign_image(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_valign_image_convert();
}

valign_image::valign_image(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_valign_image_convert();
}

valign_image::valign_image(const ::std::string &s,
                           const ::xercesc::DOMElement *e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_valign_image_convert();
}

valign_image *valign_image::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class valign_image(*this, f, c);
}

valign_image::value valign_image::_xsd_valign_image_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_valign_image_literals_);
  const value *i(::std::lower_bound(_xsd_valign_image_indexes_,
                                    _xsd_valign_image_indexes_ + 3, *this, c));

  if (i == _xsd_valign_image_indexes_ + 3 ||
      _xsd_valign_image_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const valign_image::_xsd_valign_image_literals_[3] = {
  "top", "middle", "bottom"};

const valign_image::value valign_image::_xsd_valign_image_indexes_[3] = {
  ::musicxml::valign_image::bottom, ::musicxml::valign_image::middle,
  ::musicxml::valign_image::top};

// yes_no
//

yes_no::yes_no(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_yes_no_convert();
}

yes_no::yes_no(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_yes_no_convert();
}

yes_no::yes_no(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_yes_no_convert();
}

yes_no *yes_no::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class yes_no(*this, f, c);
}

yes_no::value yes_no::_xsd_yes_no_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_yes_no_literals_);
  const value *i(::std::lower_bound(_xsd_yes_no_indexes_,
                                    _xsd_yes_no_indexes_ + 2, *this, c));

  if (i == _xsd_yes_no_indexes_ + 2 || _xsd_yes_no_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const yes_no::_xsd_yes_no_literals_[2] = {"yes", "no"};

const yes_no::value yes_no::_xsd_yes_no_indexes_[2] = {::musicxml::yes_no::no,
                                                       ::musicxml::yes_no::yes};

// yes_no_number
//

yes_no_number::yes_no_number(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {}

yes_no_number::yes_no_number(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {}

yes_no_number::yes_no_number(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {}

yes_no_number *yes_no_number::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class yes_no_number(*this, f, c);
}

// yyyy_mm_dd
//

yyyy_mm_dd::yyyy_mm_dd(const ::xml_schema::date &_xsd_date_base)
: ::xml_schema::date(_xsd_date_base) {}

yyyy_mm_dd::yyyy_mm_dd(const yyyy_mm_dd &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::date(x, f, c) {}

yyyy_mm_dd::yyyy_mm_dd(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::date(e, f, c) {}

yyyy_mm_dd::yyyy_mm_dd(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::date(a, f, c) {}

yyyy_mm_dd::yyyy_mm_dd(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::date(s, e, f, c) {}

yyyy_mm_dd *yyyy_mm_dd::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class yyyy_mm_dd(*this, f, c);
}

yyyy_mm_dd::~yyyy_mm_dd() {}

// cancel_location
//

cancel_location::cancel_location(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_cancel_location_convert();
}

cancel_location::cancel_location(const ::xercesc::DOMAttr &a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_cancel_location_convert();
}

cancel_location::cancel_location(const ::std::string &s,
                                 const ::xercesc::DOMElement *e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_cancel_location_convert();
}

cancel_location *cancel_location::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class cancel_location(*this, f, c);
}

cancel_location::value cancel_location::_xsd_cancel_location_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_cancel_location_literals_);
  const value *i(::std::lower_bound(_xsd_cancel_location_indexes_,
                                    _xsd_cancel_location_indexes_ + 3, *this,
                                    c));

  if (i == _xsd_cancel_location_indexes_ + 3 ||
      _xsd_cancel_location_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const cancel_location::_xsd_cancel_location_literals_[3] = {
  "left", "right", "before-barline"};

const cancel_location::value cancel_location::_xsd_cancel_location_indexes_[3] =
  {::musicxml::cancel_location::before_barline,
   ::musicxml::cancel_location::left, ::musicxml::cancel_location::right};

// clef_sign
//

clef_sign::clef_sign(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_clef_sign_convert();
}

clef_sign::clef_sign(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_clef_sign_convert();
}

clef_sign::clef_sign(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_clef_sign_convert();
}

clef_sign *clef_sign::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class clef_sign(*this, f, c);
}

clef_sign::value clef_sign::_xsd_clef_sign_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_clef_sign_literals_);
  const value *i(::std::lower_bound(_xsd_clef_sign_indexes_,
                                    _xsd_clef_sign_indexes_ + 7, *this, c));

  if (i == _xsd_clef_sign_indexes_ + 7 ||
      _xsd_clef_sign_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const clef_sign::_xsd_clef_sign_literals_[7] = {
  "G", "F", "C", "percussion", "TAB", "jianpu", "none"};

const clef_sign::value clef_sign::_xsd_clef_sign_indexes_[7] = {
  ::musicxml::clef_sign::C,         ::musicxml::clef_sign::F,
  ::musicxml::clef_sign::G,         ::musicxml::clef_sign::TAB,
  ::musicxml::clef_sign::jianpu,    ::musicxml::clef_sign::none,
  ::musicxml::clef_sign::percussion};

// fifths
//

fifths::fifths(const ::xml_schema::integer &_xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type>(_xsd_integer_base) {
}

fifths::fifths(const fifths &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

fifths::fifths(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

fifths::fifths(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

fifths::fifths(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

fifths *fifths::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class fifths(*this, f, c);
}

fifths::~fifths() {}

// mode
//

mode::mode() : ::xml_schema::string() {}

mode::mode(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base) {}

mode::mode(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base) {}

mode::mode(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base) {}

mode::mode(const mode &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(x, f, c) {}

mode::mode(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {}

mode::mode(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {}

mode::mode(const ::std::string &s, const ::xercesc::DOMElement *e,
           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {}

mode *mode::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class mode(*this, f, c);
}

mode::~mode() {}

// show_frets
//

show_frets::show_frets(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_show_frets_convert();
}

show_frets::show_frets(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_show_frets_convert();
}

show_frets::show_frets(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_show_frets_convert();
}

show_frets *show_frets::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class show_frets(*this, f, c);
}

show_frets::value show_frets::_xsd_show_frets_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_show_frets_literals_);
  const value *i(::std::lower_bound(_xsd_show_frets_indexes_,
                                    _xsd_show_frets_indexes_ + 2, *this, c));

  if (i == _xsd_show_frets_indexes_ + 2 ||
      _xsd_show_frets_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const show_frets::_xsd_show_frets_literals_[2] = {"numbers",
                                                              "letters"};

const show_frets::value show_frets::_xsd_show_frets_indexes_[2] = {
  ::musicxml::show_frets::letters, ::musicxml::show_frets::numbers};

// staff_line
//

staff_line::staff_line(const ::xml_schema::integer &_xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type>(_xsd_integer_base) {
}

staff_line::staff_line(const staff_line &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

staff_line::staff_line(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

staff_line::staff_line(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

staff_line::staff_line(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

staff_line *staff_line::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class staff_line(*this, f, c);
}

staff_line::~staff_line() {}

// staff_number
//

staff_number::staff_number(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base) {}

staff_number::staff_number(const staff_number &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

staff_number::staff_number(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

staff_number::staff_number(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

staff_number::staff_number(const ::std::string &s,
                           const ::xercesc::DOMElement *e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

staff_number *staff_number::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class staff_number(*this, f, c);
}

staff_number::~staff_number() {}

// staff_type
//

staff_type::staff_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_staff_type_convert();
}

staff_type::staff_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_staff_type_convert();
}

staff_type::staff_type(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_staff_type_convert();
}

staff_type *staff_type::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class staff_type(*this, f, c);
}

staff_type::value staff_type::_xsd_staff_type_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_staff_type_literals_);
  const value *i(::std::lower_bound(_xsd_staff_type_indexes_,
                                    _xsd_staff_type_indexes_ + 5, *this, c));

  if (i == _xsd_staff_type_indexes_ + 5 ||
      _xsd_staff_type_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const staff_type::_xsd_staff_type_literals_[5] = {
  "ossia", "cue", "editorial", "regular", "alternate"};

const staff_type::value staff_type::_xsd_staff_type_indexes_[5] = {
  ::musicxml::staff_type::alternate, ::musicxml::staff_type::cue,
  ::musicxml::staff_type::editorial, ::musicxml::staff_type::ossia,
  ::musicxml::staff_type::regular};

// time_relation
//

time_relation::time_relation(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_time_relation_convert();
}

time_relation::time_relation(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_time_relation_convert();
}

time_relation::time_relation(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_time_relation_convert();
}

time_relation *time_relation::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class time_relation(*this, f, c);
}

time_relation::value time_relation::_xsd_time_relation_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_time_relation_literals_);
  const value *i(::std::lower_bound(_xsd_time_relation_indexes_,
                                    _xsd_time_relation_indexes_ + 6, *this, c));

  if (i == _xsd_time_relation_indexes_ + 6 ||
      _xsd_time_relation_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const time_relation::_xsd_time_relation_literals_[6] = {
  "parentheses", "bracket", "equals", "slash", "space", "hyphen"};

const time_relation::value time_relation::_xsd_time_relation_indexes_[6] = {
  ::musicxml::time_relation::bracket, ::musicxml::time_relation::equals,
  ::musicxml::time_relation::hyphen,  ::musicxml::time_relation::parentheses,
  ::musicxml::time_relation::slash,   ::musicxml::time_relation::space};

// time_separator
//

time_separator::time_separator(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_time_separator_convert();
}

time_separator::time_separator(const ::xercesc::DOMAttr &a,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_time_separator_convert();
}

time_separator::time_separator(const ::std::string &s,
                               const ::xercesc::DOMElement *e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_time_separator_convert();
}

time_separator *time_separator::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class time_separator(*this, f, c);
}

time_separator::value time_separator::_xsd_time_separator_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_time_separator_literals_);
  const value *i(::std::lower_bound(
    _xsd_time_separator_indexes_, _xsd_time_separator_indexes_ + 5, *this, c));

  if (i == _xsd_time_separator_indexes_ + 5 ||
      _xsd_time_separator_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const time_separator::_xsd_time_separator_literals_[5] = {
  "none", "horizontal", "diagonal", "vertical", "adjacent"};

const time_separator::value time_separator::_xsd_time_separator_indexes_[5] = {
  ::musicxml::time_separator::adjacent, ::musicxml::time_separator::diagonal,
  ::musicxml::time_separator::horizontal, ::musicxml::time_separator::none,
  ::musicxml::time_separator::vertical};

// time_symbol
//

time_symbol::time_symbol(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_time_symbol_convert();
}

time_symbol::time_symbol(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_time_symbol_convert();
}

time_symbol::time_symbol(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_time_symbol_convert();
}

time_symbol *time_symbol::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class time_symbol(*this, f, c);
}

time_symbol::value time_symbol::_xsd_time_symbol_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_time_symbol_literals_);
  const value *i(::std::lower_bound(_xsd_time_symbol_indexes_,
                                    _xsd_time_symbol_indexes_ + 6, *this, c));

  if (i == _xsd_time_symbol_indexes_ + 6 ||
      _xsd_time_symbol_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const time_symbol::_xsd_time_symbol_literals_[6] = {
  "common", "cut", "single-number", "note", "dotted-note", "normal"};

const time_symbol::value time_symbol::_xsd_time_symbol_indexes_[6] = {
  ::musicxml::time_symbol::common,      ::musicxml::time_symbol::cut,
  ::musicxml::time_symbol::dotted_note, ::musicxml::time_symbol::normal,
  ::musicxml::time_symbol::note,        ::musicxml::time_symbol::single_number};

// backward_forward
//

backward_forward::backward_forward(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_backward_forward_convert();
}

backward_forward::backward_forward(const ::xercesc::DOMAttr &a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_backward_forward_convert();
}

backward_forward::backward_forward(const ::std::string &s,
                                   const ::xercesc::DOMElement *e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_backward_forward_convert();
}

backward_forward *backward_forward::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class backward_forward(*this, f, c);
}

backward_forward::value
backward_forward::_xsd_backward_forward_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_backward_forward_literals_);
  const value *i(::std::lower_bound(_xsd_backward_forward_indexes_,
                                    _xsd_backward_forward_indexes_ + 2, *this,
                                    c));

  if (i == _xsd_backward_forward_indexes_ + 2 ||
      _xsd_backward_forward_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const backward_forward::_xsd_backward_forward_literals_[2] = {
  "backward", "forward"};

const backward_forward::value
  backward_forward::_xsd_backward_forward_indexes_[2] = {
    ::musicxml::backward_forward::backward,
    ::musicxml::backward_forward::forward};

// bar_style
//

bar_style::bar_style(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_bar_style_convert();
}

bar_style::bar_style(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_bar_style_convert();
}

bar_style::bar_style(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_bar_style_convert();
}

bar_style *bar_style::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class bar_style(*this, f, c);
}

bar_style::value bar_style::_xsd_bar_style_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_bar_style_literals_);
  const value *i(::std::lower_bound(_xsd_bar_style_indexes_,
                                    _xsd_bar_style_indexes_ + 11, *this, c));

  if (i == _xsd_bar_style_indexes_ + 11 ||
      _xsd_bar_style_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const bar_style::_xsd_bar_style_literals_[11] = {
  "regular",     "dotted",      "dashed", "heavy", "light-light", "light-heavy",
  "heavy-light", "heavy-heavy", "tick",   "short", "none"};

const bar_style::value bar_style::_xsd_bar_style_indexes_[11] = {
  ::musicxml::bar_style::dashed,      ::musicxml::bar_style::dotted,
  ::musicxml::bar_style::heavy,       ::musicxml::bar_style::heavy_heavy,
  ::musicxml::bar_style::heavy_light, ::musicxml::bar_style::light_heavy,
  ::musicxml::bar_style::light_light, ::musicxml::bar_style::none,
  ::musicxml::bar_style::regular,     ::musicxml::bar_style::short_,
  ::musicxml::bar_style::tick};

// ending_number
//

ending_number::ending_number() : ::xml_schema::token() {}

ending_number::ending_number(const char *_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

ending_number::ending_number(const ::std::string &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

ending_number::ending_number(const ::xml_schema::token &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

ending_number::ending_number(const ending_number &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::token(x, f, c) {}

ending_number::ending_number(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {}

ending_number::ending_number(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {}

ending_number::ending_number(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {}

ending_number *ending_number::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class ending_number(*this, f, c);
}

ending_number::~ending_number() {}

// right_left_middle
//

right_left_middle::right_left_middle(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_right_left_middle_convert();
}

right_left_middle::right_left_middle(const ::xercesc::DOMAttr &a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_right_left_middle_convert();
}

right_left_middle::right_left_middle(const ::std::string &s,
                                     const ::xercesc::DOMElement *e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_right_left_middle_convert();
}

right_left_middle *right_left_middle::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class right_left_middle(*this, f, c);
}

right_left_middle::value
right_left_middle::_xsd_right_left_middle_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_right_left_middle_literals_);
  const value *i(::std::lower_bound(_xsd_right_left_middle_indexes_,
                                    _xsd_right_left_middle_indexes_ + 3, *this,
                                    c));

  if (i == _xsd_right_left_middle_indexes_ + 3 ||
      _xsd_right_left_middle_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const right_left_middle::_xsd_right_left_middle_literals_[3] = {
  "right", "left", "middle"};

const right_left_middle::value
  right_left_middle::_xsd_right_left_middle_indexes_[3] = {
    ::musicxml::right_left_middle::left, ::musicxml::right_left_middle::middle,
    ::musicxml::right_left_middle::right};

// start_stop_discontinue
//

start_stop_discontinue::start_stop_discontinue(const ::xercesc::DOMElement &e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_start_stop_discontinue_convert();
}

start_stop_discontinue::start_stop_discontinue(const ::xercesc::DOMAttr &a,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_start_stop_discontinue_convert();
}

start_stop_discontinue::start_stop_discontinue(const ::std::string &s,
                                               const ::xercesc::DOMElement *e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_start_stop_discontinue_convert();
}

start_stop_discontinue *
start_stop_discontinue::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class start_stop_discontinue(*this, f, c);
}

start_stop_discontinue::value
start_stop_discontinue::_xsd_start_stop_discontinue_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(
    _xsd_start_stop_discontinue_literals_);
  const value *i(::std::lower_bound(_xsd_start_stop_discontinue_indexes_,
                                    _xsd_start_stop_discontinue_indexes_ + 3,
                                    *this, c));

  if (i == _xsd_start_stop_discontinue_indexes_ + 3 ||
      _xsd_start_stop_discontinue_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const
  start_stop_discontinue::_xsd_start_stop_discontinue_literals_[3] = {
    "start", "stop", "discontinue"};

const start_stop_discontinue::value
  start_stop_discontinue::_xsd_start_stop_discontinue_indexes_[3] = {
    ::musicxml::start_stop_discontinue::discontinue,
    ::musicxml::start_stop_discontinue::start,
    ::musicxml::start_stop_discontinue::stop};

// winged
//

winged::winged(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_winged_convert();
}

winged::winged(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_winged_convert();
}

winged::winged(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_winged_convert();
}

winged *winged::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class winged(*this, f, c);
}

winged::value winged::_xsd_winged_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_winged_literals_);
  const value *i(::std::lower_bound(_xsd_winged_indexes_,
                                    _xsd_winged_indexes_ + 5, *this, c));

  if (i == _xsd_winged_indexes_ + 5 || _xsd_winged_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const winged::_xsd_winged_literals_[5] = {
  "none", "straight", "curved", "double-straight", "double-curved"};

const winged::value winged::_xsd_winged_indexes_[5] = {
  ::musicxml::winged::curved, ::musicxml::winged::double_curved,
  ::musicxml::winged::double_straight, ::musicxml::winged::none,
  ::musicxml::winged::straight};

// accordion_middle
//

accordion_middle::accordion_middle(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base) {}

accordion_middle::accordion_middle(const accordion_middle &x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

accordion_middle::accordion_middle(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

accordion_middle::accordion_middle(const ::xercesc::DOMAttr &a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

accordion_middle::accordion_middle(const ::std::string &s,
                                   const ::xercesc::DOMElement *e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

accordion_middle *accordion_middle::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class accordion_middle(*this, f, c);
}

accordion_middle::~accordion_middle() {}

// beater_value
//

beater_value::beater_value(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_beater_value_convert();
}

beater_value::beater_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_beater_value_convert();
}

beater_value::beater_value(const ::std::string &s,
                           const ::xercesc::DOMElement *e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_beater_value_convert();
}

beater_value *beater_value::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class beater_value(*this, f, c);
}

beater_value::value beater_value::_xsd_beater_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_beater_value_literals_);
  const value *i(::std::lower_bound(_xsd_beater_value_indexes_,
                                    _xsd_beater_value_indexes_ + 17, *this, c));

  if (i == _xsd_beater_value_indexes_ + 17 ||
      _xsd_beater_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const beater_value::_xsd_beater_value_literals_[17] = {
  "bow",         "chime hammer", "coin",            "finger",
  "fingernail",  "fist",         "guiro scraper",   "hammer",
  "hand",        "jazz stick",   "knitting needle", "metal hammer",
  "snare stick", "spoon mallet", "triangle beater", "triangle beater plain",
  "wire brush"};

const beater_value::value beater_value::_xsd_beater_value_indexes_[17] = {
  ::musicxml::beater_value::bow,
  ::musicxml::beater_value::chime_hammer,
  ::musicxml::beater_value::coin,
  ::musicxml::beater_value::finger,
  ::musicxml::beater_value::fingernail,
  ::musicxml::beater_value::fist,
  ::musicxml::beater_value::guiro_scraper,
  ::musicxml::beater_value::hammer,
  ::musicxml::beater_value::hand,
  ::musicxml::beater_value::jazz_stick,
  ::musicxml::beater_value::knitting_needle,
  ::musicxml::beater_value::metal_hammer,
  ::musicxml::beater_value::snare_stick,
  ::musicxml::beater_value::spoon_mallet,
  ::musicxml::beater_value::triangle_beater,
  ::musicxml::beater_value::triangle_beater_plain,
  ::musicxml::beater_value::wire_brush};

// degree_symbol_value
//

degree_symbol_value::degree_symbol_value(const ::xercesc::DOMElement &e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_degree_symbol_value_convert();
}

degree_symbol_value::degree_symbol_value(const ::xercesc::DOMAttr &a,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_degree_symbol_value_convert();
}

degree_symbol_value::degree_symbol_value(const ::std::string &s,
                                         const ::xercesc::DOMElement *e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_degree_symbol_value_convert();
}

degree_symbol_value *
degree_symbol_value::_clone(::xml_schema::flags f,
                            ::xml_schema::container *c) const {
  return new class degree_symbol_value(*this, f, c);
}

degree_symbol_value::value
degree_symbol_value::_xsd_degree_symbol_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_degree_symbol_value_literals_);
  const value *i(::std::lower_bound(_xsd_degree_symbol_value_indexes_,
                                    _xsd_degree_symbol_value_indexes_ + 5,
                                    *this, c));

  if (i == _xsd_degree_symbol_value_indexes_ + 5 ||
      _xsd_degree_symbol_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const degree_symbol_value::_xsd_degree_symbol_value_literals_[5] = {
  "major", "minor", "augmented", "diminished", "half-diminished"};

const degree_symbol_value::value
  degree_symbol_value::_xsd_degree_symbol_value_indexes_[5] = {
    ::musicxml::degree_symbol_value::augmented,
    ::musicxml::degree_symbol_value::diminished,
    ::musicxml::degree_symbol_value::half_diminished,
    ::musicxml::degree_symbol_value::major,
    ::musicxml::degree_symbol_value::minor};

// degree_type_value
//

degree_type_value::degree_type_value(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_degree_type_value_convert();
}

degree_type_value::degree_type_value(const ::xercesc::DOMAttr &a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_degree_type_value_convert();
}

degree_type_value::degree_type_value(const ::std::string &s,
                                     const ::xercesc::DOMElement *e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_degree_type_value_convert();
}

degree_type_value *degree_type_value::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class degree_type_value(*this, f, c);
}

degree_type_value::value
degree_type_value::_xsd_degree_type_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_degree_type_value_literals_);
  const value *i(::std::lower_bound(_xsd_degree_type_value_indexes_,
                                    _xsd_degree_type_value_indexes_ + 3, *this,
                                    c));

  if (i == _xsd_degree_type_value_indexes_ + 3 ||
      _xsd_degree_type_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const degree_type_value::_xsd_degree_type_value_literals_[3] = {
  "add", "alter", "subtract"};

const degree_type_value::value
  degree_type_value::_xsd_degree_type_value_indexes_[3] = {
    ::musicxml::degree_type_value::add, ::musicxml::degree_type_value::alter,
    ::musicxml::degree_type_value::subtract};

// effect
//

effect::effect(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_effect_convert();
}

effect::effect(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_effect_convert();
}

effect::effect(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_effect_convert();
}

effect *effect::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class effect(*this, f, c);
}

effect::value effect::_xsd_effect_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_effect_literals_);
  const value *i(::std::lower_bound(_xsd_effect_indexes_,
                                    _xsd_effect_indexes_ + 14, *this, c));

  if (i == _xsd_effect_indexes_ + 14 || _xsd_effect_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const effect::_xsd_effect_literals_[14] = {
  "anvil",          "auto horn",   "bird whistle",  "cannon",
  "duck call",      "gun shot",    "klaxon horn",   "lions roar",
  "police whistle", "siren",       "slide whistle", "thunder sheet",
  "wind machine",   "wind whistle"};

const effect::value effect::_xsd_effect_indexes_[14] = {
  ::musicxml::effect::anvil,          ::musicxml::effect::auto_horn,
  ::musicxml::effect::bird_whistle,   ::musicxml::effect::cannon,
  ::musicxml::effect::duck_call,      ::musicxml::effect::gun_shot,
  ::musicxml::effect::klaxon_horn,    ::musicxml::effect::lions_roar,
  ::musicxml::effect::police_whistle, ::musicxml::effect::siren,
  ::musicxml::effect::slide_whistle,  ::musicxml::effect::thunder_sheet,
  ::musicxml::effect::wind_machine,   ::musicxml::effect::wind_whistle};

// glass
//

glass::glass(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_glass_convert();
}

glass::glass(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_glass_convert();
}

glass::glass(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_glass_convert();
}

glass *glass::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class glass(*this, f, c);
}

glass::value glass::_xsd_glass_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_glass_literals_);
  const value *i(
    ::std::lower_bound(_xsd_glass_indexes_, _xsd_glass_indexes_ + 1, *this, c));

  if (i == _xsd_glass_indexes_ + 1 || _xsd_glass_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const glass::_xsd_glass_literals_[1] = {"wind chimes"};

const glass::value glass::_xsd_glass_indexes_[1] = {
  ::musicxml::glass::wind_chimes};

// harmony_type
//

harmony_type::harmony_type(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_harmony_type_convert();
}

harmony_type::harmony_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_harmony_type_convert();
}

harmony_type::harmony_type(const ::std::string &s,
                           const ::xercesc::DOMElement *e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_harmony_type_convert();
}

harmony_type *harmony_type::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class harmony_type(*this, f, c);
}

harmony_type::value harmony_type::_xsd_harmony_type_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_harmony_type_literals_);
  const value *i(::std::lower_bound(_xsd_harmony_type_indexes_,
                                    _xsd_harmony_type_indexes_ + 3, *this, c));

  if (i == _xsd_harmony_type_indexes_ + 3 ||
      _xsd_harmony_type_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const harmony_type::_xsd_harmony_type_literals_[3] = {
  "explicit", "implied", "alternate"};

const harmony_type::value harmony_type::_xsd_harmony_type_indexes_[3] = {
  ::musicxml::harmony_type::alternate, ::musicxml::harmony_type::explicit_,
  ::musicxml::harmony_type::implied};

// kind_value
//

kind_value::kind_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_kind_value_convert();
}

kind_value::kind_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_kind_value_convert();
}

kind_value::kind_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_kind_value_convert();
}

kind_value *kind_value::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class kind_value(*this, f, c);
}

kind_value::value kind_value::_xsd_kind_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_kind_value_literals_);
  const value *i(::std::lower_bound(_xsd_kind_value_indexes_,
                                    _xsd_kind_value_indexes_ + 33, *this, c));

  if (i == _xsd_kind_value_indexes_ + 33 ||
      _xsd_kind_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const kind_value::_xsd_kind_value_literals_[33] = {
  "major",           "minor",              "augmented",
  "diminished",      "dominant",           "major-seventh",
  "minor-seventh",   "diminished-seventh", "augmented-seventh",
  "half-diminished", "major-minor",        "major-sixth",
  "minor-sixth",     "dominant-ninth",     "major-ninth",
  "minor-ninth",     "dominant-11th",      "major-11th",
  "minor-11th",      "dominant-13th",      "major-13th",
  "minor-13th",      "suspended-second",   "suspended-fourth",
  "Neapolitan",      "Italian",            "French",
  "German",          "pedal",              "power",
  "Tristan",         "other",              "none"};

const kind_value::value kind_value::_xsd_kind_value_indexes_[33] = {
  ::musicxml::kind_value::French,
  ::musicxml::kind_value::German,
  ::musicxml::kind_value::Italian,
  ::musicxml::kind_value::Neapolitan,
  ::musicxml::kind_value::Tristan,
  ::musicxml::kind_value::augmented,
  ::musicxml::kind_value::augmented_seventh,
  ::musicxml::kind_value::diminished,
  ::musicxml::kind_value::diminished_seventh,
  ::musicxml::kind_value::dominant,
  ::musicxml::kind_value::dominant_11th,
  ::musicxml::kind_value::dominant_13th,
  ::musicxml::kind_value::dominant_ninth,
  ::musicxml::kind_value::half_diminished,
  ::musicxml::kind_value::major,
  ::musicxml::kind_value::major_11th,
  ::musicxml::kind_value::major_13th,
  ::musicxml::kind_value::major_minor,
  ::musicxml::kind_value::major_ninth,
  ::musicxml::kind_value::major_seventh,
  ::musicxml::kind_value::major_sixth,
  ::musicxml::kind_value::minor,
  ::musicxml::kind_value::minor_11th,
  ::musicxml::kind_value::minor_13th,
  ::musicxml::kind_value::minor_ninth,
  ::musicxml::kind_value::minor_seventh,
  ::musicxml::kind_value::minor_sixth,
  ::musicxml::kind_value::none,
  ::musicxml::kind_value::other,
  ::musicxml::kind_value::pedal,
  ::musicxml::kind_value::power,
  ::musicxml::kind_value::suspended_fourth,
  ::musicxml::kind_value::suspended_second};

// line_end
//

line_end::line_end(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_line_end_convert();
}

line_end::line_end(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_line_end_convert();
}

line_end::line_end(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_line_end_convert();
}

line_end *line_end::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class line_end(*this, f, c);
}

line_end::value line_end::_xsd_line_end_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_line_end_literals_);
  const value *i(::std::lower_bound(_xsd_line_end_indexes_,
                                    _xsd_line_end_indexes_ + 5, *this, c));

  if (i == _xsd_line_end_indexes_ + 5 || _xsd_line_end_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const line_end::_xsd_line_end_literals_[5] = {"up", "down", "both",
                                                          "arrow", "none"};

const line_end::value line_end::_xsd_line_end_indexes_[5] = {
  ::musicxml::line_end::arrow, ::musicxml::line_end::both,
  ::musicxml::line_end::down, ::musicxml::line_end::none,
  ::musicxml::line_end::up};

// measure_numbering_value
//

measure_numbering_value::measure_numbering_value(const ::xercesc::DOMElement &e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_measure_numbering_value_convert();
}

measure_numbering_value::measure_numbering_value(const ::xercesc::DOMAttr &a,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_measure_numbering_value_convert();
}

measure_numbering_value::measure_numbering_value(const ::std::string &s,
                                                 const ::xercesc::DOMElement *e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_measure_numbering_value_convert();
}

measure_numbering_value *
measure_numbering_value::_clone(::xml_schema::flags f,
                                ::xml_schema::container *c) const {
  return new class measure_numbering_value(*this, f, c);
}

measure_numbering_value::value
measure_numbering_value::_xsd_measure_numbering_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(
    _xsd_measure_numbering_value_literals_);
  const value *i(::std::lower_bound(_xsd_measure_numbering_value_indexes_,
                                    _xsd_measure_numbering_value_indexes_ + 3,
                                    *this, c));

  if (i == _xsd_measure_numbering_value_indexes_ + 3 ||
      _xsd_measure_numbering_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const
  measure_numbering_value::_xsd_measure_numbering_value_literals_[3] = {
    "none", "measure", "system"};

const measure_numbering_value::value
  measure_numbering_value::_xsd_measure_numbering_value_indexes_[3] = {
    ::musicxml::measure_numbering_value::measure,
    ::musicxml::measure_numbering_value::none,
    ::musicxml::measure_numbering_value::system};

// membrane
//

membrane::membrane(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_membrane_convert();
}

membrane::membrane(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_membrane_convert();
}

membrane::membrane(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_membrane_convert();
}

membrane *membrane::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class membrane(*this, f, c);
}

membrane::value membrane::_xsd_membrane_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_membrane_literals_);
  const value *i(::std::lower_bound(_xsd_membrane_indexes_,
                                    _xsd_membrane_indexes_ + 12, *this, c));

  if (i == _xsd_membrane_indexes_ + 12 ||
      _xsd_membrane_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const membrane::_xsd_membrane_literals_[12] = {
  "bass drum",   "bass drum on side", "bongos",     "conga drum",
  "goblet drum", "military drum",     "snare drum", "snare drum snares off",
  "tambourine",  "tenor drum",        "timbales",   "tomtom"};

const membrane::value membrane::_xsd_membrane_indexes_[12] = {
  ::musicxml::membrane::bass_drum,
  ::musicxml::membrane::bass_drum_on_side,
  ::musicxml::membrane::bongos,
  ::musicxml::membrane::conga_drum,
  ::musicxml::membrane::goblet_drum,
  ::musicxml::membrane::military_drum,
  ::musicxml::membrane::snare_drum,
  ::musicxml::membrane::snare_drum_snares_off,
  ::musicxml::membrane::tambourine,
  ::musicxml::membrane::tenor_drum,
  ::musicxml::membrane::timbales,
  ::musicxml::membrane::tomtom};

// metal
//

metal::metal(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_metal_convert();
}

metal::metal(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_metal_convert();
}

metal::metal(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_metal_convert();
}

metal *metal::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class metal(*this, f, c);
}

metal::value metal::_xsd_metal_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_metal_literals_);
  const value *i(::std::lower_bound(_xsd_metal_indexes_,
                                    _xsd_metal_indexes_ + 23, *this, c));

  if (i == _xsd_metal_indexes_ + 23 || _xsd_metal_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const metal::_xsd_metal_literals_[23] = {
  "almglocken",     "bell",          "bell plate",       "brake drum",
  "Chinese cymbal", "cowbell",       "crash cymbals",    "crotale",
  "cymbal tongs",   "domed gong",    "finger cymbals",   "flexatone",
  "gong",           "hi-hat",        "high-hat cymbals", "handbell",
  "sistrum",        "sizzle cymbal", "sleigh bells",     "suspended cymbal",
  "tam tam",        "triangle",      "Vietnamese hat"};

const metal::value metal::_xsd_metal_indexes_[23] = {
  ::musicxml::metal::Chinese_cymbal,   ::musicxml::metal::Vietnamese_hat,
  ::musicxml::metal::almglocken,       ::musicxml::metal::bell,
  ::musicxml::metal::bell_plate,       ::musicxml::metal::brake_drum,
  ::musicxml::metal::cowbell,          ::musicxml::metal::crash_cymbals,
  ::musicxml::metal::crotale,          ::musicxml::metal::cymbal_tongs,
  ::musicxml::metal::domed_gong,       ::musicxml::metal::finger_cymbals,
  ::musicxml::metal::flexatone,        ::musicxml::metal::gong,
  ::musicxml::metal::handbell,         ::musicxml::metal::hi_hat,
  ::musicxml::metal::high_hat_cymbals, ::musicxml::metal::sistrum,
  ::musicxml::metal::sizzle_cymbal,    ::musicxml::metal::sleigh_bells,
  ::musicxml::metal::suspended_cymbal, ::musicxml::metal::tam_tam,
  ::musicxml::metal::triangle};

// on_off
//

on_off::on_off(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_on_off_convert();
}

on_off::on_off(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_on_off_convert();
}

on_off::on_off(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_on_off_convert();
}

on_off *on_off::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class on_off(*this, f, c);
}

on_off::value on_off::_xsd_on_off_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_on_off_literals_);
  const value *i(::std::lower_bound(_xsd_on_off_indexes_,
                                    _xsd_on_off_indexes_ + 2, *this, c));

  if (i == _xsd_on_off_indexes_ + 2 || _xsd_on_off_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const on_off::_xsd_on_off_literals_[2] = {"on", "off"};

const on_off::value on_off::_xsd_on_off_indexes_[2] = {::musicxml::on_off::off,
                                                       ::musicxml::on_off::on};

// pitched
//

pitched::pitched(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_pitched_convert();
}

pitched::pitched(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_pitched_convert();
}

pitched::pitched(const ::std::string &s, const ::xercesc::DOMElement *e,
                 ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_pitched_convert();
}

pitched *pitched::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class pitched(*this, f, c);
}

pitched::value pitched::_xsd_pitched_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_pitched_literals_);
  const value *i(::std::lower_bound(_xsd_pitched_indexes_,
                                    _xsd_pitched_indexes_ + 7, *this, c));

  if (i == _xsd_pitched_indexes_ + 7 || _xsd_pitched_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const pitched::_xsd_pitched_literals_[7] = {
  "chimes",         "glockenspiel", "mallet",   "marimba",
  "tubular chimes", "vibraphone",   "xylophone"};

const pitched::value pitched::_xsd_pitched_indexes_[7] = {
  ::musicxml::pitched::chimes,         ::musicxml::pitched::glockenspiel,
  ::musicxml::pitched::mallet,         ::musicxml::pitched::marimba,
  ::musicxml::pitched::tubular_chimes, ::musicxml::pitched::vibraphone,
  ::musicxml::pitched::xylophone};

// principal_voice_symbol
//

principal_voice_symbol::principal_voice_symbol(const ::xercesc::DOMElement &e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_principal_voice_symbol_convert();
}

principal_voice_symbol::principal_voice_symbol(const ::xercesc::DOMAttr &a,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_principal_voice_symbol_convert();
}

principal_voice_symbol::principal_voice_symbol(const ::std::string &s,
                                               const ::xercesc::DOMElement *e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_principal_voice_symbol_convert();
}

principal_voice_symbol *
principal_voice_symbol::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class principal_voice_symbol(*this, f, c);
}

principal_voice_symbol::value
principal_voice_symbol::_xsd_principal_voice_symbol_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(
    _xsd_principal_voice_symbol_literals_);
  const value *i(::std::lower_bound(_xsd_principal_voice_symbol_indexes_,
                                    _xsd_principal_voice_symbol_indexes_ + 4,
                                    *this, c));

  if (i == _xsd_principal_voice_symbol_indexes_ + 4 ||
      _xsd_principal_voice_symbol_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const
  principal_voice_symbol::_xsd_principal_voice_symbol_literals_[4] = {
    "Hauptstimme", "Nebenstimme", "plain", "none"};

const principal_voice_symbol::value
  principal_voice_symbol::_xsd_principal_voice_symbol_indexes_[4] = {
    ::musicxml::principal_voice_symbol::Hauptstimme,
    ::musicxml::principal_voice_symbol::Nebenstimme,
    ::musicxml::principal_voice_symbol::none,
    ::musicxml::principal_voice_symbol::plain};

// start_stop_change_continue
//

start_stop_change_continue::start_stop_change_continue(
  const ::xercesc::DOMElement &e, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_start_stop_change_continue_convert();
}

start_stop_change_continue::start_stop_change_continue(
  const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_start_stop_change_continue_convert();
}

start_stop_change_continue::start_stop_change_continue(
  const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_start_stop_change_continue_convert();
}

start_stop_change_continue *
start_stop_change_continue::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class start_stop_change_continue(*this, f, c);
}

start_stop_change_continue::value
start_stop_change_continue::_xsd_start_stop_change_continue_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(
    _xsd_start_stop_change_continue_literals_);
  const value *i(
    ::std::lower_bound(_xsd_start_stop_change_continue_indexes_,
                       _xsd_start_stop_change_continue_indexes_ + 4, *this, c));

  if (i == _xsd_start_stop_change_continue_indexes_ + 4 ||
      _xsd_start_stop_change_continue_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const
  start_stop_change_continue::_xsd_start_stop_change_continue_literals_[4] = {
    "start", "stop", "change", "continue"};

const start_stop_change_continue::value
  start_stop_change_continue::_xsd_start_stop_change_continue_indexes_[4] = {
    ::musicxml::start_stop_change_continue::change,
    ::musicxml::start_stop_change_continue::continue_,
    ::musicxml::start_stop_change_continue::start,
    ::musicxml::start_stop_change_continue::stop};

// tip_direction
//

tip_direction::tip_direction(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_tip_direction_convert();
}

tip_direction::tip_direction(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_tip_direction_convert();
}

tip_direction::tip_direction(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_tip_direction_convert();
}

tip_direction *tip_direction::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class tip_direction(*this, f, c);
}

tip_direction::value tip_direction::_xsd_tip_direction_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_tip_direction_literals_);
  const value *i(::std::lower_bound(_xsd_tip_direction_indexes_,
                                    _xsd_tip_direction_indexes_ + 8, *this, c));

  if (i == _xsd_tip_direction_indexes_ + 8 ||
      _xsd_tip_direction_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const tip_direction::_xsd_tip_direction_literals_[8] = {
  "up",        "down",      "left",      "right",
  "northwest", "northeast", "southeast", "southwest"};

const tip_direction::value tip_direction::_xsd_tip_direction_indexes_[8] = {
  ::musicxml::tip_direction::down,      ::musicxml::tip_direction::left,
  ::musicxml::tip_direction::northeast, ::musicxml::tip_direction::northwest,
  ::musicxml::tip_direction::right,     ::musicxml::tip_direction::southeast,
  ::musicxml::tip_direction::southwest, ::musicxml::tip_direction::up};

// stick_location
//

stick_location::stick_location(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_stick_location_convert();
}

stick_location::stick_location(const ::xercesc::DOMAttr &a,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_stick_location_convert();
}

stick_location::stick_location(const ::std::string &s,
                               const ::xercesc::DOMElement *e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_stick_location_convert();
}

stick_location *stick_location::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class stick_location(*this, f, c);
}

stick_location::value stick_location::_xsd_stick_location_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_stick_location_literals_);
  const value *i(::std::lower_bound(
    _xsd_stick_location_indexes_, _xsd_stick_location_indexes_ + 4, *this, c));

  if (i == _xsd_stick_location_indexes_ + 4 ||
      _xsd_stick_location_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const stick_location::_xsd_stick_location_literals_[4] = {
  "center", "rim", "cymbal bell", "cymbal edge"};

const stick_location::value stick_location::_xsd_stick_location_indexes_[4] = {
  ::musicxml::stick_location::center, ::musicxml::stick_location::cymbal_bell,
  ::musicxml::stick_location::cymbal_edge, ::musicxml::stick_location::rim};

// stick_material
//

stick_material::stick_material(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_stick_material_convert();
}

stick_material::stick_material(const ::xercesc::DOMAttr &a,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_stick_material_convert();
}

stick_material::stick_material(const ::std::string &s,
                               const ::xercesc::DOMElement *e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_stick_material_convert();
}

stick_material *stick_material::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class stick_material(*this, f, c);
}

stick_material::value stick_material::_xsd_stick_material_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_stick_material_literals_);
  const value *i(::std::lower_bound(
    _xsd_stick_material_indexes_, _xsd_stick_material_indexes_ + 5, *this, c));

  if (i == _xsd_stick_material_indexes_ + 5 ||
      _xsd_stick_material_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const stick_material::_xsd_stick_material_literals_[5] = {
  "soft", "medium", "hard", "shaded", "x"};

const stick_material::value stick_material::_xsd_stick_material_indexes_[5] = {
  ::musicxml::stick_material::hard, ::musicxml::stick_material::medium,
  ::musicxml::stick_material::shaded, ::musicxml::stick_material::soft,
  ::musicxml::stick_material::x};

// stick_type
//

stick_type::stick_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_stick_type_convert();
}

stick_type::stick_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_stick_type_convert();
}

stick_type::stick_type(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_stick_type_convert();
}

stick_type *stick_type::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class stick_type(*this, f, c);
}

stick_type::value stick_type::_xsd_stick_type_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_stick_type_literals_);
  const value *i(::std::lower_bound(_xsd_stick_type_indexes_,
                                    _xsd_stick_type_indexes_ + 5, *this, c));

  if (i == _xsd_stick_type_indexes_ + 5 ||
      _xsd_stick_type_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const stick_type::_xsd_stick_type_literals_[5] = {
  "bass drum", "double bass drum", "timpani", "xylophone", "yarn"};

const stick_type::value stick_type::_xsd_stick_type_indexes_[5] = {
  ::musicxml::stick_type::bass_drum, ::musicxml::stick_type::double_bass_drum,
  ::musicxml::stick_type::timpani, ::musicxml::stick_type::xylophone,
  ::musicxml::stick_type::yarn};

// up_down_stop_continue
//

up_down_stop_continue::up_down_stop_continue(const ::xercesc::DOMElement &e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_up_down_stop_continue_convert();
}

up_down_stop_continue::up_down_stop_continue(const ::xercesc::DOMAttr &a,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_up_down_stop_continue_convert();
}

up_down_stop_continue::up_down_stop_continue(const ::std::string &s,
                                             const ::xercesc::DOMElement *e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_up_down_stop_continue_convert();
}

up_down_stop_continue *
up_down_stop_continue::_clone(::xml_schema::flags f,
                              ::xml_schema::container *c) const {
  return new class up_down_stop_continue(*this, f, c);
}

up_down_stop_continue::value
up_down_stop_continue::_xsd_up_down_stop_continue_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(
    _xsd_up_down_stop_continue_literals_);
  const value *i(::std::lower_bound(_xsd_up_down_stop_continue_indexes_,
                                    _xsd_up_down_stop_continue_indexes_ + 4,
                                    *this, c));

  if (i == _xsd_up_down_stop_continue_indexes_ + 4 ||
      _xsd_up_down_stop_continue_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const
  up_down_stop_continue::_xsd_up_down_stop_continue_literals_[4] = {
    "up", "down", "stop", "continue"};

const up_down_stop_continue::value
  up_down_stop_continue::_xsd_up_down_stop_continue_indexes_[4] = {
    ::musicxml::up_down_stop_continue::continue_,
    ::musicxml::up_down_stop_continue::down,
    ::musicxml::up_down_stop_continue::stop,
    ::musicxml::up_down_stop_continue::up};

// wedge_type
//

wedge_type::wedge_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_wedge_type_convert();
}

wedge_type::wedge_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_wedge_type_convert();
}

wedge_type::wedge_type(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_wedge_type_convert();
}

wedge_type *wedge_type::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class wedge_type(*this, f, c);
}

wedge_type::value wedge_type::_xsd_wedge_type_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_wedge_type_literals_);
  const value *i(::std::lower_bound(_xsd_wedge_type_indexes_,
                                    _xsd_wedge_type_indexes_ + 4, *this, c));

  if (i == _xsd_wedge_type_indexes_ + 4 ||
      _xsd_wedge_type_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const wedge_type::_xsd_wedge_type_literals_[4] = {
  "crescendo", "diminuendo", "stop", "continue"};

const wedge_type::value wedge_type::_xsd_wedge_type_indexes_[4] = {
  ::musicxml::wedge_type::continue_, ::musicxml::wedge_type::crescendo,
  ::musicxml::wedge_type::diminuendo, ::musicxml::wedge_type::stop};

// wood
//

wood::wood(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_wood_convert();
}

wood::wood(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_wood_convert();
}

wood::wood(const ::std::string &s, const ::xercesc::DOMElement *e,
           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_wood_convert();
}

wood *wood::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class wood(*this, f, c);
}

wood::value wood::_xsd_wood_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_wood_literals_);
  const value *i(
    ::std::lower_bound(_xsd_wood_indexes_, _xsd_wood_indexes_ + 14, *this, c));

  if (i == _xsd_wood_indexes_ + 14 || _xsd_wood_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const wood::_xsd_wood_literals_[14] = {
  "board clapper", "cabasa",       "castanets", "claves",    "guiro",
  "log drum",      "maraca",       "maracas",   "ratchet",   "sandpaper blocks",
  "slit drum",     "temple block", "vibraslap", "wood block"};

const wood::value wood::_xsd_wood_indexes_[14] = {
  ::musicxml::wood::board_clapper, ::musicxml::wood::cabasa,
  ::musicxml::wood::castanets,     ::musicxml::wood::claves,
  ::musicxml::wood::guiro,         ::musicxml::wood::log_drum,
  ::musicxml::wood::maraca,        ::musicxml::wood::maracas,
  ::musicxml::wood::ratchet,       ::musicxml::wood::sandpaper_blocks,
  ::musicxml::wood::slit_drum,     ::musicxml::wood::temple_block,
  ::musicxml::wood::vibraslap,     ::musicxml::wood::wood_block};

// distance_type
//

distance_type::distance_type() : ::xml_schema::token() {}

distance_type::distance_type(const char *_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

distance_type::distance_type(const ::std::string &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

distance_type::distance_type(const ::xml_schema::token &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

distance_type::distance_type(const distance_type &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::token(x, f, c) {}

distance_type::distance_type(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {}

distance_type::distance_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {}

distance_type::distance_type(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {}

distance_type *distance_type::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class distance_type(*this, f, c);
}

distance_type::~distance_type() {}

// line_width_type
//

line_width_type::line_width_type() : ::xml_schema::token() {}

line_width_type::line_width_type(const char *_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

line_width_type::line_width_type(const ::std::string &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

line_width_type::line_width_type(const ::xml_schema::token &_xsd_token_base)
: ::xml_schema::token(_xsd_token_base) {}

line_width_type::line_width_type(const line_width_type &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::token(x, f, c) {}

line_width_type::line_width_type(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {}

line_width_type::line_width_type(const ::xercesc::DOMAttr &a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {}

line_width_type::line_width_type(const ::std::string &s,
                                 const ::xercesc::DOMElement *e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {}

line_width_type *line_width_type::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class line_width_type(*this, f, c);
}

line_width_type::~line_width_type() {}

// margin_type
//

margin_type::margin_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_margin_type_convert();
}

margin_type::margin_type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_margin_type_convert();
}

margin_type::margin_type(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_margin_type_convert();
}

margin_type *margin_type::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class margin_type(*this, f, c);
}

margin_type::value margin_type::_xsd_margin_type_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_margin_type_literals_);
  const value *i(::std::lower_bound(_xsd_margin_type_indexes_,
                                    _xsd_margin_type_indexes_ + 3, *this, c));

  if (i == _xsd_margin_type_indexes_ + 3 ||
      _xsd_margin_type_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const margin_type::_xsd_margin_type_literals_[3] = {"odd", "even",
                                                                "both"};

const margin_type::value margin_type::_xsd_margin_type_indexes_[3] = {
  ::musicxml::margin_type::both, ::musicxml::margin_type::even,
  ::musicxml::margin_type::odd};

// millimeters
//

millimeters::millimeters(const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

millimeters::millimeters(const millimeters &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

millimeters::millimeters(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

millimeters::millimeters(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

millimeters::millimeters(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

millimeters *millimeters::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class millimeters(*this, f, c);
}

millimeters::~millimeters() {}

// note_size_type
//

note_size_type::note_size_type(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_note_size_type_convert();
}

note_size_type::note_size_type(const ::xercesc::DOMAttr &a,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_note_size_type_convert();
}

note_size_type::note_size_type(const ::std::string &s,
                               const ::xercesc::DOMElement *e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_note_size_type_convert();
}

note_size_type *note_size_type::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class note_size_type(*this, f, c);
}

note_size_type::value note_size_type::_xsd_note_size_type_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_note_size_type_literals_);
  const value *i(::std::lower_bound(
    _xsd_note_size_type_indexes_, _xsd_note_size_type_indexes_ + 3, *this, c));

  if (i == _xsd_note_size_type_indexes_ + 3 ||
      _xsd_note_size_type_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const note_size_type::_xsd_note_size_type_literals_[3] = {
  "cue", "grace", "large"};

const note_size_type::value note_size_type::_xsd_note_size_type_indexes_[3] = {
  ::musicxml::note_size_type::cue, ::musicxml::note_size_type::grace,
  ::musicxml::note_size_type::large};

// accidental_value
//

accidental_value::accidental_value(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_accidental_value_convert();
}

accidental_value::accidental_value(const ::xercesc::DOMAttr &a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_accidental_value_convert();
}

accidental_value::accidental_value(const ::std::string &s,
                                   const ::xercesc::DOMElement *e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_accidental_value_convert();
}

accidental_value *accidental_value::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class accidental_value(*this, f, c);
}

accidental_value::value
accidental_value::_xsd_accidental_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_accidental_value_literals_);
  const value *i(::std::lower_bound(_xsd_accidental_value_indexes_,
                                    _xsd_accidental_value_indexes_ + 34, *this,
                                    c));

  if (i == _xsd_accidental_value_indexes_ + 34 ||
      _xsd_accidental_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const accidental_value::_xsd_accidental_value_literals_[34] = {
  "sharp",         "natural",             "flat",
  "double-sharp",  "sharp-sharp",         "flat-flat",
  "natural-sharp", "natural-flat",        "quarter-flat",
  "quarter-sharp", "three-quarters-flat", "three-quarters-sharp",
  "sharp-down",    "sharp-up",            "natural-down",
  "natural-up",    "flat-down",           "flat-up",
  "triple-sharp",  "triple-flat",         "slash-quarter-sharp",
  "slash-sharp",   "slash-flat",          "double-slash-flat",
  "sharp-1",       "sharp-2",             "sharp-3",
  "sharp-5",       "flat-1",              "flat-2",
  "flat-3",        "flat-4",              "sori",
  "koron"};

const accidental_value::value
  accidental_value::_xsd_accidental_value_indexes_[34] = {
    ::musicxml::accidental_value::double_sharp,
    ::musicxml::accidental_value::double_slash_flat,
    ::musicxml::accidental_value::flat,
    ::musicxml::accidental_value::flat_1,
    ::musicxml::accidental_value::flat_2,
    ::musicxml::accidental_value::flat_3,
    ::musicxml::accidental_value::flat_4,
    ::musicxml::accidental_value::flat_down,
    ::musicxml::accidental_value::flat_flat,
    ::musicxml::accidental_value::flat_up,
    ::musicxml::accidental_value::koron,
    ::musicxml::accidental_value::natural,
    ::musicxml::accidental_value::natural_down,
    ::musicxml::accidental_value::natural_flat,
    ::musicxml::accidental_value::natural_sharp,
    ::musicxml::accidental_value::natural_up,
    ::musicxml::accidental_value::quarter_flat,
    ::musicxml::accidental_value::quarter_sharp,
    ::musicxml::accidental_value::sharp,
    ::musicxml::accidental_value::sharp_1,
    ::musicxml::accidental_value::sharp_2,
    ::musicxml::accidental_value::sharp_3,
    ::musicxml::accidental_value::sharp_5,
    ::musicxml::accidental_value::sharp_down,
    ::musicxml::accidental_value::sharp_sharp,
    ::musicxml::accidental_value::sharp_up,
    ::musicxml::accidental_value::slash_flat,
    ::musicxml::accidental_value::slash_quarter_sharp,
    ::musicxml::accidental_value::slash_sharp,
    ::musicxml::accidental_value::sori,
    ::musicxml::accidental_value::three_quarters_flat,
    ::musicxml::accidental_value::three_quarters_sharp,
    ::musicxml::accidental_value::triple_flat,
    ::musicxml::accidental_value::triple_sharp};

// arrow_direction
//

arrow_direction::arrow_direction(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_arrow_direction_convert();
}

arrow_direction::arrow_direction(const ::xercesc::DOMAttr &a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_arrow_direction_convert();
}

arrow_direction::arrow_direction(const ::std::string &s,
                                 const ::xercesc::DOMElement *e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_arrow_direction_convert();
}

arrow_direction *arrow_direction::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class arrow_direction(*this, f, c);
}

arrow_direction::value arrow_direction::_xsd_arrow_direction_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_arrow_direction_literals_);
  const value *i(::std::lower_bound(_xsd_arrow_direction_indexes_,
                                    _xsd_arrow_direction_indexes_ + 13, *this,
                                    c));

  if (i == _xsd_arrow_direction_indexes_ + 13 ||
      _xsd_arrow_direction_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const arrow_direction::_xsd_arrow_direction_literals_[13] = {
  "left",       "up",        "right",               "down",
  "northwest",  "northeast", "southeast",           "southwest",
  "left right", "up down",   "northwest southeast", "northeast southwest",
  "other"};

const arrow_direction::value
  arrow_direction::_xsd_arrow_direction_indexes_[13] = {
    ::musicxml::arrow_direction::down,
    ::musicxml::arrow_direction::left,
    ::musicxml::arrow_direction::left_right,
    ::musicxml::arrow_direction::northeast,
    ::musicxml::arrow_direction::northeast_southwest,
    ::musicxml::arrow_direction::northwest,
    ::musicxml::arrow_direction::northwest_southeast,
    ::musicxml::arrow_direction::other,
    ::musicxml::arrow_direction::right,
    ::musicxml::arrow_direction::southeast,
    ::musicxml::arrow_direction::southwest,
    ::musicxml::arrow_direction::up,
    ::musicxml::arrow_direction::up_down};

// arrow_style
//

arrow_style::arrow_style(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_arrow_style_convert();
}

arrow_style::arrow_style(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_arrow_style_convert();
}

arrow_style::arrow_style(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_arrow_style_convert();
}

arrow_style *arrow_style::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class arrow_style(*this, f, c);
}

arrow_style::value arrow_style::_xsd_arrow_style_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_arrow_style_literals_);
  const value *i(::std::lower_bound(_xsd_arrow_style_indexes_,
                                    _xsd_arrow_style_indexes_ + 7, *this, c));

  if (i == _xsd_arrow_style_indexes_ + 7 ||
      _xsd_arrow_style_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const arrow_style::_xsd_arrow_style_literals_[7] = {
  "single", "double", "filled", "hollow", "paired", "combined", "other"};

const arrow_style::value arrow_style::_xsd_arrow_style_indexes_[7] = {
  ::musicxml::arrow_style::combined, ::musicxml::arrow_style::double_,
  ::musicxml::arrow_style::filled,   ::musicxml::arrow_style::hollow,
  ::musicxml::arrow_style::other,    ::musicxml::arrow_style::paired,
  ::musicxml::arrow_style::single};

// beam_value
//

beam_value::beam_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_beam_value_convert();
}

beam_value::beam_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_beam_value_convert();
}

beam_value::beam_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_beam_value_convert();
}

beam_value *beam_value::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class beam_value(*this, f, c);
}

beam_value::value beam_value::_xsd_beam_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_beam_value_literals_);
  const value *i(::std::lower_bound(_xsd_beam_value_indexes_,
                                    _xsd_beam_value_indexes_ + 5, *this, c));

  if (i == _xsd_beam_value_indexes_ + 5 ||
      _xsd_beam_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const beam_value::_xsd_beam_value_literals_[5] = {
  "begin", "continue", "end", "forward hook", "backward hook"};

const beam_value::value beam_value::_xsd_beam_value_indexes_[5] = {
  ::musicxml::beam_value::backward_hook, ::musicxml::beam_value::begin,
  ::musicxml::beam_value::continue_, ::musicxml::beam_value::end,
  ::musicxml::beam_value::forward_hook};

// breath_mark_value
//

breath_mark_value::breath_mark_value(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_breath_mark_value_convert();
}

breath_mark_value::breath_mark_value(const ::xercesc::DOMAttr &a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_breath_mark_value_convert();
}

breath_mark_value::breath_mark_value(const ::std::string &s,
                                     const ::xercesc::DOMElement *e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_breath_mark_value_convert();
}

breath_mark_value *breath_mark_value::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class breath_mark_value(*this, f, c);
}

breath_mark_value::value
breath_mark_value::_xsd_breath_mark_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_breath_mark_value_literals_);
  const value *i(::std::lower_bound(_xsd_breath_mark_value_indexes_,
                                    _xsd_breath_mark_value_indexes_ + 3, *this,
                                    c));

  if (i == _xsd_breath_mark_value_indexes_ + 3 ||
      _xsd_breath_mark_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const breath_mark_value::_xsd_breath_mark_value_literals_[3] = {
  "", "comma", "tick"};

const breath_mark_value::value
  breath_mark_value::_xsd_breath_mark_value_indexes_[3] = {
    ::musicxml::breath_mark_value::empty, ::musicxml::breath_mark_value::comma,
    ::musicxml::breath_mark_value::tick};

// circular_arrow
//

circular_arrow::circular_arrow(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_circular_arrow_convert();
}

circular_arrow::circular_arrow(const ::xercesc::DOMAttr &a,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_circular_arrow_convert();
}

circular_arrow::circular_arrow(const ::std::string &s,
                               const ::xercesc::DOMElement *e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_circular_arrow_convert();
}

circular_arrow *circular_arrow::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class circular_arrow(*this, f, c);
}

circular_arrow::value circular_arrow::_xsd_circular_arrow_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_circular_arrow_literals_);
  const value *i(::std::lower_bound(
    _xsd_circular_arrow_indexes_, _xsd_circular_arrow_indexes_ + 2, *this, c));

  if (i == _xsd_circular_arrow_indexes_ + 2 ||
      _xsd_circular_arrow_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const circular_arrow::_xsd_circular_arrow_literals_[2] = {
  "clockwise", "anticlockwise"};

const circular_arrow::value circular_arrow::_xsd_circular_arrow_indexes_[2] = {
  ::musicxml::circular_arrow::anticlockwise,
  ::musicxml::circular_arrow::clockwise};

// fan
//

fan::fan(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_fan_convert();
}

fan::fan(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_fan_convert();
}

fan::fan(const ::std::string &s, const ::xercesc::DOMElement *e,
         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_fan_convert();
}

fan *fan::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class fan(*this, f, c);
}

fan::value fan::_xsd_fan_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_fan_literals_);
  const value *i(
    ::std::lower_bound(_xsd_fan_indexes_, _xsd_fan_indexes_ + 3, *this, c));

  if (i == _xsd_fan_indexes_ + 3 || _xsd_fan_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const fan::_xsd_fan_literals_[3] = {"accel", "rit", "none"};

const fan::value fan::_xsd_fan_indexes_[3] = {
  ::musicxml::fan::accel, ::musicxml::fan::none, ::musicxml::fan::rit};

// handbell_value
//

handbell_value::handbell_value(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_handbell_value_convert();
}

handbell_value::handbell_value(const ::xercesc::DOMAttr &a,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_handbell_value_convert();
}

handbell_value::handbell_value(const ::std::string &s,
                               const ::xercesc::DOMElement *e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_handbell_value_convert();
}

handbell_value *handbell_value::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class handbell_value(*this, f, c);
}

handbell_value::value handbell_value::_xsd_handbell_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_handbell_value_literals_);
  const value *i(::std::lower_bound(
    _xsd_handbell_value_indexes_, _xsd_handbell_value_indexes_ + 11, *this, c));

  if (i == _xsd_handbell_value_indexes_ + 11 ||
      _xsd_handbell_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const handbell_value::_xsd_handbell_value_literals_[11] = {
  "damp",             "echo",         "gyro",       "hand martellato",
  "mallet lift",      "mallet table", "martellato", "martellato lift",
  "muted martellato", "pluck lift",   "swing"};

const handbell_value::value handbell_value::_xsd_handbell_value_indexes_[11] = {
  ::musicxml::handbell_value::damp,
  ::musicxml::handbell_value::echo,
  ::musicxml::handbell_value::gyro,
  ::musicxml::handbell_value::hand_martellato,
  ::musicxml::handbell_value::mallet_lift,
  ::musicxml::handbell_value::mallet_table,
  ::musicxml::handbell_value::martellato,
  ::musicxml::handbell_value::martellato_lift,
  ::musicxml::handbell_value::muted_martellato,
  ::musicxml::handbell_value::pluck_lift,
  ::musicxml::handbell_value::swing};

// hole_closed_location
//

hole_closed_location::hole_closed_location(const ::xercesc::DOMElement &e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_hole_closed_location_convert();
}

hole_closed_location::hole_closed_location(const ::xercesc::DOMAttr &a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_hole_closed_location_convert();
}

hole_closed_location::hole_closed_location(const ::std::string &s,
                                           const ::xercesc::DOMElement *e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_hole_closed_location_convert();
}

hole_closed_location *
hole_closed_location::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class hole_closed_location(*this, f, c);
}

hole_closed_location::value
hole_closed_location::_xsd_hole_closed_location_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(
    _xsd_hole_closed_location_literals_);
  const value *i(::std::lower_bound(_xsd_hole_closed_location_indexes_,
                                    _xsd_hole_closed_location_indexes_ + 4,
                                    *this, c));

  if (i == _xsd_hole_closed_location_indexes_ + 4 ||
      _xsd_hole_closed_location_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const hole_closed_location::_xsd_hole_closed_location_literals_[4] =
  {"right", "bottom", "left", "top"};

const hole_closed_location::value
  hole_closed_location::_xsd_hole_closed_location_indexes_[4] = {
    ::musicxml::hole_closed_location::bottom,
    ::musicxml::hole_closed_location::left,
    ::musicxml::hole_closed_location::right,
    ::musicxml::hole_closed_location::top};

// hole_closed_value
//

hole_closed_value::hole_closed_value(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_hole_closed_value_convert();
}

hole_closed_value::hole_closed_value(const ::xercesc::DOMAttr &a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_hole_closed_value_convert();
}

hole_closed_value::hole_closed_value(const ::std::string &s,
                                     const ::xercesc::DOMElement *e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_hole_closed_value_convert();
}

hole_closed_value *hole_closed_value::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class hole_closed_value(*this, f, c);
}

hole_closed_value::value
hole_closed_value::_xsd_hole_closed_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_hole_closed_value_literals_);
  const value *i(::std::lower_bound(_xsd_hole_closed_value_indexes_,
                                    _xsd_hole_closed_value_indexes_ + 3, *this,
                                    c));

  if (i == _xsd_hole_closed_value_indexes_ + 3 ||
      _xsd_hole_closed_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const hole_closed_value::_xsd_hole_closed_value_literals_[3] = {
  "yes", "no", "half"};

const hole_closed_value::value
  hole_closed_value::_xsd_hole_closed_value_indexes_[3] = {
    ::musicxml::hole_closed_value::half, ::musicxml::hole_closed_value::no,
    ::musicxml::hole_closed_value::yes};

// note_type_value
//

note_type_value::note_type_value(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_note_type_value_convert();
}

note_type_value::note_type_value(const ::xercesc::DOMAttr &a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_note_type_value_convert();
}

note_type_value::note_type_value(const ::std::string &s,
                                 const ::xercesc::DOMElement *e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_note_type_value_convert();
}

note_type_value *note_type_value::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class note_type_value(*this, f, c);
}

note_type_value::value note_type_value::_xsd_note_type_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_note_type_value_literals_);
  const value *i(::std::lower_bound(_xsd_note_type_value_indexes_,
                                    _xsd_note_type_value_indexes_ + 14, *this,
                                    c));

  if (i == _xsd_note_type_value_indexes_ + 14 ||
      _xsd_note_type_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const note_type_value::_xsd_note_type_value_literals_[14] = {
  "1024th", "512th",   "256th", "128th", "64th",  "32nd", "16th",
  "eighth", "quarter", "half",  "whole", "breve", "long", "maxima"};

const note_type_value::value
  note_type_value::_xsd_note_type_value_indexes_[14] = {
    ::musicxml::note_type_value::cxx_1024th,
    ::musicxml::note_type_value::cxx_128th,
    ::musicxml::note_type_value::cxx_16th,
    ::musicxml::note_type_value::cxx_256th,
    ::musicxml::note_type_value::cxx_32nd,
    ::musicxml::note_type_value::cxx_512th,
    ::musicxml::note_type_value::cxx_64th,
    ::musicxml::note_type_value::breve,
    ::musicxml::note_type_value::eighth,
    ::musicxml::note_type_value::half,
    ::musicxml::note_type_value::long_,
    ::musicxml::note_type_value::maxima,
    ::musicxml::note_type_value::quarter,
    ::musicxml::note_type_value::whole};

// notehead_value
//

notehead_value::notehead_value(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_notehead_value_convert();
}

notehead_value::notehead_value(const ::xercesc::DOMAttr &a,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_notehead_value_convert();
}

notehead_value::notehead_value(const ::std::string &s,
                               const ::xercesc::DOMElement *e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_notehead_value_convert();
}

notehead_value *notehead_value::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class notehead_value(*this, f, c);
}

notehead_value::value notehead_value::_xsd_notehead_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_notehead_value_literals_);
  const value *i(::std::lower_bound(
    _xsd_notehead_value_indexes_, _xsd_notehead_value_indexes_ + 26, *this, c));

  if (i == _xsd_notehead_value_indexes_ + 26 ||
      _xsd_notehead_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const notehead_value::_xsd_notehead_value_literals_[26] = {
  "slash",      "triangle", "diamond",    "square",
  "cross",      "x",        "circle-x",   "inverted triangle",
  "arrow down", "arrow up", "slashed",    "back slashed",
  "normal",     "cluster",  "circle dot", "left triangle",
  "rectangle",  "none",     "do",         "re",
  "mi",         "fa",       "fa up",      "so",
  "la",         "ti"};

const notehead_value::value notehead_value::_xsd_notehead_value_indexes_[26] = {
  ::musicxml::notehead_value::arrow_down,
  ::musicxml::notehead_value::arrow_up,
  ::musicxml::notehead_value::back_slashed,
  ::musicxml::notehead_value::circle_dot,
  ::musicxml::notehead_value::circle_x,
  ::musicxml::notehead_value::cluster,
  ::musicxml::notehead_value::cross,
  ::musicxml::notehead_value::diamond,
  ::musicxml::notehead_value::do_,
  ::musicxml::notehead_value::fa,
  ::musicxml::notehead_value::fa_up,
  ::musicxml::notehead_value::inverted_triangle,
  ::musicxml::notehead_value::la,
  ::musicxml::notehead_value::left_triangle,
  ::musicxml::notehead_value::mi,
  ::musicxml::notehead_value::none,
  ::musicxml::notehead_value::normal,
  ::musicxml::notehead_value::re,
  ::musicxml::notehead_value::rectangle,
  ::musicxml::notehead_value::slash,
  ::musicxml::notehead_value::slashed,
  ::musicxml::notehead_value::so,
  ::musicxml::notehead_value::square,
  ::musicxml::notehead_value::ti,
  ::musicxml::notehead_value::triangle,
  ::musicxml::notehead_value::x};

// octave
//

octave::octave(const ::xml_schema::integer &_xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type>(_xsd_integer_base) {
}

octave::octave(const octave &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

octave::octave(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

octave::octave(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

octave::octave(const ::std::string &s, const ::xercesc::DOMElement *e,
               ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

octave *octave::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class octave(*this, f, c);
}

octave::~octave() {}

// semitones
//

semitones::semitones(const ::xml_schema::decimal &_xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(_xsd_decimal_base) {}

semitones::semitones(const semitones &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(x, f, c) {}

semitones::semitones(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(e, f, c) {}

semitones::semitones(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(a, f, c) {}

semitones::semitones(const ::std::string &s, const ::xercesc::DOMElement *e,
                     ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal>(s, e, f, c) {}

semitones *semitones::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class semitones(*this, f, c);
}

semitones::~semitones() {}

// show_tuplet
//

show_tuplet::show_tuplet(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_show_tuplet_convert();
}

show_tuplet::show_tuplet(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_show_tuplet_convert();
}

show_tuplet::show_tuplet(const ::std::string &s, const ::xercesc::DOMElement *e,
                         ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_show_tuplet_convert();
}

show_tuplet *show_tuplet::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class show_tuplet(*this, f, c);
}

show_tuplet::value show_tuplet::_xsd_show_tuplet_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_show_tuplet_literals_);
  const value *i(::std::lower_bound(_xsd_show_tuplet_indexes_,
                                    _xsd_show_tuplet_indexes_ + 3, *this, c));

  if (i == _xsd_show_tuplet_indexes_ + 3 ||
      _xsd_show_tuplet_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const show_tuplet::_xsd_show_tuplet_literals_[3] = {"actual",
                                                                "both", "none"};

const show_tuplet::value show_tuplet::_xsd_show_tuplet_indexes_[3] = {
  ::musicxml::show_tuplet::actual, ::musicxml::show_tuplet::both,
  ::musicxml::show_tuplet::none};

// stem_value
//

stem_value::stem_value(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_stem_value_convert();
}

stem_value::stem_value(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_stem_value_convert();
}

stem_value::stem_value(const ::std::string &s, const ::xercesc::DOMElement *e,
                       ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_stem_value_convert();
}

stem_value *stem_value::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class stem_value(*this, f, c);
}

stem_value::value stem_value::_xsd_stem_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_stem_value_literals_);
  const value *i(::std::lower_bound(_xsd_stem_value_indexes_,
                                    _xsd_stem_value_indexes_ + 4, *this, c));

  if (i == _xsd_stem_value_indexes_ + 4 ||
      _xsd_stem_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const stem_value::_xsd_stem_value_literals_[4] = {"down", "up",
                                                              "double", "none"};

const stem_value::value stem_value::_xsd_stem_value_indexes_[4] = {
  ::musicxml::stem_value::double_, ::musicxml::stem_value::down,
  ::musicxml::stem_value::none, ::musicxml::stem_value::up};

// step
//

step::step(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_step_convert();
}

step::step(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_step_convert();
}

step::step(const ::std::string &s, const ::xercesc::DOMElement *e,
           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_step_convert();
}

step *step::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class step(*this, f, c);
}

step::value step::_xsd_step_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_step_literals_);
  const value *i(
    ::std::lower_bound(_xsd_step_indexes_, _xsd_step_indexes_ + 7, *this, c));

  if (i == _xsd_step_indexes_ + 7 || _xsd_step_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const step::_xsd_step_literals_[7] = {"A", "B", "C", "D",
                                                  "E", "F", "G"};

const step::value step::_xsd_step_indexes_[7] = {
  ::musicxml::step::A, ::musicxml::step::B, ::musicxml::step::C,
  ::musicxml::step::D, ::musicxml::step::E, ::musicxml::step::F,
  ::musicxml::step::G};

// syllabic
//

syllabic::syllabic(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_syllabic_convert();
}

syllabic::syllabic(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_syllabic_convert();
}

syllabic::syllabic(const ::std::string &s, const ::xercesc::DOMElement *e,
                   ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_syllabic_convert();
}

syllabic *syllabic::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class syllabic(*this, f, c);
}

syllabic::value syllabic::_xsd_syllabic_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_syllabic_literals_);
  const value *i(::std::lower_bound(_xsd_syllabic_indexes_,
                                    _xsd_syllabic_indexes_ + 4, *this, c));

  if (i == _xsd_syllabic_indexes_ + 4 || _xsd_syllabic_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const syllabic::_xsd_syllabic_literals_[4] = {"single", "begin",
                                                          "end", "middle"};

const syllabic::value syllabic::_xsd_syllabic_indexes_[4] = {
  ::musicxml::syllabic::begin, ::musicxml::syllabic::end,
  ::musicxml::syllabic::middle, ::musicxml::syllabic::single};

// tremolo_marks
//

tremolo_marks::tremolo_marks(const ::xml_schema::integer &_xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type>(_xsd_integer_base) {
}

tremolo_marks::tremolo_marks(const tremolo_marks &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(x, f, c) {}

tremolo_marks::tremolo_marks(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(e, f, c) {}

tremolo_marks::tremolo_marks(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(a, f, c) {}

tremolo_marks::tremolo_marks(const ::std::string &s,
                             const ::xercesc::DOMElement *e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::integer, char,
                                     ::xml_schema::simple_type>(s, e, f, c) {}

tremolo_marks *tremolo_marks::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class tremolo_marks(*this, f, c);
}

tremolo_marks::~tremolo_marks() {}

// group_barline_value
//

group_barline_value::group_barline_value(const ::xercesc::DOMElement &e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_group_barline_value_convert();
}

group_barline_value::group_barline_value(const ::xercesc::DOMAttr &a,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_group_barline_value_convert();
}

group_barline_value::group_barline_value(const ::std::string &s,
                                         const ::xercesc::DOMElement *e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_group_barline_value_convert();
}

group_barline_value *
group_barline_value::_clone(::xml_schema::flags f,
                            ::xml_schema::container *c) const {
  return new class group_barline_value(*this, f, c);
}

group_barline_value::value
group_barline_value::_xsd_group_barline_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_group_barline_value_literals_);
  const value *i(::std::lower_bound(_xsd_group_barline_value_indexes_,
                                    _xsd_group_barline_value_indexes_ + 3,
                                    *this, c));

  if (i == _xsd_group_barline_value_indexes_ + 3 ||
      _xsd_group_barline_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const group_barline_value::_xsd_group_barline_value_literals_[3] = {
  "yes", "no", "Mensurstrich"};

const group_barline_value::value
  group_barline_value::_xsd_group_barline_value_indexes_[3] = {
    ::musicxml::group_barline_value::Mensurstrich,
    ::musicxml::group_barline_value::no, ::musicxml::group_barline_value::yes};

// group_symbol_value
//

group_symbol_value::group_symbol_value(const ::xercesc::DOMElement &e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_group_symbol_value_convert();
}

group_symbol_value::group_symbol_value(const ::xercesc::DOMAttr &a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_group_symbol_value_convert();
}

group_symbol_value::group_symbol_value(const ::std::string &s,
                                       const ::xercesc::DOMElement *e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_group_symbol_value_convert();
}

group_symbol_value *
group_symbol_value::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class group_symbol_value(*this, f, c);
}

group_symbol_value::value
group_symbol_value::_xsd_group_symbol_value_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_group_symbol_value_literals_);
  const value *i(::std::lower_bound(_xsd_group_symbol_value_indexes_,
                                    _xsd_group_symbol_value_indexes_ + 5, *this,
                                    c));

  if (i == _xsd_group_symbol_value_indexes_ + 5 ||
      _xsd_group_symbol_value_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const group_symbol_value::_xsd_group_symbol_value_literals_[5] = {
  "none", "brace", "line", "bracket", "square"};

const group_symbol_value::value
  group_symbol_value::_xsd_group_symbol_value_indexes_[5] = {
    ::musicxml::group_symbol_value::brace,
    ::musicxml::group_symbol_value::bracket,
    ::musicxml::group_symbol_value::line, ::musicxml::group_symbol_value::none,
    ::musicxml::group_symbol_value::square};

// accidental_text
//

accidental_text::accidental_text(
  ::musicxml::accidental_value::value _xsd_accidental_value_base)
: ::musicxml::accidental_value(_xsd_accidental_value_base)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {}

accidental_text::accidental_text(const char *_xsd_string_base)
: ::musicxml::accidental_value(_xsd_string_base)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {}

accidental_text::accidental_text(const ::std::string &_xsd_string_base)
: ::musicxml::accidental_value(_xsd_string_base)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {}

accidental_text::accidental_text(
  const ::musicxml::accidental_value &_xsd_accidental_value_base)
: ::musicxml::accidental_value(_xsd_accidental_value_base)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {}

accidental_text::accidental_text(const accidental_text &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::musicxml::accidental_value(x, f, c)
, justify_(x.justify_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this)
, underline_(x.underline_, f, this)
, overline_(x.overline_, f, this)
, line_through_(x.line_through_, f, this)
, rotation_(x.rotation_, f, this)
, letter_spacing_(x.letter_spacing_, f, this)
, line_height_(x.line_height_, f, this)
, lang_(x.lang_, f, this)
, space_(x.space_, f, this)
, dir_(x.dir_, f, this)
, enclosure_(x.enclosure_, f, this) {}

accidental_text::accidental_text(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::musicxml::accidental_value(e, f | ::xml_schema::flags::base, c)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void accidental_text::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "justify" && n.namespace_().empty()) {
      this->justify_.set(justify_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "underline" && n.namespace_().empty()) {
      this->underline_.set(underline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "overline" && n.namespace_().empty()) {
      this->overline_.set(overline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-through" && n.namespace_().empty()) {
      this->line_through_.set(line_through_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "rotation" && n.namespace_().empty()) {
      this->rotation_.set(rotation_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "letter-spacing" && n.namespace_().empty()) {
      this->letter_spacing_.set(letter_spacing_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-height" && n.namespace_().empty()) {
      this->line_height_.set(line_height_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "lang" &&
        n.namespace_() == "http://www.w3.org/XML/1998/namespace") {
      this->lang_.set(lang_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space" &&
        n.namespace_() == "http://www.w3.org/XML/1998/namespace") {
      this->space_.set(space_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dir" && n.namespace_().empty()) {
      this->dir_.set(dir_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "enclosure" && n.namespace_().empty()) {
      this->enclosure_.set(enclosure_traits::create(i, f, this));
      continue;
    }
  }
}

accidental_text *accidental_text::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class accidental_text(*this, f, c);
}

accidental_text &accidental_text::operator=(const accidental_text &x) {
  if (this != &x) {
    static_cast<::musicxml::accidental_value &>(*this) = x;
    this->justify_ = x.justify_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
    this->underline_ = x.underline_;
    this->overline_ = x.overline_;
    this->line_through_ = x.line_through_;
    this->rotation_ = x.rotation_;
    this->letter_spacing_ = x.letter_spacing_;
    this->line_height_ = x.line_height_;
    this->lang_ = x.lang_;
    this->space_ = x.space_;
    this->dir_ = x.dir_;
    this->enclosure_ = x.enclosure_;
  }

  return *this;
}

accidental_text::~accidental_text() {}

// dynamics
//

dynamics::dynamics()
: ::xml_schema::type()
, p_(this)
, pp_(this)
, ppp_(this)
, pppp_(this)
, ppppp_(this)
, pppppp_(this)
, f_(this)
, ff_(this)
, fff_(this)
, ffff_(this)
, fffff_(this)
, ffffff_(this)
, mp_(this)
, mf_(this)
, sf_(this)
, sfp_(this)
, sfpp_(this)
, fp_(this)
, rf_(this)
, rfz_(this)
, sfz_(this)
, sffz_(this)
, fz_(this)
, other_dynamics_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, placement_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, enclosure_(this) {}

dynamics::dynamics(const dynamics &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, p_(x.p_, f, this)
, pp_(x.pp_, f, this)
, ppp_(x.ppp_, f, this)
, pppp_(x.pppp_, f, this)
, ppppp_(x.ppppp_, f, this)
, pppppp_(x.pppppp_, f, this)
, f_(x.f_, f, this)
, ff_(x.ff_, f, this)
, fff_(x.fff_, f, this)
, ffff_(x.ffff_, f, this)
, fffff_(x.fffff_, f, this)
, ffffff_(x.ffffff_, f, this)
, mp_(x.mp_, f, this)
, mf_(x.mf_, f, this)
, sf_(x.sf_, f, this)
, sfp_(x.sfp_, f, this)
, sfpp_(x.sfpp_, f, this)
, fp_(x.fp_, f, this)
, rf_(x.rf_, f, this)
, rfz_(x.rfz_, f, this)
, sfz_(x.sfz_, f, this)
, sffz_(x.sffz_, f, this)
, fz_(x.fz_, f, this)
, other_dynamics_(x.other_dynamics_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this)
, placement_(x.placement_, f, this)
, underline_(x.underline_, f, this)
, overline_(x.overline_, f, this)
, line_through_(x.line_through_, f, this)
, enclosure_(x.enclosure_, f, this) {}

dynamics::dynamics(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, p_(this)
, pp_(this)
, ppp_(this)
, pppp_(this)
, ppppp_(this)
, pppppp_(this)
, f_(this)
, ff_(this)
, fff_(this)
, ffff_(this)
, fffff_(this)
, ffffff_(this)
, mp_(this)
, mf_(this)
, sf_(this)
, sfp_(this)
, sfpp_(this)
, fp_(this)
, rf_(this)
, rfz_(this)
, sfz_(this)
, sffz_(this)
, fz_(this)
, other_dynamics_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, placement_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, enclosure_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void dynamics::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // p
    //
    if (n.name() == "p" && n.namespace_().empty()) {
      ::std::unique_ptr<p_type> r(p_traits::create(i, f, this));

      this->p_.push_back(::std::move(r));
      continue;
    }

    // pp
    //
    if (n.name() == "pp" && n.namespace_().empty()) {
      ::std::unique_ptr<pp_type> r(pp_traits::create(i, f, this));

      this->pp_.push_back(::std::move(r));
      continue;
    }

    // ppp
    //
    if (n.name() == "ppp" && n.namespace_().empty()) {
      ::std::unique_ptr<ppp_type> r(ppp_traits::create(i, f, this));

      this->ppp_.push_back(::std::move(r));
      continue;
    }

    // pppp
    //
    if (n.name() == "pppp" && n.namespace_().empty()) {
      ::std::unique_ptr<pppp_type> r(pppp_traits::create(i, f, this));

      this->pppp_.push_back(::std::move(r));
      continue;
    }

    // ppppp
    //
    if (n.name() == "ppppp" && n.namespace_().empty()) {
      ::std::unique_ptr<ppppp_type> r(ppppp_traits::create(i, f, this));

      this->ppppp_.push_back(::std::move(r));
      continue;
    }

    // pppppp
    //
    if (n.name() == "pppppp" && n.namespace_().empty()) {
      ::std::unique_ptr<pppppp_type> r(pppppp_traits::create(i, f, this));

      this->pppppp_.push_back(::std::move(r));
      continue;
    }

    // f
    //
    if (n.name() == "f" && n.namespace_().empty()) {
      ::std::unique_ptr<f_type> r(f_traits::create(i, f, this));

      this->f_.push_back(::std::move(r));
      continue;
    }

    // ff
    //
    if (n.name() == "ff" && n.namespace_().empty()) {
      ::std::unique_ptr<ff_type> r(ff_traits::create(i, f, this));

      this->ff_.push_back(::std::move(r));
      continue;
    }

    // fff
    //
    if (n.name() == "fff" && n.namespace_().empty()) {
      ::std::unique_ptr<fff_type> r(fff_traits::create(i, f, this));

      this->fff_.push_back(::std::move(r));
      continue;
    }

    // ffff
    //
    if (n.name() == "ffff" && n.namespace_().empty()) {
      ::std::unique_ptr<ffff_type> r(ffff_traits::create(i, f, this));

      this->ffff_.push_back(::std::move(r));
      continue;
    }

    // fffff
    //
    if (n.name() == "fffff" && n.namespace_().empty()) {
      ::std::unique_ptr<fffff_type> r(fffff_traits::create(i, f, this));

      this->fffff_.push_back(::std::move(r));
      continue;
    }

    // ffffff
    //
    if (n.name() == "ffffff" && n.namespace_().empty()) {
      ::std::unique_ptr<ffffff_type> r(ffffff_traits::create(i, f, this));

      this->ffffff_.push_back(::std::move(r));
      continue;
    }

    // mp
    //
    if (n.name() == "mp" && n.namespace_().empty()) {
      ::std::unique_ptr<mp_type> r(mp_traits::create(i, f, this));

      this->mp_.push_back(::std::move(r));
      continue;
    }

    // mf
    //
    if (n.name() == "mf" && n.namespace_().empty()) {
      ::std::unique_ptr<mf_type> r(mf_traits::create(i, f, this));

      this->mf_.push_back(::std::move(r));
      continue;
    }

    // sf
    //
    if (n.name() == "sf" && n.namespace_().empty()) {
      ::std::unique_ptr<sf_type> r(sf_traits::create(i, f, this));

      this->sf_.push_back(::std::move(r));
      continue;
    }

    // sfp
    //
    if (n.name() == "sfp" && n.namespace_().empty()) {
      ::std::unique_ptr<sfp_type> r(sfp_traits::create(i, f, this));

      this->sfp_.push_back(::std::move(r));
      continue;
    }

    // sfpp
    //
    if (n.name() == "sfpp" && n.namespace_().empty()) {
      ::std::unique_ptr<sfpp_type> r(sfpp_traits::create(i, f, this));

      this->sfpp_.push_back(::std::move(r));
      continue;
    }

    // fp
    //
    if (n.name() == "fp" && n.namespace_().empty()) {
      ::std::unique_ptr<fp_type> r(fp_traits::create(i, f, this));

      this->fp_.push_back(::std::move(r));
      continue;
    }

    // rf
    //
    if (n.name() == "rf" && n.namespace_().empty()) {
      ::std::unique_ptr<rf_type> r(rf_traits::create(i, f, this));

      this->rf_.push_back(::std::move(r));
      continue;
    }

    // rfz
    //
    if (n.name() == "rfz" && n.namespace_().empty()) {
      ::std::unique_ptr<rfz_type> r(rfz_traits::create(i, f, this));

      this->rfz_.push_back(::std::move(r));
      continue;
    }

    // sfz
    //
    if (n.name() == "sfz" && n.namespace_().empty()) {
      ::std::unique_ptr<sfz_type> r(sfz_traits::create(i, f, this));

      this->sfz_.push_back(::std::move(r));
      continue;
    }

    // sffz
    //
    if (n.name() == "sffz" && n.namespace_().empty()) {
      ::std::unique_ptr<sffz_type> r(sffz_traits::create(i, f, this));

      this->sffz_.push_back(::std::move(r));
      continue;
    }

    // fz
    //
    if (n.name() == "fz" && n.namespace_().empty()) {
      ::std::unique_ptr<fz_type> r(fz_traits::create(i, f, this));

      this->fz_.push_back(::std::move(r));
      continue;
    }

    // other-dynamics
    //
    if (n.name() == "other-dynamics" && n.namespace_().empty()) {
      ::std::unique_ptr<other_dynamics_type> r(
        other_dynamics_traits::create(i, f, this));

      this->other_dynamics_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "underline" && n.namespace_().empty()) {
      this->underline_.set(underline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "overline" && n.namespace_().empty()) {
      this->overline_.set(overline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-through" && n.namespace_().empty()) {
      this->line_through_.set(line_through_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "enclosure" && n.namespace_().empty()) {
      this->enclosure_.set(enclosure_traits::create(i, f, this));
      continue;
    }
  }
}

dynamics *dynamics::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class dynamics(*this, f, c);
}

dynamics &dynamics::operator=(const dynamics &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->p_ = x.p_;
    this->pp_ = x.pp_;
    this->ppp_ = x.ppp_;
    this->pppp_ = x.pppp_;
    this->ppppp_ = x.ppppp_;
    this->pppppp_ = x.pppppp_;
    this->f_ = x.f_;
    this->ff_ = x.ff_;
    this->fff_ = x.fff_;
    this->ffff_ = x.ffff_;
    this->fffff_ = x.fffff_;
    this->ffffff_ = x.ffffff_;
    this->mp_ = x.mp_;
    this->mf_ = x.mf_;
    this->sf_ = x.sf_;
    this->sfp_ = x.sfp_;
    this->sfpp_ = x.sfpp_;
    this->fp_ = x.fp_;
    this->rf_ = x.rf_;
    this->rfz_ = x.rfz_;
    this->sfz_ = x.sfz_;
    this->sffz_ = x.sffz_;
    this->fz_ = x.fz_;
    this->other_dynamics_ = x.other_dynamics_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
    this->placement_ = x.placement_;
    this->underline_ = x.underline_;
    this->overline_ = x.overline_;
    this->line_through_ = x.line_through_;
    this->enclosure_ = x.enclosure_;
  }

  return *this;
}

dynamics::~dynamics() {}

// empty
//

empty::empty() : ::xml_schema::type() {}

empty::empty(const empty &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c) {}

empty::empty(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f, c) {}

empty::empty(const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(a, f, c) {}

empty::empty(const ::std::string &s, const ::xercesc::DOMElement *e,
             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(s, e, f, c) {}

empty *empty::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class empty(*this, f, c);
}

empty::~empty() {}

// empty_placement
//

empty_placement::empty_placement()
: ::xml_schema::type()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

empty_placement::empty_placement(const empty_placement &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

empty_placement::empty_placement(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void empty_placement::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

empty_placement *empty_placement::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class empty_placement(*this, f, c);
}

empty_placement &empty_placement::operator=(const empty_placement &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

empty_placement::~empty_placement() {}

// empty_print_style
//

empty_print_style::empty_print_style()
: ::xml_schema::type()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

empty_print_style::empty_print_style(const empty_print_style &x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

empty_print_style::empty_print_style(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void empty_print_style::parse(::xsd::cxx::xml::dom::parser<char> &p,
                              ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

empty_print_style *empty_print_style::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class empty_print_style(*this, f, c);
}

empty_print_style &empty_print_style::operator=(const empty_print_style &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

empty_print_style::~empty_print_style() {}

// empty_print_style_align
//

empty_print_style_align::empty_print_style_align()
: ::xml_schema::type()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

empty_print_style_align::empty_print_style_align(
  const empty_print_style_align &x, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

empty_print_style_align::empty_print_style_align(const ::xercesc::DOMElement &e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void empty_print_style_align::parse(::xsd::cxx::xml::dom::parser<char> &p,
                                    ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }
}

empty_print_style_align *
empty_print_style_align::_clone(::xml_schema::flags f,
                                ::xml_schema::container *c) const {
  return new class empty_print_style_align(*this, f, c);
}

empty_print_style_align &empty_print_style_align::
operator=(const empty_print_style_align &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

empty_print_style_align::~empty_print_style_align() {}

// empty_print_object_style_align
//

empty_print_object_style_align::empty_print_object_style_align()
: ::xml_schema::type()
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

empty_print_object_style_align::empty_print_object_style_align(
  const empty_print_object_style_align &x, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, print_object_(x.print_object_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

empty_print_object_style_align::empty_print_object_style_align(
  const ::xercesc::DOMElement &e, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void
empty_print_object_style_align::parse(::xsd::cxx::xml::dom::parser<char> &p,
                                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }
}

empty_print_object_style_align *
empty_print_object_style_align::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class empty_print_object_style_align(*this, f, c);
}

empty_print_object_style_align &empty_print_object_style_align::
operator=(const empty_print_object_style_align &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->print_object_ = x.print_object_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

empty_print_object_style_align::~empty_print_object_style_align() {}

// empty_trill_sound
//

empty_trill_sound::empty_trill_sound()
: ::xml_schema::type()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this)
, start_note_(this)
, trill_step_(this)
, two_note_turn_(this)
, accelerate_(this)
, beats_(this)
, second_beat_(this)
, last_beat_(this) {}

empty_trill_sound::empty_trill_sound(const empty_trill_sound &x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this)
, start_note_(x.start_note_, f, this)
, trill_step_(x.trill_step_, f, this)
, two_note_turn_(x.two_note_turn_, f, this)
, accelerate_(x.accelerate_, f, this)
, beats_(x.beats_, f, this)
, second_beat_(x.second_beat_, f, this)
, last_beat_(x.last_beat_, f, this) {}

empty_trill_sound::empty_trill_sound(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this)
, start_note_(this)
, trill_step_(this)
, two_note_turn_(this)
, accelerate_(this)
, beats_(this)
, second_beat_(this)
, last_beat_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void empty_trill_sound::parse(::xsd::cxx::xml::dom::parser<char> &p,
                              ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "start-note" && n.namespace_().empty()) {
      this->start_note_.set(start_note_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "trill-step" && n.namespace_().empty()) {
      this->trill_step_.set(trill_step_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "two-note-turn" && n.namespace_().empty()) {
      this->two_note_turn_.set(two_note_turn_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "accelerate" && n.namespace_().empty()) {
      this->accelerate_.set(accelerate_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "beats" && n.namespace_().empty()) {
      this->beats_.set(beats_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "second-beat" && n.namespace_().empty()) {
      this->second_beat_.set(second_beat_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "last-beat" && n.namespace_().empty()) {
      this->last_beat_.set(last_beat_traits::create(i, f, this));
      continue;
    }
  }
}

empty_trill_sound *empty_trill_sound::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class empty_trill_sound(*this, f, c);
}

empty_trill_sound &empty_trill_sound::operator=(const empty_trill_sound &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
    this->start_note_ = x.start_note_;
    this->trill_step_ = x.trill_step_;
    this->two_note_turn_ = x.two_note_turn_;
    this->accelerate_ = x.accelerate_;
    this->beats_ = x.beats_;
    this->second_beat_ = x.second_beat_;
    this->last_beat_ = x.last_beat_;
  }

  return *this;
}

empty_trill_sound::~empty_trill_sound() {}

// horizontal_turn
//

horizontal_turn::horizontal_turn()
: ::xml_schema::type()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this)
, start_note_(this)
, trill_step_(this)
, two_note_turn_(this)
, accelerate_(this)
, beats_(this)
, second_beat_(this)
, last_beat_(this)
, slash_(this) {}

horizontal_turn::horizontal_turn(const horizontal_turn &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this)
, start_note_(x.start_note_, f, this)
, trill_step_(x.trill_step_, f, this)
, two_note_turn_(x.two_note_turn_, f, this)
, accelerate_(x.accelerate_, f, this)
, beats_(x.beats_, f, this)
, second_beat_(x.second_beat_, f, this)
, last_beat_(x.last_beat_, f, this)
, slash_(x.slash_, f, this) {}

horizontal_turn::horizontal_turn(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this)
, start_note_(this)
, trill_step_(this)
, two_note_turn_(this)
, accelerate_(this)
, beats_(this)
, second_beat_(this)
, last_beat_(this)
, slash_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void horizontal_turn::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "start-note" && n.namespace_().empty()) {
      this->start_note_.set(start_note_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "trill-step" && n.namespace_().empty()) {
      this->trill_step_.set(trill_step_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "two-note-turn" && n.namespace_().empty()) {
      this->two_note_turn_.set(two_note_turn_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "accelerate" && n.namespace_().empty()) {
      this->accelerate_.set(accelerate_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "beats" && n.namespace_().empty()) {
      this->beats_.set(beats_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "second-beat" && n.namespace_().empty()) {
      this->second_beat_.set(second_beat_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "last-beat" && n.namespace_().empty()) {
      this->last_beat_.set(last_beat_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "slash" && n.namespace_().empty()) {
      this->slash_.set(slash_traits::create(i, f, this));
      continue;
    }
  }
}

horizontal_turn *horizontal_turn::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class horizontal_turn(*this, f, c);
}

horizontal_turn &horizontal_turn::operator=(const horizontal_turn &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
    this->start_note_ = x.start_note_;
    this->trill_step_ = x.trill_step_;
    this->two_note_turn_ = x.two_note_turn_;
    this->accelerate_ = x.accelerate_;
    this->beats_ = x.beats_;
    this->second_beat_ = x.second_beat_;
    this->last_beat_ = x.last_beat_;
    this->slash_ = x.slash_;
  }

  return *this;
}

horizontal_turn::~horizontal_turn() {}

// fermata
//

fermata::fermata(::musicxml::fermata_shape::value _xsd_fermata_shape_base)
: ::musicxml::fermata_shape(_xsd_fermata_shape_base)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

fermata::fermata(const char *_xsd_string_base)
: ::musicxml::fermata_shape(_xsd_string_base)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

fermata::fermata(const ::std::string &_xsd_string_base)
: ::musicxml::fermata_shape(_xsd_string_base)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

fermata::fermata(const ::musicxml::fermata_shape &_xsd_fermata_shape_base)
: ::musicxml::fermata_shape(_xsd_fermata_shape_base)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

fermata::fermata(const fermata &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::musicxml::fermata_shape(x, f, c)
, type_(x.type_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

fermata::fermata(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::musicxml::fermata_shape(e, f | ::xml_schema::flags::base, c)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void fermata::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

fermata *fermata::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class fermata(*this, f, c);
}

fermata &fermata::operator=(const fermata &x) {
  if (this != &x) {
    static_cast<::musicxml::fermata_shape &>(*this) = x;
    this->type_ = x.type_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

fermata::~fermata() {}

// fingering
//

fingering::fingering()
: ::xml_schema::string()
, substitution_(this)
, alternate_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

fingering::fingering(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, substitution_(this)
, alternate_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

fingering::fingering(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, substitution_(this)
, alternate_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

fingering::fingering(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, substitution_(this)
, alternate_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

fingering::fingering(const fingering &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, substitution_(x.substitution_, f, this)
, alternate_(x.alternate_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

fingering::fingering(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, substitution_(this)
, alternate_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void fingering::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "substitution" && n.namespace_().empty()) {
      this->substitution_.set(substitution_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "alternate" && n.namespace_().empty()) {
      this->alternate_.set(alternate_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

fingering *fingering::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class fingering(*this, f, c);
}

fingering &fingering::operator=(const fingering &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->substitution_ = x.substitution_;
    this->alternate_ = x.alternate_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

fingering::~fingering() {}

// formatted_text
//

formatted_text::formatted_text()
: ::xml_schema::string()
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {}

formatted_text::formatted_text(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {}

formatted_text::formatted_text(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {}

formatted_text::formatted_text(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {}

formatted_text::formatted_text(const formatted_text &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, justify_(x.justify_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this)
, underline_(x.underline_, f, this)
, overline_(x.overline_, f, this)
, line_through_(x.line_through_, f, this)
, rotation_(x.rotation_, f, this)
, letter_spacing_(x.letter_spacing_, f, this)
, line_height_(x.line_height_, f, this)
, lang_(x.lang_, f, this)
, space_(x.space_, f, this)
, dir_(x.dir_, f, this)
, enclosure_(x.enclosure_, f, this) {}

formatted_text::formatted_text(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, line_height_(this)
, lang_(this)
, space_(this)
, dir_(this)
, enclosure_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void formatted_text::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "justify" && n.namespace_().empty()) {
      this->justify_.set(justify_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "underline" && n.namespace_().empty()) {
      this->underline_.set(underline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "overline" && n.namespace_().empty()) {
      this->overline_.set(overline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-through" && n.namespace_().empty()) {
      this->line_through_.set(line_through_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "rotation" && n.namespace_().empty()) {
      this->rotation_.set(rotation_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "letter-spacing" && n.namespace_().empty()) {
      this->letter_spacing_.set(letter_spacing_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-height" && n.namespace_().empty()) {
      this->line_height_.set(line_height_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "lang" &&
        n.namespace_() == "http://www.w3.org/XML/1998/namespace") {
      this->lang_.set(lang_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space" &&
        n.namespace_() == "http://www.w3.org/XML/1998/namespace") {
      this->space_.set(space_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dir" && n.namespace_().empty()) {
      this->dir_.set(dir_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "enclosure" && n.namespace_().empty()) {
      this->enclosure_.set(enclosure_traits::create(i, f, this));
      continue;
    }
  }
}

formatted_text *formatted_text::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class formatted_text(*this, f, c);
}

formatted_text &formatted_text::operator=(const formatted_text &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->justify_ = x.justify_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
    this->underline_ = x.underline_;
    this->overline_ = x.overline_;
    this->line_through_ = x.line_through_;
    this->rotation_ = x.rotation_;
    this->letter_spacing_ = x.letter_spacing_;
    this->line_height_ = x.line_height_;
    this->lang_ = x.lang_;
    this->space_ = x.space_;
    this->dir_ = x.dir_;
    this->enclosure_ = x.enclosure_;
  }

  return *this;
}

formatted_text::~formatted_text() {}

// fret
//

fret::fret(
  const ::xml_schema::non_negative_integer &_xsd_non_negative_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_non_negative_integer_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

fret::fret(const fret &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(x, f, c)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

fret::fret(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(
    e, f | ::xml_schema::flags::base, c)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void fret::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

fret *fret::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class fret(*this, f, c);
}

fret &fret::operator=(const fret &x) {
  if (this != &x) {
    static_cast<::xsd::cxx::tree::fundamental_base<
      ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(
      *this) = x;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

fret::~fret() {}

// level
//

level::level()
: ::xml_schema::string()
, reference_(this)
, parentheses_(this)
, bracket_(this)
, size_(this) {}

level::level(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, reference_(this)
, parentheses_(this)
, bracket_(this)
, size_(this) {}

level::level(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, reference_(this)
, parentheses_(this)
, bracket_(this)
, size_(this) {}

level::level(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, reference_(this)
, parentheses_(this)
, bracket_(this)
, size_(this) {}

level::level(const level &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, reference_(x.reference_, f, this)
, parentheses_(x.parentheses_, f, this)
, bracket_(x.bracket_, f, this)
, size_(x.size_, f, this) {}

level::level(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, reference_(this)
, parentheses_(this)
, bracket_(this)
, size_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void level::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "reference" && n.namespace_().empty()) {
      this->reference_.set(reference_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "parentheses" && n.namespace_().empty()) {
      this->parentheses_.set(parentheses_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bracket" && n.namespace_().empty()) {
      this->bracket_.set(bracket_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "size" && n.namespace_().empty()) {
      this->size_.set(size_traits::create(i, f, this));
      continue;
    }
  }
}

level *level::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class level(*this, f, c);
}

level &level::operator=(const level &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->reference_ = x.reference_;
    this->parentheses_ = x.parentheses_;
    this->bracket_ = x.bracket_;
    this->size_ = x.size_;
  }

  return *this;
}

level::~level() {}

// midi_device
//

midi_device::midi_device() : ::xml_schema::string(), port_(this), id_(this) {}

midi_device::midi_device(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), port_(this), id_(this) {}

midi_device::midi_device(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), port_(this), id_(this) {}

midi_device::midi_device(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), port_(this), id_(this) {}

midi_device::midi_device(const midi_device &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::string(x, f, c), port_(x.port_, f, this), id_(x.id_, f, this) {}

midi_device::midi_device(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, port_(this)
, id_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void midi_device::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "port" && n.namespace_().empty()) {
      this->port_.set(port_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }
  }
}

midi_device *midi_device::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class midi_device(*this, f, c);
}

midi_device &midi_device::operator=(const midi_device &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->port_ = x.port_;
    this->id_ = x.id_;
  }

  return *this;
}

midi_device::~midi_device() {}

// midi_instrument
//

midi_instrument::midi_instrument(const id_type &id)
: ::xml_schema::type()
, midi_channel_(this)
, midi_name_(this)
, midi_bank_(this)
, midi_program_(this)
, midi_unpitched_(this)
, volume_(this)
, pan_(this)
, elevation_(this)
, id_(id, this) {}

midi_instrument::midi_instrument(const midi_instrument &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, midi_channel_(x.midi_channel_, f, this)
, midi_name_(x.midi_name_, f, this)
, midi_bank_(x.midi_bank_, f, this)
, midi_program_(x.midi_program_, f, this)
, midi_unpitched_(x.midi_unpitched_, f, this)
, volume_(x.volume_, f, this)
, pan_(x.pan_, f, this)
, elevation_(x.elevation_, f, this)
, id_(x.id_, f, this) {}

midi_instrument::midi_instrument(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, midi_channel_(this)
, midi_name_(this)
, midi_bank_(this)
, midi_program_(this)
, midi_unpitched_(this)
, volume_(this)
, pan_(this)
, elevation_(this)
, id_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void midi_instrument::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // midi-channel
    //
    if (n.name() == "midi-channel" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_channel_type> r(
        midi_channel_traits::create(i, f, this));

      if (!this->midi_channel_) {
        this->midi_channel_.set(::std::move(r));
        continue;
      }
    }

    // midi-name
    //
    if (n.name() == "midi-name" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_name_type> r(midi_name_traits::create(i, f, this));

      if (!this->midi_name_) {
        this->midi_name_.set(::std::move(r));
        continue;
      }
    }

    // midi-bank
    //
    if (n.name() == "midi-bank" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_bank_type> r(midi_bank_traits::create(i, f, this));

      if (!this->midi_bank_) {
        this->midi_bank_.set(::std::move(r));
        continue;
      }
    }

    // midi-program
    //
    if (n.name() == "midi-program" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_program_type> r(
        midi_program_traits::create(i, f, this));

      if (!this->midi_program_) {
        this->midi_program_.set(::std::move(r));
        continue;
      }
    }

    // midi-unpitched
    //
    if (n.name() == "midi-unpitched" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_unpitched_type> r(
        midi_unpitched_traits::create(i, f, this));

      if (!this->midi_unpitched_) {
        this->midi_unpitched_.set(::std::move(r));
        continue;
      }
    }

    // volume
    //
    if (n.name() == "volume" && n.namespace_().empty()) {
      ::std::unique_ptr<volume_type> r(volume_traits::create(i, f, this));

      if (!this->volume_) {
        this->volume_.set(::std::move(r));
        continue;
      }
    }

    // pan
    //
    if (n.name() == "pan" && n.namespace_().empty()) {
      ::std::unique_ptr<pan_type> r(pan_traits::create(i, f, this));

      if (!this->pan_) {
        this->pan_.set(::std::move(r));
        continue;
      }
    }

    // elevation
    //
    if (n.name() == "elevation" && n.namespace_().empty()) {
      ::std::unique_ptr<elevation_type> r(elevation_traits::create(i, f, this));

      if (!this->elevation_) {
        this->elevation_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }
  }

  if (!id_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("id", "");
  }
}

midi_instrument *midi_instrument::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class midi_instrument(*this, f, c);
}

midi_instrument &midi_instrument::operator=(const midi_instrument &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->midi_channel_ = x.midi_channel_;
    this->midi_name_ = x.midi_name_;
    this->midi_bank_ = x.midi_bank_;
    this->midi_program_ = x.midi_program_;
    this->midi_unpitched_ = x.midi_unpitched_;
    this->volume_ = x.volume_;
    this->pan_ = x.pan_;
    this->elevation_ = x.elevation_;
    this->id_ = x.id_;
  }

  return *this;
}

midi_instrument::~midi_instrument() {}

// name_display
//

name_display::name_display()
: ::xml_schema::type()
, display_text_(this)
, accidental_text_(this)
, print_object_(this) {}

name_display::name_display(const name_display &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, display_text_(x.display_text_, f, this)
, accidental_text_(x.accidental_text_, f, this)
, print_object_(x.print_object_, f, this) {}

name_display::name_display(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, display_text_(this)
, accidental_text_(this)
, print_object_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void name_display::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // display-text
    //
    if (n.name() == "display-text" && n.namespace_().empty()) {
      ::std::unique_ptr<display_text_type> r(
        display_text_traits::create(i, f, this));

      this->display_text_.push_back(::std::move(r));
      continue;
    }

    // accidental-text
    //
    if (n.name() == "accidental-text" && n.namespace_().empty()) {
      ::std::unique_ptr<accidental_text_type> r(
        accidental_text_traits::create(i, f, this));

      this->accidental_text_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }
  }
}

name_display *name_display::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class name_display(*this, f, c);
}

name_display &name_display::operator=(const name_display &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->display_text_ = x.display_text_;
    this->accidental_text_ = x.accidental_text_;
    this->print_object_ = x.print_object_;
  }

  return *this;
}

name_display::~name_display() {}

// other_play
//

other_play::other_play(const type_type &type)
: ::xml_schema::string(), type_(type, this) {}

other_play::other_play(const char *_xsd_string_base, const type_type &type)
: ::xml_schema::string(_xsd_string_base), type_(type, this) {}

other_play::other_play(const ::std::string &_xsd_string_base,
                       const type_type &type)
: ::xml_schema::string(_xsd_string_base), type_(type, this) {}

other_play::other_play(const ::xml_schema::string &_xsd_string_base,
                       const type_type &type)
: ::xml_schema::string(_xsd_string_base), type_(type, this) {}

other_play::other_play(const other_play &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(x, f, c), type_(x.type_, f, this) {}

other_play::other_play(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c), type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void other_play::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

other_play *other_play::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class other_play(*this, f, c);
}

other_play &other_play::operator=(const other_play &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

other_play::~other_play() {}

// play
//

play::play()
: ::xml_schema::type()
, ipa_(this)
, mute_(this)
, semi_pitched_(this)
, other_play_(this)
, id_(this) {}

play::play(const play &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, ipa_(x.ipa_, f, this)
, mute_(x.mute_, f, this)
, semi_pitched_(x.semi_pitched_, f, this)
, other_play_(x.other_play_, f, this)
, id_(x.id_, f, this) {}

play::play(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, ipa_(this)
, mute_(this)
, semi_pitched_(this)
, other_play_(this)
, id_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void play::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // ipa
    //
    if (n.name() == "ipa" && n.namespace_().empty()) {
      ::std::unique_ptr<ipa_type> r(ipa_traits::create(i, f, this));

      this->ipa_.push_back(::std::move(r));
      continue;
    }

    // mute
    //
    if (n.name() == "mute" && n.namespace_().empty()) {
      ::std::unique_ptr<mute_type> r(mute_traits::create(i, f, this));

      this->mute_.push_back(::std::move(r));
      continue;
    }

    // semi-pitched
    //
    if (n.name() == "semi-pitched" && n.namespace_().empty()) {
      ::std::unique_ptr<semi_pitched_type> r(
        semi_pitched_traits::create(i, f, this));

      this->semi_pitched_.push_back(::std::move(r));
      continue;
    }

    // other-play
    //
    if (n.name() == "other-play" && n.namespace_().empty()) {
      ::std::unique_ptr<other_play_type> r(
        other_play_traits::create(i, f, this));

      this->other_play_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }
  }
}

play *play::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class play(*this, f, c);
}

play &play::operator=(const play &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->ipa_ = x.ipa_;
    this->mute_ = x.mute_;
    this->semi_pitched_ = x.semi_pitched_;
    this->other_play_ = x.other_play_;
    this->id_ = x.id_;
  }

  return *this;
}

play::~play() {}

// string
//

string::string(const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::musicxml::string_number(_xsd_positive_integer_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

string::string(const string &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::musicxml::string_number(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

string::string(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::musicxml::string_number(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void string::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

string *string::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class string(*this, f, c);
}

string &string::operator=(const string &x) {
  if (this != &x) {
    static_cast<::musicxml::string_number &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

string::~string() {}

// typed_text
//

typed_text::typed_text() : ::xml_schema::string(), type_(this) {}

typed_text::typed_text(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), type_(this) {}

typed_text::typed_text(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), type_(this) {}

typed_text::typed_text(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), type_(this) {}

typed_text::typed_text(const typed_text &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(x, f, c), type_(x.type_, f, this) {}

typed_text::typed_text(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c), type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void typed_text::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }
}

typed_text *typed_text::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class typed_text(*this, f, c);
}

typed_text &typed_text::operator=(const typed_text &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

typed_text::~typed_text() {}

// wavy_line
//

wavy_line::wavy_line(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, number_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, color_(this)
, start_note_(this)
, trill_step_(this)
, two_note_turn_(this)
, accelerate_(this)
, beats_(this)
, second_beat_(this)
, last_beat_(this) {}

wavy_line::wavy_line(const wavy_line &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, placement_(x.placement_, f, this)
, color_(x.color_, f, this)
, start_note_(x.start_note_, f, this)
, trill_step_(x.trill_step_, f, this)
, two_note_turn_(x.two_note_turn_, f, this)
, accelerate_(x.accelerate_, f, this)
, beats_(x.beats_, f, this)
, second_beat_(x.second_beat_, f, this)
, last_beat_(x.last_beat_, f, this) {}

wavy_line::wavy_line(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, color_(this)
, start_note_(this)
, trill_step_(this)
, two_note_turn_(this)
, accelerate_(this)
, beats_(this)
, second_beat_(this)
, last_beat_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void wavy_line::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "start-note" && n.namespace_().empty()) {
      this->start_note_.set(start_note_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "trill-step" && n.namespace_().empty()) {
      this->trill_step_.set(trill_step_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "two-note-turn" && n.namespace_().empty()) {
      this->two_note_turn_.set(two_note_turn_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "accelerate" && n.namespace_().empty()) {
      this->accelerate_.set(accelerate_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "beats" && n.namespace_().empty()) {
      this->beats_.set(beats_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "second-beat" && n.namespace_().empty()) {
      this->second_beat_.set(second_beat_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "last-beat" && n.namespace_().empty()) {
      this->last_beat_.set(last_beat_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

wavy_line *wavy_line::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class wavy_line(*this, f, c);
}

wavy_line &wavy_line::operator=(const wavy_line &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->placement_ = x.placement_;
    this->color_ = x.color_;
    this->start_note_ = x.start_note_;
    this->trill_step_ = x.trill_step_;
    this->two_note_turn_ = x.two_note_turn_;
    this->accelerate_ = x.accelerate_;
    this->beats_ = x.beats_;
    this->second_beat_ = x.second_beat_;
    this->last_beat_ = x.last_beat_;
  }

  return *this;
}

wavy_line::~wavy_line() {}

// attributes
//

attributes::attributes()
: ::xml_schema::type()
, footnote_(this)
, level_(this)
, divisions_(this)
, key_(this)
, time_(this)
, staves_(this)
, part_symbol_(this)
, instruments_(this)
, clef_(this)
, staff_details_(this)
, transpose_(this)
, directive_(this)
, measure_style_(this) {}

attributes::attributes(const attributes &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, divisions_(x.divisions_, f, this)
, key_(x.key_, f, this)
, time_(x.time_, f, this)
, staves_(x.staves_, f, this)
, part_symbol_(x.part_symbol_, f, this)
, instruments_(x.instruments_, f, this)
, clef_(x.clef_, f, this)
, staff_details_(x.staff_details_, f, this)
, transpose_(x.transpose_, f, this)
, directive_(x.directive_, f, this)
, measure_style_(x.measure_style_, f, this) {}

attributes::attributes(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, footnote_(this)
, level_(this)
, divisions_(this)
, key_(this)
, time_(this)
, staves_(this)
, part_symbol_(this)
, instruments_(this)
, clef_(this)
, staff_details_(this)
, transpose_(this)
, directive_(this)
, measure_style_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void attributes::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    // divisions
    //
    if (n.name() == "divisions" && n.namespace_().empty()) {
      ::std::unique_ptr<divisions_type> r(divisions_traits::create(i, f, this));

      if (!this->divisions_) {
        this->divisions_.set(::std::move(r));
        continue;
      }
    }

    // key
    //
    if (n.name() == "key" && n.namespace_().empty()) {
      ::std::unique_ptr<key_type> r(key_traits::create(i, f, this));

      this->key_.push_back(::std::move(r));
      continue;
    }

    // time
    //
    if (n.name() == "time" && n.namespace_().empty()) {
      ::std::unique_ptr<time_type> r(time_traits::create(i, f, this));

      this->time_.push_back(::std::move(r));
      continue;
    }

    // staves
    //
    if (n.name() == "staves" && n.namespace_().empty()) {
      if (!this->staves_) {
        this->staves_.set(staves_traits::create(i, f, this));
        continue;
      }
    }

    // part-symbol
    //
    if (n.name() == "part-symbol" && n.namespace_().empty()) {
      ::std::unique_ptr<part_symbol_type> r(
        part_symbol_traits::create(i, f, this));

      if (!this->part_symbol_) {
        this->part_symbol_.set(::std::move(r));
        continue;
      }
    }

    // instruments
    //
    if (n.name() == "instruments" && n.namespace_().empty()) {
      if (!this->instruments_) {
        this->instruments_.set(instruments_traits::create(i, f, this));
        continue;
      }
    }

    // clef
    //
    if (n.name() == "clef" && n.namespace_().empty()) {
      ::std::unique_ptr<clef_type> r(clef_traits::create(i, f, this));

      this->clef_.push_back(::std::move(r));
      continue;
    }

    // staff-details
    //
    if (n.name() == "staff-details" && n.namespace_().empty()) {
      ::std::unique_ptr<staff_details_type> r(
        staff_details_traits::create(i, f, this));

      this->staff_details_.push_back(::std::move(r));
      continue;
    }

    // transpose
    //
    if (n.name() == "transpose" && n.namespace_().empty()) {
      ::std::unique_ptr<transpose_type> r(transpose_traits::create(i, f, this));

      this->transpose_.push_back(::std::move(r));
      continue;
    }

    // directive
    //
    if (n.name() == "directive" && n.namespace_().empty()) {
      ::std::unique_ptr<directive_type> r(directive_traits::create(i, f, this));

      this->directive_.push_back(::std::move(r));
      continue;
    }

    // measure-style
    //
    if (n.name() == "measure-style" && n.namespace_().empty()) {
      ::std::unique_ptr<measure_style_type> r(
        measure_style_traits::create(i, f, this));

      this->measure_style_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

attributes *attributes::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class attributes(*this, f, c);
}

attributes &attributes::operator=(const attributes &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->divisions_ = x.divisions_;
    this->key_ = x.key_;
    this->time_ = x.time_;
    this->staves_ = x.staves_;
    this->part_symbol_ = x.part_symbol_;
    this->instruments_ = x.instruments_;
    this->clef_ = x.clef_;
    this->staff_details_ = x.staff_details_;
    this->transpose_ = x.transpose_;
    this->directive_ = x.directive_;
    this->measure_style_ = x.measure_style_;
  }

  return *this;
}

attributes::~attributes() {}

// beat_repeat
//

beat_repeat::beat_repeat(const type_type &type)
: ::xml_schema::type()
, slash_type_(this)
, slash_dot_(this)
, type_(type, this)
, slashes_(this)
, use_dots_(this) {}

beat_repeat::beat_repeat(const beat_repeat &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, slash_type_(x.slash_type_, f, this)
, slash_dot_(x.slash_dot_, f, this)
, type_(x.type_, f, this)
, slashes_(x.slashes_, f, this)
, use_dots_(x.use_dots_, f, this) {}

beat_repeat::beat_repeat(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, slash_type_(this)
, slash_dot_(this)
, type_(this)
, slashes_(this)
, use_dots_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void beat_repeat::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // slash-type
    //
    if (n.name() == "slash-type" && n.namespace_().empty()) {
      ::std::unique_ptr<slash_type_type> r(
        slash_type_traits::create(i, f, this));

      if (!this->slash_type_) {
        this->slash_type_.set(::std::move(r));
        continue;
      }
    }

    // slash-dot
    //
    if (n.name() == "slash-dot" && n.namespace_().empty()) {
      ::std::unique_ptr<slash_dot_type> r(slash_dot_traits::create(i, f, this));

      this->slash_dot_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "slashes" && n.namespace_().empty()) {
      this->slashes_.set(slashes_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "use-dots" && n.namespace_().empty()) {
      this->use_dots_.set(use_dots_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

beat_repeat *beat_repeat::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class beat_repeat(*this, f, c);
}

beat_repeat &beat_repeat::operator=(const beat_repeat &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->slash_type_ = x.slash_type_;
    this->slash_dot_ = x.slash_dot_;
    this->type_ = x.type_;
    this->slashes_ = x.slashes_;
    this->use_dots_ = x.use_dots_;
  }

  return *this;
}

beat_repeat::~beat_repeat() {}

// cancel
//

cancel::cancel(const ::xml_schema::integer &_xsd_integer_base)
: ::musicxml::fifths(_xsd_integer_base), location_(this) {}

cancel::cancel(const cancel &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::musicxml::fifths(x, f, c), location_(x.location_, f, this) {}

cancel::cancel(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::musicxml::fifths(e, f | ::xml_schema::flags::base, c), location_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void cancel::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "location" && n.namespace_().empty()) {
      this->location_.set(location_traits::create(i, f, this));
      continue;
    }
  }
}

cancel *cancel::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class cancel(*this, f, c);
}

cancel &cancel::operator=(const cancel &x) {
  if (this != &x) {
    static_cast<::musicxml::fifths &>(*this) = x;
    this->location_ = x.location_;
  }

  return *this;
}

cancel::~cancel() {}

// clef
//

clef::clef(const sign_type &sign)
: ::xml_schema::type()
, sign_(sign, this)
, line_(this)
, clef_octave_change_(this)
, number_(this)
, additional_(this)
, size_(this)
, after_barline_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this) {}

clef::clef(const clef &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, sign_(x.sign_, f, this)
, line_(x.line_, f, this)
, clef_octave_change_(x.clef_octave_change_, f, this)
, number_(x.number_, f, this)
, additional_(x.additional_, f, this)
, size_(x.size_, f, this)
, after_barline_(x.after_barline_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, print_object_(x.print_object_, f, this) {}

clef::clef(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, sign_(this)
, line_(this)
, clef_octave_change_(this)
, number_(this)
, additional_(this)
, size_(this)
, after_barline_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void clef::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // sign
    //
    if (n.name() == "sign" && n.namespace_().empty()) {
      ::std::unique_ptr<sign_type> r(sign_traits::create(i, f, this));

      if (!sign_.present()) {
        this->sign_.set(::std::move(r));
        continue;
      }
    }

    // line
    //
    if (n.name() == "line" && n.namespace_().empty()) {
      ::std::unique_ptr<line_type> r(line_traits::create(i, f, this));

      if (!this->line_) {
        this->line_.set(::std::move(r));
        continue;
      }
    }

    // clef-octave-change
    //
    if (n.name() == "clef-octave-change" && n.namespace_().empty()) {
      if (!this->clef_octave_change_) {
        this->clef_octave_change_.set(
          clef_octave_change_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!sign_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("sign", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "additional" && n.namespace_().empty()) {
      this->additional_.set(additional_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "size" && n.namespace_().empty()) {
      this->size_.set(size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "after-barline" && n.namespace_().empty()) {
      this->after_barline_.set(after_barline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }
  }
}

clef *clef::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class clef(*this, f, c);
}

clef &clef::operator=(const clef &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->sign_ = x.sign_;
    this->line_ = x.line_;
    this->clef_octave_change_ = x.clef_octave_change_;
    this->number_ = x.number_;
    this->additional_ = x.additional_;
    this->size_ = x.size_;
    this->after_barline_ = x.after_barline_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->print_object_ = x.print_object_;
  }

  return *this;
}

clef::~clef() {}

// interchangeable
//

interchangeable::interchangeable()
: ::xml_schema::type()
, time_relation_(this)
, beats_(this)
, beat_type_(this)
, symbol_(this)
, separator_(this) {}

interchangeable::interchangeable(const interchangeable &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, time_relation_(x.time_relation_, f, this)
, beats_(x.beats_, f, this)
, beat_type_(x.beat_type_, f, this)
, symbol_(x.symbol_, f, this)
, separator_(x.separator_, f, this) {}

interchangeable::interchangeable(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, time_relation_(this)
, beats_(this)
, beat_type_(this)
, symbol_(this)
, separator_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void interchangeable::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // time-relation
    //
    if (n.name() == "time-relation" && n.namespace_().empty()) {
      ::std::unique_ptr<time_relation_type> r(
        time_relation_traits::create(i, f, this));

      if (!this->time_relation_) {
        this->time_relation_.set(::std::move(r));
        continue;
      }
    }

    // beats
    //
    if (n.name() == "beats" && n.namespace_().empty()) {
      ::std::unique_ptr<beats_type> r(beats_traits::create(i, f, this));

      this->beats_.push_back(::std::move(r));
      continue;
    }

    // beat-type
    //
    if (n.name() == "beat-type" && n.namespace_().empty()) {
      ::std::unique_ptr<beat_type_type> r(beat_type_traits::create(i, f, this));

      this->beat_type_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "symbol" && n.namespace_().empty()) {
      this->symbol_.set(symbol_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "separator" && n.namespace_().empty()) {
      this->separator_.set(separator_traits::create(i, f, this));
      continue;
    }
  }
}

interchangeable *interchangeable::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class interchangeable(*this, f, c);
}

interchangeable &interchangeable::operator=(const interchangeable &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->time_relation_ = x.time_relation_;
    this->beats_ = x.beats_;
    this->beat_type_ = x.beat_type_;
    this->symbol_ = x.symbol_;
    this->separator_ = x.separator_;
  }

  return *this;
}

interchangeable::~interchangeable() {}

// key
//

key::key()
: ::xml_schema::type()
, cancel_(this)
, fifths_(this)
, mode_(this)
, key_step_(this)
, key_alter_(this)
, key_accidental_(this)
, key_octave_(this)
, number_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this) {}

key::key(const key &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, cancel_(x.cancel_, f, this)
, fifths_(x.fifths_, f, this)
, mode_(x.mode_, f, this)
, key_step_(x.key_step_, f, this)
, key_alter_(x.key_alter_, f, this)
, key_accidental_(x.key_accidental_, f, this)
, key_octave_(x.key_octave_, f, this)
, number_(x.number_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, print_object_(x.print_object_, f, this) {}

key::key(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
         ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, cancel_(this)
, fifths_(this)
, mode_(this)
, key_step_(this)
, key_alter_(this)
, key_accidental_(this)
, key_octave_(this)
, number_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void key::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // cancel
    //
    if (n.name() == "cancel" && n.namespace_().empty()) {
      ::std::unique_ptr<cancel_type> r(cancel_traits::create(i, f, this));

      if (!this->cancel_) {
        this->cancel_.set(::std::move(r));
        continue;
      }
    }

    // fifths
    //
    if (n.name() == "fifths" && n.namespace_().empty()) {
      ::std::unique_ptr<fifths_type> r(fifths_traits::create(i, f, this));

      if (!this->fifths_) {
        this->fifths_.set(::std::move(r));
        continue;
      }
    }

    // mode
    //
    if (n.name() == "mode" && n.namespace_().empty()) {
      ::std::unique_ptr<mode_type> r(mode_traits::create(i, f, this));

      if (!this->mode_) {
        this->mode_.set(::std::move(r));
        continue;
      }
    }

    // key-step
    //
    if (n.name() == "key-step" && n.namespace_().empty()) {
      ::std::unique_ptr<key_step_type> r(key_step_traits::create(i, f, this));

      this->key_step_.push_back(::std::move(r));
      continue;
    }

    // key-alter
    //
    if (n.name() == "key-alter" && n.namespace_().empty()) {
      ::std::unique_ptr<key_alter_type> r(key_alter_traits::create(i, f, this));

      this->key_alter_.push_back(::std::move(r));
      continue;
    }

    // key-accidental
    //
    if (n.name() == "key-accidental" && n.namespace_().empty()) {
      ::std::unique_ptr<key_accidental_type> r(
        key_accidental_traits::create(i, f, this));

      this->key_accidental_.push_back(::std::move(r));
      continue;
    }

    // key-octave
    //
    if (n.name() == "key-octave" && n.namespace_().empty()) {
      ::std::unique_ptr<key_octave_type> r(
        key_octave_traits::create(i, f, this));

      this->key_octave_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }
  }
}

key *key::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class key(*this, f, c);
}

key &key::operator=(const key &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->cancel_ = x.cancel_;
    this->fifths_ = x.fifths_;
    this->mode_ = x.mode_;
    this->key_step_ = x.key_step_;
    this->key_alter_ = x.key_alter_;
    this->key_accidental_ = x.key_accidental_;
    this->key_octave_ = x.key_octave_;
    this->number_ = x.number_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->print_object_ = x.print_object_;
  }

  return *this;
}

key::~key() {}

// key_octave
//

key_octave::key_octave(const ::xml_schema::integer &_xsd_integer_base,
                       const number_type &number)
: ::musicxml::octave(_xsd_integer_base), number_(number, this), cancel_(this) {}

key_octave::key_octave(const key_octave &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::octave(x, f, c)
, number_(x.number_, f, this)
, cancel_(x.cancel_, f, this) {}

key_octave::key_octave(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::octave(e, f | ::xml_schema::flags::base, c)
, number_(this)
, cancel_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void key_octave::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "cancel" && n.namespace_().empty()) {
      this->cancel_.set(cancel_traits::create(i, f, this));
      continue;
    }
  }

  if (!number_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("number", "");
  }
}

key_octave *key_octave::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class key_octave(*this, f, c);
}

key_octave &key_octave::operator=(const key_octave &x) {
  if (this != &x) {
    static_cast<::musicxml::octave &>(*this) = x;
    this->number_ = x.number_;
    this->cancel_ = x.cancel_;
  }

  return *this;
}

key_octave::~key_octave() {}

// measure_repeat
//

measure_repeat::measure_repeat(const char *_xsd_positive_integer_or_empty_base,
                               const type_type &type)
: ::musicxml::positive_integer_or_empty(_xsd_positive_integer_or_empty_base)
, type_(type, this)
, slashes_(this) {}

measure_repeat::measure_repeat(
  const ::std::string &_xsd_positive_integer_or_empty_base,
  const type_type &type)
: ::musicxml::positive_integer_or_empty(_xsd_positive_integer_or_empty_base)
, type_(type, this)
, slashes_(this) {}

measure_repeat::measure_repeat(const ::musicxml::positive_integer_or_empty &
                                 _xsd_positive_integer_or_empty_base,
                               const type_type &type)
: ::musicxml::positive_integer_or_empty(_xsd_positive_integer_or_empty_base)
, type_(type, this)
, slashes_(this) {}

measure_repeat::measure_repeat(const measure_repeat &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::musicxml::positive_integer_or_empty(x, f, c)
, type_(x.type_, f, this)
, slashes_(x.slashes_, f, this) {}

measure_repeat::measure_repeat(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::musicxml::positive_integer_or_empty(e, f | ::xml_schema::flags::base, c)
, type_(this)
, slashes_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void measure_repeat::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "slashes" && n.namespace_().empty()) {
      this->slashes_.set(slashes_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

measure_repeat *measure_repeat::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class measure_repeat(*this, f, c);
}

measure_repeat &measure_repeat::operator=(const measure_repeat &x) {
  if (this != &x) {
    static_cast<::musicxml::positive_integer_or_empty &>(*this) = x;
    this->type_ = x.type_;
    this->slashes_ = x.slashes_;
  }

  return *this;
}

measure_repeat::~measure_repeat() {}

// measure_style
//

measure_style::measure_style()
: ::xml_schema::type()
, multiple_rest_(this)
, measure_repeat_(this)
, beat_repeat_(this)
, slash_(this)
, number_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

measure_style::measure_style(const measure_style &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, multiple_rest_(x.multiple_rest_, f, this)
, measure_repeat_(x.measure_repeat_, f, this)
, beat_repeat_(x.beat_repeat_, f, this)
, slash_(x.slash_, f, this)
, number_(x.number_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

measure_style::measure_style(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, multiple_rest_(this)
, measure_repeat_(this)
, beat_repeat_(this)
, slash_(this)
, number_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void measure_style::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // multiple-rest
    //
    if (n.name() == "multiple-rest" && n.namespace_().empty()) {
      ::std::unique_ptr<multiple_rest_type> r(
        multiple_rest_traits::create(i, f, this));

      if (!this->multiple_rest_) {
        this->multiple_rest_.set(::std::move(r));
        continue;
      }
    }

    // measure-repeat
    //
    if (n.name() == "measure-repeat" && n.namespace_().empty()) {
      ::std::unique_ptr<measure_repeat_type> r(
        measure_repeat_traits::create(i, f, this));

      if (!this->measure_repeat_) {
        this->measure_repeat_.set(::std::move(r));
        continue;
      }
    }

    // beat-repeat
    //
    if (n.name() == "beat-repeat" && n.namespace_().empty()) {
      ::std::unique_ptr<beat_repeat_type> r(
        beat_repeat_traits::create(i, f, this));

      if (!this->beat_repeat_) {
        this->beat_repeat_.set(::std::move(r));
        continue;
      }
    }

    // slash
    //
    if (n.name() == "slash" && n.namespace_().empty()) {
      ::std::unique_ptr<slash_type> r(slash_traits::create(i, f, this));

      if (!this->slash_) {
        this->slash_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

measure_style *measure_style::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class measure_style(*this, f, c);
}

measure_style &measure_style::operator=(const measure_style &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->multiple_rest_ = x.multiple_rest_;
    this->measure_repeat_ = x.measure_repeat_;
    this->beat_repeat_ = x.beat_repeat_;
    this->slash_ = x.slash_;
    this->number_ = x.number_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

measure_style::~measure_style() {}

// multiple_rest
//

multiple_rest::multiple_rest(const char *_xsd_positive_integer_or_empty_base)
: ::musicxml::positive_integer_or_empty(_xsd_positive_integer_or_empty_base)
, use_symbols_(this) {}

multiple_rest::multiple_rest(
  const ::std::string &_xsd_positive_integer_or_empty_base)
: ::musicxml::positive_integer_or_empty(_xsd_positive_integer_or_empty_base)
, use_symbols_(this) {}

multiple_rest::multiple_rest(const ::musicxml::positive_integer_or_empty &
                               _xsd_positive_integer_or_empty_base)
: ::musicxml::positive_integer_or_empty(_xsd_positive_integer_or_empty_base)
, use_symbols_(this) {}

multiple_rest::multiple_rest(const multiple_rest &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::musicxml::positive_integer_or_empty(x, f, c)
, use_symbols_(x.use_symbols_, f, this) {}

multiple_rest::multiple_rest(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::musicxml::positive_integer_or_empty(e, f | ::xml_schema::flags::base, c)
, use_symbols_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void multiple_rest::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "use-symbols" && n.namespace_().empty()) {
      this->use_symbols_.set(use_symbols_traits::create(i, f, this));
      continue;
    }
  }
}

multiple_rest *multiple_rest::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class multiple_rest(*this, f, c);
}

multiple_rest &multiple_rest::operator=(const multiple_rest &x) {
  if (this != &x) {
    static_cast<::musicxml::positive_integer_or_empty &>(*this) = x;
    this->use_symbols_ = x.use_symbols_;
  }

  return *this;
}

multiple_rest::~multiple_rest() {}

// part_symbol
//

part_symbol::part_symbol(
  ::musicxml::group_symbol_value::value _xsd_group_symbol_value_base)
: ::musicxml::group_symbol_value(_xsd_group_symbol_value_base)
, top_staff_(this)
, bottom_staff_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

part_symbol::part_symbol(const char *_xsd_string_base)
: ::musicxml::group_symbol_value(_xsd_string_base)
, top_staff_(this)
, bottom_staff_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

part_symbol::part_symbol(const ::std::string &_xsd_string_base)
: ::musicxml::group_symbol_value(_xsd_string_base)
, top_staff_(this)
, bottom_staff_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

part_symbol::part_symbol(
  const ::musicxml::group_symbol_value &_xsd_group_symbol_value_base)
: ::musicxml::group_symbol_value(_xsd_group_symbol_value_base)
, top_staff_(this)
, bottom_staff_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

part_symbol::part_symbol(const part_symbol &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::group_symbol_value(x, f, c)
, top_staff_(x.top_staff_, f, this)
, bottom_staff_(x.bottom_staff_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, color_(x.color_, f, this) {}

part_symbol::part_symbol(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::group_symbol_value(e, f | ::xml_schema::flags::base, c)
, top_staff_(this)
, bottom_staff_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void part_symbol::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "top-staff" && n.namespace_().empty()) {
      this->top_staff_.set(top_staff_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bottom-staff" && n.namespace_().empty()) {
      this->bottom_staff_.set(bottom_staff_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

part_symbol *part_symbol::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class part_symbol(*this, f, c);
}

part_symbol &part_symbol::operator=(const part_symbol &x) {
  if (this != &x) {
    static_cast<::musicxml::group_symbol_value &>(*this) = x;
    this->top_staff_ = x.top_staff_;
    this->bottom_staff_ = x.bottom_staff_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->color_ = x.color_;
  }

  return *this;
}

part_symbol::~part_symbol() {}

// slash
//

slash::slash(const type_type &type)
: ::xml_schema::type()
, slash_type_(this)
, slash_dot_(this)
, type_(type, this)
, use_dots_(this)
, use_stems_(this) {}

slash::slash(const slash &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, slash_type_(x.slash_type_, f, this)
, slash_dot_(x.slash_dot_, f, this)
, type_(x.type_, f, this)
, use_dots_(x.use_dots_, f, this)
, use_stems_(x.use_stems_, f, this) {}

slash::slash(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, slash_type_(this)
, slash_dot_(this)
, type_(this)
, use_dots_(this)
, use_stems_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void slash::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // slash-type
    //
    if (n.name() == "slash-type" && n.namespace_().empty()) {
      ::std::unique_ptr<slash_type_type> r(
        slash_type_traits::create(i, f, this));

      if (!this->slash_type_) {
        this->slash_type_.set(::std::move(r));
        continue;
      }
    }

    // slash-dot
    //
    if (n.name() == "slash-dot" && n.namespace_().empty()) {
      ::std::unique_ptr<slash_dot_type> r(slash_dot_traits::create(i, f, this));

      this->slash_dot_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "use-dots" && n.namespace_().empty()) {
      this->use_dots_.set(use_dots_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "use-stems" && n.namespace_().empty()) {
      this->use_stems_.set(use_stems_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

slash *slash::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class slash(*this, f, c);
}

slash &slash::operator=(const slash &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->slash_type_ = x.slash_type_;
    this->slash_dot_ = x.slash_dot_;
    this->type_ = x.type_;
    this->use_dots_ = x.use_dots_;
    this->use_stems_ = x.use_stems_;
  }

  return *this;
}

slash::~slash() {}

// staff_details
//

staff_details::staff_details()
: ::xml_schema::type()
, staff_type_(this)
, staff_lines_(this)
, staff_tuning_(this)
, capo_(this)
, staff_size_(this)
, number_(this)
, show_frets_(this)
, print_object_(this)
, print_spacing_(this) {}

staff_details::staff_details(const staff_details &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, staff_type_(x.staff_type_, f, this)
, staff_lines_(x.staff_lines_, f, this)
, staff_tuning_(x.staff_tuning_, f, this)
, capo_(x.capo_, f, this)
, staff_size_(x.staff_size_, f, this)
, number_(x.number_, f, this)
, show_frets_(x.show_frets_, f, this)
, print_object_(x.print_object_, f, this)
, print_spacing_(x.print_spacing_, f, this) {}

staff_details::staff_details(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, staff_type_(this)
, staff_lines_(this)
, staff_tuning_(this)
, capo_(this)
, staff_size_(this)
, number_(this)
, show_frets_(this)
, print_object_(this)
, print_spacing_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void staff_details::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // staff-type
    //
    if (n.name() == "staff-type" && n.namespace_().empty()) {
      ::std::unique_ptr<staff_type_type> r(
        staff_type_traits::create(i, f, this));

      if (!this->staff_type_) {
        this->staff_type_.set(::std::move(r));
        continue;
      }
    }

    // staff-lines
    //
    if (n.name() == "staff-lines" && n.namespace_().empty()) {
      if (!this->staff_lines_) {
        this->staff_lines_.set(staff_lines_traits::create(i, f, this));
        continue;
      }
    }

    // staff-tuning
    //
    if (n.name() == "staff-tuning" && n.namespace_().empty()) {
      ::std::unique_ptr<staff_tuning_type> r(
        staff_tuning_traits::create(i, f, this));

      this->staff_tuning_.push_back(::std::move(r));
      continue;
    }

    // capo
    //
    if (n.name() == "capo" && n.namespace_().empty()) {
      if (!this->capo_) {
        this->capo_.set(capo_traits::create(i, f, this));
        continue;
      }
    }

    // staff-size
    //
    if (n.name() == "staff-size" && n.namespace_().empty()) {
      ::std::unique_ptr<staff_size_type> r(
        staff_size_traits::create(i, f, this));

      if (!this->staff_size_) {
        this->staff_size_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "show-frets" && n.namespace_().empty()) {
      this->show_frets_.set(show_frets_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-spacing" && n.namespace_().empty()) {
      this->print_spacing_.set(print_spacing_traits::create(i, f, this));
      continue;
    }
  }
}

staff_details *staff_details::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class staff_details(*this, f, c);
}

staff_details &staff_details::operator=(const staff_details &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->staff_type_ = x.staff_type_;
    this->staff_lines_ = x.staff_lines_;
    this->staff_tuning_ = x.staff_tuning_;
    this->capo_ = x.capo_;
    this->staff_size_ = x.staff_size_;
    this->number_ = x.number_;
    this->show_frets_ = x.show_frets_;
    this->print_object_ = x.print_object_;
    this->print_spacing_ = x.print_spacing_;
  }

  return *this;
}

staff_details::~staff_details() {}

// staff_tuning
//

staff_tuning::staff_tuning(const tuning_step_type &tuning_step,
                           const tuning_octave_type &tuning_octave)
: ::xml_schema::type()
, tuning_step_(tuning_step, this)
, tuning_alter_(this)
, tuning_octave_(tuning_octave, this)
, line_(this) {}

staff_tuning::staff_tuning(const staff_tuning &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, tuning_step_(x.tuning_step_, f, this)
, tuning_alter_(x.tuning_alter_, f, this)
, tuning_octave_(x.tuning_octave_, f, this)
, line_(x.line_, f, this) {}

staff_tuning::staff_tuning(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, tuning_step_(this)
, tuning_alter_(this)
, tuning_octave_(this)
, line_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void staff_tuning::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // tuning-step
    //
    if (n.name() == "tuning-step" && n.namespace_().empty()) {
      ::std::unique_ptr<tuning_step_type> r(
        tuning_step_traits::create(i, f, this));

      if (!tuning_step_.present()) {
        this->tuning_step_.set(::std::move(r));
        continue;
      }
    }

    // tuning-alter
    //
    if (n.name() == "tuning-alter" && n.namespace_().empty()) {
      ::std::unique_ptr<tuning_alter_type> r(
        tuning_alter_traits::create(i, f, this));

      if (!this->tuning_alter_) {
        this->tuning_alter_.set(::std::move(r));
        continue;
      }
    }

    // tuning-octave
    //
    if (n.name() == "tuning-octave" && n.namespace_().empty()) {
      ::std::unique_ptr<tuning_octave_type> r(
        tuning_octave_traits::create(i, f, this));

      if (!tuning_octave_.present()) {
        this->tuning_octave_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!tuning_step_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("tuning-step", "");
  }

  if (!tuning_octave_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("tuning-octave", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "line" && n.namespace_().empty()) {
      this->line_.set(line_traits::create(i, f, this));
      continue;
    }
  }
}

staff_tuning *staff_tuning::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class staff_tuning(*this, f, c);
}

staff_tuning &staff_tuning::operator=(const staff_tuning &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->tuning_step_ = x.tuning_step_;
    this->tuning_alter_ = x.tuning_alter_;
    this->tuning_octave_ = x.tuning_octave_;
    this->line_ = x.line_;
  }

  return *this;
}

staff_tuning::~staff_tuning() {}

// time
//

time::time()
: ::xml_schema::type()
, beats_(this)
, beat_type_(this)
, interchangeable_(this)
, senza_misura_(this)
, number_(this)
, symbol_(this)
, separator_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, print_object_(this) {}

time::time(const time &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, beats_(x.beats_, f, this)
, beat_type_(x.beat_type_, f, this)
, interchangeable_(x.interchangeable_, f, this)
, senza_misura_(x.senza_misura_, f, this)
, number_(x.number_, f, this)
, symbol_(x.symbol_, f, this)
, separator_(x.separator_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this)
, print_object_(x.print_object_, f, this) {}

time::time(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, beats_(this)
, beat_type_(this)
, interchangeable_(this)
, senza_misura_(this)
, number_(this)
, symbol_(this)
, separator_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, print_object_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void time::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // beats
    //
    if (n.name() == "beats" && n.namespace_().empty()) {
      ::std::unique_ptr<beats_type> r(beats_traits::create(i, f, this));

      this->beats_.push_back(::std::move(r));
      continue;
    }

    // beat-type
    //
    if (n.name() == "beat-type" && n.namespace_().empty()) {
      ::std::unique_ptr<beat_type_type> r(beat_type_traits::create(i, f, this));

      this->beat_type_.push_back(::std::move(r));
      continue;
    }

    // interchangeable
    //
    if (n.name() == "interchangeable" && n.namespace_().empty()) {
      ::std::unique_ptr<interchangeable_type> r(
        interchangeable_traits::create(i, f, this));

      if (!this->interchangeable_) {
        this->interchangeable_.set(::std::move(r));
        continue;
      }
    }

    // senza-misura
    //
    if (n.name() == "senza-misura" && n.namespace_().empty()) {
      ::std::unique_ptr<senza_misura_type> r(
        senza_misura_traits::create(i, f, this));

      if (!this->senza_misura_) {
        this->senza_misura_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "symbol" && n.namespace_().empty()) {
      this->symbol_.set(symbol_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "separator" && n.namespace_().empty()) {
      this->separator_.set(separator_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }
  }
}

time *time::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class time(*this, f, c);
}

time &time::operator=(const time &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->beats_ = x.beats_;
    this->beat_type_ = x.beat_type_;
    this->interchangeable_ = x.interchangeable_;
    this->senza_misura_ = x.senza_misura_;
    this->number_ = x.number_;
    this->symbol_ = x.symbol_;
    this->separator_ = x.separator_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
    this->print_object_ = x.print_object_;
  }

  return *this;
}

time::~time() {}

// transpose
//

transpose::transpose(const chromatic_type &chromatic)
: ::xml_schema::type()
, diatonic_(this)
, chromatic_(chromatic, this)
, octave_change_(this)
, double__(this)
, number_(this) {}

transpose::transpose(const transpose &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, diatonic_(x.diatonic_, f, this)
, chromatic_(x.chromatic_, f, this)
, octave_change_(x.octave_change_, f, this)
, double__(x.double__, f, this)
, number_(x.number_, f, this) {}

transpose::transpose(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, diatonic_(this)
, chromatic_(this)
, octave_change_(this)
, double__(this)
, number_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void transpose::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // diatonic
    //
    if (n.name() == "diatonic" && n.namespace_().empty()) {
      if (!this->diatonic_) {
        this->diatonic_.set(diatonic_traits::create(i, f, this));
        continue;
      }
    }

    // chromatic
    //
    if (n.name() == "chromatic" && n.namespace_().empty()) {
      ::std::unique_ptr<chromatic_type> r(chromatic_traits::create(i, f, this));

      if (!chromatic_.present()) {
        this->chromatic_.set(::std::move(r));
        continue;
      }
    }

    // octave-change
    //
    if (n.name() == "octave-change" && n.namespace_().empty()) {
      if (!this->octave_change_) {
        this->octave_change_.set(octave_change_traits::create(i, f, this));
        continue;
      }
    }

    // double
    //
    if (n.name() == "double" && n.namespace_().empty()) {
      ::std::unique_ptr<double_type> r(double_traits::create(i, f, this));

      if (!this->double__) {
        this->double__.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!chromatic_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("chromatic", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }
  }
}

transpose *transpose::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class transpose(*this, f, c);
}

transpose &transpose::operator=(const transpose &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->diatonic_ = x.diatonic_;
    this->chromatic_ = x.chromatic_;
    this->octave_change_ = x.octave_change_;
    this->double__ = x.double__;
    this->number_ = x.number_;
  }

  return *this;
}

transpose::~transpose() {}

// bar_style_color
//

bar_style_color::bar_style_color(
  ::musicxml::bar_style::value _xsd_bar_style_base)
: ::musicxml::bar_style(_xsd_bar_style_base), color_(this) {}

bar_style_color::bar_style_color(const char *_xsd_string_base)
: ::musicxml::bar_style(_xsd_string_base), color_(this) {}

bar_style_color::bar_style_color(const ::std::string &_xsd_string_base)
: ::musicxml::bar_style(_xsd_string_base), color_(this) {}

bar_style_color::bar_style_color(
  const ::musicxml::bar_style &_xsd_bar_style_base)
: ::musicxml::bar_style(_xsd_bar_style_base), color_(this) {}

bar_style_color::bar_style_color(const bar_style_color &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::musicxml::bar_style(x, f, c), color_(x.color_, f, this) {}

bar_style_color::bar_style_color(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::musicxml::bar_style(e, f | ::xml_schema::flags::base, c), color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void bar_style_color::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

bar_style_color *bar_style_color::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class bar_style_color(*this, f, c);
}

bar_style_color &bar_style_color::operator=(const bar_style_color &x) {
  if (this != &x) {
    static_cast<::musicxml::bar_style &>(*this) = x;
    this->color_ = x.color_;
  }

  return *this;
}

bar_style_color::~bar_style_color() {}

// barline
//

const barline::location_type barline::location_default_value_("right");

barline::barline()
: ::xml_schema::type()
, bar_style_(this)
, footnote_(this)
, level_(this)
, wavy_line_(this)
, segno_(this)
, coda_(this)
, fermata_(this)
, ending_(this)
, repeat_(this)
, location_(location_default_value(), this)
, segno1_(this)
, coda1_(this)
, divisions_(this) {}

barline::barline(const barline &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, bar_style_(x.bar_style_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, wavy_line_(x.wavy_line_, f, this)
, segno_(x.segno_, f, this)
, coda_(x.coda_, f, this)
, fermata_(x.fermata_, f, this)
, ending_(x.ending_, f, this)
, repeat_(x.repeat_, f, this)
, location_(x.location_, f, this)
, segno1_(x.segno1_, f, this)
, coda1_(x.coda1_, f, this)
, divisions_(x.divisions_, f, this) {}

barline::barline(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, bar_style_(this)
, footnote_(this)
, level_(this)
, wavy_line_(this)
, segno_(this)
, coda_(this)
, fermata_(this)
, ending_(this)
, repeat_(this)
, location_(this)
, segno1_(this)
, coda1_(this)
, divisions_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void barline::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // bar-style
    //
    if (n.name() == "bar-style" && n.namespace_().empty()) {
      ::std::unique_ptr<bar_style_type> r(bar_style_traits::create(i, f, this));

      if (!this->bar_style_) {
        this->bar_style_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    // wavy-line
    //
    if (n.name() == "wavy-line" && n.namespace_().empty()) {
      ::std::unique_ptr<wavy_line_type> r(wavy_line_traits::create(i, f, this));

      if (!this->wavy_line_) {
        this->wavy_line_.set(::std::move(r));
        continue;
      }
    }

    // segno
    //
    if (n.name() == "segno" && n.namespace_().empty()) {
      ::std::unique_ptr<segno_type> r(segno_traits::create(i, f, this));

      if (!this->segno_) {
        this->segno_.set(::std::move(r));
        continue;
      }
    }

    // coda
    //
    if (n.name() == "coda" && n.namespace_().empty()) {
      ::std::unique_ptr<coda_type> r(coda_traits::create(i, f, this));

      if (!this->coda_) {
        this->coda_.set(::std::move(r));
        continue;
      }
    }

    // fermata
    //
    if (n.name() == "fermata" && n.namespace_().empty()) {
      ::std::unique_ptr<fermata_type> r(fermata_traits::create(i, f, this));

      this->fermata_.push_back(::std::move(r));
      continue;
    }

    // ending
    //
    if (n.name() == "ending" && n.namespace_().empty()) {
      ::std::unique_ptr<ending_type> r(ending_traits::create(i, f, this));

      if (!this->ending_) {
        this->ending_.set(::std::move(r));
        continue;
      }
    }

    // repeat
    //
    if (n.name() == "repeat" && n.namespace_().empty()) {
      ::std::unique_ptr<repeat_type> r(repeat_traits::create(i, f, this));

      if (!this->repeat_) {
        this->repeat_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "location" && n.namespace_().empty()) {
      this->location_.set(location_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "segno" && n.namespace_().empty()) {
      this->segno1_.set(segno1_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "coda" && n.namespace_().empty()) {
      this->coda1_.set(coda1_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "divisions" && n.namespace_().empty()) {
      this->divisions_.set(divisions_traits::create(i, f, this));
      continue;
    }
  }

  if (!location_.present()) { this->location_.set(location_default_value()); }
}

barline *barline::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class barline(*this, f, c);
}

barline &barline::operator=(const barline &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->bar_style_ = x.bar_style_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->wavy_line_ = x.wavy_line_;
    this->segno_ = x.segno_;
    this->coda_ = x.coda_;
    this->fermata_ = x.fermata_;
    this->ending_ = x.ending_;
    this->repeat_ = x.repeat_;
    this->location_ = x.location_;
    this->segno1_ = x.segno1_;
    this->coda1_ = x.coda1_;
    this->divisions_ = x.divisions_;
  }

  return *this;
}

barline::~barline() {}

// ending
//

ending::ending(const number_type &number, const type_type &type)
: ::xml_schema::string()
, number_(number, this)
, type_(type, this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, end_length_(this)
, text_x_(this)
, text_y_(this) {}

ending::ending(const char *_xsd_string_base, const number_type &number,
               const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, number_(number, this)
, type_(type, this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, end_length_(this)
, text_x_(this)
, text_y_(this) {}

ending::ending(const ::std::string &_xsd_string_base, const number_type &number,
               const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, number_(number, this)
, type_(type, this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, end_length_(this)
, text_x_(this)
, text_y_(this) {}

ending::ending(const ::xml_schema::string &_xsd_string_base,
               const number_type &number, const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, number_(number, this)
, type_(type, this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, end_length_(this)
, text_x_(this)
, text_y_(this) {}

ending::ending(const ending &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, number_(x.number_, f, this)
, type_(x.type_, f, this)
, print_object_(x.print_object_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, end_length_(x.end_length_, f, this)
, text_x_(x.text_x_, f, this)
, text_y_(x.text_y_, f, this) {}

ending::ending(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, number_(this)
, type_(this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, end_length_(this)
, text_x_(this)
, text_y_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void ending::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "end-length" && n.namespace_().empty()) {
      this->end_length_.set(end_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "text-x" && n.namespace_().empty()) {
      this->text_x_.set(text_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "text-y" && n.namespace_().empty()) {
      this->text_y_.set(text_y_traits::create(i, f, this));
      continue;
    }
  }

  if (!number_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("number", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

ending *ending::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class ending(*this, f, c);
}

ending &ending::operator=(const ending &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->number_ = x.number_;
    this->type_ = x.type_;
    this->print_object_ = x.print_object_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->end_length_ = x.end_length_;
    this->text_x_ = x.text_x_;
    this->text_y_ = x.text_y_;
  }

  return *this;
}

ending::~ending() {}

// repeat
//

repeat::repeat(const direction_type &direction)
: ::xml_schema::type()
, direction_(direction, this)
, times_(this)
, winged_(this) {}

repeat::repeat(const repeat &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, direction_(x.direction_, f, this)
, times_(x.times_, f, this)
, winged_(x.winged_, f, this) {}

repeat::repeat(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, direction_(this)
, times_(this)
, winged_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void repeat::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "direction" && n.namespace_().empty()) {
      this->direction_.set(direction_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "times" && n.namespace_().empty()) {
      this->times_.set(times_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "winged" && n.namespace_().empty()) {
      this->winged_.set(winged_traits::create(i, f, this));
      continue;
    }
  }

  if (!direction_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("direction", "");
  }
}

repeat *repeat::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class repeat(*this, f, c);
}

repeat &repeat::operator=(const repeat &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->direction_ = x.direction_;
    this->times_ = x.times_;
    this->winged_ = x.winged_;
  }

  return *this;
}

repeat::~repeat() {}

// accord
//

accord::accord(const tuning_step_type &tuning_step,
               const tuning_octave_type &tuning_octave)
: ::xml_schema::type()
, tuning_step_(tuning_step, this)
, tuning_alter_(this)
, tuning_octave_(tuning_octave, this)
, string_(this) {}

accord::accord(const accord &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, tuning_step_(x.tuning_step_, f, this)
, tuning_alter_(x.tuning_alter_, f, this)
, tuning_octave_(x.tuning_octave_, f, this)
, string_(x.string_, f, this) {}

accord::accord(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, tuning_step_(this)
, tuning_alter_(this)
, tuning_octave_(this)
, string_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void accord::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // tuning-step
    //
    if (n.name() == "tuning-step" && n.namespace_().empty()) {
      ::std::unique_ptr<tuning_step_type> r(
        tuning_step_traits::create(i, f, this));

      if (!tuning_step_.present()) {
        this->tuning_step_.set(::std::move(r));
        continue;
      }
    }

    // tuning-alter
    //
    if (n.name() == "tuning-alter" && n.namespace_().empty()) {
      ::std::unique_ptr<tuning_alter_type> r(
        tuning_alter_traits::create(i, f, this));

      if (!this->tuning_alter_) {
        this->tuning_alter_.set(::std::move(r));
        continue;
      }
    }

    // tuning-octave
    //
    if (n.name() == "tuning-octave" && n.namespace_().empty()) {
      ::std::unique_ptr<tuning_octave_type> r(
        tuning_octave_traits::create(i, f, this));

      if (!tuning_octave_.present()) {
        this->tuning_octave_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!tuning_step_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("tuning-step", "");
  }

  if (!tuning_octave_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("tuning-octave", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "string" && n.namespace_().empty()) {
      this->string_.set(string_traits::create(i, f, this));
      continue;
    }
  }
}

accord *accord::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class accord(*this, f, c);
}

accord &accord::operator=(const accord &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->tuning_step_ = x.tuning_step_;
    this->tuning_alter_ = x.tuning_alter_;
    this->tuning_octave_ = x.tuning_octave_;
    this->string_ = x.string_;
  }

  return *this;
}

accord::~accord() {}

// accordion_registration
//

accordion_registration::accordion_registration()
: ::xml_schema::type()
, accordion_high_(this)
, accordion_middle_(this)
, accordion_low_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

accordion_registration::accordion_registration(const accordion_registration &x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, accordion_high_(x.accordion_high_, f, this)
, accordion_middle_(x.accordion_middle_, f, this)
, accordion_low_(x.accordion_low_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

accordion_registration::accordion_registration(const ::xercesc::DOMElement &e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, accordion_high_(this)
, accordion_middle_(this)
, accordion_low_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void accordion_registration::parse(::xsd::cxx::xml::dom::parser<char> &p,
                                   ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // accordion-high
    //
    if (n.name() == "accordion-high" && n.namespace_().empty()) {
      ::std::unique_ptr<accordion_high_type> r(
        accordion_high_traits::create(i, f, this));

      if (!this->accordion_high_) {
        this->accordion_high_.set(::std::move(r));
        continue;
      }
    }

    // accordion-middle
    //
    if (n.name() == "accordion-middle" && n.namespace_().empty()) {
      ::std::unique_ptr<accordion_middle_type> r(
        accordion_middle_traits::create(i, f, this));

      if (!this->accordion_middle_) {
        this->accordion_middle_.set(::std::move(r));
        continue;
      }
    }

    // accordion-low
    //
    if (n.name() == "accordion-low" && n.namespace_().empty()) {
      ::std::unique_ptr<accordion_low_type> r(
        accordion_low_traits::create(i, f, this));

      if (!this->accordion_low_) {
        this->accordion_low_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }
}

accordion_registration *
accordion_registration::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class accordion_registration(*this, f, c);
}

accordion_registration &accordion_registration::
operator=(const accordion_registration &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->accordion_high_ = x.accordion_high_;
    this->accordion_middle_ = x.accordion_middle_;
    this->accordion_low_ = x.accordion_low_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

accordion_registration::~accordion_registration() {}

// barre
//

barre::barre(const type_type &type)
: ::xml_schema::type(), type_(type, this), color_(this) {}

barre::barre(const barre &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, color_(x.color_, f, this) {}

barre::barre(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void barre::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

barre *barre::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class barre(*this, f, c);
}

barre &barre::operator=(const barre &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->color_ = x.color_;
  }

  return *this;
}

barre::~barre() {}

// bass
//

bass::bass(const bass_step_type &bass_step)
: ::xml_schema::type(), bass_step_(bass_step, this), bass_alter_(this) {}

bass::bass(::std::unique_ptr<bass_step_type> bass_step)
: ::xml_schema::type()
, bass_step_(std::move(bass_step), this)
, bass_alter_(this) {}

bass::bass(const bass &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, bass_step_(x.bass_step_, f, this)
, bass_alter_(x.bass_alter_, f, this) {}

bass::bass(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, bass_step_(this)
, bass_alter_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void bass::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // bass-step
    //
    if (n.name() == "bass-step" && n.namespace_().empty()) {
      ::std::unique_ptr<bass_step_type> r(bass_step_traits::create(i, f, this));

      if (!bass_step_.present()) {
        this->bass_step_.set(::std::move(r));
        continue;
      }
    }

    // bass-alter
    //
    if (n.name() == "bass-alter" && n.namespace_().empty()) {
      ::std::unique_ptr<bass_alter_type> r(
        bass_alter_traits::create(i, f, this));

      if (!this->bass_alter_) {
        this->bass_alter_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!bass_step_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("bass-step", "");
  }
}

bass *bass::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class bass(*this, f, c);
}

bass &bass::operator=(const bass &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->bass_step_ = x.bass_step_;
    this->bass_alter_ = x.bass_alter_;
  }

  return *this;
}

bass::~bass() {}

// bass_alter
//

bass_alter::bass_alter(const ::xml_schema::decimal &_xsd_decimal_base)
: ::musicxml::semitones(_xsd_decimal_base)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, location_(this) {}

bass_alter::bass_alter(const bass_alter &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::semitones(x, f, c)
, print_object_(x.print_object_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, location_(x.location_, f, this) {}

bass_alter::bass_alter(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::semitones(e, f | ::xml_schema::flags::base, c)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, location_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void bass_alter::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "location" && n.namespace_().empty()) {
      this->location_.set(location_traits::create(i, f, this));
      continue;
    }
  }
}

bass_alter *bass_alter::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class bass_alter(*this, f, c);
}

bass_alter &bass_alter::operator=(const bass_alter &x) {
  if (this != &x) {
    static_cast<::musicxml::semitones &>(*this) = x;
    this->print_object_ = x.print_object_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->location_ = x.location_;
  }

  return *this;
}

bass_alter::~bass_alter() {}

// bass_step
//

bass_step::bass_step(::musicxml::step::value _xsd_step_base)
: ::musicxml::step(_xsd_step_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

bass_step::bass_step(const char *_xsd_string_base)
: ::musicxml::step(_xsd_string_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

bass_step::bass_step(const ::std::string &_xsd_string_base)
: ::musicxml::step(_xsd_string_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

bass_step::bass_step(const ::musicxml::step &_xsd_step_base)
: ::musicxml::step(_xsd_step_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

bass_step::bass_step(const bass_step &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::musicxml::step(x, f, c)
, text_(x.text_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

bass_step::bass_step(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::musicxml::step(e, f | ::xml_schema::flags::base, c)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void bass_step::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "text" && n.namespace_().empty()) {
      this->text_.set(text_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

bass_step *bass_step::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class bass_step(*this, f, c);
}

bass_step &bass_step::operator=(const bass_step &x) {
  if (this != &x) {
    static_cast<::musicxml::step &>(*this) = x;
    this->text_ = x.text_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

bass_step::~bass_step() {}

// beater
//

beater::beater(::musicxml::beater_value::value _xsd_beater_value_base)
: ::musicxml::beater_value(_xsd_beater_value_base), tip_(this) {}

beater::beater(const char *_xsd_string_base)
: ::musicxml::beater_value(_xsd_string_base), tip_(this) {}

beater::beater(const ::std::string &_xsd_string_base)
: ::musicxml::beater_value(_xsd_string_base), tip_(this) {}

beater::beater(const ::musicxml::beater_value &_xsd_beater_value_base)
: ::musicxml::beater_value(_xsd_beater_value_base), tip_(this) {}

beater::beater(const beater &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::musicxml::beater_value(x, f, c), tip_(x.tip_, f, this) {}

beater::beater(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::musicxml::beater_value(e, f | ::xml_schema::flags::base, c), tip_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void beater::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "tip" && n.namespace_().empty()) {
      this->tip_.set(tip_traits::create(i, f, this));
      continue;
    }
  }
}

beater *beater::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class beater(*this, f, c);
}

beater &beater::operator=(const beater &x) {
  if (this != &x) {
    static_cast<::musicxml::beater_value &>(*this) = x;
    this->tip_ = x.tip_;
  }

  return *this;
}

beater::~beater() {}

// bracket
//

bracket::bracket(const type_type &type, const line_end_type &line_end)
: ::xml_schema::type()
, type_(type, this)
, number_(this)
, line_end_(line_end, this)
, end_length_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

bracket::bracket(const bracket &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, line_end_(x.line_end_, f, this)
, end_length_(x.end_length_, f, this)
, line_type_(x.line_type_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, color_(x.color_, f, this) {}

bracket::bracket(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, line_end_(this)
, end_length_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void bracket::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-end" && n.namespace_().empty()) {
      this->line_end_.set(line_end_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "end-length" && n.namespace_().empty()) {
      this->end_length_.set(end_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-type" && n.namespace_().empty()) {
      this->line_type_.set(line_type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!line_end_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("line-end", "");
  }
}

bracket *bracket::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class bracket(*this, f, c);
}

bracket &bracket::operator=(const bracket &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->line_end_ = x.line_end_;
    this->end_length_ = x.end_length_;
    this->line_type_ = x.line_type_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->color_ = x.color_;
  }

  return *this;
}

bracket::~bracket() {}

// dashes
//

dashes::dashes(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, number_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

dashes::dashes(const dashes &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, color_(x.color_, f, this) {}

dashes::dashes(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void dashes::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

dashes *dashes::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class dashes(*this, f, c);
}

dashes &dashes::operator=(const dashes &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->color_ = x.color_;
  }

  return *this;
}

dashes::~dashes() {}

// degree
//

degree::degree(const degree_value_type &degree_value,
               const degree_alter_type &degree_alter,
               const degree_type_type &degree_type)
: ::xml_schema::type()
, degree_value_(degree_value, this)
, degree_alter_(degree_alter, this)
, degree_type_(degree_type, this)
, print_object_(this) {}

degree::degree(::std::unique_ptr<degree_value_type> degree_value,
               ::std::unique_ptr<degree_alter_type> degree_alter,
               ::std::unique_ptr<degree_type_type> degree_type)
: ::xml_schema::type()
, degree_value_(std::move(degree_value), this)
, degree_alter_(std::move(degree_alter), this)
, degree_type_(std::move(degree_type), this)
, print_object_(this) {}

degree::degree(const degree &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, degree_value_(x.degree_value_, f, this)
, degree_alter_(x.degree_alter_, f, this)
, degree_type_(x.degree_type_, f, this)
, print_object_(x.print_object_, f, this) {}

degree::degree(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, degree_value_(this)
, degree_alter_(this)
, degree_type_(this)
, print_object_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void degree::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // degree-value
    //
    if (n.name() == "degree-value" && n.namespace_().empty()) {
      ::std::unique_ptr<degree_value_type> r(
        degree_value_traits::create(i, f, this));

      if (!degree_value_.present()) {
        this->degree_value_.set(::std::move(r));
        continue;
      }
    }

    // degree-alter
    //
    if (n.name() == "degree-alter" && n.namespace_().empty()) {
      ::std::unique_ptr<degree_alter_type> r(
        degree_alter_traits::create(i, f, this));

      if (!degree_alter_.present()) {
        this->degree_alter_.set(::std::move(r));
        continue;
      }
    }

    // degree-type
    //
    if (n.name() == "degree-type" && n.namespace_().empty()) {
      ::std::unique_ptr<degree_type_type> r(
        degree_type_traits::create(i, f, this));

      if (!degree_type_.present()) {
        this->degree_type_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!degree_value_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("degree-value", "");
  }

  if (!degree_alter_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("degree-alter", "");
  }

  if (!degree_type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("degree-type", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }
  }
}

degree *degree::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class degree(*this, f, c);
}

degree &degree::operator=(const degree &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->degree_value_ = x.degree_value_;
    this->degree_alter_ = x.degree_alter_;
    this->degree_type_ = x.degree_type_;
    this->print_object_ = x.print_object_;
  }

  return *this;
}

degree::~degree() {}

// degree_alter
//

degree_alter::degree_alter(const ::xml_schema::decimal &_xsd_decimal_base)
: ::musicxml::semitones(_xsd_decimal_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, plus_minus_(this) {}

degree_alter::degree_alter(const degree_alter &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::musicxml::semitones(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, plus_minus_(x.plus_minus_, f, this) {}

degree_alter::degree_alter(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::musicxml::semitones(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, plus_minus_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void degree_alter::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "plus-minus" && n.namespace_().empty()) {
      this->plus_minus_.set(plus_minus_traits::create(i, f, this));
      continue;
    }
  }
}

degree_alter *degree_alter::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class degree_alter(*this, f, c);
}

degree_alter &degree_alter::operator=(const degree_alter &x) {
  if (this != &x) {
    static_cast<::musicxml::semitones &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->plus_minus_ = x.plus_minus_;
  }

  return *this;
}

degree_alter::~degree_alter() {}

// degree_type
//

degree_type::degree_type(
  ::musicxml::degree_type_value::value _xsd_degree_type_value_base)
: ::musicxml::degree_type_value(_xsd_degree_type_value_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

degree_type::degree_type(const char *_xsd_string_base)
: ::musicxml::degree_type_value(_xsd_string_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

degree_type::degree_type(const ::std::string &_xsd_string_base)
: ::musicxml::degree_type_value(_xsd_string_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

degree_type::degree_type(
  const ::musicxml::degree_type_value &_xsd_degree_type_value_base)
: ::musicxml::degree_type_value(_xsd_degree_type_value_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

degree_type::degree_type(const degree_type &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::degree_type_value(x, f, c)
, text_(x.text_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

degree_type::degree_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::degree_type_value(e, f | ::xml_schema::flags::base, c)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void degree_type::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "text" && n.namespace_().empty()) {
      this->text_.set(text_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

degree_type *degree_type::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class degree_type(*this, f, c);
}

degree_type &degree_type::operator=(const degree_type &x) {
  if (this != &x) {
    static_cast<::musicxml::degree_type_value &>(*this) = x;
    this->text_ = x.text_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

degree_type::~degree_type() {}

// degree_value
//

degree_value::degree_value(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base)
, symbol_(this)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

degree_value::degree_value(const degree_value &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c)
, symbol_(x.symbol_, f, this)
, text_(x.text_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

degree_value::degree_value(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    e, f | ::xml_schema::flags::base, c)
, symbol_(this)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void degree_value::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "symbol" && n.namespace_().empty()) {
      this->symbol_.set(symbol_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "text" && n.namespace_().empty()) {
      this->text_.set(text_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

degree_value *degree_value::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class degree_value(*this, f, c);
}

degree_value &degree_value::operator=(const degree_value &x) {
  if (this != &x) {
    static_cast<::xsd::cxx::tree::fundamental_base<
      ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(
      *this) = x;
    this->symbol_ = x.symbol_;
    this->text_ = x.text_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

degree_value::~degree_value() {}

// direction
//

direction::direction()
: ::xml_schema::type()
, direction_type_(this)
, offset_(this)
, footnote_(this)
, level_(this)
, voice_(this)
, staff_(this)
, sound_(this)
, placement_(this)
, directive_(this) {}

direction::direction(const direction &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, direction_type_(x.direction_type_, f, this)
, offset_(x.offset_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, voice_(x.voice_, f, this)
, staff_(x.staff_, f, this)
, sound_(x.sound_, f, this)
, placement_(x.placement_, f, this)
, directive_(x.directive_, f, this) {}

direction::direction(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, direction_type_(this)
, offset_(this)
, footnote_(this)
, level_(this)
, voice_(this)
, staff_(this)
, sound_(this)
, placement_(this)
, directive_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void direction::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // direction-type
    //
    if (n.name() == "direction-type" && n.namespace_().empty()) {
      ::std::unique_ptr<direction_type_type> r(
        direction_type_traits::create(i, f, this));

      this->direction_type_.push_back(::std::move(r));
      continue;
    }

    // offset
    //
    if (n.name() == "offset" && n.namespace_().empty()) {
      ::std::unique_ptr<offset_type> r(offset_traits::create(i, f, this));

      if (!this->offset_) {
        this->offset_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    // voice
    //
    if (n.name() == "voice" && n.namespace_().empty()) {
      ::std::unique_ptr<voice_type> r(voice_traits::create(i, f, this));

      if (!this->voice_) {
        this->voice_.set(::std::move(r));
        continue;
      }
    }

    // staff
    //
    if (n.name() == "staff" && n.namespace_().empty()) {
      if (!this->staff_) {
        this->staff_.set(staff_traits::create(i, f, this));
        continue;
      }
    }

    // sound
    //
    if (n.name() == "sound" && n.namespace_().empty()) {
      ::std::unique_ptr<sound_type> r(sound_traits::create(i, f, this));

      if (!this->sound_) {
        this->sound_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "directive" && n.namespace_().empty()) {
      this->directive_.set(directive_traits::create(i, f, this));
      continue;
    }
  }
}

direction *direction::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class direction(*this, f, c);
}

direction &direction::operator=(const direction &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->direction_type_ = x.direction_type_;
    this->offset_ = x.offset_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->voice_ = x.voice_;
    this->staff_ = x.staff_;
    this->sound_ = x.sound_;
    this->placement_ = x.placement_;
    this->directive_ = x.directive_;
  }

  return *this;
}

direction::~direction() {}

// direction_type
//

direction_type::direction_type()
: ::xml_schema::type()
, rehearsal_(this)
, segno_(this)
, words_(this)
, coda_(this)
, wedge_(this)
, dynamics_(this)
, dashes_(this)
, bracket_(this)
, pedal_(this)
, metronome_(this)
, octave_shift_(this)
, harp_pedals_(this)
, damp_(this)
, damp_all_(this)
, eyeglasses_(this)
, string_mute_(this)
, scordatura_(this)
, image_(this)
, principal_voice_(this)
, accordion_registration_(this)
, percussion_(this)
, other_direction_(this) {}

direction_type::direction_type(const direction_type &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, rehearsal_(x.rehearsal_, f, this)
, segno_(x.segno_, f, this)
, words_(x.words_, f, this)
, coda_(x.coda_, f, this)
, wedge_(x.wedge_, f, this)
, dynamics_(x.dynamics_, f, this)
, dashes_(x.dashes_, f, this)
, bracket_(x.bracket_, f, this)
, pedal_(x.pedal_, f, this)
, metronome_(x.metronome_, f, this)
, octave_shift_(x.octave_shift_, f, this)
, harp_pedals_(x.harp_pedals_, f, this)
, damp_(x.damp_, f, this)
, damp_all_(x.damp_all_, f, this)
, eyeglasses_(x.eyeglasses_, f, this)
, string_mute_(x.string_mute_, f, this)
, scordatura_(x.scordatura_, f, this)
, image_(x.image_, f, this)
, principal_voice_(x.principal_voice_, f, this)
, accordion_registration_(x.accordion_registration_, f, this)
, percussion_(x.percussion_, f, this)
, other_direction_(x.other_direction_, f, this) {}

direction_type::direction_type(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, rehearsal_(this)
, segno_(this)
, words_(this)
, coda_(this)
, wedge_(this)
, dynamics_(this)
, dashes_(this)
, bracket_(this)
, pedal_(this)
, metronome_(this)
, octave_shift_(this)
, harp_pedals_(this)
, damp_(this)
, damp_all_(this)
, eyeglasses_(this)
, string_mute_(this)
, scordatura_(this)
, image_(this)
, principal_voice_(this)
, accordion_registration_(this)
, percussion_(this)
, other_direction_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void direction_type::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // rehearsal
    //
    if (n.name() == "rehearsal" && n.namespace_().empty()) {
      ::std::unique_ptr<rehearsal_type> r(rehearsal_traits::create(i, f, this));

      this->rehearsal_.push_back(::std::move(r));
      continue;
    }

    // segno
    //
    if (n.name() == "segno" && n.namespace_().empty()) {
      ::std::unique_ptr<segno_type> r(segno_traits::create(i, f, this));

      this->segno_.push_back(::std::move(r));
      continue;
    }

    // words
    //
    if (n.name() == "words" && n.namespace_().empty()) {
      ::std::unique_ptr<words_type> r(words_traits::create(i, f, this));

      this->words_.push_back(::std::move(r));
      continue;
    }

    // coda
    //
    if (n.name() == "coda" && n.namespace_().empty()) {
      ::std::unique_ptr<coda_type> r(coda_traits::create(i, f, this));

      this->coda_.push_back(::std::move(r));
      continue;
    }

    // wedge
    //
    if (n.name() == "wedge" && n.namespace_().empty()) {
      ::std::unique_ptr<wedge_type> r(wedge_traits::create(i, f, this));

      if (!this->wedge_) {
        this->wedge_.set(::std::move(r));
        continue;
      }
    }

    // dynamics
    //
    if (n.name() == "dynamics" && n.namespace_().empty()) {
      ::std::unique_ptr<dynamics_type> r(dynamics_traits::create(i, f, this));

      this->dynamics_.push_back(::std::move(r));
      continue;
    }

    // dashes
    //
    if (n.name() == "dashes" && n.namespace_().empty()) {
      ::std::unique_ptr<dashes_type> r(dashes_traits::create(i, f, this));

      if (!this->dashes_) {
        this->dashes_.set(::std::move(r));
        continue;
      }
    }

    // bracket
    //
    if (n.name() == "bracket" && n.namespace_().empty()) {
      ::std::unique_ptr<bracket_type> r(bracket_traits::create(i, f, this));

      if (!this->bracket_) {
        this->bracket_.set(::std::move(r));
        continue;
      }
    }

    // pedal
    //
    if (n.name() == "pedal" && n.namespace_().empty()) {
      ::std::unique_ptr<pedal_type> r(pedal_traits::create(i, f, this));

      if (!this->pedal_) {
        this->pedal_.set(::std::move(r));
        continue;
      }
    }

    // metronome
    //
    if (n.name() == "metronome" && n.namespace_().empty()) {
      ::std::unique_ptr<metronome_type> r(metronome_traits::create(i, f, this));

      if (!this->metronome_) {
        this->metronome_.set(::std::move(r));
        continue;
      }
    }

    // octave-shift
    //
    if (n.name() == "octave-shift" && n.namespace_().empty()) {
      ::std::unique_ptr<octave_shift_type> r(
        octave_shift_traits::create(i, f, this));

      if (!this->octave_shift_) {
        this->octave_shift_.set(::std::move(r));
        continue;
      }
    }

    // harp-pedals
    //
    if (n.name() == "harp-pedals" && n.namespace_().empty()) {
      ::std::unique_ptr<harp_pedals_type> r(
        harp_pedals_traits::create(i, f, this));

      if (!this->harp_pedals_) {
        this->harp_pedals_.set(::std::move(r));
        continue;
      }
    }

    // damp
    //
    if (n.name() == "damp" && n.namespace_().empty()) {
      ::std::unique_ptr<damp_type> r(damp_traits::create(i, f, this));

      if (!this->damp_) {
        this->damp_.set(::std::move(r));
        continue;
      }
    }

    // damp-all
    //
    if (n.name() == "damp-all" && n.namespace_().empty()) {
      ::std::unique_ptr<damp_all_type> r(damp_all_traits::create(i, f, this));

      if (!this->damp_all_) {
        this->damp_all_.set(::std::move(r));
        continue;
      }
    }

    // eyeglasses
    //
    if (n.name() == "eyeglasses" && n.namespace_().empty()) {
      ::std::unique_ptr<eyeglasses_type> r(
        eyeglasses_traits::create(i, f, this));

      if (!this->eyeglasses_) {
        this->eyeglasses_.set(::std::move(r));
        continue;
      }
    }

    // string-mute
    //
    if (n.name() == "string-mute" && n.namespace_().empty()) {
      ::std::unique_ptr<string_mute_type> r(
        string_mute_traits::create(i, f, this));

      if (!this->string_mute_) {
        this->string_mute_.set(::std::move(r));
        continue;
      }
    }

    // scordatura
    //
    if (n.name() == "scordatura" && n.namespace_().empty()) {
      ::std::unique_ptr<scordatura_type> r(
        scordatura_traits::create(i, f, this));

      if (!this->scordatura_) {
        this->scordatura_.set(::std::move(r));
        continue;
      }
    }

    // image
    //
    if (n.name() == "image" && n.namespace_().empty()) {
      ::std::unique_ptr<image_type> r(image_traits::create(i, f, this));

      if (!this->image_) {
        this->image_.set(::std::move(r));
        continue;
      }
    }

    // principal-voice
    //
    if (n.name() == "principal-voice" && n.namespace_().empty()) {
      ::std::unique_ptr<principal_voice_type> r(
        principal_voice_traits::create(i, f, this));

      if (!this->principal_voice_) {
        this->principal_voice_.set(::std::move(r));
        continue;
      }
    }

    // accordion-registration
    //
    if (n.name() == "accordion-registration" && n.namespace_().empty()) {
      ::std::unique_ptr<accordion_registration_type> r(
        accordion_registration_traits::create(i, f, this));

      if (!this->accordion_registration_) {
        this->accordion_registration_.set(::std::move(r));
        continue;
      }
    }

    // percussion
    //
    if (n.name() == "percussion" && n.namespace_().empty()) {
      ::std::unique_ptr<percussion_type> r(
        percussion_traits::create(i, f, this));

      this->percussion_.push_back(::std::move(r));
      continue;
    }

    // other-direction
    //
    if (n.name() == "other-direction" && n.namespace_().empty()) {
      ::std::unique_ptr<other_direction_type> r(
        other_direction_traits::create(i, f, this));

      if (!this->other_direction_) {
        this->other_direction_.set(::std::move(r));
        continue;
      }
    }

    break;
  }
}

direction_type *direction_type::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class direction_type(*this, f, c);
}

direction_type &direction_type::operator=(const direction_type &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->rehearsal_ = x.rehearsal_;
    this->segno_ = x.segno_;
    this->words_ = x.words_;
    this->coda_ = x.coda_;
    this->wedge_ = x.wedge_;
    this->dynamics_ = x.dynamics_;
    this->dashes_ = x.dashes_;
    this->bracket_ = x.bracket_;
    this->pedal_ = x.pedal_;
    this->metronome_ = x.metronome_;
    this->octave_shift_ = x.octave_shift_;
    this->harp_pedals_ = x.harp_pedals_;
    this->damp_ = x.damp_;
    this->damp_all_ = x.damp_all_;
    this->eyeglasses_ = x.eyeglasses_;
    this->string_mute_ = x.string_mute_;
    this->scordatura_ = x.scordatura_;
    this->image_ = x.image_;
    this->principal_voice_ = x.principal_voice_;
    this->accordion_registration_ = x.accordion_registration_;
    this->percussion_ = x.percussion_;
    this->other_direction_ = x.other_direction_;
  }

  return *this;
}

direction_type::~direction_type() {}

// feature
//

feature::feature() : ::xml_schema::string(), type_(this) {}

feature::feature(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), type_(this) {}

feature::feature(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), type_(this) {}

feature::feature(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base), type_(this) {}

feature::feature(const feature &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::string(x, f, c), type_(x.type_, f, this) {}

feature::feature(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c), type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void feature::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }
}

feature *feature::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class feature(*this, f, c);
}

feature &feature::operator=(const feature &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

feature::~feature() {}

// first_fret
//

first_fret::first_fret(
  const ::xml_schema::positive_integer &_xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_positive_integer_base)
, text_(this)
, location_(this) {}

first_fret::first_fret(const first_fret &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(x, f, c)
, text_(x.text_, f, this)
, location_(x.location_, f, this) {}

first_fret::first_fret(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::positive_integer, char,
                                     ::xml_schema::simple_type>(
    e, f | ::xml_schema::flags::base, c)
, text_(this)
, location_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void first_fret::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "text" && n.namespace_().empty()) {
      this->text_.set(text_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "location" && n.namespace_().empty()) {
      this->location_.set(location_traits::create(i, f, this));
      continue;
    }
  }
}

first_fret *first_fret::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class first_fret(*this, f, c);
}

first_fret &first_fret::operator=(const first_fret &x) {
  if (this != &x) {
    static_cast<::xsd::cxx::tree::fundamental_base<
      ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(
      *this) = x;
    this->text_ = x.text_;
    this->location_ = x.location_;
  }

  return *this;
}

first_fret::~first_fret() {}

// frame
//

frame::frame(const frame_strings_type &frame_strings,
             const frame_frets_type &frame_frets)
: ::xml_schema::type()
, frame_strings_(frame_strings, this)
, frame_frets_(frame_frets, this)
, first_fret_(this)
, frame_note_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this)
, halign_(this)
, valign_(this)
, height_(this)
, width_(this)
, unplayed_(this) {}

frame::frame(const frame &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, frame_strings_(x.frame_strings_, f, this)
, frame_frets_(x.frame_frets_, f, this)
, first_fret_(x.first_fret_, f, this)
, frame_note_(x.frame_note_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this)
, height_(x.height_, f, this)
, width_(x.width_, f, this)
, unplayed_(x.unplayed_, f, this) {}

frame::frame(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, frame_strings_(this)
, frame_frets_(this)
, first_fret_(this)
, frame_note_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this)
, halign_(this)
, valign_(this)
, height_(this)
, width_(this)
, unplayed_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void frame::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // frame-strings
    //
    if (n.name() == "frame-strings" && n.namespace_().empty()) {
      if (!frame_strings_.present()) {
        this->frame_strings_.set(frame_strings_traits::create(i, f, this));
        continue;
      }
    }

    // frame-frets
    //
    if (n.name() == "frame-frets" && n.namespace_().empty()) {
      if (!frame_frets_.present()) {
        this->frame_frets_.set(frame_frets_traits::create(i, f, this));
        continue;
      }
    }

    // first-fret
    //
    if (n.name() == "first-fret" && n.namespace_().empty()) {
      ::std::unique_ptr<first_fret_type> r(
        first_fret_traits::create(i, f, this));

      if (!this->first_fret_) {
        this->first_fret_.set(::std::move(r));
        continue;
      }
    }

    // frame-note
    //
    if (n.name() == "frame-note" && n.namespace_().empty()) {
      ::std::unique_ptr<frame_note_type> r(
        frame_note_traits::create(i, f, this));

      this->frame_note_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  if (!frame_strings_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("frame-strings", "");
  }

  if (!frame_frets_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("frame-frets", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "height" && n.namespace_().empty()) {
      this->height_.set(height_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "width" && n.namespace_().empty()) {
      this->width_.set(width_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "unplayed" && n.namespace_().empty()) {
      this->unplayed_.set(unplayed_traits::create(i, f, this));
      continue;
    }
  }
}

frame *frame::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class frame(*this, f, c);
}

frame &frame::operator=(const frame &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->frame_strings_ = x.frame_strings_;
    this->frame_frets_ = x.frame_frets_;
    this->first_fret_ = x.first_fret_;
    this->frame_note_ = x.frame_note_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
    this->height_ = x.height_;
    this->width_ = x.width_;
    this->unplayed_ = x.unplayed_;
  }

  return *this;
}

frame::~frame() {}

// frame_note
//

frame_note::frame_note(const string_type &string, const fret_type &fret)
: ::xml_schema::type()
, string_(string, this)
, fret_(fret, this)
, fingering_(this)
, barre_(this) {}

frame_note::frame_note(::std::unique_ptr<string_type> string,
                       ::std::unique_ptr<fret_type> fret)
: ::xml_schema::type()
, string_(std::move(string), this)
, fret_(std::move(fret), this)
, fingering_(this)
, barre_(this) {}

frame_note::frame_note(const frame_note &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, string_(x.string_, f, this)
, fret_(x.fret_, f, this)
, fingering_(x.fingering_, f, this)
, barre_(x.barre_, f, this) {}

frame_note::frame_note(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, string_(this)
, fret_(this)
, fingering_(this)
, barre_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void frame_note::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // string
    //
    if (n.name() == "string" && n.namespace_().empty()) {
      ::std::unique_ptr<string_type> r(string_traits::create(i, f, this));

      if (!string_.present()) {
        this->string_.set(::std::move(r));
        continue;
      }
    }

    // fret
    //
    if (n.name() == "fret" && n.namespace_().empty()) {
      ::std::unique_ptr<fret_type> r(fret_traits::create(i, f, this));

      if (!fret_.present()) {
        this->fret_.set(::std::move(r));
        continue;
      }
    }

    // fingering
    //
    if (n.name() == "fingering" && n.namespace_().empty()) {
      ::std::unique_ptr<fingering_type> r(fingering_traits::create(i, f, this));

      if (!this->fingering_) {
        this->fingering_.set(::std::move(r));
        continue;
      }
    }

    // barre
    //
    if (n.name() == "barre" && n.namespace_().empty()) {
      ::std::unique_ptr<barre_type> r(barre_traits::create(i, f, this));

      if (!this->barre_) {
        this->barre_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!string_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("string", "");
  }

  if (!fret_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("fret", "");
  }
}

frame_note *frame_note::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class frame_note(*this, f, c);
}

frame_note &frame_note::operator=(const frame_note &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->string_ = x.string_;
    this->fret_ = x.fret_;
    this->fingering_ = x.fingering_;
    this->barre_ = x.barre_;
  }

  return *this;
}

frame_note::~frame_note() {}

// grouping
//

const grouping::number_type grouping::number_default_value_("1");

grouping::grouping(const type_type &type)
: ::xml_schema::type()
, feature_(this)
, type_(type, this)
, number_(number_default_value(), this)
, member_of_(this) {}

grouping::grouping(const grouping &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, feature_(x.feature_, f, this)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, member_of_(x.member_of_, f, this) {}

grouping::grouping(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, feature_(this)
, type_(this)
, number_(this)
, member_of_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void grouping::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // feature
    //
    if (n.name() == "feature" && n.namespace_().empty()) {
      ::std::unique_ptr<feature_type> r(feature_traits::create(i, f, this));

      this->feature_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "member-of" && n.namespace_().empty()) {
      this->member_of_.set(member_of_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

grouping *grouping::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class grouping(*this, f, c);
}

grouping &grouping::operator=(const grouping &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->feature_ = x.feature_;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->member_of_ = x.member_of_;
  }

  return *this;
}

grouping::~grouping() {}

// harmony
//

harmony::harmony()
: ::xml_schema::type()
, root_(this)
, function_(this)
, kind_(this)
, inversion_(this)
, bass_(this)
, degree_(this)
, frame_(this)
, offset_(this)
, footnote_(this)
, level_(this)
, staff_(this)
, type_(this)
, print_object_(this)
, print_frame_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

harmony::harmony(const harmony &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, root_(x.root_, f, this)
, function_(x.function_, f, this)
, kind_(x.kind_, f, this)
, inversion_(x.inversion_, f, this)
, bass_(x.bass_, f, this)
, degree_(x.degree_, f, this)
, frame_(x.frame_, f, this)
, offset_(x.offset_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, staff_(x.staff_, f, this)
, type_(x.type_, f, this)
, print_object_(x.print_object_, f, this)
, print_frame_(x.print_frame_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

harmony::harmony(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, root_(this)
, function_(this)
, kind_(this)
, inversion_(this)
, bass_(this)
, degree_(this)
, frame_(this)
, offset_(this)
, footnote_(this)
, level_(this)
, staff_(this)
, type_(this)
, print_object_(this)
, print_frame_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void harmony::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // root
    //
    if (n.name() == "root" && n.namespace_().empty()) {
      ::std::unique_ptr<root_type> r(root_traits::create(i, f, this));

      this->root_.push_back(::std::move(r));
      continue;
    }

    // function
    //
    if (n.name() == "function" && n.namespace_().empty()) {
      ::std::unique_ptr<function_type> r(function_traits::create(i, f, this));

      this->function_.push_back(::std::move(r));
      continue;
    }

    // kind
    //
    if (n.name() == "kind" && n.namespace_().empty()) {
      ::std::unique_ptr<kind_type> r(kind_traits::create(i, f, this));

      this->kind_.push_back(::std::move(r));
      continue;
    }

    // inversion
    //
    if (n.name() == "inversion" && n.namespace_().empty()) {
      ::std::unique_ptr<inversion_type> r(inversion_traits::create(i, f, this));

      this->inversion_.push_back(::std::move(r));
      continue;
    }

    // bass
    //
    if (n.name() == "bass" && n.namespace_().empty()) {
      ::std::unique_ptr<bass_type> r(bass_traits::create(i, f, this));

      this->bass_.push_back(::std::move(r));
      continue;
    }

    // degree
    //
    if (n.name() == "degree" && n.namespace_().empty()) {
      ::std::unique_ptr<degree_type> r(degree_traits::create(i, f, this));

      this->degree_.push_back(::std::move(r));
      continue;
    }

    // frame
    //
    if (n.name() == "frame" && n.namespace_().empty()) {
      ::std::unique_ptr<frame_type> r(frame_traits::create(i, f, this));

      if (!this->frame_) {
        this->frame_.set(::std::move(r));
        continue;
      }
    }

    // offset
    //
    if (n.name() == "offset" && n.namespace_().empty()) {
      ::std::unique_ptr<offset_type> r(offset_traits::create(i, f, this));

      if (!this->offset_) {
        this->offset_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    // staff
    //
    if (n.name() == "staff" && n.namespace_().empty()) {
      if (!this->staff_) {
        this->staff_.set(staff_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-frame" && n.namespace_().empty()) {
      this->print_frame_.set(print_frame_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

harmony *harmony::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class harmony(*this, f, c);
}

harmony &harmony::operator=(const harmony &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->root_ = x.root_;
    this->function_ = x.function_;
    this->kind_ = x.kind_;
    this->inversion_ = x.inversion_;
    this->bass_ = x.bass_;
    this->degree_ = x.degree_;
    this->frame_ = x.frame_;
    this->offset_ = x.offset_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->staff_ = x.staff_;
    this->type_ = x.type_;
    this->print_object_ = x.print_object_;
    this->print_frame_ = x.print_frame_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

harmony::~harmony() {}

// harp_pedals
//

harp_pedals::harp_pedals()
: ::xml_schema::type()
, pedal_tuning_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

harp_pedals::harp_pedals(const harp_pedals &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, pedal_tuning_(x.pedal_tuning_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

harp_pedals::harp_pedals(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, pedal_tuning_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void harp_pedals::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // pedal-tuning
    //
    if (n.name() == "pedal-tuning" && n.namespace_().empty()) {
      ::std::unique_ptr<pedal_tuning_type> r(
        pedal_tuning_traits::create(i, f, this));

      this->pedal_tuning_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }
}

harp_pedals *harp_pedals::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class harp_pedals(*this, f, c);
}

harp_pedals &harp_pedals::operator=(const harp_pedals &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->pedal_tuning_ = x.pedal_tuning_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

harp_pedals::~harp_pedals() {}

// image
//

image::image(const source_type &source, const type_type &type)
: ::xml_schema::type()
, source_(source, this)
, type_(type, this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, halign_(this)
, valign_(this) {}

image::image(const image &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, source_(x.source_, f, this)
, type_(x.type_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

image::image(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, source_(this)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void image::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "source" && n.namespace_().empty()) {
      this->source_.set(source_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }

  if (!source_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("source", "");
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

image *image::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class image(*this, f, c);
}

image &image::operator=(const image &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->source_ = x.source_;
    this->type_ = x.type_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

image::~image() {}

// inversion
//

inversion::inversion(
  const ::xml_schema::non_negative_integer &_xsd_non_negative_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_non_negative_integer_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

inversion::inversion(const inversion &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

inversion::inversion(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(
    e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void inversion::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

inversion *inversion::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class inversion(*this, f, c);
}

inversion &inversion::operator=(const inversion &x) {
  if (this != &x) {
    static_cast<::xsd::cxx::tree::fundamental_base<
      ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(
      *this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

inversion::~inversion() {}

// kind
//

kind::kind(::musicxml::kind_value::value _xsd_kind_value_base)
: ::musicxml::kind_value(_xsd_kind_value_base)
, use_symbols_(this)
, text_(this)
, stack_degrees_(this)
, parentheses_degrees_(this)
, bracket_degrees_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

kind::kind(const char *_xsd_string_base)
: ::musicxml::kind_value(_xsd_string_base)
, use_symbols_(this)
, text_(this)
, stack_degrees_(this)
, parentheses_degrees_(this)
, bracket_degrees_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

kind::kind(const ::std::string &_xsd_string_base)
: ::musicxml::kind_value(_xsd_string_base)
, use_symbols_(this)
, text_(this)
, stack_degrees_(this)
, parentheses_degrees_(this)
, bracket_degrees_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

kind::kind(const ::musicxml::kind_value &_xsd_kind_value_base)
: ::musicxml::kind_value(_xsd_kind_value_base)
, use_symbols_(this)
, text_(this)
, stack_degrees_(this)
, parentheses_degrees_(this)
, bracket_degrees_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

kind::kind(const kind &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::musicxml::kind_value(x, f, c)
, use_symbols_(x.use_symbols_, f, this)
, text_(x.text_, f, this)
, stack_degrees_(x.stack_degrees_, f, this)
, parentheses_degrees_(x.parentheses_degrees_, f, this)
, bracket_degrees_(x.bracket_degrees_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

kind::kind(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::musicxml::kind_value(e, f | ::xml_schema::flags::base, c)
, use_symbols_(this)
, text_(this)
, stack_degrees_(this)
, parentheses_degrees_(this)
, bracket_degrees_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void kind::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "use-symbols" && n.namespace_().empty()) {
      this->use_symbols_.set(use_symbols_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "text" && n.namespace_().empty()) {
      this->text_.set(text_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "stack-degrees" && n.namespace_().empty()) {
      this->stack_degrees_.set(stack_degrees_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "parentheses-degrees" && n.namespace_().empty()) {
      this->parentheses_degrees_.set(
        parentheses_degrees_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bracket-degrees" && n.namespace_().empty()) {
      this->bracket_degrees_.set(bracket_degrees_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }
}

kind *kind::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class kind(*this, f, c);
}

kind &kind::operator=(const kind &x) {
  if (this != &x) {
    static_cast<::musicxml::kind_value &>(*this) = x;
    this->use_symbols_ = x.use_symbols_;
    this->text_ = x.text_;
    this->stack_degrees_ = x.stack_degrees_;
    this->parentheses_degrees_ = x.parentheses_degrees_;
    this->bracket_degrees_ = x.bracket_degrees_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

kind::~kind() {}

// measure_numbering
//

measure_numbering::measure_numbering(
  ::musicxml::measure_numbering_value::value _xsd_measure_numbering_value_base)
: ::musicxml::measure_numbering_value(_xsd_measure_numbering_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

measure_numbering::measure_numbering(const char *_xsd_string_base)
: ::musicxml::measure_numbering_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

measure_numbering::measure_numbering(const ::std::string &_xsd_string_base)
: ::musicxml::measure_numbering_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

measure_numbering::measure_numbering(
  const ::musicxml::measure_numbering_value &_xsd_measure_numbering_value_base)
: ::musicxml::measure_numbering_value(_xsd_measure_numbering_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

measure_numbering::measure_numbering(const measure_numbering &x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::musicxml::measure_numbering_value(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

measure_numbering::measure_numbering(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::musicxml::measure_numbering_value(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void measure_numbering::parse(::xsd::cxx::xml::dom::parser<char> &p,
                              ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }
}

measure_numbering *measure_numbering::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class measure_numbering(*this, f, c);
}

measure_numbering &measure_numbering::operator=(const measure_numbering &x) {
  if (this != &x) {
    static_cast<::musicxml::measure_numbering_value &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

measure_numbering::~measure_numbering() {}

// metronome
//

metronome::metronome()
: ::xml_schema::type()
, beat_unit_(this)
, beat_unit_dot_(this)
, per_minute_(this)
, metronome_note_(this)
, metronome_relation_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, justify_(this)
, parentheses_(this) {}

metronome::metronome(const metronome &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, beat_unit_(x.beat_unit_, f, this)
, beat_unit_dot_(x.beat_unit_dot_, f, this)
, per_minute_(x.per_minute_, f, this)
, metronome_note_(x.metronome_note_, f, this)
, metronome_relation_(x.metronome_relation_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this)
, justify_(x.justify_, f, this)
, parentheses_(x.parentheses_, f, this) {}

metronome::metronome(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, beat_unit_(this)
, beat_unit_dot_(this)
, per_minute_(this)
, metronome_note_(this)
, metronome_relation_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, justify_(this)
, parentheses_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void metronome::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // beat-unit
    //
    if (n.name() == "beat-unit" && n.namespace_().empty()) {
      ::std::unique_ptr<beat_unit_type> r(beat_unit_traits::create(i, f, this));

      this->beat_unit_.push_back(::std::move(r));
      continue;
    }

    // beat-unit-dot
    //
    if (n.name() == "beat-unit-dot" && n.namespace_().empty()) {
      ::std::unique_ptr<beat_unit_dot_type> r(
        beat_unit_dot_traits::create(i, f, this));

      this->beat_unit_dot_.push_back(::std::move(r));
      continue;
    }

    // per-minute
    //
    if (n.name() == "per-minute" && n.namespace_().empty()) {
      ::std::unique_ptr<per_minute_type> r(
        per_minute_traits::create(i, f, this));

      if (!this->per_minute_) {
        this->per_minute_.set(::std::move(r));
        continue;
      }
    }

    // metronome-note
    //
    if (n.name() == "metronome-note" && n.namespace_().empty()) {
      ::std::unique_ptr<metronome_note_type> r(
        metronome_note_traits::create(i, f, this));

      this->metronome_note_.push_back(::std::move(r));
      continue;
    }

    // metronome-relation
    //
    if (n.name() == "metronome-relation" && n.namespace_().empty()) {
      ::std::unique_ptr<metronome_relation_type> r(
        metronome_relation_traits::create(i, f, this));

      if (!this->metronome_relation_) {
        this->metronome_relation_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "justify" && n.namespace_().empty()) {
      this->justify_.set(justify_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "parentheses" && n.namespace_().empty()) {
      this->parentheses_.set(parentheses_traits::create(i, f, this));
      continue;
    }
  }
}

metronome *metronome::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class metronome(*this, f, c);
}

metronome &metronome::operator=(const metronome &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->beat_unit_ = x.beat_unit_;
    this->beat_unit_dot_ = x.beat_unit_dot_;
    this->per_minute_ = x.per_minute_;
    this->metronome_note_ = x.metronome_note_;
    this->metronome_relation_ = x.metronome_relation_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
    this->justify_ = x.justify_;
    this->parentheses_ = x.parentheses_;
  }

  return *this;
}

metronome::~metronome() {}

// metronome_beam
//

metronome_beam::metronome_beam(
  ::musicxml::beam_value::value _xsd_beam_value_base)
: ::musicxml::beam_value(_xsd_beam_value_base)
, number_(number_default_value(), this) {}

metronome_beam::metronome_beam(const char *_xsd_string_base)
: ::musicxml::beam_value(_xsd_string_base)
, number_(number_default_value(), this) {}

metronome_beam::metronome_beam(const ::std::string &_xsd_string_base)
: ::musicxml::beam_value(_xsd_string_base)
, number_(number_default_value(), this) {}

metronome_beam::metronome_beam(
  const ::musicxml::beam_value &_xsd_beam_value_base)
: ::musicxml::beam_value(_xsd_beam_value_base)
, number_(number_default_value(), this) {}

metronome_beam::metronome_beam(const metronome_beam &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::musicxml::beam_value(x, f, c), number_(x.number_, f, this) {}

metronome_beam::metronome_beam(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::musicxml::beam_value(e, f | ::xml_schema::flags::base, c), number_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void metronome_beam::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

metronome_beam *metronome_beam::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class metronome_beam(*this, f, c);
}

metronome_beam &metronome_beam::operator=(const metronome_beam &x) {
  if (this != &x) {
    static_cast<::musicxml::beam_value &>(*this) = x;
    this->number_ = x.number_;
  }

  return *this;
}

metronome_beam::~metronome_beam() {}

// metronome_note
//

metronome_note::metronome_note(const metronome_type_type &metronome_type)
: ::xml_schema::type()
, metronome_type_(metronome_type, this)
, metronome_dot_(this)
, metronome_beam_(this)
, metronome_tuplet_(this) {}

metronome_note::metronome_note(const metronome_note &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, metronome_type_(x.metronome_type_, f, this)
, metronome_dot_(x.metronome_dot_, f, this)
, metronome_beam_(x.metronome_beam_, f, this)
, metronome_tuplet_(x.metronome_tuplet_, f, this) {}

metronome_note::metronome_note(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, metronome_type_(this)
, metronome_dot_(this)
, metronome_beam_(this)
, metronome_tuplet_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void metronome_note::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // metronome-type
    //
    if (n.name() == "metronome-type" && n.namespace_().empty()) {
      ::std::unique_ptr<metronome_type_type> r(
        metronome_type_traits::create(i, f, this));

      if (!metronome_type_.present()) {
        this->metronome_type_.set(::std::move(r));
        continue;
      }
    }

    // metronome-dot
    //
    if (n.name() == "metronome-dot" && n.namespace_().empty()) {
      ::std::unique_ptr<metronome_dot_type> r(
        metronome_dot_traits::create(i, f, this));

      this->metronome_dot_.push_back(::std::move(r));
      continue;
    }

    // metronome-beam
    //
    if (n.name() == "metronome-beam" && n.namespace_().empty()) {
      ::std::unique_ptr<metronome_beam_type> r(
        metronome_beam_traits::create(i, f, this));

      this->metronome_beam_.push_back(::std::move(r));
      continue;
    }

    // metronome-tuplet
    //
    if (n.name() == "metronome-tuplet" && n.namespace_().empty()) {
      ::std::unique_ptr<metronome_tuplet_type> r(
        metronome_tuplet_traits::create(i, f, this));

      if (!this->metronome_tuplet_) {
        this->metronome_tuplet_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!metronome_type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("metronome-type", "");
  }
}

metronome_note *metronome_note::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class metronome_note(*this, f, c);
}

metronome_note &metronome_note::operator=(const metronome_note &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->metronome_type_ = x.metronome_type_;
    this->metronome_dot_ = x.metronome_dot_;
    this->metronome_beam_ = x.metronome_beam_;
    this->metronome_tuplet_ = x.metronome_tuplet_;
  }

  return *this;
}

metronome_note::~metronome_note() {}

// time_modification
//

time_modification::time_modification(const actual_notes_type &actual_notes,
                                     const normal_notes_type &normal_notes)
: ::xml_schema::type()
, actual_notes_(actual_notes, this)
, normal_notes_(normal_notes, this)
, normal_type_(this)
, normal_dot_(this) {}

time_modification::time_modification(const time_modification &x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, actual_notes_(x.actual_notes_, f, this)
, normal_notes_(x.normal_notes_, f, this)
, normal_type_(x.normal_type_, f, this)
, normal_dot_(x.normal_dot_, f, this) {}

time_modification::time_modification(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, actual_notes_(this)
, normal_notes_(this)
, normal_type_(this)
, normal_dot_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void time_modification::parse(::xsd::cxx::xml::dom::parser<char> &p,
                              ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // actual-notes
    //
    if (n.name() == "actual-notes" && n.namespace_().empty()) {
      if (!actual_notes_.present()) {
        this->actual_notes_.set(actual_notes_traits::create(i, f, this));
        continue;
      }
    }

    // normal-notes
    //
    if (n.name() == "normal-notes" && n.namespace_().empty()) {
      if (!normal_notes_.present()) {
        this->normal_notes_.set(normal_notes_traits::create(i, f, this));
        continue;
      }
    }

    // normal-type
    //
    if (n.name() == "normal-type" && n.namespace_().empty()) {
      ::std::unique_ptr<normal_type_type> r(
        normal_type_traits::create(i, f, this));

      if (!this->normal_type_) {
        this->normal_type_.set(::std::move(r));
        continue;
      }
    }

    // normal-dot
    //
    if (n.name() == "normal-dot" && n.namespace_().empty()) {
      ::std::unique_ptr<normal_dot_type> r(
        normal_dot_traits::create(i, f, this));

      this->normal_dot_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  if (!actual_notes_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("actual-notes", "");
  }

  if (!normal_notes_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("normal-notes", "");
  }
}

time_modification *time_modification::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class time_modification(*this, f, c);
}

time_modification &time_modification::operator=(const time_modification &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->actual_notes_ = x.actual_notes_;
    this->normal_notes_ = x.normal_notes_;
    this->normal_type_ = x.normal_type_;
    this->normal_dot_ = x.normal_dot_;
  }

  return *this;
}

time_modification::~time_modification() {}

// metronome_tuplet
//

metronome_tuplet::metronome_tuplet(const actual_notes_type &actual_notes,
                                   const normal_notes_type &normal_notes,
                                   const type_type &type)
: ::musicxml::time_modification(actual_notes, normal_notes)
, type_(type, this)
, bracket_(this)
, show_number_(this) {}

metronome_tuplet::metronome_tuplet(const metronome_tuplet &x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::musicxml::time_modification(x, f, c)
, type_(x.type_, f, this)
, bracket_(x.bracket_, f, this)
, show_number_(x.show_number_, f, this) {}

metronome_tuplet::metronome_tuplet(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::musicxml::time_modification(e, f | ::xml_schema::flags::base, c)
, type_(this)
, bracket_(this)
, show_number_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void metronome_tuplet::parse(::xsd::cxx::xml::dom::parser<char> &p,
                             ::xml_schema::flags f) {
  this->::musicxml::time_modification::parse(p, f);

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bracket" && n.namespace_().empty()) {
      this->bracket_.set(bracket_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "show-number" && n.namespace_().empty()) {
      this->show_number_.set(show_number_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

metronome_tuplet *metronome_tuplet::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class metronome_tuplet(*this, f, c);
}

metronome_tuplet &metronome_tuplet::operator=(const metronome_tuplet &x) {
  if (this != &x) {
    static_cast<::musicxml::time_modification &>(*this) = x;
    this->type_ = x.type_;
    this->bracket_ = x.bracket_;
    this->show_number_ = x.show_number_;
  }

  return *this;
}

metronome_tuplet::~metronome_tuplet() {}

// octave_shift
//

octave_shift::octave_shift(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, number_(this)
, size_(size_default_value(), this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

octave_shift::octave_shift(const octave_shift &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, size_(x.size_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

octave_shift::octave_shift(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, size_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void octave_shift::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "size" && n.namespace_().empty()) {
      this->size_.set(size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!size_.present()) { this->size_.set(size_default_value()); }
}

octave_shift *octave_shift::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class octave_shift(*this, f, c);
}

octave_shift &octave_shift::operator=(const octave_shift &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->size_ = x.size_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

octave_shift::~octave_shift() {}

// offset
//

offset::offset(const ::xml_schema::decimal &_xsd_decimal_base)
: ::musicxml::divisions(_xsd_decimal_base), sound_(this) {}

offset::offset(const offset &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::musicxml::divisions(x, f, c), sound_(x.sound_, f, this) {}

offset::offset(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::musicxml::divisions(e, f | ::xml_schema::flags::base, c), sound_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void offset::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "sound" && n.namespace_().empty()) {
      this->sound_.set(sound_traits::create(i, f, this));
      continue;
    }
  }
}

offset *offset::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class offset(*this, f, c);
}

offset &offset::operator=(const offset &x) {
  if (this != &x) {
    static_cast<::musicxml::divisions &>(*this) = x;
    this->sound_ = x.sound_;
  }

  return *this;
}

offset::~offset() {}

// other_direction
//

other_direction::other_direction()
: ::xml_schema::string()
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

other_direction::other_direction(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

other_direction::other_direction(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

other_direction::other_direction(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

other_direction::other_direction(const other_direction &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, print_object_(x.print_object_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

other_direction::other_direction(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void other_direction::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }
}

other_direction *other_direction::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class other_direction(*this, f, c);
}

other_direction &other_direction::operator=(const other_direction &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->print_object_ = x.print_object_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

other_direction::~other_direction() {}

// pedal
//

pedal::pedal(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, line_(this)
, sign_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

pedal::pedal(const pedal &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, line_(x.line_, f, this)
, sign_(x.sign_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

pedal::pedal(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, line_(this)
, sign_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void pedal::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line" && n.namespace_().empty()) {
      this->line_.set(line_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "sign" && n.namespace_().empty()) {
      this->sign_.set(sign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

pedal *pedal::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class pedal(*this, f, c);
}

pedal &pedal::operator=(const pedal &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->line_ = x.line_;
    this->sign_ = x.sign_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

pedal::~pedal() {}

// pedal_tuning
//

pedal_tuning::pedal_tuning(const pedal_step_type &pedal_step,
                           const pedal_alter_type &pedal_alter)
: ::xml_schema::type()
, pedal_step_(pedal_step, this)
, pedal_alter_(pedal_alter, this) {}

pedal_tuning::pedal_tuning(const pedal_tuning &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, pedal_step_(x.pedal_step_, f, this)
, pedal_alter_(x.pedal_alter_, f, this) {}

pedal_tuning::pedal_tuning(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, pedal_step_(this)
, pedal_alter_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void pedal_tuning::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // pedal-step
    //
    if (n.name() == "pedal-step" && n.namespace_().empty()) {
      ::std::unique_ptr<pedal_step_type> r(
        pedal_step_traits::create(i, f, this));

      if (!pedal_step_.present()) {
        this->pedal_step_.set(::std::move(r));
        continue;
      }
    }

    // pedal-alter
    //
    if (n.name() == "pedal-alter" && n.namespace_().empty()) {
      ::std::unique_ptr<pedal_alter_type> r(
        pedal_alter_traits::create(i, f, this));

      if (!pedal_alter_.present()) {
        this->pedal_alter_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!pedal_step_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("pedal-step", "");
  }

  if (!pedal_alter_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("pedal-alter", "");
  }
}

pedal_tuning *pedal_tuning::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class pedal_tuning(*this, f, c);
}

pedal_tuning &pedal_tuning::operator=(const pedal_tuning &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->pedal_step_ = x.pedal_step_;
    this->pedal_alter_ = x.pedal_alter_;
  }

  return *this;
}

pedal_tuning::~pedal_tuning() {}

// per_minute
//

per_minute::per_minute()
: ::xml_schema::string()
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {}

per_minute::per_minute(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {}

per_minute::per_minute(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {}

per_minute::per_minute(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {}

per_minute::per_minute(const per_minute &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this) {}

per_minute::per_minute(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void per_minute::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }
  }
}

per_minute *per_minute::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class per_minute(*this, f, c);
}

per_minute &per_minute::operator=(const per_minute &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
  }

  return *this;
}

per_minute::~per_minute() {}

// percussion
//

percussion::percussion()
: ::xml_schema::type()
, glass_(this)
, metal_(this)
, wood_(this)
, pitched_(this)
, membrane_(this)
, effect_(this)
, timpani_(this)
, beater_(this)
, stick_(this)
, stick_location_(this)
, other_percussion_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, enclosure_(this) {}

percussion::percussion(const percussion &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, glass_(x.glass_, f, this)
, metal_(x.metal_, f, this)
, wood_(x.wood_, f, this)
, pitched_(x.pitched_, f, this)
, membrane_(x.membrane_, f, this)
, effect_(x.effect_, f, this)
, timpani_(x.timpani_, f, this)
, beater_(x.beater_, f, this)
, stick_(x.stick_, f, this)
, stick_location_(x.stick_location_, f, this)
, other_percussion_(x.other_percussion_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this)
, enclosure_(x.enclosure_, f, this) {}

percussion::percussion(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, glass_(this)
, metal_(this)
, wood_(this)
, pitched_(this)
, membrane_(this)
, effect_(this)
, timpani_(this)
, beater_(this)
, stick_(this)
, stick_location_(this)
, other_percussion_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this)
, enclosure_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void percussion::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // glass
    //
    if (n.name() == "glass" && n.namespace_().empty()) {
      ::std::unique_ptr<glass_type> r(glass_traits::create(i, f, this));

      if (!this->glass_) {
        this->glass_.set(::std::move(r));
        continue;
      }
    }

    // metal
    //
    if (n.name() == "metal" && n.namespace_().empty()) {
      ::std::unique_ptr<metal_type> r(metal_traits::create(i, f, this));

      if (!this->metal_) {
        this->metal_.set(::std::move(r));
        continue;
      }
    }

    // wood
    //
    if (n.name() == "wood" && n.namespace_().empty()) {
      ::std::unique_ptr<wood_type> r(wood_traits::create(i, f, this));

      if (!this->wood_) {
        this->wood_.set(::std::move(r));
        continue;
      }
    }

    // pitched
    //
    if (n.name() == "pitched" && n.namespace_().empty()) {
      ::std::unique_ptr<pitched_type> r(pitched_traits::create(i, f, this));

      if (!this->pitched_) {
        this->pitched_.set(::std::move(r));
        continue;
      }
    }

    // membrane
    //
    if (n.name() == "membrane" && n.namespace_().empty()) {
      ::std::unique_ptr<membrane_type> r(membrane_traits::create(i, f, this));

      if (!this->membrane_) {
        this->membrane_.set(::std::move(r));
        continue;
      }
    }

    // effect
    //
    if (n.name() == "effect" && n.namespace_().empty()) {
      ::std::unique_ptr<effect_type> r(effect_traits::create(i, f, this));

      if (!this->effect_) {
        this->effect_.set(::std::move(r));
        continue;
      }
    }

    // timpani
    //
    if (n.name() == "timpani" && n.namespace_().empty()) {
      ::std::unique_ptr<timpani_type> r(timpani_traits::create(i, f, this));

      if (!this->timpani_) {
        this->timpani_.set(::std::move(r));
        continue;
      }
    }

    // beater
    //
    if (n.name() == "beater" && n.namespace_().empty()) {
      ::std::unique_ptr<beater_type> r(beater_traits::create(i, f, this));

      if (!this->beater_) {
        this->beater_.set(::std::move(r));
        continue;
      }
    }

    // stick
    //
    if (n.name() == "stick" && n.namespace_().empty()) {
      ::std::unique_ptr<stick_type> r(stick_traits::create(i, f, this));

      if (!this->stick_) {
        this->stick_.set(::std::move(r));
        continue;
      }
    }

    // stick-location
    //
    if (n.name() == "stick-location" && n.namespace_().empty()) {
      ::std::unique_ptr<stick_location_type> r(
        stick_location_traits::create(i, f, this));

      if (!this->stick_location_) {
        this->stick_location_.set(::std::move(r));
        continue;
      }
    }

    // other-percussion
    //
    if (n.name() == "other-percussion" && n.namespace_().empty()) {
      ::std::unique_ptr<other_percussion_type> r(
        other_percussion_traits::create(i, f, this));

      if (!this->other_percussion_) {
        this->other_percussion_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "enclosure" && n.namespace_().empty()) {
      this->enclosure_.set(enclosure_traits::create(i, f, this));
      continue;
    }
  }
}

percussion *percussion::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class percussion(*this, f, c);
}

percussion &percussion::operator=(const percussion &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->glass_ = x.glass_;
    this->metal_ = x.metal_;
    this->wood_ = x.wood_;
    this->pitched_ = x.pitched_;
    this->membrane_ = x.membrane_;
    this->effect_ = x.effect_;
    this->timpani_ = x.timpani_;
    this->beater_ = x.beater_;
    this->stick_ = x.stick_;
    this->stick_location_ = x.stick_location_;
    this->other_percussion_ = x.other_percussion_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
    this->enclosure_ = x.enclosure_;
  }

  return *this;
}

percussion::~percussion() {}

// principal_voice
//

principal_voice::principal_voice(const type_type &type,
                                 const symbol_type &symbol)
: ::xml_schema::string()
, type_(type, this)
, symbol_(symbol, this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

principal_voice::principal_voice(const char *_xsd_string_base,
                                 const type_type &type,
                                 const symbol_type &symbol)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, symbol_(symbol, this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

principal_voice::principal_voice(const ::std::string &_xsd_string_base,
                                 const type_type &type,
                                 const symbol_type &symbol)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, symbol_(symbol, this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

principal_voice::principal_voice(const ::xml_schema::string &_xsd_string_base,
                                 const type_type &type,
                                 const symbol_type &symbol)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, symbol_(symbol, this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

principal_voice::principal_voice(const principal_voice &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, type_(x.type_, f, this)
, symbol_(x.symbol_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

principal_voice::principal_voice(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, type_(this)
, symbol_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void principal_voice::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "symbol" && n.namespace_().empty()) {
      this->symbol_.set(symbol_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!symbol_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("symbol", "");
  }
}

principal_voice *principal_voice::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class principal_voice(*this, f, c);
}

principal_voice &principal_voice::operator=(const principal_voice &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
    this->symbol_ = x.symbol_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

principal_voice::~principal_voice() {}

// print
//

print::print()
: ::xml_schema::type()
, page_layout_(this)
, system_layout_(this)
, staff_layout_(this)
, measure_layout_(this)
, measure_numbering_(this)
, part_name_display_(this)
, part_abbreviation_display_(this)
, staff_spacing_(this)
, new_system_(this)
, new_page_(this)
, blank_page_(this)
, page_number_(this) {}

print::print(const print &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, page_layout_(x.page_layout_, f, this)
, system_layout_(x.system_layout_, f, this)
, staff_layout_(x.staff_layout_, f, this)
, measure_layout_(x.measure_layout_, f, this)
, measure_numbering_(x.measure_numbering_, f, this)
, part_name_display_(x.part_name_display_, f, this)
, part_abbreviation_display_(x.part_abbreviation_display_, f, this)
, staff_spacing_(x.staff_spacing_, f, this)
, new_system_(x.new_system_, f, this)
, new_page_(x.new_page_, f, this)
, blank_page_(x.blank_page_, f, this)
, page_number_(x.page_number_, f, this) {}

print::print(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, page_layout_(this)
, system_layout_(this)
, staff_layout_(this)
, measure_layout_(this)
, measure_numbering_(this)
, part_name_display_(this)
, part_abbreviation_display_(this)
, staff_spacing_(this)
, new_system_(this)
, new_page_(this)
, blank_page_(this)
, page_number_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void print::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // page-layout
    //
    if (n.name() == "page-layout" && n.namespace_().empty()) {
      ::std::unique_ptr<page_layout_type> r(
        page_layout_traits::create(i, f, this));

      if (!this->page_layout_) {
        this->page_layout_.set(::std::move(r));
        continue;
      }
    }

    // system-layout
    //
    if (n.name() == "system-layout" && n.namespace_().empty()) {
      ::std::unique_ptr<system_layout_type> r(
        system_layout_traits::create(i, f, this));

      if (!this->system_layout_) {
        this->system_layout_.set(::std::move(r));
        continue;
      }
    }

    // staff-layout
    //
    if (n.name() == "staff-layout" && n.namespace_().empty()) {
      ::std::unique_ptr<staff_layout_type> r(
        staff_layout_traits::create(i, f, this));

      this->staff_layout_.push_back(::std::move(r));
      continue;
    }

    // measure-layout
    //
    if (n.name() == "measure-layout" && n.namespace_().empty()) {
      ::std::unique_ptr<measure_layout_type> r(
        measure_layout_traits::create(i, f, this));

      if (!this->measure_layout_) {
        this->measure_layout_.set(::std::move(r));
        continue;
      }
    }

    // measure-numbering
    //
    if (n.name() == "measure-numbering" && n.namespace_().empty()) {
      ::std::unique_ptr<measure_numbering_type> r(
        measure_numbering_traits::create(i, f, this));

      if (!this->measure_numbering_) {
        this->measure_numbering_.set(::std::move(r));
        continue;
      }
    }

    // part-name-display
    //
    if (n.name() == "part-name-display" && n.namespace_().empty()) {
      ::std::unique_ptr<part_name_display_type> r(
        part_name_display_traits::create(i, f, this));

      if (!this->part_name_display_) {
        this->part_name_display_.set(::std::move(r));
        continue;
      }
    }

    // part-abbreviation-display
    //
    if (n.name() == "part-abbreviation-display" && n.namespace_().empty()) {
      ::std::unique_ptr<part_abbreviation_display_type> r(
        part_abbreviation_display_traits::create(i, f, this));

      if (!this->part_abbreviation_display_) {
        this->part_abbreviation_display_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "staff-spacing" && n.namespace_().empty()) {
      this->staff_spacing_.set(staff_spacing_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "new-system" && n.namespace_().empty()) {
      this->new_system_.set(new_system_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "new-page" && n.namespace_().empty()) {
      this->new_page_.set(new_page_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "blank-page" && n.namespace_().empty()) {
      this->blank_page_.set(blank_page_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "page-number" && n.namespace_().empty()) {
      this->page_number_.set(page_number_traits::create(i, f, this));
      continue;
    }
  }
}

print *print::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class print(*this, f, c);
}

print &print::operator=(const print &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->page_layout_ = x.page_layout_;
    this->system_layout_ = x.system_layout_;
    this->staff_layout_ = x.staff_layout_;
    this->measure_layout_ = x.measure_layout_;
    this->measure_numbering_ = x.measure_numbering_;
    this->part_name_display_ = x.part_name_display_;
    this->part_abbreviation_display_ = x.part_abbreviation_display_;
    this->staff_spacing_ = x.staff_spacing_;
    this->new_system_ = x.new_system_;
    this->new_page_ = x.new_page_;
    this->blank_page_ = x.blank_page_;
    this->page_number_ = x.page_number_;
  }

  return *this;
}

print::~print() {}

// root
//

root::root(const root_step_type &root_step)
: ::xml_schema::type(), root_step_(root_step, this), root_alter_(this) {}

root::root(::std::unique_ptr<root_step_type> root_step)
: ::xml_schema::type()
, root_step_(std::move(root_step), this)
, root_alter_(this) {}

root::root(const root &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, root_step_(x.root_step_, f, this)
, root_alter_(x.root_alter_, f, this) {}

root::root(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, root_step_(this)
, root_alter_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void root::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // root-step
    //
    if (n.name() == "root-step" && n.namespace_().empty()) {
      ::std::unique_ptr<root_step_type> r(root_step_traits::create(i, f, this));

      if (!root_step_.present()) {
        this->root_step_.set(::std::move(r));
        continue;
      }
    }

    // root-alter
    //
    if (n.name() == "root-alter" && n.namespace_().empty()) {
      ::std::unique_ptr<root_alter_type> r(
        root_alter_traits::create(i, f, this));

      if (!this->root_alter_) {
        this->root_alter_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!root_step_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("root-step", "");
  }
}

root *root::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class root(*this, f, c);
}

root &root::operator=(const root &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->root_step_ = x.root_step_;
    this->root_alter_ = x.root_alter_;
  }

  return *this;
}

root::~root() {}

// root_alter
//

root_alter::root_alter(const ::xml_schema::decimal &_xsd_decimal_base)
: ::musicxml::semitones(_xsd_decimal_base)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, location_(this) {}

root_alter::root_alter(const root_alter &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::semitones(x, f, c)
, print_object_(x.print_object_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, location_(x.location_, f, this) {}

root_alter::root_alter(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::semitones(e, f | ::xml_schema::flags::base, c)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, location_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void root_alter::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "location" && n.namespace_().empty()) {
      this->location_.set(location_traits::create(i, f, this));
      continue;
    }
  }
}

root_alter *root_alter::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class root_alter(*this, f, c);
}

root_alter &root_alter::operator=(const root_alter &x) {
  if (this != &x) {
    static_cast<::musicxml::semitones &>(*this) = x;
    this->print_object_ = x.print_object_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->location_ = x.location_;
  }

  return *this;
}

root_alter::~root_alter() {}

// root_step
//

root_step::root_step(::musicxml::step::value _xsd_step_base)
: ::musicxml::step(_xsd_step_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

root_step::root_step(const char *_xsd_string_base)
: ::musicxml::step(_xsd_string_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

root_step::root_step(const ::std::string &_xsd_string_base)
: ::musicxml::step(_xsd_string_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

root_step::root_step(const ::musicxml::step &_xsd_step_base)
: ::musicxml::step(_xsd_step_base)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

root_step::root_step(const root_step &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::musicxml::step(x, f, c)
, text_(x.text_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

root_step::root_step(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::musicxml::step(e, f | ::xml_schema::flags::base, c)
, text_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void root_step::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "text" && n.namespace_().empty()) {
      this->text_.set(text_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

root_step *root_step::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class root_step(*this, f, c);
}

root_step &root_step::operator=(const root_step &x) {
  if (this != &x) {
    static_cast<::musicxml::step &>(*this) = x;
    this->text_ = x.text_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

root_step::~root_step() {}

// scordatura
//

scordatura::scordatura() : ::xml_schema::type(), accord_(this) {}

scordatura::scordatura(const scordatura &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c), accord_(x.accord_, f, this) {}

scordatura::scordatura(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c), accord_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void scordatura::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // accord
    //
    if (n.name() == "accord" && n.namespace_().empty()) {
      ::std::unique_ptr<accord_type> r(accord_traits::create(i, f, this));

      this->accord_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

scordatura *scordatura::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class scordatura(*this, f, c);
}

scordatura &scordatura::operator=(const scordatura &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->accord_ = x.accord_;
  }

  return *this;
}

scordatura::~scordatura() {}

// sound
//

sound::sound()
: ::xml_schema::type()
, midi_device_(this)
, midi_instrument_(this)
, play_(this)
, offset_(this)
, tempo_(this)
, dynamics_(this)
, dacapo_(this)
, segno_(this)
, dalsegno_(this)
, coda_(this)
, tocoda_(this)
, divisions_(this)
, forward_repeat_(this)
, fine_(this)
, time_only_(this)
, pizzicato_(this)
, pan_(this)
, elevation_(this)
, damper_pedal_(this)
, soft_pedal_(this)
, sostenuto_pedal_(this) {}

sound::sound(const sound &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, midi_device_(x.midi_device_, f, this)
, midi_instrument_(x.midi_instrument_, f, this)
, play_(x.play_, f, this)
, offset_(x.offset_, f, this)
, tempo_(x.tempo_, f, this)
, dynamics_(x.dynamics_, f, this)
, dacapo_(x.dacapo_, f, this)
, segno_(x.segno_, f, this)
, dalsegno_(x.dalsegno_, f, this)
, coda_(x.coda_, f, this)
, tocoda_(x.tocoda_, f, this)
, divisions_(x.divisions_, f, this)
, forward_repeat_(x.forward_repeat_, f, this)
, fine_(x.fine_, f, this)
, time_only_(x.time_only_, f, this)
, pizzicato_(x.pizzicato_, f, this)
, pan_(x.pan_, f, this)
, elevation_(x.elevation_, f, this)
, damper_pedal_(x.damper_pedal_, f, this)
, soft_pedal_(x.soft_pedal_, f, this)
, sostenuto_pedal_(x.sostenuto_pedal_, f, this) {}

sound::sound(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, midi_device_(this)
, midi_instrument_(this)
, play_(this)
, offset_(this)
, tempo_(this)
, dynamics_(this)
, dacapo_(this)
, segno_(this)
, dalsegno_(this)
, coda_(this)
, tocoda_(this)
, divisions_(this)
, forward_repeat_(this)
, fine_(this)
, time_only_(this)
, pizzicato_(this)
, pan_(this)
, elevation_(this)
, damper_pedal_(this)
, soft_pedal_(this)
, sostenuto_pedal_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void sound::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // midi-device
    //
    if (n.name() == "midi-device" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_device_type> r(
        midi_device_traits::create(i, f, this));

      this->midi_device_.push_back(::std::move(r));
      continue;
    }

    // midi-instrument
    //
    if (n.name() == "midi-instrument" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_instrument_type> r(
        midi_instrument_traits::create(i, f, this));

      this->midi_instrument_.push_back(::std::move(r));
      continue;
    }

    // play
    //
    if (n.name() == "play" && n.namespace_().empty()) {
      ::std::unique_ptr<play_type> r(play_traits::create(i, f, this));

      this->play_.push_back(::std::move(r));
      continue;
    }

    // offset
    //
    if (n.name() == "offset" && n.namespace_().empty()) {
      ::std::unique_ptr<offset_type> r(offset_traits::create(i, f, this));

      if (!this->offset_) {
        this->offset_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "tempo" && n.namespace_().empty()) {
      this->tempo_.set(tempo_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dynamics" && n.namespace_().empty()) {
      this->dynamics_.set(dynamics_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dacapo" && n.namespace_().empty()) {
      this->dacapo_.set(dacapo_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "segno" && n.namespace_().empty()) {
      this->segno_.set(segno_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dalsegno" && n.namespace_().empty()) {
      this->dalsegno_.set(dalsegno_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "coda" && n.namespace_().empty()) {
      this->coda_.set(coda_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "tocoda" && n.namespace_().empty()) {
      this->tocoda_.set(tocoda_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "divisions" && n.namespace_().empty()) {
      this->divisions_.set(divisions_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "forward-repeat" && n.namespace_().empty()) {
      this->forward_repeat_.set(forward_repeat_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "fine" && n.namespace_().empty()) {
      this->fine_.set(fine_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "time-only" && n.namespace_().empty()) {
      this->time_only_.set(time_only_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "pizzicato" && n.namespace_().empty()) {
      this->pizzicato_.set(pizzicato_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "pan" && n.namespace_().empty()) {
      this->pan_.set(pan_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "elevation" && n.namespace_().empty()) {
      this->elevation_.set(elevation_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "damper-pedal" && n.namespace_().empty()) {
      this->damper_pedal_.set(damper_pedal_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "soft-pedal" && n.namespace_().empty()) {
      this->soft_pedal_.set(soft_pedal_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "sostenuto-pedal" && n.namespace_().empty()) {
      this->sostenuto_pedal_.set(sostenuto_pedal_traits::create(i, f, this));
      continue;
    }
  }
}

sound *sound::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class sound(*this, f, c);
}

sound &sound::operator=(const sound &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->midi_device_ = x.midi_device_;
    this->midi_instrument_ = x.midi_instrument_;
    this->play_ = x.play_;
    this->offset_ = x.offset_;
    this->tempo_ = x.tempo_;
    this->dynamics_ = x.dynamics_;
    this->dacapo_ = x.dacapo_;
    this->segno_ = x.segno_;
    this->dalsegno_ = x.dalsegno_;
    this->coda_ = x.coda_;
    this->tocoda_ = x.tocoda_;
    this->divisions_ = x.divisions_;
    this->forward_repeat_ = x.forward_repeat_;
    this->fine_ = x.fine_;
    this->time_only_ = x.time_only_;
    this->pizzicato_ = x.pizzicato_;
    this->pan_ = x.pan_;
    this->elevation_ = x.elevation_;
    this->damper_pedal_ = x.damper_pedal_;
    this->soft_pedal_ = x.soft_pedal_;
    this->sostenuto_pedal_ = x.sostenuto_pedal_;
  }

  return *this;
}

sound::~sound() {}

// stick
//

stick::stick(const stick_type_type &stick_type,
             const stick_material_type &stick_material)
: ::xml_schema::type()
, stick_type_(stick_type, this)
, stick_material_(stick_material, this)
, tip_(this) {}

stick::stick(const stick &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, stick_type_(x.stick_type_, f, this)
, stick_material_(x.stick_material_, f, this)
, tip_(x.tip_, f, this) {}

stick::stick(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, stick_type_(this)
, stick_material_(this)
, tip_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void stick::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // stick-type
    //
    if (n.name() == "stick-type" && n.namespace_().empty()) {
      ::std::unique_ptr<stick_type_type> r(
        stick_type_traits::create(i, f, this));

      if (!stick_type_.present()) {
        this->stick_type_.set(::std::move(r));
        continue;
      }
    }

    // stick-material
    //
    if (n.name() == "stick-material" && n.namespace_().empty()) {
      ::std::unique_ptr<stick_material_type> r(
        stick_material_traits::create(i, f, this));

      if (!stick_material_.present()) {
        this->stick_material_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!stick_type_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("stick-type", "");
  }

  if (!stick_material_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("stick-material", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "tip" && n.namespace_().empty()) {
      this->tip_.set(tip_traits::create(i, f, this));
      continue;
    }
  }
}

stick *stick::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class stick(*this, f, c);
}

stick &stick::operator=(const stick &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->stick_type_ = x.stick_type_;
    this->stick_material_ = x.stick_material_;
    this->tip_ = x.tip_;
  }

  return *this;
}

stick::~stick() {}

// string_mute
//

string_mute::string_mute(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {}

string_mute::string_mute(const string_mute &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, halign_(x.halign_, f, this)
, valign_(x.valign_, f, this) {}

string_mute::string_mute(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, halign_(this)
, valign_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void string_mute::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "halign" && n.namespace_().empty()) {
      this->halign_.set(halign_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "valign" && n.namespace_().empty()) {
      this->valign_.set(valign_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

string_mute *string_mute::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class string_mute(*this, f, c);
}

string_mute &string_mute::operator=(const string_mute &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->halign_ = x.halign_;
    this->valign_ = x.valign_;
  }

  return *this;
}

string_mute::~string_mute() {}

// wedge
//

wedge::wedge(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, number_(this)
, spread_(this)
, niente_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

wedge::wedge(const wedge &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, spread_(x.spread_, f, this)
, niente_(x.niente_, f, this)
, line_type_(x.line_type_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, color_(x.color_, f, this) {}

wedge::wedge(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, spread_(this)
, niente_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void wedge::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "spread" && n.namespace_().empty()) {
      this->spread_.set(spread_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "niente" && n.namespace_().empty()) {
      this->niente_.set(niente_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-type" && n.namespace_().empty()) {
      this->line_type_.set(line_type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

wedge *wedge::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class wedge(*this, f, c);
}

wedge &wedge::operator=(const wedge &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->spread_ = x.spread_;
    this->niente_ = x.niente_;
    this->line_type_ = x.line_type_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->color_ = x.color_;
  }

  return *this;
}

wedge::~wedge() {}

// encoding
//

encoding::encoding()
: ::xml_schema::type()
, encoding_date_(this)
, encoder_(this)
, software_(this)
, encoding_description_(this)
, supports_(this) {}

encoding::encoding(const encoding &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, encoding_date_(x.encoding_date_, f, this)
, encoder_(x.encoder_, f, this)
, software_(x.software_, f, this)
, encoding_description_(x.encoding_description_, f, this)
, supports_(x.supports_, f, this) {}

encoding::encoding(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, encoding_date_(this)
, encoder_(this)
, software_(this)
, encoding_description_(this)
, supports_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void encoding::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // encoding-date
    //
    if (n.name() == "encoding-date" && n.namespace_().empty()) {
      ::std::unique_ptr<encoding_date_type> r(
        encoding_date_traits::create(i, f, this));

      this->encoding_date_.push_back(::std::move(r));
      continue;
    }

    // encoder
    //
    if (n.name() == "encoder" && n.namespace_().empty()) {
      ::std::unique_ptr<encoder_type> r(encoder_traits::create(i, f, this));

      this->encoder_.push_back(::std::move(r));
      continue;
    }

    // software
    //
    if (n.name() == "software" && n.namespace_().empty()) {
      ::std::unique_ptr<software_type> r(software_traits::create(i, f, this));

      this->software_.push_back(::std::move(r));
      continue;
    }

    // encoding-description
    //
    if (n.name() == "encoding-description" && n.namespace_().empty()) {
      ::std::unique_ptr<encoding_description_type> r(
        encoding_description_traits::create(i, f, this));

      this->encoding_description_.push_back(::std::move(r));
      continue;
    }

    // supports
    //
    if (n.name() == "supports" && n.namespace_().empty()) {
      ::std::unique_ptr<supports_type> r(supports_traits::create(i, f, this));

      this->supports_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

encoding *encoding::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class encoding(*this, f, c);
}

encoding &encoding::operator=(const encoding &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->encoding_date_ = x.encoding_date_;
    this->encoder_ = x.encoder_;
    this->software_ = x.software_;
    this->encoding_description_ = x.encoding_description_;
    this->supports_ = x.supports_;
  }

  return *this;
}

encoding::~encoding() {}

// identification
//

identification::identification()
: ::xml_schema::type()
, creator_(this)
, rights_(this)
, encoding_(this)
, source_(this)
, relation_(this)
, miscellaneous_(this) {}

identification::identification(const identification &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, creator_(x.creator_, f, this)
, rights_(x.rights_, f, this)
, encoding_(x.encoding_, f, this)
, source_(x.source_, f, this)
, relation_(x.relation_, f, this)
, miscellaneous_(x.miscellaneous_, f, this) {}

identification::identification(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, creator_(this)
, rights_(this)
, encoding_(this)
, source_(this)
, relation_(this)
, miscellaneous_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void identification::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // creator
    //
    if (n.name() == "creator" && n.namespace_().empty()) {
      ::std::unique_ptr<creator_type> r(creator_traits::create(i, f, this));

      this->creator_.push_back(::std::move(r));
      continue;
    }

    // rights
    //
    if (n.name() == "rights" && n.namespace_().empty()) {
      ::std::unique_ptr<rights_type> r(rights_traits::create(i, f, this));

      this->rights_.push_back(::std::move(r));
      continue;
    }

    // encoding
    //
    if (n.name() == "encoding" && n.namespace_().empty()) {
      ::std::unique_ptr<encoding_type> r(encoding_traits::create(i, f, this));

      if (!this->encoding_) {
        this->encoding_.set(::std::move(r));
        continue;
      }
    }

    // source
    //
    if (n.name() == "source" && n.namespace_().empty()) {
      ::std::unique_ptr<source_type> r(source_traits::create(i, f, this));

      if (!this->source_) {
        this->source_.set(::std::move(r));
        continue;
      }
    }

    // relation
    //
    if (n.name() == "relation" && n.namespace_().empty()) {
      ::std::unique_ptr<relation_type> r(relation_traits::create(i, f, this));

      this->relation_.push_back(::std::move(r));
      continue;
    }

    // miscellaneous
    //
    if (n.name() == "miscellaneous" && n.namespace_().empty()) {
      ::std::unique_ptr<miscellaneous_type> r(
        miscellaneous_traits::create(i, f, this));

      if (!this->miscellaneous_) {
        this->miscellaneous_.set(::std::move(r));
        continue;
      }
    }

    break;
  }
}

identification *identification::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class identification(*this, f, c);
}

identification &identification::operator=(const identification &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->creator_ = x.creator_;
    this->rights_ = x.rights_;
    this->encoding_ = x.encoding_;
    this->source_ = x.source_;
    this->relation_ = x.relation_;
    this->miscellaneous_ = x.miscellaneous_;
  }

  return *this;
}

identification::~identification() {}

// miscellaneous
//

miscellaneous::miscellaneous()
: ::xml_schema::type(), miscellaneous_field_(this) {}

miscellaneous::miscellaneous(const miscellaneous &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, miscellaneous_field_(x.miscellaneous_field_, f, this) {}

miscellaneous::miscellaneous(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, miscellaneous_field_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void miscellaneous::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // miscellaneous-field
    //
    if (n.name() == "miscellaneous-field" && n.namespace_().empty()) {
      ::std::unique_ptr<miscellaneous_field_type> r(
        miscellaneous_field_traits::create(i, f, this));

      this->miscellaneous_field_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

miscellaneous *miscellaneous::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class miscellaneous(*this, f, c);
}

miscellaneous &miscellaneous::operator=(const miscellaneous &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->miscellaneous_field_ = x.miscellaneous_field_;
  }

  return *this;
}

miscellaneous::~miscellaneous() {}

// miscellaneous_field
//

miscellaneous_field::miscellaneous_field(const name_type &name)
: ::xml_schema::string(), name_(name, this) {}

miscellaneous_field::miscellaneous_field(const char *_xsd_string_base,
                                         const name_type &name)
: ::xml_schema::string(_xsd_string_base), name_(name, this) {}

miscellaneous_field::miscellaneous_field(const ::std::string &_xsd_string_base,
                                         const name_type &name)
: ::xml_schema::string(_xsd_string_base), name_(name, this) {}

miscellaneous_field::miscellaneous_field(
  const ::xml_schema::string &_xsd_string_base, const name_type &name)
: ::xml_schema::string(_xsd_string_base), name_(name, this) {}

miscellaneous_field::miscellaneous_field(const miscellaneous_field &x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::string(x, f, c), name_(x.name_, f, this) {}

miscellaneous_field::miscellaneous_field(const ::xercesc::DOMElement &e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c), name_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void miscellaneous_field::parse(::xsd::cxx::xml::dom::parser<char> &p,
                                ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }
  }

  if (!name_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("name", "");
  }
}

miscellaneous_field *
miscellaneous_field::_clone(::xml_schema::flags f,
                            ::xml_schema::container *c) const {
  return new class miscellaneous_field(*this, f, c);
}

miscellaneous_field &miscellaneous_field::
operator=(const miscellaneous_field &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->name_ = x.name_;
  }

  return *this;
}

miscellaneous_field::~miscellaneous_field() {}

// supports
//

supports::supports(const type_type &type, const element_type &element)
: ::xml_schema::type()
, type_(type, this)
, element_(element, this)
, attribute_(this)
, value_(this) {}

supports::supports(const supports &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, element_(x.element_, f, this)
, attribute_(x.attribute_, f, this)
, value_(x.value_, f, this) {}

supports::supports(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, element_(this)
, attribute_(this)
, value_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void supports::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "element" && n.namespace_().empty()) {
      this->element_.set(element_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "attribute" && n.namespace_().empty()) {
      this->attribute_.set(attribute_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "value" && n.namespace_().empty()) {
      this->value_.set(value_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!element_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("element", "");
  }
}

supports *supports::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class supports(*this, f, c);
}

supports &supports::operator=(const supports &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->element_ = x.element_;
    this->attribute_ = x.attribute_;
    this->value_ = x.value_;
  }

  return *this;
}

supports::~supports() {}

// appearance
//

appearance::appearance()
: ::xml_schema::type()
, line_width_(this)
, note_size_(this)
, distance_(this)
, other_appearance_(this) {}

appearance::appearance(const appearance &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, line_width_(x.line_width_, f, this)
, note_size_(x.note_size_, f, this)
, distance_(x.distance_, f, this)
, other_appearance_(x.other_appearance_, f, this) {}

appearance::appearance(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, line_width_(this)
, note_size_(this)
, distance_(this)
, other_appearance_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void appearance::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // line-width
    //
    if (n.name() == "line-width" && n.namespace_().empty()) {
      ::std::unique_ptr<line_width_type> r(
        line_width_traits::create(i, f, this));

      this->line_width_.push_back(::std::move(r));
      continue;
    }

    // note-size
    //
    if (n.name() == "note-size" && n.namespace_().empty()) {
      ::std::unique_ptr<note_size_type> r(note_size_traits::create(i, f, this));

      this->note_size_.push_back(::std::move(r));
      continue;
    }

    // distance
    //
    if (n.name() == "distance" && n.namespace_().empty()) {
      ::std::unique_ptr<distance_type> r(distance_traits::create(i, f, this));

      this->distance_.push_back(::std::move(r));
      continue;
    }

    // other-appearance
    //
    if (n.name() == "other-appearance" && n.namespace_().empty()) {
      ::std::unique_ptr<other_appearance_type> r(
        other_appearance_traits::create(i, f, this));

      this->other_appearance_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

appearance *appearance::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class appearance(*this, f, c);
}

appearance &appearance::operator=(const appearance &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->line_width_ = x.line_width_;
    this->note_size_ = x.note_size_;
    this->distance_ = x.distance_;
    this->other_appearance_ = x.other_appearance_;
  }

  return *this;
}

appearance::~appearance() {}

// distance
//

distance::distance(const ::xml_schema::decimal &_xsd_decimal_base,
                   const type_type &type)
: ::musicxml::tenths(_xsd_decimal_base), type_(type, this) {}

distance::distance(const distance &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::musicxml::tenths(x, f, c), type_(x.type_, f, this) {}

distance::distance(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::musicxml::tenths(e, f | ::xml_schema::flags::base, c), type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void distance::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

distance *distance::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class distance(*this, f, c);
}

distance &distance::operator=(const distance &x) {
  if (this != &x) {
    static_cast<::musicxml::tenths &>(*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

distance::~distance() {}

// line_width
//

line_width::line_width(const ::xml_schema::decimal &_xsd_decimal_base,
                       const type_type &type)
: ::musicxml::tenths(_xsd_decimal_base), type_(type, this) {}

line_width::line_width(const line_width &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::tenths(x, f, c), type_(x.type_, f, this) {}

line_width::line_width(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::tenths(e, f | ::xml_schema::flags::base, c), type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void line_width::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

line_width *line_width::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class line_width(*this, f, c);
}

line_width &line_width::operator=(const line_width &x) {
  if (this != &x) {
    static_cast<::musicxml::tenths &>(*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

line_width::~line_width() {}

// measure_layout
//

measure_layout::measure_layout()
: ::xml_schema::type(), measure_distance_(this) {}

measure_layout::measure_layout(const measure_layout &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, measure_distance_(x.measure_distance_, f, this) {}

measure_layout::measure_layout(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, measure_distance_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void measure_layout::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // measure-distance
    //
    if (n.name() == "measure-distance" && n.namespace_().empty()) {
      ::std::unique_ptr<measure_distance_type> r(
        measure_distance_traits::create(i, f, this));

      if (!this->measure_distance_) {
        this->measure_distance_.set(::std::move(r));
        continue;
      }
    }

    break;
  }
}

measure_layout *measure_layout::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class measure_layout(*this, f, c);
}

measure_layout &measure_layout::operator=(const measure_layout &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->measure_distance_ = x.measure_distance_;
  }

  return *this;
}

measure_layout::~measure_layout() {}

// note_size
//

note_size::note_size(const ::xml_schema::decimal &_xsd_decimal_base,
                     const type_type &type)
: ::musicxml::non_negative_decimal(_xsd_decimal_base), type_(type, this) {}

note_size::note_size(const note_size &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::musicxml::non_negative_decimal(x, f, c), type_(x.type_, f, this) {}

note_size::note_size(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::musicxml::non_negative_decimal(e, f | ::xml_schema::flags::base, c)
, type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void note_size::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

note_size *note_size::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class note_size(*this, f, c);
}

note_size &note_size::operator=(const note_size &x) {
  if (this != &x) {
    static_cast<::musicxml::non_negative_decimal &>(*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

note_size::~note_size() {}

// other_appearance
//

other_appearance::other_appearance(const type_type &type)
: ::xml_schema::string(), type_(type, this) {}

other_appearance::other_appearance(const char *_xsd_string_base,
                                   const type_type &type)
: ::xml_schema::string(_xsd_string_base), type_(type, this) {}

other_appearance::other_appearance(const ::std::string &_xsd_string_base,
                                   const type_type &type)
: ::xml_schema::string(_xsd_string_base), type_(type, this) {}

other_appearance::other_appearance(const ::xml_schema::string &_xsd_string_base,
                                   const type_type &type)
: ::xml_schema::string(_xsd_string_base), type_(type, this) {}

other_appearance::other_appearance(const other_appearance &x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(x, f, c), type_(x.type_, f, this) {}

other_appearance::other_appearance(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c), type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void other_appearance::parse(::xsd::cxx::xml::dom::parser<char> &p,
                             ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

other_appearance *other_appearance::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class other_appearance(*this, f, c);
}

other_appearance &other_appearance::operator=(const other_appearance &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

other_appearance::~other_appearance() {}

// page_layout
//

page_layout::page_layout()
: ::xml_schema::type()
, page_height_(this)
, page_width_(this)
, page_margins_(this) {}

page_layout::page_layout(const page_layout &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, page_height_(x.page_height_, f, this)
, page_width_(x.page_width_, f, this)
, page_margins_(x.page_margins_, f, this) {}

page_layout::page_layout(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, page_height_(this)
, page_width_(this)
, page_margins_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void page_layout::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // page-height
    //
    if (n.name() == "page-height" && n.namespace_().empty()) {
      ::std::unique_ptr<page_height_type> r(
        page_height_traits::create(i, f, this));

      if (!this->page_height_) {
        this->page_height_.set(::std::move(r));
        continue;
      }
    }

    // page-width
    //
    if (n.name() == "page-width" && n.namespace_().empty()) {
      ::std::unique_ptr<page_width_type> r(
        page_width_traits::create(i, f, this));

      if (!this->page_width_) {
        this->page_width_.set(::std::move(r));
        continue;
      }
    }

    // page-margins
    //
    if (n.name() == "page-margins" && n.namespace_().empty()) {
      ::std::unique_ptr<page_margins_type> r(
        page_margins_traits::create(i, f, this));

      this->page_margins_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

page_layout *page_layout::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class page_layout(*this, f, c);
}

page_layout &page_layout::operator=(const page_layout &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->page_height_ = x.page_height_;
    this->page_width_ = x.page_width_;
    this->page_margins_ = x.page_margins_;
  }

  return *this;
}

page_layout::~page_layout() {}

// page_margins
//

page_margins::page_margins(const left_margin_type &left_margin,
                           const right_margin_type &right_margin,
                           const top_margin_type &top_margin,
                           const bottom_margin_type &bottom_margin)
: ::xml_schema::type()
, left_margin_(left_margin, this)
, right_margin_(right_margin, this)
, top_margin_(top_margin, this)
, bottom_margin_(bottom_margin, this)
, type_(this) {}

page_margins::page_margins(const page_margins &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, left_margin_(x.left_margin_, f, this)
, right_margin_(x.right_margin_, f, this)
, top_margin_(x.top_margin_, f, this)
, bottom_margin_(x.bottom_margin_, f, this)
, type_(x.type_, f, this) {}

page_margins::page_margins(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, left_margin_(this)
, right_margin_(this)
, top_margin_(this)
, bottom_margin_(this)
, type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void page_margins::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // left-margin
    //
    if (n.name() == "left-margin" && n.namespace_().empty()) {
      ::std::unique_ptr<left_margin_type> r(
        left_margin_traits::create(i, f, this));

      if (!left_margin_.present()) {
        this->left_margin_.set(::std::move(r));
        continue;
      }
    }

    // right-margin
    //
    if (n.name() == "right-margin" && n.namespace_().empty()) {
      ::std::unique_ptr<right_margin_type> r(
        right_margin_traits::create(i, f, this));

      if (!right_margin_.present()) {
        this->right_margin_.set(::std::move(r));
        continue;
      }
    }

    // top-margin
    //
    if (n.name() == "top-margin" && n.namespace_().empty()) {
      ::std::unique_ptr<top_margin_type> r(
        top_margin_traits::create(i, f, this));

      if (!top_margin_.present()) {
        this->top_margin_.set(::std::move(r));
        continue;
      }
    }

    // bottom-margin
    //
    if (n.name() == "bottom-margin" && n.namespace_().empty()) {
      ::std::unique_ptr<bottom_margin_type> r(
        bottom_margin_traits::create(i, f, this));

      if (!bottom_margin_.present()) {
        this->bottom_margin_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!left_margin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("left-margin", "");
  }

  if (!right_margin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("right-margin", "");
  }

  if (!top_margin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("top-margin", "");
  }

  if (!bottom_margin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("bottom-margin", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }
}

page_margins *page_margins::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class page_margins(*this, f, c);
}

page_margins &page_margins::operator=(const page_margins &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->left_margin_ = x.left_margin_;
    this->right_margin_ = x.right_margin_;
    this->top_margin_ = x.top_margin_;
    this->bottom_margin_ = x.bottom_margin_;
    this->type_ = x.type_;
  }

  return *this;
}

page_margins::~page_margins() {}

// scaling
//

scaling::scaling(const millimeters_type &millimeters, const tenths_type &tenths)
: ::xml_schema::type()
, millimeters_(millimeters, this)
, tenths_(tenths, this) {}

scaling::scaling(const scaling &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, millimeters_(x.millimeters_, f, this)
, tenths_(x.tenths_, f, this) {}

scaling::scaling(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, millimeters_(this)
, tenths_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void scaling::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // millimeters
    //
    if (n.name() == "millimeters" && n.namespace_().empty()) {
      ::std::unique_ptr<millimeters_type> r(
        millimeters_traits::create(i, f, this));

      if (!millimeters_.present()) {
        this->millimeters_.set(::std::move(r));
        continue;
      }
    }

    // tenths
    //
    if (n.name() == "tenths" && n.namespace_().empty()) {
      ::std::unique_ptr<tenths_type> r(tenths_traits::create(i, f, this));

      if (!tenths_.present()) {
        this->tenths_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!millimeters_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("millimeters", "");
  }

  if (!tenths_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("tenths", "");
  }
}

scaling *scaling::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class scaling(*this, f, c);
}

scaling &scaling::operator=(const scaling &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->millimeters_ = x.millimeters_;
    this->tenths_ = x.tenths_;
  }

  return *this;
}

scaling::~scaling() {}

// staff_layout
//

staff_layout::staff_layout()
: ::xml_schema::type(), staff_distance_(this), number_(this) {}

staff_layout::staff_layout(const staff_layout &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, staff_distance_(x.staff_distance_, f, this)
, number_(x.number_, f, this) {}

staff_layout::staff_layout(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, staff_distance_(this)
, number_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void staff_layout::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // staff-distance
    //
    if (n.name() == "staff-distance" && n.namespace_().empty()) {
      ::std::unique_ptr<staff_distance_type> r(
        staff_distance_traits::create(i, f, this));

      if (!this->staff_distance_) {
        this->staff_distance_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }
  }
}

staff_layout *staff_layout::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class staff_layout(*this, f, c);
}

staff_layout &staff_layout::operator=(const staff_layout &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->staff_distance_ = x.staff_distance_;
    this->number_ = x.number_;
  }

  return *this;
}

staff_layout::~staff_layout() {}

// system_dividers
//

system_dividers::system_dividers(const left_divider_type &left_divider,
                                 const right_divider_type &right_divider)
: ::xml_schema::type()
, left_divider_(left_divider, this)
, right_divider_(right_divider, this) {}

system_dividers::system_dividers(
  ::std::unique_ptr<left_divider_type> left_divider,
  ::std::unique_ptr<right_divider_type> right_divider)
: ::xml_schema::type()
, left_divider_(std::move(left_divider), this)
, right_divider_(std::move(right_divider), this) {}

system_dividers::system_dividers(const system_dividers &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, left_divider_(x.left_divider_, f, this)
, right_divider_(x.right_divider_, f, this) {}

system_dividers::system_dividers(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, left_divider_(this)
, right_divider_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void system_dividers::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // left-divider
    //
    if (n.name() == "left-divider" && n.namespace_().empty()) {
      ::std::unique_ptr<left_divider_type> r(
        left_divider_traits::create(i, f, this));

      if (!left_divider_.present()) {
        this->left_divider_.set(::std::move(r));
        continue;
      }
    }

    // right-divider
    //
    if (n.name() == "right-divider" && n.namespace_().empty()) {
      ::std::unique_ptr<right_divider_type> r(
        right_divider_traits::create(i, f, this));

      if (!right_divider_.present()) {
        this->right_divider_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!left_divider_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("left-divider", "");
  }

  if (!right_divider_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("right-divider", "");
  }
}

system_dividers *system_dividers::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class system_dividers(*this, f, c);
}

system_dividers &system_dividers::operator=(const system_dividers &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->left_divider_ = x.left_divider_;
    this->right_divider_ = x.right_divider_;
  }

  return *this;
}

system_dividers::~system_dividers() {}

// system_layout
//

system_layout::system_layout()
: ::xml_schema::type()
, system_margins_(this)
, system_distance_(this)
, top_system_distance_(this)
, system_dividers_(this) {}

system_layout::system_layout(const system_layout &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, system_margins_(x.system_margins_, f, this)
, system_distance_(x.system_distance_, f, this)
, top_system_distance_(x.top_system_distance_, f, this)
, system_dividers_(x.system_dividers_, f, this) {}

system_layout::system_layout(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, system_margins_(this)
, system_distance_(this)
, top_system_distance_(this)
, system_dividers_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void system_layout::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // system-margins
    //
    if (n.name() == "system-margins" && n.namespace_().empty()) {
      ::std::unique_ptr<system_margins_type> r(
        system_margins_traits::create(i, f, this));

      if (!this->system_margins_) {
        this->system_margins_.set(::std::move(r));
        continue;
      }
    }

    // system-distance
    //
    if (n.name() == "system-distance" && n.namespace_().empty()) {
      ::std::unique_ptr<system_distance_type> r(
        system_distance_traits::create(i, f, this));

      if (!this->system_distance_) {
        this->system_distance_.set(::std::move(r));
        continue;
      }
    }

    // top-system-distance
    //
    if (n.name() == "top-system-distance" && n.namespace_().empty()) {
      ::std::unique_ptr<top_system_distance_type> r(
        top_system_distance_traits::create(i, f, this));

      if (!this->top_system_distance_) {
        this->top_system_distance_.set(::std::move(r));
        continue;
      }
    }

    // system-dividers
    //
    if (n.name() == "system-dividers" && n.namespace_().empty()) {
      ::std::unique_ptr<system_dividers_type> r(
        system_dividers_traits::create(i, f, this));

      if (!this->system_dividers_) {
        this->system_dividers_.set(::std::move(r));
        continue;
      }
    }

    break;
  }
}

system_layout *system_layout::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class system_layout(*this, f, c);
}

system_layout &system_layout::operator=(const system_layout &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->system_margins_ = x.system_margins_;
    this->system_distance_ = x.system_distance_;
    this->top_system_distance_ = x.top_system_distance_;
    this->system_dividers_ = x.system_dividers_;
  }

  return *this;
}

system_layout::~system_layout() {}

// system_margins
//

system_margins::system_margins(const left_margin_type &left_margin,
                               const right_margin_type &right_margin)
: ::xml_schema::type()
, left_margin_(left_margin, this)
, right_margin_(right_margin, this) {}

system_margins::system_margins(const system_margins &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, left_margin_(x.left_margin_, f, this)
, right_margin_(x.right_margin_, f, this) {}

system_margins::system_margins(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, left_margin_(this)
, right_margin_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void system_margins::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // left-margin
    //
    if (n.name() == "left-margin" && n.namespace_().empty()) {
      ::std::unique_ptr<left_margin_type> r(
        left_margin_traits::create(i, f, this));

      if (!left_margin_.present()) {
        this->left_margin_.set(::std::move(r));
        continue;
      }
    }

    // right-margin
    //
    if (n.name() == "right-margin" && n.namespace_().empty()) {
      ::std::unique_ptr<right_margin_type> r(
        right_margin_traits::create(i, f, this));

      if (!right_margin_.present()) {
        this->right_margin_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!left_margin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("left-margin", "");
  }

  if (!right_margin_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("right-margin", "");
  }
}

system_margins *system_margins::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class system_margins(*this, f, c);
}

system_margins &system_margins::operator=(const system_margins &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->left_margin_ = x.left_margin_;
    this->right_margin_ = x.right_margin_;
  }

  return *this;
}

system_margins::~system_margins() {}

// bookmark
//

bookmark::bookmark(const id_type &id)
: ::xml_schema::type()
, id_(id, this)
, name_(this)
, element_(this)
, position_(this) {}

bookmark::bookmark(const bookmark &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, id_(x.id_, f, this)
, name_(x.name_, f, this)
, element_(x.element_, f, this)
, position_(x.position_, f, this) {}

bookmark::bookmark(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, id_(this)
, name_(this)
, element_(this)
, position_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void bookmark::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "element" && n.namespace_().empty()) {
      this->element_.set(element_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "position" && n.namespace_().empty()) {
      this->position_.set(position_traits::create(i, f, this));
      continue;
    }
  }

  if (!id_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("id", "");
  }
}

bookmark *bookmark::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class bookmark(*this, f, c);
}

bookmark &bookmark::operator=(const bookmark &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->id_ = x.id_;
    this->name_ = x.name_;
    this->element_ = x.element_;
    this->position_ = x.position_;
  }

  return *this;
}

bookmark::~bookmark() {}

// link
//

const link::type_type link::type_default_value_("simple");

const link::show_type link::show_default_value_("replace");

const link::actuate_type link::actuate_default_value_("onRequest");

link::link(const href_type &href)
: ::xml_schema::type()
, href_(href, this)
, type_(type_default_value(), this)
, role_(this)
, title_(this)
, show_(show_default_value(), this)
, actuate_(actuate_default_value(), this)
, name_(this)
, element_(this)
, position_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this) {}

link::link(const link &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, href_(x.href_, f, this)
, type_(x.type_, f, this)
, role_(x.role_, f, this)
, title_(x.title_, f, this)
, show_(x.show_, f, this)
, actuate_(x.actuate_, f, this)
, name_(x.name_, f, this)
, element_(x.element_, f, this)
, position_(x.position_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this) {}

link::link(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, href_(this)
, type_(this)
, role_(this)
, title_(this)
, show_(this)
, actuate_(this)
, name_(this)
, element_(this)
, position_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void link::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "href" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->href_.set(href_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "type" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "role" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->role_.set(role_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "title" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->title_.set(title_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "show" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->show_.set(show_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "actuate" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->actuate_.set(actuate_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "element" && n.namespace_().empty()) {
      this->element_.set(element_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "position" && n.namespace_().empty()) {
      this->position_.set(position_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }
  }

  if (!href_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>(
      "href", "http://www.w3.org/1999/xlink");
  }

  if (!type_.present()) { this->type_.set(type_default_value()); }

  if (!show_.present()) { this->show_.set(show_default_value()); }

  if (!actuate_.present()) { this->actuate_.set(actuate_default_value()); }
}

link *link::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class link(*this, f, c);
}

link &link::operator=(const link &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->href_ = x.href_;
    this->type_ = x.type_;
    this->role_ = x.role_;
    this->title_ = x.title_;
    this->show_ = x.show_;
    this->actuate_ = x.actuate_;
    this->name_ = x.name_;
    this->element_ = x.element_;
    this->position_ = x.position_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
  }

  return *this;
}

link::~link() {}

// accidental
//

accidental::accidental(
  ::musicxml::accidental_value::value _xsd_accidental_value_base)
: ::musicxml::accidental_value(_xsd_accidental_value_base)
, cautionary_(this)
, editorial_(this)
, parentheses_(this)
, bracket_(this)
, size_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

accidental::accidental(const char *_xsd_string_base)
: ::musicxml::accidental_value(_xsd_string_base)
, cautionary_(this)
, editorial_(this)
, parentheses_(this)
, bracket_(this)
, size_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

accidental::accidental(const ::std::string &_xsd_string_base)
: ::musicxml::accidental_value(_xsd_string_base)
, cautionary_(this)
, editorial_(this)
, parentheses_(this)
, bracket_(this)
, size_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

accidental::accidental(
  const ::musicxml::accidental_value &_xsd_accidental_value_base)
: ::musicxml::accidental_value(_xsd_accidental_value_base)
, cautionary_(this)
, editorial_(this)
, parentheses_(this)
, bracket_(this)
, size_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

accidental::accidental(const accidental &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::accidental_value(x, f, c)
, cautionary_(x.cautionary_, f, this)
, editorial_(x.editorial_, f, this)
, parentheses_(x.parentheses_, f, this)
, bracket_(x.bracket_, f, this)
, size_(x.size_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

accidental::accidental(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::musicxml::accidental_value(e, f | ::xml_schema::flags::base, c)
, cautionary_(this)
, editorial_(this)
, parentheses_(this)
, bracket_(this)
, size_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void accidental::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "cautionary" && n.namespace_().empty()) {
      this->cautionary_.set(cautionary_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "editorial" && n.namespace_().empty()) {
      this->editorial_.set(editorial_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "parentheses" && n.namespace_().empty()) {
      this->parentheses_.set(parentheses_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bracket" && n.namespace_().empty()) {
      this->bracket_.set(bracket_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "size" && n.namespace_().empty()) {
      this->size_.set(size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

accidental *accidental::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class accidental(*this, f, c);
}

accidental &accidental::operator=(const accidental &x) {
  if (this != &x) {
    static_cast<::musicxml::accidental_value &>(*this) = x;
    this->cautionary_ = x.cautionary_;
    this->editorial_ = x.editorial_;
    this->parentheses_ = x.parentheses_;
    this->bracket_ = x.bracket_;
    this->size_ = x.size_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

accidental::~accidental() {}

// accidental_mark
//

accidental_mark::accidental_mark(
  ::musicxml::accidental_value::value _xsd_accidental_value_base)
: ::musicxml::accidental_value(_xsd_accidental_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

accidental_mark::accidental_mark(const char *_xsd_string_base)
: ::musicxml::accidental_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

accidental_mark::accidental_mark(const ::std::string &_xsd_string_base)
: ::musicxml::accidental_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

accidental_mark::accidental_mark(
  const ::musicxml::accidental_value &_xsd_accidental_value_base)
: ::musicxml::accidental_value(_xsd_accidental_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

accidental_mark::accidental_mark(const accidental_mark &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::musicxml::accidental_value(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

accidental_mark::accidental_mark(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::musicxml::accidental_value(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void accidental_mark::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

accidental_mark *accidental_mark::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class accidental_mark(*this, f, c);
}

accidental_mark &accidental_mark::operator=(const accidental_mark &x) {
  if (this != &x) {
    static_cast<::musicxml::accidental_value &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

accidental_mark::~accidental_mark() {}

// arpeggiate
//

arpeggiate::arpeggiate()
: ::xml_schema::type()
, number_(this)
, direction_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, color_(this) {}

arpeggiate::arpeggiate(const arpeggiate &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, number_(x.number_, f, this)
, direction_(x.direction_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, placement_(x.placement_, f, this)
, color_(x.color_, f, this) {}

arpeggiate::arpeggiate(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, number_(this)
, direction_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void arpeggiate::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "direction" && n.namespace_().empty()) {
      this->direction_.set(direction_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

arpeggiate *arpeggiate::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class arpeggiate(*this, f, c);
}

arpeggiate &arpeggiate::operator=(const arpeggiate &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->number_ = x.number_;
    this->direction_ = x.direction_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->placement_ = x.placement_;
    this->color_ = x.color_;
  }

  return *this;
}

arpeggiate::~arpeggiate() {}

// articulations
//

articulations::articulations()
: ::xml_schema::type()
, accent_(this)
, strong_accent_(this)
, staccato_(this)
, tenuto_(this)
, detached_legato_(this)
, staccatissimo_(this)
, spiccato_(this)
, scoop_(this)
, plop_(this)
, doit_(this)
, falloff_(this)
, breath_mark_(this)
, caesura_(this)
, stress_(this)
, unstress_(this)
, other_articulation_(this) {}

articulations::articulations(const articulations &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, accent_(x.accent_, f, this)
, strong_accent_(x.strong_accent_, f, this)
, staccato_(x.staccato_, f, this)
, tenuto_(x.tenuto_, f, this)
, detached_legato_(x.detached_legato_, f, this)
, staccatissimo_(x.staccatissimo_, f, this)
, spiccato_(x.spiccato_, f, this)
, scoop_(x.scoop_, f, this)
, plop_(x.plop_, f, this)
, doit_(x.doit_, f, this)
, falloff_(x.falloff_, f, this)
, breath_mark_(x.breath_mark_, f, this)
, caesura_(x.caesura_, f, this)
, stress_(x.stress_, f, this)
, unstress_(x.unstress_, f, this)
, other_articulation_(x.other_articulation_, f, this) {}

articulations::articulations(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, accent_(this)
, strong_accent_(this)
, staccato_(this)
, tenuto_(this)
, detached_legato_(this)
, staccatissimo_(this)
, spiccato_(this)
, scoop_(this)
, plop_(this)
, doit_(this)
, falloff_(this)
, breath_mark_(this)
, caesura_(this)
, stress_(this)
, unstress_(this)
, other_articulation_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void articulations::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // accent
    //
    if (n.name() == "accent" && n.namespace_().empty()) {
      ::std::unique_ptr<accent_type> r(accent_traits::create(i, f, this));

      this->accent_.push_back(::std::move(r));
      continue;
    }

    // strong-accent
    //
    if (n.name() == "strong-accent" && n.namespace_().empty()) {
      ::std::unique_ptr<strong_accent_type> r(
        strong_accent_traits::create(i, f, this));

      this->strong_accent_.push_back(::std::move(r));
      continue;
    }

    // staccato
    //
    if (n.name() == "staccato" && n.namespace_().empty()) {
      ::std::unique_ptr<staccato_type> r(staccato_traits::create(i, f, this));

      this->staccato_.push_back(::std::move(r));
      continue;
    }

    // tenuto
    //
    if (n.name() == "tenuto" && n.namespace_().empty()) {
      ::std::unique_ptr<tenuto_type> r(tenuto_traits::create(i, f, this));

      this->tenuto_.push_back(::std::move(r));
      continue;
    }

    // detached-legato
    //
    if (n.name() == "detached-legato" && n.namespace_().empty()) {
      ::std::unique_ptr<detached_legato_type> r(
        detached_legato_traits::create(i, f, this));

      this->detached_legato_.push_back(::std::move(r));
      continue;
    }

    // staccatissimo
    //
    if (n.name() == "staccatissimo" && n.namespace_().empty()) {
      ::std::unique_ptr<staccatissimo_type> r(
        staccatissimo_traits::create(i, f, this));

      this->staccatissimo_.push_back(::std::move(r));
      continue;
    }

    // spiccato
    //
    if (n.name() == "spiccato" && n.namespace_().empty()) {
      ::std::unique_ptr<spiccato_type> r(spiccato_traits::create(i, f, this));

      this->spiccato_.push_back(::std::move(r));
      continue;
    }

    // scoop
    //
    if (n.name() == "scoop" && n.namespace_().empty()) {
      ::std::unique_ptr<scoop_type> r(scoop_traits::create(i, f, this));

      this->scoop_.push_back(::std::move(r));
      continue;
    }

    // plop
    //
    if (n.name() == "plop" && n.namespace_().empty()) {
      ::std::unique_ptr<plop_type> r(plop_traits::create(i, f, this));

      this->plop_.push_back(::std::move(r));
      continue;
    }

    // doit
    //
    if (n.name() == "doit" && n.namespace_().empty()) {
      ::std::unique_ptr<doit_type> r(doit_traits::create(i, f, this));

      this->doit_.push_back(::std::move(r));
      continue;
    }

    // falloff
    //
    if (n.name() == "falloff" && n.namespace_().empty()) {
      ::std::unique_ptr<falloff_type> r(falloff_traits::create(i, f, this));

      this->falloff_.push_back(::std::move(r));
      continue;
    }

    // breath-mark
    //
    if (n.name() == "breath-mark" && n.namespace_().empty()) {
      ::std::unique_ptr<breath_mark_type> r(
        breath_mark_traits::create(i, f, this));

      this->breath_mark_.push_back(::std::move(r));
      continue;
    }

    // caesura
    //
    if (n.name() == "caesura" && n.namespace_().empty()) {
      ::std::unique_ptr<caesura_type> r(caesura_traits::create(i, f, this));

      this->caesura_.push_back(::std::move(r));
      continue;
    }

    // stress
    //
    if (n.name() == "stress" && n.namespace_().empty()) {
      ::std::unique_ptr<stress_type> r(stress_traits::create(i, f, this));

      this->stress_.push_back(::std::move(r));
      continue;
    }

    // unstress
    //
    if (n.name() == "unstress" && n.namespace_().empty()) {
      ::std::unique_ptr<unstress_type> r(unstress_traits::create(i, f, this));

      this->unstress_.push_back(::std::move(r));
      continue;
    }

    // other-articulation
    //
    if (n.name() == "other-articulation" && n.namespace_().empty()) {
      ::std::unique_ptr<other_articulation_type> r(
        other_articulation_traits::create(i, f, this));

      this->other_articulation_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

articulations *articulations::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class articulations(*this, f, c);
}

articulations &articulations::operator=(const articulations &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->accent_ = x.accent_;
    this->strong_accent_ = x.strong_accent_;
    this->staccato_ = x.staccato_;
    this->tenuto_ = x.tenuto_;
    this->detached_legato_ = x.detached_legato_;
    this->staccatissimo_ = x.staccatissimo_;
    this->spiccato_ = x.spiccato_;
    this->scoop_ = x.scoop_;
    this->plop_ = x.plop_;
    this->doit_ = x.doit_;
    this->falloff_ = x.falloff_;
    this->breath_mark_ = x.breath_mark_;
    this->caesura_ = x.caesura_;
    this->stress_ = x.stress_;
    this->unstress_ = x.unstress_;
    this->other_articulation_ = x.other_articulation_;
  }

  return *this;
}

articulations::~articulations() {}

// arrow
//

arrow::arrow()
: ::xml_schema::type()
, arrow_direction_(this)
, arrow_style_(this)
, circular_arrow_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

arrow::arrow(const arrow &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, arrow_direction_(x.arrow_direction_, f, this)
, arrow_style_(x.arrow_style_, f, this)
, circular_arrow_(x.circular_arrow_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

arrow::arrow(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, arrow_direction_(this)
, arrow_style_(this)
, circular_arrow_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void arrow::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // arrow-direction
    //
    if (n.name() == "arrow-direction" && n.namespace_().empty()) {
      ::std::unique_ptr<arrow_direction_type> r(
        arrow_direction_traits::create(i, f, this));

      if (!this->arrow_direction_) {
        this->arrow_direction_.set(::std::move(r));
        continue;
      }
    }

    // arrow-style
    //
    if (n.name() == "arrow-style" && n.namespace_().empty()) {
      ::std::unique_ptr<arrow_style_type> r(
        arrow_style_traits::create(i, f, this));

      if (!this->arrow_style_) {
        this->arrow_style_.set(::std::move(r));
        continue;
      }
    }

    // circular-arrow
    //
    if (n.name() == "circular-arrow" && n.namespace_().empty()) {
      ::std::unique_ptr<circular_arrow_type> r(
        circular_arrow_traits::create(i, f, this));

      if (!this->circular_arrow_) {
        this->circular_arrow_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

arrow *arrow::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class arrow(*this, f, c);
}

arrow &arrow::operator=(const arrow &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->arrow_direction_ = x.arrow_direction_;
    this->arrow_style_ = x.arrow_style_;
    this->circular_arrow_ = x.circular_arrow_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

arrow::~arrow() {}

// backup
//

backup::backup(const duration_type &duration)
: ::xml_schema::type()
, duration_(duration, this)
, footnote_(this)
, level_(this) {}

backup::backup(const backup &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, duration_(x.duration_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this) {}

backup::backup(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, duration_(this)
, footnote_(this)
, level_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void backup::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // duration
    //
    if (n.name() == "duration" && n.namespace_().empty()) {
      ::std::unique_ptr<duration_type> r(duration_traits::create(i, f, this));

      if (!duration_.present()) {
        this->duration_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!duration_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("duration", "");
  }
}

backup *backup::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class backup(*this, f, c);
}

backup &backup::operator=(const backup &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->duration_ = x.duration_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
  }

  return *this;
}

backup::~backup() {}

// beam
//

beam::beam(::musicxml::beam_value::value _xsd_beam_value_base)
: ::musicxml::beam_value(_xsd_beam_value_base)
, number_(number_default_value(), this)
, repeater_(this)
, fan_(this)
, color_(this) {}

beam::beam(const char *_xsd_string_base)
: ::musicxml::beam_value(_xsd_string_base)
, number_(number_default_value(), this)
, repeater_(this)
, fan_(this)
, color_(this) {}

beam::beam(const ::std::string &_xsd_string_base)
: ::musicxml::beam_value(_xsd_string_base)
, number_(number_default_value(), this)
, repeater_(this)
, fan_(this)
, color_(this) {}

beam::beam(const ::musicxml::beam_value &_xsd_beam_value_base)
: ::musicxml::beam_value(_xsd_beam_value_base)
, number_(number_default_value(), this)
, repeater_(this)
, fan_(this)
, color_(this) {}

beam::beam(const beam &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::musicxml::beam_value(x, f, c)
, number_(x.number_, f, this)
, repeater_(x.repeater_, f, this)
, fan_(x.fan_, f, this)
, color_(x.color_, f, this) {}

beam::beam(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::musicxml::beam_value(e, f | ::xml_schema::flags::base, c)
, number_(this)
, repeater_(this)
, fan_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void beam::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "repeater" && n.namespace_().empty()) {
      this->repeater_.set(repeater_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "fan" && n.namespace_().empty()) {
      this->fan_.set(fan_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

beam *beam::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class beam(*this, f, c);
}

beam &beam::operator=(const beam &x) {
  if (this != &x) {
    static_cast<::musicxml::beam_value &>(*this) = x;
    this->number_ = x.number_;
    this->repeater_ = x.repeater_;
    this->fan_ = x.fan_;
    this->color_ = x.color_;
  }

  return *this;
}

beam::~beam() {}

// bend
//

bend::bend(const bend_alter_type &bend_alter)
: ::xml_schema::type()
, bend_alter_(bend_alter, this)
, pre_bend_(this)
, release_(this)
, with_bar_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, accelerate_(this)
, beats_(this)
, first_beat_(this)
, last_beat_(this) {}

bend::bend(const bend &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, bend_alter_(x.bend_alter_, f, this)
, pre_bend_(x.pre_bend_, f, this)
, release_(x.release_, f, this)
, with_bar_(x.with_bar_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, accelerate_(x.accelerate_, f, this)
, beats_(x.beats_, f, this)
, first_beat_(x.first_beat_, f, this)
, last_beat_(x.last_beat_, f, this) {}

bend::bend(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, bend_alter_(this)
, pre_bend_(this)
, release_(this)
, with_bar_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, accelerate_(this)
, beats_(this)
, first_beat_(this)
, last_beat_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void bend::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // bend-alter
    //
    if (n.name() == "bend-alter" && n.namespace_().empty()) {
      ::std::unique_ptr<bend_alter_type> r(
        bend_alter_traits::create(i, f, this));

      if (!bend_alter_.present()) {
        this->bend_alter_.set(::std::move(r));
        continue;
      }
    }

    // pre-bend
    //
    if (n.name() == "pre-bend" && n.namespace_().empty()) {
      ::std::unique_ptr<pre_bend_type> r(pre_bend_traits::create(i, f, this));

      if (!this->pre_bend_) {
        this->pre_bend_.set(::std::move(r));
        continue;
      }
    }

    // release
    //
    if (n.name() == "release" && n.namespace_().empty()) {
      ::std::unique_ptr<release_type> r(release_traits::create(i, f, this));

      if (!this->release_) {
        this->release_.set(::std::move(r));
        continue;
      }
    }

    // with-bar
    //
    if (n.name() == "with-bar" && n.namespace_().empty()) {
      ::std::unique_ptr<with_bar_type> r(with_bar_traits::create(i, f, this));

      if (!this->with_bar_) {
        this->with_bar_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!bend_alter_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("bend-alter", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "accelerate" && n.namespace_().empty()) {
      this->accelerate_.set(accelerate_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "beats" && n.namespace_().empty()) {
      this->beats_.set(beats_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "first-beat" && n.namespace_().empty()) {
      this->first_beat_.set(first_beat_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "last-beat" && n.namespace_().empty()) {
      this->last_beat_.set(last_beat_traits::create(i, f, this));
      continue;
    }
  }
}

bend *bend::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class bend(*this, f, c);
}

bend &bend::operator=(const bend &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->bend_alter_ = x.bend_alter_;
    this->pre_bend_ = x.pre_bend_;
    this->release_ = x.release_;
    this->with_bar_ = x.with_bar_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->accelerate_ = x.accelerate_;
    this->beats_ = x.beats_;
    this->first_beat_ = x.first_beat_;
    this->last_beat_ = x.last_beat_;
  }

  return *this;
}

bend::~bend() {}

// breath_mark
//

breath_mark::breath_mark(
  ::musicxml::breath_mark_value::value _xsd_breath_mark_value_base)
: ::musicxml::breath_mark_value(_xsd_breath_mark_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

breath_mark::breath_mark(const char *_xsd_string_base)
: ::musicxml::breath_mark_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

breath_mark::breath_mark(const ::std::string &_xsd_string_base)
: ::musicxml::breath_mark_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

breath_mark::breath_mark(
  const ::musicxml::breath_mark_value &_xsd_breath_mark_value_base)
: ::musicxml::breath_mark_value(_xsd_breath_mark_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

breath_mark::breath_mark(const breath_mark &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::breath_mark_value(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

breath_mark::breath_mark(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::breath_mark_value(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void breath_mark::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

breath_mark *breath_mark::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class breath_mark(*this, f, c);
}

breath_mark &breath_mark::operator=(const breath_mark &x) {
  if (this != &x) {
    static_cast<::musicxml::breath_mark_value &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

breath_mark::~breath_mark() {}

// empty_line
//

empty_line::empty_line()
: ::xml_schema::type()
, line_shape_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

empty_line::empty_line(const empty_line &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, line_shape_(x.line_shape_, f, this)
, line_type_(x.line_type_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

empty_line::empty_line(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, line_shape_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void empty_line::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "line-shape" && n.namespace_().empty()) {
      this->line_shape_.set(line_shape_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-type" && n.namespace_().empty()) {
      this->line_type_.set(line_type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

empty_line *empty_line::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class empty_line(*this, f, c);
}

empty_line &empty_line::operator=(const empty_line &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->line_shape_ = x.line_shape_;
    this->line_type_ = x.line_type_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

empty_line::~empty_line() {}

// extend
//

extend::extend()
: ::xml_schema::type()
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

extend::extend(const extend &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

extend::extend(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void extend::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

extend *extend::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class extend(*this, f, c);
}

extend &extend::operator=(const extend &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

extend::~extend() {}

// figure
//

figure::figure()
: ::xml_schema::type()
, prefix_(this)
, figure_number_(this)
, suffix_(this)
, extend_(this) {}

figure::figure(const figure &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, prefix_(x.prefix_, f, this)
, figure_number_(x.figure_number_, f, this)
, suffix_(x.suffix_, f, this)
, extend_(x.extend_, f, this) {}

figure::figure(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, prefix_(this)
, figure_number_(this)
, suffix_(this)
, extend_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void figure::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // prefix
    //
    if (n.name() == "prefix" && n.namespace_().empty()) {
      ::std::unique_ptr<prefix_type> r(prefix_traits::create(i, f, this));

      if (!this->prefix_) {
        this->prefix_.set(::std::move(r));
        continue;
      }
    }

    // figure-number
    //
    if (n.name() == "figure-number" && n.namespace_().empty()) {
      ::std::unique_ptr<figure_number_type> r(
        figure_number_traits::create(i, f, this));

      if (!this->figure_number_) {
        this->figure_number_.set(::std::move(r));
        continue;
      }
    }

    // suffix
    //
    if (n.name() == "suffix" && n.namespace_().empty()) {
      ::std::unique_ptr<suffix_type> r(suffix_traits::create(i, f, this));

      if (!this->suffix_) {
        this->suffix_.set(::std::move(r));
        continue;
      }
    }

    // extend
    //
    if (n.name() == "extend" && n.namespace_().empty()) {
      ::std::unique_ptr<extend_type> r(extend_traits::create(i, f, this));

      if (!this->extend_) {
        this->extend_.set(::std::move(r));
        continue;
      }
    }

    break;
  }
}

figure *figure::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class figure(*this, f, c);
}

figure &figure::operator=(const figure &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->prefix_ = x.prefix_;
    this->figure_number_ = x.figure_number_;
    this->suffix_ = x.suffix_;
    this->extend_ = x.extend_;
  }

  return *this;
}

figure::~figure() {}

// figured_bass
//

figured_bass::figured_bass()
: ::xml_schema::type()
, figure_(this)
, duration_(this)
, footnote_(this)
, level_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, print_dot_(this)
, print_spacing_(this)
, print_lyric_(this)
, parentheses_(this) {}

figured_bass::figured_bass(const figured_bass &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, figure_(x.figure_, f, this)
, duration_(x.duration_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, print_object_(x.print_object_, f, this)
, print_dot_(x.print_dot_, f, this)
, print_spacing_(x.print_spacing_, f, this)
, print_lyric_(x.print_lyric_, f, this)
, parentheses_(x.parentheses_, f, this) {}

figured_bass::figured_bass(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, figure_(this)
, duration_(this)
, footnote_(this)
, level_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, print_dot_(this)
, print_spacing_(this)
, print_lyric_(this)
, parentheses_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void figured_bass::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // figure
    //
    if (n.name() == "figure" && n.namespace_().empty()) {
      ::std::unique_ptr<figure_type> r(figure_traits::create(i, f, this));

      this->figure_.push_back(::std::move(r));
      continue;
    }

    // duration
    //
    if (n.name() == "duration" && n.namespace_().empty()) {
      ::std::unique_ptr<duration_type> r(duration_traits::create(i, f, this));

      if (!this->duration_) {
        this->duration_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-dot" && n.namespace_().empty()) {
      this->print_dot_.set(print_dot_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-spacing" && n.namespace_().empty()) {
      this->print_spacing_.set(print_spacing_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-lyric" && n.namespace_().empty()) {
      this->print_lyric_.set(print_lyric_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "parentheses" && n.namespace_().empty()) {
      this->parentheses_.set(parentheses_traits::create(i, f, this));
      continue;
    }
  }
}

figured_bass *figured_bass::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class figured_bass(*this, f, c);
}

figured_bass &figured_bass::operator=(const figured_bass &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->figure_ = x.figure_;
    this->duration_ = x.duration_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->print_object_ = x.print_object_;
    this->print_dot_ = x.print_dot_;
    this->print_spacing_ = x.print_spacing_;
    this->print_lyric_ = x.print_lyric_;
    this->parentheses_ = x.parentheses_;
  }

  return *this;
}

figured_bass::~figured_bass() {}

// forward
//

forward::forward(const duration_type &duration)
: ::xml_schema::type()
, duration_(duration, this)
, footnote_(this)
, level_(this)
, voice_(this)
, staff_(this) {}

forward::forward(const forward &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, duration_(x.duration_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, voice_(x.voice_, f, this)
, staff_(x.staff_, f, this) {}

forward::forward(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, duration_(this)
, footnote_(this)
, level_(this)
, voice_(this)
, staff_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void forward::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // duration
    //
    if (n.name() == "duration" && n.namespace_().empty()) {
      ::std::unique_ptr<duration_type> r(duration_traits::create(i, f, this));

      if (!duration_.present()) {
        this->duration_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    // voice
    //
    if (n.name() == "voice" && n.namespace_().empty()) {
      ::std::unique_ptr<voice_type> r(voice_traits::create(i, f, this));

      if (!this->voice_) {
        this->voice_.set(::std::move(r));
        continue;
      }
    }

    // staff
    //
    if (n.name() == "staff" && n.namespace_().empty()) {
      if (!this->staff_) {
        this->staff_.set(staff_traits::create(i, f, this));
        continue;
      }
    }

    break;
  }

  if (!duration_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("duration", "");
  }
}

forward *forward::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class forward(*this, f, c);
}

forward &forward::operator=(const forward &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->duration_ = x.duration_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->voice_ = x.voice_;
    this->staff_ = x.staff_;
  }

  return *this;
}

forward::~forward() {}

// glissando
//

glissando::glissando(const type_type &type)
: ::xml_schema::string()
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

glissando::glissando(const char *_xsd_string_base, const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

glissando::glissando(const ::std::string &_xsd_string_base,
                     const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

glissando::glissando(const ::xml_schema::string &_xsd_string_base,
                     const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

glissando::glissando(const glissando &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, line_type_(x.line_type_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

glissando::glissando(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void glissando::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-type" && n.namespace_().empty()) {
      this->line_type_.set(line_type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

glissando *glissando::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class glissando(*this, f, c);
}

glissando &glissando::operator=(const glissando &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->line_type_ = x.line_type_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

glissando::~glissando() {}

// grace
//

grace::grace()
: ::xml_schema::type()
, steal_time_previous_(this)
, steal_time_following_(this)
, make_time_(this)
, slash_(this) {}

grace::grace(const grace &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, steal_time_previous_(x.steal_time_previous_, f, this)
, steal_time_following_(x.steal_time_following_, f, this)
, make_time_(x.make_time_, f, this)
, slash_(x.slash_, f, this) {}

grace::grace(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, steal_time_previous_(this)
, steal_time_following_(this)
, make_time_(this)
, slash_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void grace::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "steal-time-previous" && n.namespace_().empty()) {
      this->steal_time_previous_.set(
        steal_time_previous_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "steal-time-following" && n.namespace_().empty()) {
      this->steal_time_following_.set(
        steal_time_following_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "make-time" && n.namespace_().empty()) {
      this->make_time_.set(make_time_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "slash" && n.namespace_().empty()) {
      this->slash_.set(slash_traits::create(i, f, this));
      continue;
    }
  }
}

grace *grace::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class grace(*this, f, c);
}

grace &grace::operator=(const grace &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->steal_time_previous_ = x.steal_time_previous_;
    this->steal_time_following_ = x.steal_time_following_;
    this->make_time_ = x.make_time_;
    this->slash_ = x.slash_;
  }

  return *this;
}

grace::~grace() {}

// hammer_on_pull_off
//

hammer_on_pull_off::hammer_on_pull_off(const type_type &type)
: ::xml_schema::string()
, type_(type, this)
, number_(number_default_value(), this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

hammer_on_pull_off::hammer_on_pull_off(const char *_xsd_string_base,
                                       const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

hammer_on_pull_off::hammer_on_pull_off(const ::std::string &_xsd_string_base,
                                       const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

hammer_on_pull_off::hammer_on_pull_off(
  const ::xml_schema::string &_xsd_string_base, const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

hammer_on_pull_off::hammer_on_pull_off(const hammer_on_pull_off &x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

hammer_on_pull_off::hammer_on_pull_off(const ::xercesc::DOMElement &e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void hammer_on_pull_off::parse(::xsd::cxx::xml::dom::parser<char> &p,
                               ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

hammer_on_pull_off *
hammer_on_pull_off::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class hammer_on_pull_off(*this, f, c);
}

hammer_on_pull_off &hammer_on_pull_off::operator=(const hammer_on_pull_off &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

hammer_on_pull_off::~hammer_on_pull_off() {}

// handbell
//

handbell::handbell(::musicxml::handbell_value::value _xsd_handbell_value_base)
: ::musicxml::handbell_value(_xsd_handbell_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

handbell::handbell(const char *_xsd_string_base)
: ::musicxml::handbell_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

handbell::handbell(const ::std::string &_xsd_string_base)
: ::musicxml::handbell_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

handbell::handbell(const ::musicxml::handbell_value &_xsd_handbell_value_base)
: ::musicxml::handbell_value(_xsd_handbell_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

handbell::handbell(const handbell &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::musicxml::handbell_value(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

handbell::handbell(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::musicxml::handbell_value(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void handbell::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

handbell *handbell::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class handbell(*this, f, c);
}

handbell &handbell::operator=(const handbell &x) {
  if (this != &x) {
    static_cast<::musicxml::handbell_value &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

handbell::~handbell() {}

// harmonic
//

harmonic::harmonic()
: ::xml_schema::type()
, natural_(this)
, artificial_(this)
, base_pitch_(this)
, touching_pitch_(this)
, sounding_pitch_(this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

harmonic::harmonic(const harmonic &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, natural_(x.natural_, f, this)
, artificial_(x.artificial_, f, this)
, base_pitch_(x.base_pitch_, f, this)
, touching_pitch_(x.touching_pitch_, f, this)
, sounding_pitch_(x.sounding_pitch_, f, this)
, print_object_(x.print_object_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

harmonic::harmonic(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, natural_(this)
, artificial_(this)
, base_pitch_(this)
, touching_pitch_(this)
, sounding_pitch_(this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void harmonic::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // natural
    //
    if (n.name() == "natural" && n.namespace_().empty()) {
      ::std::unique_ptr<natural_type> r(natural_traits::create(i, f, this));

      if (!this->natural_) {
        this->natural_.set(::std::move(r));
        continue;
      }
    }

    // artificial
    //
    if (n.name() == "artificial" && n.namespace_().empty()) {
      ::std::unique_ptr<artificial_type> r(
        artificial_traits::create(i, f, this));

      if (!this->artificial_) {
        this->artificial_.set(::std::move(r));
        continue;
      }
    }

    // base-pitch
    //
    if (n.name() == "base-pitch" && n.namespace_().empty()) {
      ::std::unique_ptr<base_pitch_type> r(
        base_pitch_traits::create(i, f, this));

      if (!this->base_pitch_) {
        this->base_pitch_.set(::std::move(r));
        continue;
      }
    }

    // touching-pitch
    //
    if (n.name() == "touching-pitch" && n.namespace_().empty()) {
      ::std::unique_ptr<touching_pitch_type> r(
        touching_pitch_traits::create(i, f, this));

      if (!this->touching_pitch_) {
        this->touching_pitch_.set(::std::move(r));
        continue;
      }
    }

    // sounding-pitch
    //
    if (n.name() == "sounding-pitch" && n.namespace_().empty()) {
      ::std::unique_ptr<sounding_pitch_type> r(
        sounding_pitch_traits::create(i, f, this));

      if (!this->sounding_pitch_) {
        this->sounding_pitch_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

harmonic *harmonic::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class harmonic(*this, f, c);
}

harmonic &harmonic::operator=(const harmonic &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->natural_ = x.natural_;
    this->artificial_ = x.artificial_;
    this->base_pitch_ = x.base_pitch_;
    this->touching_pitch_ = x.touching_pitch_;
    this->sounding_pitch_ = x.sounding_pitch_;
    this->print_object_ = x.print_object_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

harmonic::~harmonic() {}

// heel_toe
//

heel_toe::heel_toe() : ::musicxml::empty_placement(), substitution_(this) {}

heel_toe::heel_toe(const heel_toe &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::musicxml::empty_placement(x, f, c)
, substitution_(x.substitution_, f, this) {}

heel_toe::heel_toe(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::musicxml::empty_placement(e, f | ::xml_schema::flags::base, c)
, substitution_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void heel_toe::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  this->::musicxml::empty_placement::parse(p, f);

  p.reset_attributes();

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "substitution" && n.namespace_().empty()) {
      this->substitution_.set(substitution_traits::create(i, f, this));
      continue;
    }
  }
}

heel_toe *heel_toe::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class heel_toe(*this, f, c);
}

heel_toe &heel_toe::operator=(const heel_toe &x) {
  if (this != &x) {
    static_cast<::musicxml::empty_placement &>(*this) = x;
    this->substitution_ = x.substitution_;
  }

  return *this;
}

heel_toe::~heel_toe() {}

// hole
//

hole::hole(const hole_closed_type &hole_closed)
: ::xml_schema::type()
, hole_type_(this)
, hole_closed_(hole_closed, this)
, hole_shape_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

hole::hole(::std::unique_ptr<hole_closed_type> hole_closed)
: ::xml_schema::type()
, hole_type_(this)
, hole_closed_(std::move(hole_closed), this)
, hole_shape_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

hole::hole(const hole &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, hole_type_(x.hole_type_, f, this)
, hole_closed_(x.hole_closed_, f, this)
, hole_shape_(x.hole_shape_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

hole::hole(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, hole_type_(this)
, hole_closed_(this)
, hole_shape_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void hole::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // hole-type
    //
    if (n.name() == "hole-type" && n.namespace_().empty()) {
      ::std::unique_ptr<hole_type_type> r(hole_type_traits::create(i, f, this));

      if (!this->hole_type_) {
        this->hole_type_.set(::std::move(r));
        continue;
      }
    }

    // hole-closed
    //
    if (n.name() == "hole-closed" && n.namespace_().empty()) {
      ::std::unique_ptr<hole_closed_type> r(
        hole_closed_traits::create(i, f, this));

      if (!hole_closed_.present()) {
        this->hole_closed_.set(::std::move(r));
        continue;
      }
    }

    // hole-shape
    //
    if (n.name() == "hole-shape" && n.namespace_().empty()) {
      ::std::unique_ptr<hole_shape_type> r(
        hole_shape_traits::create(i, f, this));

      if (!this->hole_shape_) {
        this->hole_shape_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!hole_closed_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("hole-closed", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

hole *hole::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class hole(*this, f, c);
}

hole &hole::operator=(const hole &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->hole_type_ = x.hole_type_;
    this->hole_closed_ = x.hole_closed_;
    this->hole_shape_ = x.hole_shape_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

hole::~hole() {}

// hole_closed
//

hole_closed::hole_closed(
  ::musicxml::hole_closed_value::value _xsd_hole_closed_value_base)
: ::musicxml::hole_closed_value(_xsd_hole_closed_value_base), location_(this) {}

hole_closed::hole_closed(const char *_xsd_string_base)
: ::musicxml::hole_closed_value(_xsd_string_base), location_(this) {}

hole_closed::hole_closed(const ::std::string &_xsd_string_base)
: ::musicxml::hole_closed_value(_xsd_string_base), location_(this) {}

hole_closed::hole_closed(
  const ::musicxml::hole_closed_value &_xsd_hole_closed_value_base)
: ::musicxml::hole_closed_value(_xsd_hole_closed_value_base), location_(this) {}

hole_closed::hole_closed(const hole_closed &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::hole_closed_value(x, f, c), location_(x.location_, f, this) {}

hole_closed::hole_closed(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::hole_closed_value(e, f | ::xml_schema::flags::base, c)
, location_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void hole_closed::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "location" && n.namespace_().empty()) {
      this->location_.set(location_traits::create(i, f, this));
      continue;
    }
  }
}

hole_closed *hole_closed::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class hole_closed(*this, f, c);
}

hole_closed &hole_closed::operator=(const hole_closed &x) {
  if (this != &x) {
    static_cast<::musicxml::hole_closed_value &>(*this) = x;
    this->location_ = x.location_;
  }

  return *this;
}

hole_closed::~hole_closed() {}

// instrument
//

instrument::instrument(const id_type &id)
: ::xml_schema::type(), id_(id, this) {}

instrument::instrument(const instrument &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c), id_(x.id_, f, this) {}

instrument::instrument(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c), id_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void instrument::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }
  }

  if (!id_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("id", "");
  }
}

instrument *instrument::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class instrument(*this, f, c);
}

instrument &instrument::operator=(const instrument &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

instrument::~instrument() {}

// lyric
//

lyric::lyric()
: ::xml_schema::type()
, syllabic_(this)
, text_(this)
, elision_(this)
, extend_(this)
, laughing_(this)
, humming_(this)
, end_line_(this)
, end_paragraph_(this)
, footnote_(this)
, level_(this)
, number_(this)
, name_(this)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, color_(this)
, print_object_(this) {}

lyric::lyric(const lyric &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, syllabic_(x.syllabic_, f, this)
, text_(x.text_, f, this)
, elision_(x.elision_, f, this)
, extend_(x.extend_, f, this)
, laughing_(x.laughing_, f, this)
, humming_(x.humming_, f, this)
, end_line_(x.end_line_, f, this)
, end_paragraph_(x.end_paragraph_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, number_(x.number_, f, this)
, name_(x.name_, f, this)
, justify_(x.justify_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, placement_(x.placement_, f, this)
, color_(x.color_, f, this)
, print_object_(x.print_object_, f, this) {}

lyric::lyric(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, syllabic_(this)
, text_(this)
, elision_(this)
, extend_(this)
, laughing_(this)
, humming_(this)
, end_line_(this)
, end_paragraph_(this)
, footnote_(this)
, level_(this)
, number_(this)
, name_(this)
, justify_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, color_(this)
, print_object_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void lyric::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // syllabic
    //
    if (n.name() == "syllabic" && n.namespace_().empty()) {
      ::std::unique_ptr<syllabic_type> r(syllabic_traits::create(i, f, this));

      this->syllabic_.push_back(::std::move(r));
      continue;
    }

    // text
    //
    if (n.name() == "text" && n.namespace_().empty()) {
      ::std::unique_ptr<text_type> r(text_traits::create(i, f, this));

      this->text_.push_back(::std::move(r));
      continue;
    }

    // elision
    //
    if (n.name() == "elision" && n.namespace_().empty()) {
      ::std::unique_ptr<elision_type> r(elision_traits::create(i, f, this));

      this->elision_.push_back(::std::move(r));
      continue;
    }

    // extend
    //
    if (n.name() == "extend" && n.namespace_().empty()) {
      ::std::unique_ptr<extend_type> r(extend_traits::create(i, f, this));

      if (!this->extend_) {
        this->extend_.set(::std::move(r));
        continue;
      }
    }

    // laughing
    //
    if (n.name() == "laughing" && n.namespace_().empty()) {
      ::std::unique_ptr<laughing_type> r(laughing_traits::create(i, f, this));

      if (!this->laughing_) {
        this->laughing_.set(::std::move(r));
        continue;
      }
    }

    // humming
    //
    if (n.name() == "humming" && n.namespace_().empty()) {
      ::std::unique_ptr<humming_type> r(humming_traits::create(i, f, this));

      if (!this->humming_) {
        this->humming_.set(::std::move(r));
        continue;
      }
    }

    // end-line
    //
    if (n.name() == "end-line" && n.namespace_().empty()) {
      ::std::unique_ptr<end_line_type> r(end_line_traits::create(i, f, this));

      if (!this->end_line_) {
        this->end_line_.set(::std::move(r));
        continue;
      }
    }

    // end-paragraph
    //
    if (n.name() == "end-paragraph" && n.namespace_().empty()) {
      ::std::unique_ptr<end_paragraph_type> r(
        end_paragraph_traits::create(i, f, this));

      if (!this->end_paragraph_) {
        this->end_paragraph_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "justify" && n.namespace_().empty()) {
      this->justify_.set(justify_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }
  }
}

lyric *lyric::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class lyric(*this, f, c);
}

lyric &lyric::operator=(const lyric &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->syllabic_ = x.syllabic_;
    this->text_ = x.text_;
    this->elision_ = x.elision_;
    this->extend_ = x.extend_;
    this->laughing_ = x.laughing_;
    this->humming_ = x.humming_;
    this->end_line_ = x.end_line_;
    this->end_paragraph_ = x.end_paragraph_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->number_ = x.number_;
    this->name_ = x.name_;
    this->justify_ = x.justify_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->placement_ = x.placement_;
    this->color_ = x.color_;
    this->print_object_ = x.print_object_;
  }

  return *this;
}

lyric::~lyric() {}

// mordent
//

mordent::mordent()
: ::musicxml::empty_trill_sound()
, long__(this)
, approach_(this)
, departure_(this) {}

mordent::mordent(const mordent &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::musicxml::empty_trill_sound(x, f, c)
, long__(x.long__, f, this)
, approach_(x.approach_, f, this)
, departure_(x.departure_, f, this) {}

mordent::mordent(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::musicxml::empty_trill_sound(e, f | ::xml_schema::flags::base, c)
, long__(this)
, approach_(this)
, departure_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void mordent::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  this->::musicxml::empty_trill_sound::parse(p, f);

  p.reset_attributes();

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "long" && n.namespace_().empty()) {
      this->long__.set(long_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "approach" && n.namespace_().empty()) {
      this->approach_.set(approach_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "departure" && n.namespace_().empty()) {
      this->departure_.set(departure_traits::create(i, f, this));
      continue;
    }
  }
}

mordent *mordent::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class mordent(*this, f, c);
}

mordent &mordent::operator=(const mordent &x) {
  if (this != &x) {
    static_cast<::musicxml::empty_trill_sound &>(*this) = x;
    this->long__ = x.long__;
    this->approach_ = x.approach_;
    this->departure_ = x.departure_;
  }

  return *this;
}

mordent::~mordent() {}

// non_arpeggiate
//

non_arpeggiate::non_arpeggiate(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, number_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, color_(this) {}

non_arpeggiate::non_arpeggiate(const non_arpeggiate &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, placement_(x.placement_, f, this)
, color_(x.color_, f, this) {}

non_arpeggiate::non_arpeggiate(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void non_arpeggiate::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

non_arpeggiate *non_arpeggiate::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class non_arpeggiate(*this, f, c);
}

non_arpeggiate &non_arpeggiate::operator=(const non_arpeggiate &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->placement_ = x.placement_;
    this->color_ = x.color_;
  }

  return *this;
}

non_arpeggiate::~non_arpeggiate() {}

// notations
//

notations::notations()
: ::xml_schema::type()
, footnote_(this)
, level_(this)
, tied_(this)
, slur_(this)
, tuplet_(this)
, glissando_(this)
, slide_(this)
, ornaments_(this)
, technical_(this)
, articulations_(this)
, dynamics_(this)
, fermata_(this)
, arpeggiate_(this)
, non_arpeggiate_(this)
, accidental_mark_(this)
, other_notation_(this)
, print_object_(this) {}

notations::notations(const notations &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, tied_(x.tied_, f, this)
, slur_(x.slur_, f, this)
, tuplet_(x.tuplet_, f, this)
, glissando_(x.glissando_, f, this)
, slide_(x.slide_, f, this)
, ornaments_(x.ornaments_, f, this)
, technical_(x.technical_, f, this)
, articulations_(x.articulations_, f, this)
, dynamics_(x.dynamics_, f, this)
, fermata_(x.fermata_, f, this)
, arpeggiate_(x.arpeggiate_, f, this)
, non_arpeggiate_(x.non_arpeggiate_, f, this)
, accidental_mark_(x.accidental_mark_, f, this)
, other_notation_(x.other_notation_, f, this)
, print_object_(x.print_object_, f, this) {}

notations::notations(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, footnote_(this)
, level_(this)
, tied_(this)
, slur_(this)
, tuplet_(this)
, glissando_(this)
, slide_(this)
, ornaments_(this)
, technical_(this)
, articulations_(this)
, dynamics_(this)
, fermata_(this)
, arpeggiate_(this)
, non_arpeggiate_(this)
, accidental_mark_(this)
, other_notation_(this)
, print_object_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void notations::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    // tied
    //
    if (n.name() == "tied" && n.namespace_().empty()) {
      ::std::unique_ptr<tied_type> r(tied_traits::create(i, f, this));

      this->tied_.push_back(::std::move(r));
      continue;
    }

    // slur
    //
    if (n.name() == "slur" && n.namespace_().empty()) {
      ::std::unique_ptr<slur_type> r(slur_traits::create(i, f, this));

      this->slur_.push_back(::std::move(r));
      continue;
    }

    // tuplet
    //
    if (n.name() == "tuplet" && n.namespace_().empty()) {
      ::std::unique_ptr<tuplet_type> r(tuplet_traits::create(i, f, this));

      this->tuplet_.push_back(::std::move(r));
      continue;
    }

    // glissando
    //
    if (n.name() == "glissando" && n.namespace_().empty()) {
      ::std::unique_ptr<glissando_type> r(glissando_traits::create(i, f, this));

      this->glissando_.push_back(::std::move(r));
      continue;
    }

    // slide
    //
    if (n.name() == "slide" && n.namespace_().empty()) {
      ::std::unique_ptr<slide_type> r(slide_traits::create(i, f, this));

      this->slide_.push_back(::std::move(r));
      continue;
    }

    // ornaments
    //
    if (n.name() == "ornaments" && n.namespace_().empty()) {
      ::std::unique_ptr<ornaments_type> r(ornaments_traits::create(i, f, this));

      this->ornaments_.push_back(::std::move(r));
      continue;
    }

    // technical
    //
    if (n.name() == "technical" && n.namespace_().empty()) {
      ::std::unique_ptr<technical_type> r(technical_traits::create(i, f, this));

      this->technical_.push_back(::std::move(r));
      continue;
    }

    // articulations
    //
    if (n.name() == "articulations" && n.namespace_().empty()) {
      ::std::unique_ptr<articulations_type> r(
        articulations_traits::create(i, f, this));

      this->articulations_.push_back(::std::move(r));
      continue;
    }

    // dynamics
    //
    if (n.name() == "dynamics" && n.namespace_().empty()) {
      ::std::unique_ptr<dynamics_type> r(dynamics_traits::create(i, f, this));

      this->dynamics_.push_back(::std::move(r));
      continue;
    }

    // fermata
    //
    if (n.name() == "fermata" && n.namespace_().empty()) {
      ::std::unique_ptr<fermata_type> r(fermata_traits::create(i, f, this));

      this->fermata_.push_back(::std::move(r));
      continue;
    }

    // arpeggiate
    //
    if (n.name() == "arpeggiate" && n.namespace_().empty()) {
      ::std::unique_ptr<arpeggiate_type> r(
        arpeggiate_traits::create(i, f, this));

      this->arpeggiate_.push_back(::std::move(r));
      continue;
    }

    // non-arpeggiate
    //
    if (n.name() == "non-arpeggiate" && n.namespace_().empty()) {
      ::std::unique_ptr<non_arpeggiate_type> r(
        non_arpeggiate_traits::create(i, f, this));

      this->non_arpeggiate_.push_back(::std::move(r));
      continue;
    }

    // accidental-mark
    //
    if (n.name() == "accidental-mark" && n.namespace_().empty()) {
      ::std::unique_ptr<accidental_mark_type> r(
        accidental_mark_traits::create(i, f, this));

      this->accidental_mark_.push_back(::std::move(r));
      continue;
    }

    // other-notation
    //
    if (n.name() == "other-notation" && n.namespace_().empty()) {
      ::std::unique_ptr<other_notation_type> r(
        other_notation_traits::create(i, f, this));

      this->other_notation_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }
  }
}

notations *notations::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class notations(*this, f, c);
}

notations &notations::operator=(const notations &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->tied_ = x.tied_;
    this->slur_ = x.slur_;
    this->tuplet_ = x.tuplet_;
    this->glissando_ = x.glissando_;
    this->slide_ = x.slide_;
    this->ornaments_ = x.ornaments_;
    this->technical_ = x.technical_;
    this->articulations_ = x.articulations_;
    this->dynamics_ = x.dynamics_;
    this->fermata_ = x.fermata_;
    this->arpeggiate_ = x.arpeggiate_;
    this->non_arpeggiate_ = x.non_arpeggiate_;
    this->accidental_mark_ = x.accidental_mark_;
    this->other_notation_ = x.other_notation_;
    this->print_object_ = x.print_object_;
  }

  return *this;
}

notations::~notations() {}

// note
//

note::note()
: ::xml_schema::type()
, grace_(this)
, chord_(this)
, pitch_(this)
, unpitched_(this)
, rest_(this)
, tie_(this)
, cue_(this)
, duration_(this)
, instrument_(this)
, footnote_(this)
, level_(this)
, voice_(this)
, type_(this)
, dot_(this)
, accidental_(this)
, time_modification_(this)
, stem_(this)
, notehead_(this)
, notehead_text_(this)
, staff_(this)
, beam_(this)
, notations_(this)
, lyric_(this)
, play_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, print_dot_(this)
, print_spacing_(this)
, print_lyric_(this)
, dynamics_(this)
, end_dynamics_(this)
, attack_(this)
, release_(this)
, time_only_(this)
, pizzicato_(this) {}

note::note(const note &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, grace_(x.grace_, f, this)
, chord_(x.chord_, f, this)
, pitch_(x.pitch_, f, this)
, unpitched_(x.unpitched_, f, this)
, rest_(x.rest_, f, this)
, tie_(x.tie_, f, this)
, cue_(x.cue_, f, this)
, duration_(x.duration_, f, this)
, instrument_(x.instrument_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, voice_(x.voice_, f, this)
, type_(x.type_, f, this)
, dot_(x.dot_, f, this)
, accidental_(x.accidental_, f, this)
, time_modification_(x.time_modification_, f, this)
, stem_(x.stem_, f, this)
, notehead_(x.notehead_, f, this)
, notehead_text_(x.notehead_text_, f, this)
, staff_(x.staff_, f, this)
, beam_(x.beam_, f, this)
, notations_(x.notations_, f, this)
, lyric_(x.lyric_, f, this)
, play_(x.play_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, print_object_(x.print_object_, f, this)
, print_dot_(x.print_dot_, f, this)
, print_spacing_(x.print_spacing_, f, this)
, print_lyric_(x.print_lyric_, f, this)
, dynamics_(x.dynamics_, f, this)
, end_dynamics_(x.end_dynamics_, f, this)
, attack_(x.attack_, f, this)
, release_(x.release_, f, this)
, time_only_(x.time_only_, f, this)
, pizzicato_(x.pizzicato_, f, this) {}

note::note(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, grace_(this)
, chord_(this)
, pitch_(this)
, unpitched_(this)
, rest_(this)
, tie_(this)
, cue_(this)
, duration_(this)
, instrument_(this)
, footnote_(this)
, level_(this)
, voice_(this)
, type_(this)
, dot_(this)
, accidental_(this)
, time_modification_(this)
, stem_(this)
, notehead_(this)
, notehead_text_(this)
, staff_(this)
, beam_(this)
, notations_(this)
, lyric_(this)
, play_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, print_dot_(this)
, print_spacing_(this)
, print_lyric_(this)
, dynamics_(this)
, end_dynamics_(this)
, attack_(this)
, release_(this)
, time_only_(this)
, pizzicato_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void note::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // grace
    //
    if (n.name() == "grace" && n.namespace_().empty()) {
      ::std::unique_ptr<grace_type> r(grace_traits::create(i, f, this));

      if (!this->grace_) {
        this->grace_.set(::std::move(r));
        continue;
      }
    }

    // chord
    //
    if (n.name() == "chord" && n.namespace_().empty()) {
      ::std::unique_ptr<chord_type> r(chord_traits::create(i, f, this));

      if (!this->chord_) {
        this->chord_.set(::std::move(r));
        continue;
      }
    }

    // pitch
    //
    if (n.name() == "pitch" && n.namespace_().empty()) {
      ::std::unique_ptr<pitch_type> r(pitch_traits::create(i, f, this));

      if (!this->pitch_) {
        this->pitch_.set(::std::move(r));
        continue;
      }
    }

    // unpitched
    //
    if (n.name() == "unpitched" && n.namespace_().empty()) {
      ::std::unique_ptr<unpitched_type> r(unpitched_traits::create(i, f, this));

      if (!this->unpitched_) {
        this->unpitched_.set(::std::move(r));
        continue;
      }
    }

    // rest
    //
    if (n.name() == "rest" && n.namespace_().empty()) {
      ::std::unique_ptr<rest_type> r(rest_traits::create(i, f, this));

      if (!this->rest_) {
        this->rest_.set(::std::move(r));
        continue;
      }
    }

    // tie
    //
    if (n.name() == "tie" && n.namespace_().empty()) {
      ::std::unique_ptr<tie_type> r(tie_traits::create(i, f, this));

      this->tie_.push_back(::std::move(r));
      continue;
    }

    // cue
    //
    if (n.name() == "cue" && n.namespace_().empty()) {
      ::std::unique_ptr<cue_type> r(cue_traits::create(i, f, this));

      if (!this->cue_) {
        this->cue_.set(::std::move(r));
        continue;
      }
    }

    // duration
    //
    if (n.name() == "duration" && n.namespace_().empty()) {
      ::std::unique_ptr<duration_type> r(duration_traits::create(i, f, this));

      if (!this->duration_) {
        this->duration_.set(::std::move(r));
        continue;
      }
    }

    // instrument
    //
    if (n.name() == "instrument" && n.namespace_().empty()) {
      ::std::unique_ptr<instrument_type> r(
        instrument_traits::create(i, f, this));

      if (!this->instrument_) {
        this->instrument_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    // voice
    //
    if (n.name() == "voice" && n.namespace_().empty()) {
      ::std::unique_ptr<voice_type> r(voice_traits::create(i, f, this));

      if (!this->voice_) {
        this->voice_.set(::std::move(r));
        continue;
      }
    }

    // type
    //
    if (n.name() == "type" && n.namespace_().empty()) {
      ::std::unique_ptr<type_type> r(type_traits::create(i, f, this));

      if (!this->type_) {
        this->type_.set(::std::move(r));
        continue;
      }
    }

    // dot
    //
    if (n.name() == "dot" && n.namespace_().empty()) {
      ::std::unique_ptr<dot_type> r(dot_traits::create(i, f, this));

      this->dot_.push_back(::std::move(r));
      continue;
    }

    // accidental
    //
    if (n.name() == "accidental" && n.namespace_().empty()) {
      ::std::unique_ptr<accidental_type> r(
        accidental_traits::create(i, f, this));

      if (!this->accidental_) {
        this->accidental_.set(::std::move(r));
        continue;
      }
    }

    // time-modification
    //
    if (n.name() == "time-modification" && n.namespace_().empty()) {
      ::std::unique_ptr<time_modification_type> r(
        time_modification_traits::create(i, f, this));

      if (!this->time_modification_) {
        this->time_modification_.set(::std::move(r));
        continue;
      }
    }

    // stem
    //
    if (n.name() == "stem" && n.namespace_().empty()) {
      ::std::unique_ptr<stem_type> r(stem_traits::create(i, f, this));

      if (!this->stem_) {
        this->stem_.set(::std::move(r));
        continue;
      }
    }

    // notehead
    //
    if (n.name() == "notehead" && n.namespace_().empty()) {
      ::std::unique_ptr<notehead_type> r(notehead_traits::create(i, f, this));

      if (!this->notehead_) {
        this->notehead_.set(::std::move(r));
        continue;
      }
    }

    // notehead-text
    //
    if (n.name() == "notehead-text" && n.namespace_().empty()) {
      ::std::unique_ptr<notehead_text_type> r(
        notehead_text_traits::create(i, f, this));

      if (!this->notehead_text_) {
        this->notehead_text_.set(::std::move(r));
        continue;
      }
    }

    // staff
    //
    if (n.name() == "staff" && n.namespace_().empty()) {
      if (!this->staff_) {
        this->staff_.set(staff_traits::create(i, f, this));
        continue;
      }
    }

    // beam
    //
    if (n.name() == "beam" && n.namespace_().empty()) {
      ::std::unique_ptr<beam_type> r(beam_traits::create(i, f, this));

      this->beam_.push_back(::std::move(r));
      continue;
    }

    // notations
    //
    if (n.name() == "notations" && n.namespace_().empty()) {
      ::std::unique_ptr<notations_type> r(notations_traits::create(i, f, this));

      this->notations_.push_back(::std::move(r));
      continue;
    }

    // lyric
    //
    if (n.name() == "lyric" && n.namespace_().empty()) {
      ::std::unique_ptr<lyric_type> r(lyric_traits::create(i, f, this));

      this->lyric_.push_back(::std::move(r));
      continue;
    }

    // play
    //
    if (n.name() == "play" && n.namespace_().empty()) {
      ::std::unique_ptr<play_type> r(play_traits::create(i, f, this));

      if (!this->play_) {
        this->play_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-dot" && n.namespace_().empty()) {
      this->print_dot_.set(print_dot_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-spacing" && n.namespace_().empty()) {
      this->print_spacing_.set(print_spacing_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-lyric" && n.namespace_().empty()) {
      this->print_lyric_.set(print_lyric_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dynamics" && n.namespace_().empty()) {
      this->dynamics_.set(dynamics_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "end-dynamics" && n.namespace_().empty()) {
      this->end_dynamics_.set(end_dynamics_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "attack" && n.namespace_().empty()) {
      this->attack_.set(attack_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "release" && n.namespace_().empty()) {
      this->release_.set(release_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "time-only" && n.namespace_().empty()) {
      this->time_only_.set(time_only_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "pizzicato" && n.namespace_().empty()) {
      this->pizzicato_.set(pizzicato_traits::create(i, f, this));
      continue;
    }
  }
}

note *note::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class note(*this, f, c);
}

note &note::operator=(const note &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->grace_ = x.grace_;
    this->chord_ = x.chord_;
    this->pitch_ = x.pitch_;
    this->unpitched_ = x.unpitched_;
    this->rest_ = x.rest_;
    this->tie_ = x.tie_;
    this->cue_ = x.cue_;
    this->duration_ = x.duration_;
    this->instrument_ = x.instrument_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->voice_ = x.voice_;
    this->type_ = x.type_;
    this->dot_ = x.dot_;
    this->accidental_ = x.accidental_;
    this->time_modification_ = x.time_modification_;
    this->stem_ = x.stem_;
    this->notehead_ = x.notehead_;
    this->notehead_text_ = x.notehead_text_;
    this->staff_ = x.staff_;
    this->beam_ = x.beam_;
    this->notations_ = x.notations_;
    this->lyric_ = x.lyric_;
    this->play_ = x.play_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->print_object_ = x.print_object_;
    this->print_dot_ = x.print_dot_;
    this->print_spacing_ = x.print_spacing_;
    this->print_lyric_ = x.print_lyric_;
    this->dynamics_ = x.dynamics_;
    this->end_dynamics_ = x.end_dynamics_;
    this->attack_ = x.attack_;
    this->release_ = x.release_;
    this->time_only_ = x.time_only_;
    this->pizzicato_ = x.pizzicato_;
  }

  return *this;
}

note::~note() {}

// note_type
//

note_type::note_type(
  ::musicxml::note_type_value::value _xsd_note_type_value_base)
: ::musicxml::note_type_value(_xsd_note_type_value_base), size_(this) {}

note_type::note_type(const char *_xsd_string_base)
: ::musicxml::note_type_value(_xsd_string_base), size_(this) {}

note_type::note_type(const ::std::string &_xsd_string_base)
: ::musicxml::note_type_value(_xsd_string_base), size_(this) {}

note_type::note_type(
  const ::musicxml::note_type_value &_xsd_note_type_value_base)
: ::musicxml::note_type_value(_xsd_note_type_value_base), size_(this) {}

note_type::note_type(const note_type &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::musicxml::note_type_value(x, f, c), size_(x.size_, f, this) {}

note_type::note_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::musicxml::note_type_value(e, f | ::xml_schema::flags::base, c)
, size_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void note_type::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "size" && n.namespace_().empty()) {
      this->size_.set(size_traits::create(i, f, this));
      continue;
    }
  }
}

note_type *note_type::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class note_type(*this, f, c);
}

note_type &note_type::operator=(const note_type &x) {
  if (this != &x) {
    static_cast<::musicxml::note_type_value &>(*this) = x;
    this->size_ = x.size_;
  }

  return *this;
}

note_type::~note_type() {}

// notehead
//

notehead::notehead(::musicxml::notehead_value::value _xsd_notehead_value_base)
: ::musicxml::notehead_value(_xsd_notehead_value_base)
, filled_(this)
, parentheses_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

notehead::notehead(const char *_xsd_string_base)
: ::musicxml::notehead_value(_xsd_string_base)
, filled_(this)
, parentheses_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

notehead::notehead(const ::std::string &_xsd_string_base)
: ::musicxml::notehead_value(_xsd_string_base)
, filled_(this)
, parentheses_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

notehead::notehead(const ::musicxml::notehead_value &_xsd_notehead_value_base)
: ::musicxml::notehead_value(_xsd_notehead_value_base)
, filled_(this)
, parentheses_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

notehead::notehead(const notehead &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::musicxml::notehead_value(x, f, c)
, filled_(x.filled_, f, this)
, parentheses_(x.parentheses_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

notehead::notehead(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::musicxml::notehead_value(e, f | ::xml_schema::flags::base, c)
, filled_(this)
, parentheses_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void notehead::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "filled" && n.namespace_().empty()) {
      this->filled_.set(filled_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "parentheses" && n.namespace_().empty()) {
      this->parentheses_.set(parentheses_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

notehead *notehead::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class notehead(*this, f, c);
}

notehead &notehead::operator=(const notehead &x) {
  if (this != &x) {
    static_cast<::musicxml::notehead_value &>(*this) = x;
    this->filled_ = x.filled_;
    this->parentheses_ = x.parentheses_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

notehead::~notehead() {}

// notehead_text
//

notehead_text::notehead_text()
: ::xml_schema::type(), display_text_(this), accidental_text_(this) {}

notehead_text::notehead_text(const notehead_text &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, display_text_(x.display_text_, f, this)
, accidental_text_(x.accidental_text_, f, this) {}

notehead_text::notehead_text(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, display_text_(this)
, accidental_text_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void notehead_text::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // display-text
    //
    if (n.name() == "display-text" && n.namespace_().empty()) {
      ::std::unique_ptr<display_text_type> r(
        display_text_traits::create(i, f, this));

      this->display_text_.push_back(::std::move(r));
      continue;
    }

    // accidental-text
    //
    if (n.name() == "accidental-text" && n.namespace_().empty()) {
      ::std::unique_ptr<accidental_text_type> r(
        accidental_text_traits::create(i, f, this));

      this->accidental_text_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

notehead_text *notehead_text::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class notehead_text(*this, f, c);
}

notehead_text &notehead_text::operator=(const notehead_text &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->display_text_ = x.display_text_;
    this->accidental_text_ = x.accidental_text_;
  }

  return *this;
}

notehead_text::~notehead_text() {}

// ornaments
//

ornaments::ornaments()
: ::xml_schema::type()
, trill_mark_(this)
, turn_(this)
, delayed_turn_(this)
, inverted_turn_(this)
, delayed_inverted_turn_(this)
, vertical_turn_(this)
, shake_(this)
, wavy_line_(this)
, mordent_(this)
, inverted_mordent_(this)
, schleifer_(this)
, tremolo_(this)
, other_ornament_(this)
, accidental_mark_(this) {}

ornaments::ornaments(const ornaments &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, trill_mark_(x.trill_mark_, f, this)
, turn_(x.turn_, f, this)
, delayed_turn_(x.delayed_turn_, f, this)
, inverted_turn_(x.inverted_turn_, f, this)
, delayed_inverted_turn_(x.delayed_inverted_turn_, f, this)
, vertical_turn_(x.vertical_turn_, f, this)
, shake_(x.shake_, f, this)
, wavy_line_(x.wavy_line_, f, this)
, mordent_(x.mordent_, f, this)
, inverted_mordent_(x.inverted_mordent_, f, this)
, schleifer_(x.schleifer_, f, this)
, tremolo_(x.tremolo_, f, this)
, other_ornament_(x.other_ornament_, f, this)
, accidental_mark_(x.accidental_mark_, f, this) {}

ornaments::ornaments(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, trill_mark_(this)
, turn_(this)
, delayed_turn_(this)
, inverted_turn_(this)
, delayed_inverted_turn_(this)
, vertical_turn_(this)
, shake_(this)
, wavy_line_(this)
, mordent_(this)
, inverted_mordent_(this)
, schleifer_(this)
, tremolo_(this)
, other_ornament_(this)
, accidental_mark_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ornaments::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // trill-mark
    //
    if (n.name() == "trill-mark" && n.namespace_().empty()) {
      ::std::unique_ptr<trill_mark_type> r(
        trill_mark_traits::create(i, f, this));

      this->trill_mark_.push_back(::std::move(r));
      continue;
    }

    // turn
    //
    if (n.name() == "turn" && n.namespace_().empty()) {
      ::std::unique_ptr<turn_type> r(turn_traits::create(i, f, this));

      this->turn_.push_back(::std::move(r));
      continue;
    }

    // delayed-turn
    //
    if (n.name() == "delayed-turn" && n.namespace_().empty()) {
      ::std::unique_ptr<delayed_turn_type> r(
        delayed_turn_traits::create(i, f, this));

      this->delayed_turn_.push_back(::std::move(r));
      continue;
    }

    // inverted-turn
    //
    if (n.name() == "inverted-turn" && n.namespace_().empty()) {
      ::std::unique_ptr<inverted_turn_type> r(
        inverted_turn_traits::create(i, f, this));

      this->inverted_turn_.push_back(::std::move(r));
      continue;
    }

    // delayed-inverted-turn
    //
    if (n.name() == "delayed-inverted-turn" && n.namespace_().empty()) {
      ::std::unique_ptr<delayed_inverted_turn_type> r(
        delayed_inverted_turn_traits::create(i, f, this));

      this->delayed_inverted_turn_.push_back(::std::move(r));
      continue;
    }

    // vertical-turn
    //
    if (n.name() == "vertical-turn" && n.namespace_().empty()) {
      ::std::unique_ptr<vertical_turn_type> r(
        vertical_turn_traits::create(i, f, this));

      this->vertical_turn_.push_back(::std::move(r));
      continue;
    }

    // shake
    //
    if (n.name() == "shake" && n.namespace_().empty()) {
      ::std::unique_ptr<shake_type> r(shake_traits::create(i, f, this));

      this->shake_.push_back(::std::move(r));
      continue;
    }

    // wavy-line
    //
    if (n.name() == "wavy-line" && n.namespace_().empty()) {
      ::std::unique_ptr<wavy_line_type> r(wavy_line_traits::create(i, f, this));

      this->wavy_line_.push_back(::std::move(r));
      continue;
    }

    // mordent
    //
    if (n.name() == "mordent" && n.namespace_().empty()) {
      ::std::unique_ptr<mordent_type> r(mordent_traits::create(i, f, this));

      this->mordent_.push_back(::std::move(r));
      continue;
    }

    // inverted-mordent
    //
    if (n.name() == "inverted-mordent" && n.namespace_().empty()) {
      ::std::unique_ptr<inverted_mordent_type> r(
        inverted_mordent_traits::create(i, f, this));

      this->inverted_mordent_.push_back(::std::move(r));
      continue;
    }

    // schleifer
    //
    if (n.name() == "schleifer" && n.namespace_().empty()) {
      ::std::unique_ptr<schleifer_type> r(schleifer_traits::create(i, f, this));

      this->schleifer_.push_back(::std::move(r));
      continue;
    }

    // tremolo
    //
    if (n.name() == "tremolo" && n.namespace_().empty()) {
      ::std::unique_ptr<tremolo_type> r(tremolo_traits::create(i, f, this));

      this->tremolo_.push_back(::std::move(r));
      continue;
    }

    // other-ornament
    //
    if (n.name() == "other-ornament" && n.namespace_().empty()) {
      ::std::unique_ptr<other_ornament_type> r(
        other_ornament_traits::create(i, f, this));

      this->other_ornament_.push_back(::std::move(r));
      continue;
    }

    // accidental-mark
    //
    if (n.name() == "accidental-mark" && n.namespace_().empty()) {
      ::std::unique_ptr<accidental_mark_type> r(
        accidental_mark_traits::create(i, f, this));

      this->accidental_mark_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

ornaments *ornaments::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class ornaments(*this, f, c);
}

ornaments &ornaments::operator=(const ornaments &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->trill_mark_ = x.trill_mark_;
    this->turn_ = x.turn_;
    this->delayed_turn_ = x.delayed_turn_;
    this->inverted_turn_ = x.inverted_turn_;
    this->delayed_inverted_turn_ = x.delayed_inverted_turn_;
    this->vertical_turn_ = x.vertical_turn_;
    this->shake_ = x.shake_;
    this->wavy_line_ = x.wavy_line_;
    this->mordent_ = x.mordent_;
    this->inverted_mordent_ = x.inverted_mordent_;
    this->schleifer_ = x.schleifer_;
    this->tremolo_ = x.tremolo_;
    this->other_ornament_ = x.other_ornament_;
    this->accidental_mark_ = x.accidental_mark_;
  }

  return *this;
}

ornaments::~ornaments() {}

// other_notation
//

other_notation::other_notation(const type_type &type)
: ::xml_schema::string()
, type_(type, this)
, number_(number_default_value(), this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

other_notation::other_notation(const char *_xsd_string_base,
                               const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

other_notation::other_notation(const ::std::string &_xsd_string_base,
                               const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

other_notation::other_notation(const ::xml_schema::string &_xsd_string_base,
                               const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

other_notation::other_notation(const other_notation &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, print_object_(x.print_object_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

other_notation::other_notation(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, print_object_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void other_notation::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

other_notation *other_notation::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class other_notation(*this, f, c);
}

other_notation &other_notation::operator=(const other_notation &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->print_object_ = x.print_object_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

other_notation::~other_notation() {}

// pitch
//

pitch::pitch(const step_type &step, const octave_type &octave)
: ::xml_schema::type()
, step_(step, this)
, alter_(this)
, octave_(octave, this) {}

pitch::pitch(const pitch &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, step_(x.step_, f, this)
, alter_(x.alter_, f, this)
, octave_(x.octave_, f, this) {}

pitch::pitch(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, step_(this)
, alter_(this)
, octave_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void pitch::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // step
    //
    if (n.name() == "step" && n.namespace_().empty()) {
      ::std::unique_ptr<step_type> r(step_traits::create(i, f, this));

      if (!step_.present()) {
        this->step_.set(::std::move(r));
        continue;
      }
    }

    // alter
    //
    if (n.name() == "alter" && n.namespace_().empty()) {
      ::std::unique_ptr<alter_type> r(alter_traits::create(i, f, this));

      if (!this->alter_) {
        this->alter_.set(::std::move(r));
        continue;
      }
    }

    // octave
    //
    if (n.name() == "octave" && n.namespace_().empty()) {
      ::std::unique_ptr<octave_type> r(octave_traits::create(i, f, this));

      if (!octave_.present()) {
        this->octave_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!step_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("step", "");
  }

  if (!octave_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("octave", "");
  }
}

pitch *pitch::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class pitch(*this, f, c);
}

pitch &pitch::operator=(const pitch &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->step_ = x.step_;
    this->alter_ = x.alter_;
    this->octave_ = x.octave_;
  }

  return *this;
}

pitch::~pitch() {}

// placement_text
//

placement_text::placement_text()
: ::xml_schema::string()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

placement_text::placement_text(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

placement_text::placement_text(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

placement_text::placement_text(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

placement_text::placement_text(const placement_text &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

placement_text::placement_text(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void placement_text::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }
}

placement_text *placement_text::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class placement_text(*this, f, c);
}

placement_text &placement_text::operator=(const placement_text &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

placement_text::~placement_text() {}

// rest
//

rest::rest()
: ::xml_schema::type()
, display_step_(this)
, display_octave_(this)
, measure_(this) {}

rest::rest(const rest &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, display_step_(x.display_step_, f, this)
, display_octave_(x.display_octave_, f, this)
, measure_(x.measure_, f, this) {}

rest::rest(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, display_step_(this)
, display_octave_(this)
, measure_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void rest::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // display-step
    //
    if (n.name() == "display-step" && n.namespace_().empty()) {
      ::std::unique_ptr<display_step_type> r(
        display_step_traits::create(i, f, this));

      if (!this->display_step_) {
        this->display_step_.set(::std::move(r));
        continue;
      }
    }

    // display-octave
    //
    if (n.name() == "display-octave" && n.namespace_().empty()) {
      ::std::unique_ptr<display_octave_type> r(
        display_octave_traits::create(i, f, this));

      if (!this->display_octave_) {
        this->display_octave_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "measure" && n.namespace_().empty()) {
      this->measure_.set(measure_traits::create(i, f, this));
      continue;
    }
  }
}

rest *rest::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class rest(*this, f, c);
}

rest &rest::operator=(const rest &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->display_step_ = x.display_step_;
    this->display_octave_ = x.display_octave_;
    this->measure_ = x.measure_;
  }

  return *this;
}

rest::~rest() {}

// slide
//

slide::slide(const type_type &type)
: ::xml_schema::string()
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, accelerate_(this)
, beats_(this)
, first_beat_(this)
, last_beat_(this) {}

slide::slide(const char *_xsd_string_base, const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, accelerate_(this)
, beats_(this)
, first_beat_(this)
, last_beat_(this) {}

slide::slide(const ::std::string &_xsd_string_base, const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, accelerate_(this)
, beats_(this)
, first_beat_(this)
, last_beat_(this) {}

slide::slide(const ::xml_schema::string &_xsd_string_base,
             const type_type &type)
: ::xml_schema::string(_xsd_string_base)
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, accelerate_(this)
, beats_(this)
, first_beat_(this)
, last_beat_(this) {}

slide::slide(const slide &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, line_type_(x.line_type_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, accelerate_(x.accelerate_, f, this)
, beats_(x.beats_, f, this)
, first_beat_(x.first_beat_, f, this)
, last_beat_(x.last_beat_, f, this) {}

slide::slide(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, accelerate_(this)
, beats_(this)
, first_beat_(this)
, last_beat_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void slide::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-type" && n.namespace_().empty()) {
      this->line_type_.set(line_type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "accelerate" && n.namespace_().empty()) {
      this->accelerate_.set(accelerate_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "beats" && n.namespace_().empty()) {
      this->beats_.set(beats_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "first-beat" && n.namespace_().empty()) {
      this->first_beat_.set(first_beat_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "last-beat" && n.namespace_().empty()) {
      this->last_beat_.set(last_beat_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

slide *slide::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class slide(*this, f, c);
}

slide &slide::operator=(const slide &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->line_type_ = x.line_type_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->accelerate_ = x.accelerate_;
    this->beats_ = x.beats_;
    this->first_beat_ = x.first_beat_;
    this->last_beat_ = x.last_beat_;
  }

  return *this;
}

slide::~slide() {}

// slur
//

slur::slur(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, number_(number_default_value(), this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, orientation_(this)
, bezier_offset_(this)
, bezier_offset2_(this)
, bezier_x_(this)
, bezier_y_(this)
, bezier_x2_(this)
, bezier_y2_(this)
, color_(this) {}

slur::slur(const slur &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, line_type_(x.line_type_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, placement_(x.placement_, f, this)
, orientation_(x.orientation_, f, this)
, bezier_offset_(x.bezier_offset_, f, this)
, bezier_offset2_(x.bezier_offset2_, f, this)
, bezier_x_(x.bezier_x_, f, this)
, bezier_y_(x.bezier_y_, f, this)
, bezier_x2_(x.bezier_x2_, f, this)
, bezier_y2_(x.bezier_y2_, f, this)
, color_(x.color_, f, this) {}

slur::slur(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, orientation_(this)
, bezier_offset_(this)
, bezier_offset2_(this)
, bezier_x_(this)
, bezier_y_(this)
, bezier_x2_(this)
, bezier_y2_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void slur::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-type" && n.namespace_().empty()) {
      this->line_type_.set(line_type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "orientation" && n.namespace_().empty()) {
      this->orientation_.set(orientation_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-offset" && n.namespace_().empty()) {
      this->bezier_offset_.set(bezier_offset_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-offset2" && n.namespace_().empty()) {
      this->bezier_offset2_.set(bezier_offset2_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-x" && n.namespace_().empty()) {
      this->bezier_x_.set(bezier_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-y" && n.namespace_().empty()) {
      this->bezier_y_.set(bezier_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-x2" && n.namespace_().empty()) {
      this->bezier_x2_.set(bezier_x2_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-y2" && n.namespace_().empty()) {
      this->bezier_y2_.set(bezier_y2_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

slur *slur::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class slur(*this, f, c);
}

slur &slur::operator=(const slur &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->line_type_ = x.line_type_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->placement_ = x.placement_;
    this->orientation_ = x.orientation_;
    this->bezier_offset_ = x.bezier_offset_;
    this->bezier_offset2_ = x.bezier_offset2_;
    this->bezier_x_ = x.bezier_x_;
    this->bezier_y_ = x.bezier_y_;
    this->bezier_x2_ = x.bezier_x2_;
    this->bezier_y2_ = x.bezier_y2_;
    this->color_ = x.color_;
  }

  return *this;
}

slur::~slur() {}

// stem
//

stem::stem(::musicxml::stem_value::value _xsd_stem_value_base)
: ::musicxml::stem_value(_xsd_stem_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

stem::stem(const char *_xsd_string_base)
: ::musicxml::stem_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

stem::stem(const ::std::string &_xsd_string_base)
: ::musicxml::stem_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

stem::stem(const ::musicxml::stem_value &_xsd_stem_value_base)
: ::musicxml::stem_value(_xsd_stem_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

stem::stem(const stem &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::musicxml::stem_value(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, color_(x.color_, f, this) {}

stem::stem(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::musicxml::stem_value(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void stem::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

stem *stem::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class stem(*this, f, c);
}

stem &stem::operator=(const stem &x) {
  if (this != &x) {
    static_cast<::musicxml::stem_value &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->color_ = x.color_;
  }

  return *this;
}

stem::~stem() {}

// strong_accent
//

const strong_accent::type_type strong_accent::type_default_value_("up");

strong_accent::strong_accent()
: ::musicxml::empty_placement(), type_(type_default_value(), this) {}

strong_accent::strong_accent(const strong_accent &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::musicxml::empty_placement(x, f, c), type_(x.type_, f, this) {}

strong_accent::strong_accent(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::musicxml::empty_placement(e, f | ::xml_schema::flags::base, c)
, type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void strong_accent::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  this->::musicxml::empty_placement::parse(p, f);

  p.reset_attributes();

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) { this->type_.set(type_default_value()); }
}

strong_accent *strong_accent::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class strong_accent(*this, f, c);
}

strong_accent &strong_accent::operator=(const strong_accent &x) {
  if (this != &x) {
    static_cast<::musicxml::empty_placement &>(*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

strong_accent::~strong_accent() {}

// style_text
//

style_text::style_text()
: ::xml_schema::string()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

style_text::style_text(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

style_text::style_text(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

style_text::style_text(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

style_text::style_text(const style_text &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

style_text::style_text(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void style_text::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

style_text *style_text::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class style_text(*this, f, c);
}

style_text &style_text::operator=(const style_text &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

style_text::~style_text() {}

// technical
//

technical::technical()
: ::xml_schema::type()
, up_bow_(this)
, down_bow_(this)
, harmonic_(this)
, open_string_(this)
, thumb_position_(this)
, fingering_(this)
, pluck_(this)
, double_tongue_(this)
, triple_tongue_(this)
, stopped_(this)
, snap_pizzicato_(this)
, fret_(this)
, string_(this)
, hammer_on_(this)
, pull_off_(this)
, bend_(this)
, tap_(this)
, heel_(this)
, toe_(this)
, fingernails_(this)
, hole_(this)
, arrow_(this)
, handbell_(this)
, other_technical_(this) {}

technical::technical(const technical &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, up_bow_(x.up_bow_, f, this)
, down_bow_(x.down_bow_, f, this)
, harmonic_(x.harmonic_, f, this)
, open_string_(x.open_string_, f, this)
, thumb_position_(x.thumb_position_, f, this)
, fingering_(x.fingering_, f, this)
, pluck_(x.pluck_, f, this)
, double_tongue_(x.double_tongue_, f, this)
, triple_tongue_(x.triple_tongue_, f, this)
, stopped_(x.stopped_, f, this)
, snap_pizzicato_(x.snap_pizzicato_, f, this)
, fret_(x.fret_, f, this)
, string_(x.string_, f, this)
, hammer_on_(x.hammer_on_, f, this)
, pull_off_(x.pull_off_, f, this)
, bend_(x.bend_, f, this)
, tap_(x.tap_, f, this)
, heel_(x.heel_, f, this)
, toe_(x.toe_, f, this)
, fingernails_(x.fingernails_, f, this)
, hole_(x.hole_, f, this)
, arrow_(x.arrow_, f, this)
, handbell_(x.handbell_, f, this)
, other_technical_(x.other_technical_, f, this) {}

technical::technical(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, up_bow_(this)
, down_bow_(this)
, harmonic_(this)
, open_string_(this)
, thumb_position_(this)
, fingering_(this)
, pluck_(this)
, double_tongue_(this)
, triple_tongue_(this)
, stopped_(this)
, snap_pizzicato_(this)
, fret_(this)
, string_(this)
, hammer_on_(this)
, pull_off_(this)
, bend_(this)
, tap_(this)
, heel_(this)
, toe_(this)
, fingernails_(this)
, hole_(this)
, arrow_(this)
, handbell_(this)
, other_technical_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void technical::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // up-bow
    //
    if (n.name() == "up-bow" && n.namespace_().empty()) {
      ::std::unique_ptr<up_bow_type> r(up_bow_traits::create(i, f, this));

      this->up_bow_.push_back(::std::move(r));
      continue;
    }

    // down-bow
    //
    if (n.name() == "down-bow" && n.namespace_().empty()) {
      ::std::unique_ptr<down_bow_type> r(down_bow_traits::create(i, f, this));

      this->down_bow_.push_back(::std::move(r));
      continue;
    }

    // harmonic
    //
    if (n.name() == "harmonic" && n.namespace_().empty()) {
      ::std::unique_ptr<harmonic_type> r(harmonic_traits::create(i, f, this));

      this->harmonic_.push_back(::std::move(r));
      continue;
    }

    // open-string
    //
    if (n.name() == "open-string" && n.namespace_().empty()) {
      ::std::unique_ptr<open_string_type> r(
        open_string_traits::create(i, f, this));

      this->open_string_.push_back(::std::move(r));
      continue;
    }

    // thumb-position
    //
    if (n.name() == "thumb-position" && n.namespace_().empty()) {
      ::std::unique_ptr<thumb_position_type> r(
        thumb_position_traits::create(i, f, this));

      this->thumb_position_.push_back(::std::move(r));
      continue;
    }

    // fingering
    //
    if (n.name() == "fingering" && n.namespace_().empty()) {
      ::std::unique_ptr<fingering_type> r(fingering_traits::create(i, f, this));

      this->fingering_.push_back(::std::move(r));
      continue;
    }

    // pluck
    //
    if (n.name() == "pluck" && n.namespace_().empty()) {
      ::std::unique_ptr<pluck_type> r(pluck_traits::create(i, f, this));

      this->pluck_.push_back(::std::move(r));
      continue;
    }

    // double-tongue
    //
    if (n.name() == "double-tongue" && n.namespace_().empty()) {
      ::std::unique_ptr<double_tongue_type> r(
        double_tongue_traits::create(i, f, this));

      this->double_tongue_.push_back(::std::move(r));
      continue;
    }

    // triple-tongue
    //
    if (n.name() == "triple-tongue" && n.namespace_().empty()) {
      ::std::unique_ptr<triple_tongue_type> r(
        triple_tongue_traits::create(i, f, this));

      this->triple_tongue_.push_back(::std::move(r));
      continue;
    }

    // stopped
    //
    if (n.name() == "stopped" && n.namespace_().empty()) {
      ::std::unique_ptr<stopped_type> r(stopped_traits::create(i, f, this));

      this->stopped_.push_back(::std::move(r));
      continue;
    }

    // snap-pizzicato
    //
    if (n.name() == "snap-pizzicato" && n.namespace_().empty()) {
      ::std::unique_ptr<snap_pizzicato_type> r(
        snap_pizzicato_traits::create(i, f, this));

      this->snap_pizzicato_.push_back(::std::move(r));
      continue;
    }

    // fret
    //
    if (n.name() == "fret" && n.namespace_().empty()) {
      ::std::unique_ptr<fret_type> r(fret_traits::create(i, f, this));

      this->fret_.push_back(::std::move(r));
      continue;
    }

    // string
    //
    if (n.name() == "string" && n.namespace_().empty()) {
      ::std::unique_ptr<string_type> r(string_traits::create(i, f, this));

      this->string_.push_back(::std::move(r));
      continue;
    }

    // hammer-on
    //
    if (n.name() == "hammer-on" && n.namespace_().empty()) {
      ::std::unique_ptr<hammer_on_type> r(hammer_on_traits::create(i, f, this));

      this->hammer_on_.push_back(::std::move(r));
      continue;
    }

    // pull-off
    //
    if (n.name() == "pull-off" && n.namespace_().empty()) {
      ::std::unique_ptr<pull_off_type> r(pull_off_traits::create(i, f, this));

      this->pull_off_.push_back(::std::move(r));
      continue;
    }

    // bend
    //
    if (n.name() == "bend" && n.namespace_().empty()) {
      ::std::unique_ptr<bend_type> r(bend_traits::create(i, f, this));

      this->bend_.push_back(::std::move(r));
      continue;
    }

    // tap
    //
    if (n.name() == "tap" && n.namespace_().empty()) {
      ::std::unique_ptr<tap_type> r(tap_traits::create(i, f, this));

      this->tap_.push_back(::std::move(r));
      continue;
    }

    // heel
    //
    if (n.name() == "heel" && n.namespace_().empty()) {
      ::std::unique_ptr<heel_type> r(heel_traits::create(i, f, this));

      this->heel_.push_back(::std::move(r));
      continue;
    }

    // toe
    //
    if (n.name() == "toe" && n.namespace_().empty()) {
      ::std::unique_ptr<toe_type> r(toe_traits::create(i, f, this));

      this->toe_.push_back(::std::move(r));
      continue;
    }

    // fingernails
    //
    if (n.name() == "fingernails" && n.namespace_().empty()) {
      ::std::unique_ptr<fingernails_type> r(
        fingernails_traits::create(i, f, this));

      this->fingernails_.push_back(::std::move(r));
      continue;
    }

    // hole
    //
    if (n.name() == "hole" && n.namespace_().empty()) {
      ::std::unique_ptr<hole_type> r(hole_traits::create(i, f, this));

      this->hole_.push_back(::std::move(r));
      continue;
    }

    // arrow
    //
    if (n.name() == "arrow" && n.namespace_().empty()) {
      ::std::unique_ptr<arrow_type> r(arrow_traits::create(i, f, this));

      this->arrow_.push_back(::std::move(r));
      continue;
    }

    // handbell
    //
    if (n.name() == "handbell" && n.namespace_().empty()) {
      ::std::unique_ptr<handbell_type> r(handbell_traits::create(i, f, this));

      this->handbell_.push_back(::std::move(r));
      continue;
    }

    // other-technical
    //
    if (n.name() == "other-technical" && n.namespace_().empty()) {
      ::std::unique_ptr<other_technical_type> r(
        other_technical_traits::create(i, f, this));

      this->other_technical_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

technical *technical::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class technical(*this, f, c);
}

technical &technical::operator=(const technical &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->up_bow_ = x.up_bow_;
    this->down_bow_ = x.down_bow_;
    this->harmonic_ = x.harmonic_;
    this->open_string_ = x.open_string_;
    this->thumb_position_ = x.thumb_position_;
    this->fingering_ = x.fingering_;
    this->pluck_ = x.pluck_;
    this->double_tongue_ = x.double_tongue_;
    this->triple_tongue_ = x.triple_tongue_;
    this->stopped_ = x.stopped_;
    this->snap_pizzicato_ = x.snap_pizzicato_;
    this->fret_ = x.fret_;
    this->string_ = x.string_;
    this->hammer_on_ = x.hammer_on_;
    this->pull_off_ = x.pull_off_;
    this->bend_ = x.bend_;
    this->tap_ = x.tap_;
    this->heel_ = x.heel_;
    this->toe_ = x.toe_;
    this->fingernails_ = x.fingernails_;
    this->hole_ = x.hole_;
    this->arrow_ = x.arrow_;
    this->handbell_ = x.handbell_;
    this->other_technical_ = x.other_technical_;
  }

  return *this;
}

technical::~technical() {}

// text_element_data
//

text_element_data::text_element_data()
: ::xml_schema::string()
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {}

text_element_data::text_element_data(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {}

text_element_data::text_element_data(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {}

text_element_data::text_element_data(
  const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {}

text_element_data::text_element_data(const text_element_data &x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, underline_(x.underline_, f, this)
, overline_(x.overline_, f, this)
, line_through_(x.line_through_, f, this)
, rotation_(x.rotation_, f, this)
, letter_spacing_(x.letter_spacing_, f, this)
, lang_(x.lang_, f, this)
, dir_(x.dir_, f, this) {}

text_element_data::text_element_data(const ::xercesc::DOMElement &e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void text_element_data::parse(::xsd::cxx::xml::dom::parser<char> &p,
                              ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "underline" && n.namespace_().empty()) {
      this->underline_.set(underline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "overline" && n.namespace_().empty()) {
      this->overline_.set(overline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-through" && n.namespace_().empty()) {
      this->line_through_.set(line_through_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "rotation" && n.namespace_().empty()) {
      this->rotation_.set(rotation_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "letter-spacing" && n.namespace_().empty()) {
      this->letter_spacing_.set(letter_spacing_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "lang" &&
        n.namespace_() == "http://www.w3.org/XML/1998/namespace") {
      this->lang_.set(lang_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dir" && n.namespace_().empty()) {
      this->dir_.set(dir_traits::create(i, f, this));
      continue;
    }
  }
}

text_element_data *text_element_data::_clone(::xml_schema::flags f,
                                             ::xml_schema::container *c) const {
  return new class text_element_data(*this, f, c);
}

text_element_data &text_element_data::operator=(const text_element_data &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->underline_ = x.underline_;
    this->overline_ = x.overline_;
    this->line_through_ = x.line_through_;
    this->rotation_ = x.rotation_;
    this->letter_spacing_ = x.letter_spacing_;
    this->lang_ = x.lang_;
    this->dir_ = x.dir_;
  }

  return *this;
}

text_element_data::~text_element_data() {}

// text_font_color
//

text_font_color::text_font_color()
: ::xml_schema::string()
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {}

text_font_color::text_font_color(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {}

text_font_color::text_font_color(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {}

text_font_color::text_font_color(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {}

text_font_color::text_font_color(const text_font_color &x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, underline_(x.underline_, f, this)
, overline_(x.overline_, f, this)
, line_through_(x.line_through_, f, this)
, rotation_(x.rotation_, f, this)
, letter_spacing_(x.letter_spacing_, f, this)
, lang_(x.lang_, f, this)
, dir_(x.dir_, f, this) {}

text_font_color::text_font_color(const ::xercesc::DOMElement &e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, underline_(this)
, overline_(this)
, line_through_(this)
, rotation_(this)
, letter_spacing_(this)
, lang_(this)
, dir_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void text_font_color::parse(::xsd::cxx::xml::dom::parser<char> &p,
                            ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "underline" && n.namespace_().empty()) {
      this->underline_.set(underline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "overline" && n.namespace_().empty()) {
      this->overline_.set(overline_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-through" && n.namespace_().empty()) {
      this->line_through_.set(line_through_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "rotation" && n.namespace_().empty()) {
      this->rotation_.set(rotation_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "letter-spacing" && n.namespace_().empty()) {
      this->letter_spacing_.set(letter_spacing_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "lang" &&
        n.namespace_() == "http://www.w3.org/XML/1998/namespace") {
      this->lang_.set(lang_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dir" && n.namespace_().empty()) {
      this->dir_.set(dir_traits::create(i, f, this));
      continue;
    }
  }
}

text_font_color *text_font_color::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class text_font_color(*this, f, c);
}

text_font_color &text_font_color::operator=(const text_font_color &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->underline_ = x.underline_;
    this->overline_ = x.overline_;
    this->line_through_ = x.line_through_;
    this->rotation_ = x.rotation_;
    this->letter_spacing_ = x.letter_spacing_;
    this->lang_ = x.lang_;
    this->dir_ = x.dir_;
  }

  return *this;
}

text_font_color::~text_font_color() {}

// tie
//

tie::tie(const type_type &type)
: ::xml_schema::type(), type_(type, this), time_only_(this) {}

tie::tie(const tie &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, time_only_(x.time_only_, f, this) {}

tie::tie(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
         ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, time_only_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void tie::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "time-only" && n.namespace_().empty()) {
      this->time_only_.set(time_only_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

tie *tie::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class tie(*this, f, c);
}

tie &tie::operator=(const tie &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->time_only_ = x.time_only_;
  }

  return *this;
}

tie::~tie() {}

// tied
//

tied::tied(const type_type &type)
: ::xml_schema::type()
, type_(type, this)
, number_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, orientation_(this)
, bezier_offset_(this)
, bezier_offset2_(this)
, bezier_x_(this)
, bezier_y_(this)
, bezier_x2_(this)
, bezier_y2_(this)
, color_(this) {}

tied::tied(const tied &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, line_type_(x.line_type_, f, this)
, dash_length_(x.dash_length_, f, this)
, space_length_(x.space_length_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, placement_(x.placement_, f, this)
, orientation_(x.orientation_, f, this)
, bezier_offset_(x.bezier_offset_, f, this)
, bezier_offset2_(x.bezier_offset2_, f, this)
, bezier_x_(x.bezier_x_, f, this)
, bezier_y_(x.bezier_y_, f, this)
, bezier_x2_(x.bezier_x2_, f, this)
, bezier_y2_(x.bezier_y2_, f, this)
, color_(x.color_, f, this) {}

tied::tied(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, type_(this)
, number_(this)
, line_type_(this)
, dash_length_(this)
, space_length_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this)
, orientation_(this)
, bezier_offset_(this)
, bezier_offset2_(this)
, bezier_x_(this)
, bezier_y_(this)
, bezier_x2_(this)
, bezier_y2_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void tied::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-type" && n.namespace_().empty()) {
      this->line_type_.set(line_type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "dash-length" && n.namespace_().empty()) {
      this->dash_length_.set(dash_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "space-length" && n.namespace_().empty()) {
      this->space_length_.set(space_length_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "orientation" && n.namespace_().empty()) {
      this->orientation_.set(orientation_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-offset" && n.namespace_().empty()) {
      this->bezier_offset_.set(bezier_offset_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-offset2" && n.namespace_().empty()) {
      this->bezier_offset2_.set(bezier_offset2_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-x" && n.namespace_().empty()) {
      this->bezier_x_.set(bezier_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-y" && n.namespace_().empty()) {
      this->bezier_y_.set(bezier_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-x2" && n.namespace_().empty()) {
      this->bezier_x2_.set(bezier_x2_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bezier-y2" && n.namespace_().empty()) {
      this->bezier_y2_.set(bezier_y2_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

tied *tied::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class tied(*this, f, c);
}

tied &tied::operator=(const tied &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->line_type_ = x.line_type_;
    this->dash_length_ = x.dash_length_;
    this->space_length_ = x.space_length_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->placement_ = x.placement_;
    this->orientation_ = x.orientation_;
    this->bezier_offset_ = x.bezier_offset_;
    this->bezier_offset2_ = x.bezier_offset2_;
    this->bezier_x_ = x.bezier_x_;
    this->bezier_y_ = x.bezier_y_;
    this->bezier_x2_ = x.bezier_x2_;
    this->bezier_y2_ = x.bezier_y2_;
    this->color_ = x.color_;
  }

  return *this;
}

tied::~tied() {}

// tremolo
//

const tremolo::type_type tremolo::type_default_value_("single");

tremolo::tremolo(const ::xml_schema::integer &_xsd_integer_base)
: ::musicxml::tremolo_marks(_xsd_integer_base)
, type_(type_default_value(), this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {}

tremolo::tremolo(const tremolo &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::musicxml::tremolo_marks(x, f, c)
, type_(x.type_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, placement_(x.placement_, f, this) {}

tremolo::tremolo(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::musicxml::tremolo_marks(e, f | ::xml_schema::flags::base, c)
, type_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void tremolo::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) { this->type_.set(type_default_value()); }
}

tremolo *tremolo::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class tremolo(*this, f, c);
}

tremolo &tremolo::operator=(const tremolo &x) {
  if (this != &x) {
    static_cast<::musicxml::tremolo_marks &>(*this) = x;
    this->type_ = x.type_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->placement_ = x.placement_;
  }

  return *this;
}

tremolo::~tremolo() {}

// tuplet
//

tuplet::tuplet(const type_type &type)
: ::xml_schema::type()
, tuplet_actual_(this)
, tuplet_normal_(this)
, type_(type, this)
, number_(this)
, bracket_(this)
, show_number_(this)
, show_type_(this)
, line_shape_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this) {}

tuplet::tuplet(const tuplet &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, tuplet_actual_(x.tuplet_actual_, f, this)
, tuplet_normal_(x.tuplet_normal_, f, this)
, type_(x.type_, f, this)
, number_(x.number_, f, this)
, bracket_(x.bracket_, f, this)
, show_number_(x.show_number_, f, this)
, show_type_(x.show_type_, f, this)
, line_shape_(x.line_shape_, f, this)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, placement_(x.placement_, f, this) {}

tuplet::tuplet(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, tuplet_actual_(this)
, tuplet_normal_(this)
, type_(this)
, number_(this)
, bracket_(this)
, show_number_(this)
, show_type_(this)
, line_shape_(this)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, placement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void tuplet::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // tuplet-actual
    //
    if (n.name() == "tuplet-actual" && n.namespace_().empty()) {
      ::std::unique_ptr<tuplet_actual_type> r(
        tuplet_actual_traits::create(i, f, this));

      if (!this->tuplet_actual_) {
        this->tuplet_actual_.set(::std::move(r));
        continue;
      }
    }

    // tuplet-normal
    //
    if (n.name() == "tuplet-normal" && n.namespace_().empty()) {
      ::std::unique_ptr<tuplet_normal_type> r(
        tuplet_normal_traits::create(i, f, this));

      if (!this->tuplet_normal_) {
        this->tuplet_normal_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "bracket" && n.namespace_().empty()) {
      this->bracket_.set(bracket_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "show-number" && n.namespace_().empty()) {
      this->show_number_.set(show_number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "show-type" && n.namespace_().empty()) {
      this->show_type_.set(show_type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "line-shape" && n.namespace_().empty()) {
      this->line_shape_.set(line_shape_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "placement" && n.namespace_().empty()) {
      this->placement_.set(placement_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }
}

tuplet *tuplet::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class tuplet(*this, f, c);
}

tuplet &tuplet::operator=(const tuplet &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->tuplet_actual_ = x.tuplet_actual_;
    this->tuplet_normal_ = x.tuplet_normal_;
    this->type_ = x.type_;
    this->number_ = x.number_;
    this->bracket_ = x.bracket_;
    this->show_number_ = x.show_number_;
    this->show_type_ = x.show_type_;
    this->line_shape_ = x.line_shape_;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->placement_ = x.placement_;
  }

  return *this;
}

tuplet::~tuplet() {}

// tuplet_dot
//

tuplet_dot::tuplet_dot()
: ::xml_schema::type()
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

tuplet_dot::tuplet_dot(const tuplet_dot &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

tuplet_dot::tuplet_dot(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void tuplet_dot::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

tuplet_dot *tuplet_dot::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class tuplet_dot(*this, f, c);
}

tuplet_dot &tuplet_dot::operator=(const tuplet_dot &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

tuplet_dot::~tuplet_dot() {}

// tuplet_number
//

tuplet_number::tuplet_number(
  const ::xml_schema::non_negative_integer &_xsd_non_negative_integer_base)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(
    _xsd_non_negative_integer_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

tuplet_number::tuplet_number(const tuplet_number &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(x, f, c)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

tuplet_number::tuplet_number(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::xsd::cxx::tree::fundamental_base<::xml_schema::non_negative_integer, char,
                                     ::xml_schema::simple_type>(
    e, f | ::xml_schema::flags::base, c)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void tuplet_number::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

tuplet_number *tuplet_number::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class tuplet_number(*this, f, c);
}

tuplet_number &tuplet_number::operator=(const tuplet_number &x) {
  if (this != &x) {
    static_cast<::xsd::cxx::tree::fundamental_base<
      ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(
      *this) = x;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

tuplet_number::~tuplet_number() {}

// tuplet_portion
//

tuplet_portion::tuplet_portion()
: ::xml_schema::type()
, tuplet_number_(this)
, tuplet_type_(this)
, tuplet_dot_(this) {}

tuplet_portion::tuplet_portion(const tuplet_portion &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, tuplet_number_(x.tuplet_number_, f, this)
, tuplet_type_(x.tuplet_type_, f, this)
, tuplet_dot_(x.tuplet_dot_, f, this) {}

tuplet_portion::tuplet_portion(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, tuplet_number_(this)
, tuplet_type_(this)
, tuplet_dot_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void tuplet_portion::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // tuplet-number
    //
    if (n.name() == "tuplet-number" && n.namespace_().empty()) {
      ::std::unique_ptr<tuplet_number_type> r(
        tuplet_number_traits::create(i, f, this));

      if (!this->tuplet_number_) {
        this->tuplet_number_.set(::std::move(r));
        continue;
      }
    }

    // tuplet-type
    //
    if (n.name() == "tuplet-type" && n.namespace_().empty()) {
      ::std::unique_ptr<tuplet_type_type> r(
        tuplet_type_traits::create(i, f, this));

      if (!this->tuplet_type_) {
        this->tuplet_type_.set(::std::move(r));
        continue;
      }
    }

    // tuplet-dot
    //
    if (n.name() == "tuplet-dot" && n.namespace_().empty()) {
      ::std::unique_ptr<tuplet_dot_type> r(
        tuplet_dot_traits::create(i, f, this));

      this->tuplet_dot_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

tuplet_portion *tuplet_portion::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class tuplet_portion(*this, f, c);
}

tuplet_portion &tuplet_portion::operator=(const tuplet_portion &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->tuplet_number_ = x.tuplet_number_;
    this->tuplet_type_ = x.tuplet_type_;
    this->tuplet_dot_ = x.tuplet_dot_;
  }

  return *this;
}

tuplet_portion::~tuplet_portion() {}

// tuplet_type
//

tuplet_type::tuplet_type(
  ::musicxml::note_type_value::value _xsd_note_type_value_base)
: ::musicxml::note_type_value(_xsd_note_type_value_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

tuplet_type::tuplet_type(const char *_xsd_string_base)
: ::musicxml::note_type_value(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

tuplet_type::tuplet_type(const ::std::string &_xsd_string_base)
: ::musicxml::note_type_value(_xsd_string_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

tuplet_type::tuplet_type(
  const ::musicxml::note_type_value &_xsd_note_type_value_base)
: ::musicxml::note_type_value(_xsd_note_type_value_base)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {}

tuplet_type::tuplet_type(const tuplet_type &x, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::note_type_value(x, f, c)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this) {}

tuplet_type::tuplet_type(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
: ::musicxml::note_type_value(e, f | ::xml_schema::flags::base, c)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void tuplet_type::parse(::xsd::cxx::xml::dom::parser<char> &p,
                        ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

tuplet_type *tuplet_type::_clone(::xml_schema::flags f,
                                 ::xml_schema::container *c) const {
  return new class tuplet_type(*this, f, c);
}

tuplet_type &tuplet_type::operator=(const tuplet_type &x) {
  if (this != &x) {
    static_cast<::musicxml::note_type_value &>(*this) = x;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
  }

  return *this;
}

tuplet_type::~tuplet_type() {}

// unpitched
//

unpitched::unpitched()
: ::xml_schema::type(), display_step_(this), display_octave_(this) {}

unpitched::unpitched(const unpitched &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, display_step_(x.display_step_, f, this)
, display_octave_(x.display_octave_, f, this) {}

unpitched::unpitched(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, display_step_(this)
, display_octave_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void unpitched::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // display-step
    //
    if (n.name() == "display-step" && n.namespace_().empty()) {
      ::std::unique_ptr<display_step_type> r(
        display_step_traits::create(i, f, this));

      if (!this->display_step_) {
        this->display_step_.set(::std::move(r));
        continue;
      }
    }

    // display-octave
    //
    if (n.name() == "display-octave" && n.namespace_().empty()) {
      ::std::unique_ptr<display_octave_type> r(
        display_octave_traits::create(i, f, this));

      if (!this->display_octave_) {
        this->display_octave_.set(::std::move(r));
        continue;
      }
    }

    break;
  }
}

unpitched *unpitched::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class unpitched(*this, f, c);
}

unpitched &unpitched::operator=(const unpitched &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->display_step_ = x.display_step_;
    this->display_octave_ = x.display_octave_;
  }

  return *this;
}

unpitched::~unpitched() {}

// credit
//

credit::credit()
: ::xml_schema::type()
, credit_type_(this)
, link_(this)
, bookmark_(this)
, credit_image_(this)
, credit_words_(this)
, page_(this) {}

credit::credit(const credit &x, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, credit_type_(x.credit_type_, f, this)
, link_(x.link_, f, this)
, bookmark_(x.bookmark_, f, this)
, credit_image_(x.credit_image_, f, this)
, credit_words_(x.credit_words_, f, this)
, page_(x.page_, f, this) {}

credit::credit(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, credit_type_(this)
, link_(this)
, bookmark_(this)
, credit_image_(this)
, credit_words_(this)
, page_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void credit::parse(::xsd::cxx::xml::dom::parser<char> &p,
                   ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // credit-type
    //
    if (n.name() == "credit-type" && n.namespace_().empty()) {
      ::std::unique_ptr<credit_type_type> r(
        credit_type_traits::create(i, f, this));

      this->credit_type_.push_back(::std::move(r));
      continue;
    }

    // link
    //
    if (n.name() == "link" && n.namespace_().empty()) {
      ::std::unique_ptr<link_type> r(link_traits::create(i, f, this));

      this->link_.push_back(::std::move(r));
      continue;
    }

    // bookmark
    //
    if (n.name() == "bookmark" && n.namespace_().empty()) {
      ::std::unique_ptr<bookmark_type> r(bookmark_traits::create(i, f, this));

      this->bookmark_.push_back(::std::move(r));
      continue;
    }

    // credit-image
    //
    if (n.name() == "credit-image" && n.namespace_().empty()) {
      ::std::unique_ptr<credit_image_type> r(
        credit_image_traits::create(i, f, this));

      if (!this->credit_image_) {
        this->credit_image_.set(::std::move(r));
        continue;
      }
    }

    // credit-words
    //
    if (n.name() == "credit-words" && n.namespace_().empty()) {
      ::std::unique_ptr<credit_words_type> r(
        credit_words_traits::create(i, f, this));

      this->credit_words_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "page" && n.namespace_().empty()) {
      this->page_.set(page_traits::create(i, f, this));
      continue;
    }
  }
}

credit *credit::_clone(::xml_schema::flags f,
                       ::xml_schema::container *c) const {
  return new class credit(*this, f, c);
}

credit &credit::operator=(const credit &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->credit_type_ = x.credit_type_;
    this->link_ = x.link_;
    this->bookmark_ = x.bookmark_;
    this->credit_image_ = x.credit_image_;
    this->credit_words_ = x.credit_words_;
    this->page_ = x.page_;
  }

  return *this;
}

credit::~credit() {}

// defaults
//

defaults::defaults()
: ::xml_schema::type()
, scaling_(this)
, page_layout_(this)
, system_layout_(this)
, staff_layout_(this)
, appearance_(this)
, music_font_(this)
, word_font_(this)
, lyric_font_(this)
, lyric_language_(this) {}

defaults::defaults(const defaults &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, scaling_(x.scaling_, f, this)
, page_layout_(x.page_layout_, f, this)
, system_layout_(x.system_layout_, f, this)
, staff_layout_(x.staff_layout_, f, this)
, appearance_(x.appearance_, f, this)
, music_font_(x.music_font_, f, this)
, word_font_(x.word_font_, f, this)
, lyric_font_(x.lyric_font_, f, this)
, lyric_language_(x.lyric_language_, f, this) {}

defaults::defaults(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, scaling_(this)
, page_layout_(this)
, system_layout_(this)
, staff_layout_(this)
, appearance_(this)
, music_font_(this)
, word_font_(this)
, lyric_font_(this)
, lyric_language_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void defaults::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // scaling
    //
    if (n.name() == "scaling" && n.namespace_().empty()) {
      ::std::unique_ptr<scaling_type> r(scaling_traits::create(i, f, this));

      if (!this->scaling_) {
        this->scaling_.set(::std::move(r));
        continue;
      }
    }

    // page-layout
    //
    if (n.name() == "page-layout" && n.namespace_().empty()) {
      ::std::unique_ptr<page_layout_type> r(
        page_layout_traits::create(i, f, this));

      if (!this->page_layout_) {
        this->page_layout_.set(::std::move(r));
        continue;
      }
    }

    // system-layout
    //
    if (n.name() == "system-layout" && n.namespace_().empty()) {
      ::std::unique_ptr<system_layout_type> r(
        system_layout_traits::create(i, f, this));

      if (!this->system_layout_) {
        this->system_layout_.set(::std::move(r));
        continue;
      }
    }

    // staff-layout
    //
    if (n.name() == "staff-layout" && n.namespace_().empty()) {
      ::std::unique_ptr<staff_layout_type> r(
        staff_layout_traits::create(i, f, this));

      this->staff_layout_.push_back(::std::move(r));
      continue;
    }

    // appearance
    //
    if (n.name() == "appearance" && n.namespace_().empty()) {
      ::std::unique_ptr<appearance_type> r(
        appearance_traits::create(i, f, this));

      if (!this->appearance_) {
        this->appearance_.set(::std::move(r));
        continue;
      }
    }

    // music-font
    //
    if (n.name() == "music-font" && n.namespace_().empty()) {
      ::std::unique_ptr<music_font_type> r(
        music_font_traits::create(i, f, this));

      if (!this->music_font_) {
        this->music_font_.set(::std::move(r));
        continue;
      }
    }

    // word-font
    //
    if (n.name() == "word-font" && n.namespace_().empty()) {
      ::std::unique_ptr<word_font_type> r(word_font_traits::create(i, f, this));

      if (!this->word_font_) {
        this->word_font_.set(::std::move(r));
        continue;
      }
    }

    // lyric-font
    //
    if (n.name() == "lyric-font" && n.namespace_().empty()) {
      ::std::unique_ptr<lyric_font_type> r(
        lyric_font_traits::create(i, f, this));

      this->lyric_font_.push_back(::std::move(r));
      continue;
    }

    // lyric-language
    //
    if (n.name() == "lyric-language" && n.namespace_().empty()) {
      ::std::unique_ptr<lyric_language_type> r(
        lyric_language_traits::create(i, f, this));

      this->lyric_language_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

defaults *defaults::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class defaults(*this, f, c);
}

defaults &defaults::operator=(const defaults &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->scaling_ = x.scaling_;
    this->page_layout_ = x.page_layout_;
    this->system_layout_ = x.system_layout_;
    this->staff_layout_ = x.staff_layout_;
    this->appearance_ = x.appearance_;
    this->music_font_ = x.music_font_;
    this->word_font_ = x.word_font_;
    this->lyric_font_ = x.lyric_font_;
    this->lyric_language_ = x.lyric_language_;
  }

  return *this;
}

defaults::~defaults() {}

// empty_font
//

empty_font::empty_font()
: ::xml_schema::type()
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {}

empty_font::empty_font(const empty_font &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this) {}

empty_font::empty_font(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void empty_font::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }
  }
}

empty_font *empty_font::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class empty_font(*this, f, c);
}

empty_font &empty_font::operator=(const empty_font &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
  }

  return *this;
}

empty_font::~empty_font() {}

// group_barline
//

group_barline::group_barline(
  ::musicxml::group_barline_value::value _xsd_group_barline_value_base)
: ::musicxml::group_barline_value(_xsd_group_barline_value_base)
, color_(this) {}

group_barline::group_barline(const char *_xsd_string_base)
: ::musicxml::group_barline_value(_xsd_string_base), color_(this) {}

group_barline::group_barline(const ::std::string &_xsd_string_base)
: ::musicxml::group_barline_value(_xsd_string_base), color_(this) {}

group_barline::group_barline(
  const ::musicxml::group_barline_value &_xsd_group_barline_value_base)
: ::musicxml::group_barline_value(_xsd_group_barline_value_base)
, color_(this) {}

group_barline::group_barline(const group_barline &x, ::xml_schema::flags f,
                             ::xml_schema::container *c)
: ::musicxml::group_barline_value(x, f, c), color_(x.color_, f, this) {}

group_barline::group_barline(const ::xercesc::DOMElement &e,
                             ::xml_schema::flags f, ::xml_schema::container *c)
: ::musicxml::group_barline_value(e, f | ::xml_schema::flags::base, c)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void group_barline::parse(::xsd::cxx::xml::dom::parser<char> &p,
                          ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

group_barline *group_barline::_clone(::xml_schema::flags f,
                                     ::xml_schema::container *c) const {
  return new class group_barline(*this, f, c);
}

group_barline &group_barline::operator=(const group_barline &x) {
  if (this != &x) {
    static_cast<::musicxml::group_barline_value &>(*this) = x;
    this->color_ = x.color_;
  }

  return *this;
}

group_barline::~group_barline() {}

// group_name
//

group_name::group_name()
: ::xml_schema::string()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, justify_(this) {}

group_name::group_name(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, justify_(this) {}

group_name::group_name(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, justify_(this) {}

group_name::group_name(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, justify_(this) {}

group_name::group_name(const group_name &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, justify_(x.justify_, f, this) {}

group_name::group_name(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, justify_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void group_name::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "justify" && n.namespace_().empty()) {
      this->justify_.set(justify_traits::create(i, f, this));
      continue;
    }
  }
}

group_name *group_name::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class group_name(*this, f, c);
}

group_name &group_name::operator=(const group_name &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->justify_ = x.justify_;
  }

  return *this;
}

group_name::~group_name() {}

// group_symbol
//

group_symbol::group_symbol(
  ::musicxml::group_symbol_value::value _xsd_group_symbol_value_base)
: ::musicxml::group_symbol_value(_xsd_group_symbol_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

group_symbol::group_symbol(const char *_xsd_string_base)
: ::musicxml::group_symbol_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

group_symbol::group_symbol(const ::std::string &_xsd_string_base)
: ::musicxml::group_symbol_value(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

group_symbol::group_symbol(
  const ::musicxml::group_symbol_value &_xsd_group_symbol_value_base)
: ::musicxml::group_symbol_value(_xsd_group_symbol_value_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {}

group_symbol::group_symbol(const group_symbol &x, ::xml_schema::flags f,
                           ::xml_schema::container *c)
: ::musicxml::group_symbol_value(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, color_(x.color_, f, this) {}

group_symbol::group_symbol(const ::xercesc::DOMElement &e,
                           ::xml_schema::flags f, ::xml_schema::container *c)
: ::musicxml::group_symbol_value(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, color_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void group_symbol::parse(::xsd::cxx::xml::dom::parser<char> &p,
                         ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }
  }
}

group_symbol *group_symbol::_clone(::xml_schema::flags f,
                                   ::xml_schema::container *c) const {
  return new class group_symbol(*this, f, c);
}

group_symbol &group_symbol::operator=(const group_symbol &x) {
  if (this != &x) {
    static_cast<::musicxml::group_symbol_value &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->color_ = x.color_;
  }

  return *this;
}

group_symbol::~group_symbol() {}

// lyric_font
//

lyric_font::lyric_font()
: ::xml_schema::type()
, number_(this)
, name_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {}

lyric_font::lyric_font(const lyric_font &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, number_(x.number_, f, this)
, name_(x.name_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this) {}

lyric_font::lyric_font(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, number_(this)
, name_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void lyric_font::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }
  }
}

lyric_font *lyric_font::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class lyric_font(*this, f, c);
}

lyric_font &lyric_font::operator=(const lyric_font &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->number_ = x.number_;
    this->name_ = x.name_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
  }

  return *this;
}

lyric_font::~lyric_font() {}

// lyric_language
//

lyric_language::lyric_language(const lang_type &lang)
: ::xml_schema::type(), number_(this), name_(this), lang_(lang, this) {}

lyric_language::lyric_language(const lyric_language &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, number_(x.number_, f, this)
, name_(x.name_, f, this)
, lang_(x.lang_, f, this) {}

lyric_language::lyric_language(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, number_(this)
, name_(this)
, lang_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void lyric_language::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "lang" &&
        n.namespace_() == "http://www.w3.org/XML/1998/namespace") {
      this->lang_.set(lang_traits::create(i, f, this));
      continue;
    }
  }

  if (!lang_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>(
      "lang", "http://www.w3.org/XML/1998/namespace");
  }
}

lyric_language *lyric_language::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class lyric_language(*this, f, c);
}

lyric_language &lyric_language::operator=(const lyric_language &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->number_ = x.number_;
    this->name_ = x.name_;
    this->lang_ = x.lang_;
  }

  return *this;
}

lyric_language::~lyric_language() {}

// opus
//

const opus::type_type opus::type_default_value_("simple");

const opus::show_type opus::show_default_value_("replace");

const opus::actuate_type opus::actuate_default_value_("onRequest");

opus::opus(const href_type &href)
: ::xml_schema::type()
, href_(href, this)
, type_(type_default_value(), this)
, role_(this)
, title_(this)
, show_(show_default_value(), this)
, actuate_(actuate_default_value(), this) {}

opus::opus(const opus &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, href_(x.href_, f, this)
, type_(x.type_, f, this)
, role_(x.role_, f, this)
, title_(x.title_, f, this)
, show_(x.show_, f, this)
, actuate_(x.actuate_, f, this) {}

opus::opus(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, href_(this)
, type_(this)
, role_(this)
, title_(this)
, show_(this)
, actuate_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void opus::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "href" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->href_.set(href_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "type" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "role" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->role_.set(role_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "title" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->title_.set(title_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "show" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->show_.set(show_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "actuate" &&
        n.namespace_() == "http://www.w3.org/1999/xlink") {
      this->actuate_.set(actuate_traits::create(i, f, this));
      continue;
    }
  }

  if (!href_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>(
      "href", "http://www.w3.org/1999/xlink");
  }

  if (!type_.present()) { this->type_.set(type_default_value()); }

  if (!show_.present()) { this->show_.set(show_default_value()); }

  if (!actuate_.present()) { this->actuate_.set(actuate_default_value()); }
}

opus *opus::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class opus(*this, f, c);
}

opus &opus::operator=(const opus &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->href_ = x.href_;
    this->type_ = x.type_;
    this->role_ = x.role_;
    this->title_ = x.title_;
    this->show_ = x.show_;
    this->actuate_ = x.actuate_;
  }

  return *this;
}

opus::~opus() {}

// part_group
//

const part_group::number_type part_group::number_default_value_("1");

part_group::part_group(const type_type &type)
: ::xml_schema::type()
, group_name_(this)
, group_name_display_(this)
, group_abbreviation_(this)
, group_abbreviation_display_(this)
, group_symbol_(this)
, group_barline_(this)
, group_time_(this)
, footnote_(this)
, level_(this)
, type_(type, this)
, number_(number_default_value(), this) {}

part_group::part_group(const part_group &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, group_name_(x.group_name_, f, this)
, group_name_display_(x.group_name_display_, f, this)
, group_abbreviation_(x.group_abbreviation_, f, this)
, group_abbreviation_display_(x.group_abbreviation_display_, f, this)
, group_symbol_(x.group_symbol_, f, this)
, group_barline_(x.group_barline_, f, this)
, group_time_(x.group_time_, f, this)
, footnote_(x.footnote_, f, this)
, level_(x.level_, f, this)
, type_(x.type_, f, this)
, number_(x.number_, f, this) {}

part_group::part_group(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, group_name_(this)
, group_name_display_(this)
, group_abbreviation_(this)
, group_abbreviation_display_(this)
, group_symbol_(this)
, group_barline_(this)
, group_time_(this)
, footnote_(this)
, level_(this)
, type_(this)
, number_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void part_group::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // group-name
    //
    if (n.name() == "group-name" && n.namespace_().empty()) {
      ::std::unique_ptr<group_name_type> r(
        group_name_traits::create(i, f, this));

      if (!this->group_name_) {
        this->group_name_.set(::std::move(r));
        continue;
      }
    }

    // group-name-display
    //
    if (n.name() == "group-name-display" && n.namespace_().empty()) {
      ::std::unique_ptr<group_name_display_type> r(
        group_name_display_traits::create(i, f, this));

      if (!this->group_name_display_) {
        this->group_name_display_.set(::std::move(r));
        continue;
      }
    }

    // group-abbreviation
    //
    if (n.name() == "group-abbreviation" && n.namespace_().empty()) {
      ::std::unique_ptr<group_abbreviation_type> r(
        group_abbreviation_traits::create(i, f, this));

      if (!this->group_abbreviation_) {
        this->group_abbreviation_.set(::std::move(r));
        continue;
      }
    }

    // group-abbreviation-display
    //
    if (n.name() == "group-abbreviation-display" && n.namespace_().empty()) {
      ::std::unique_ptr<group_abbreviation_display_type> r(
        group_abbreviation_display_traits::create(i, f, this));

      if (!this->group_abbreviation_display_) {
        this->group_abbreviation_display_.set(::std::move(r));
        continue;
      }
    }

    // group-symbol
    //
    if (n.name() == "group-symbol" && n.namespace_().empty()) {
      ::std::unique_ptr<group_symbol_type> r(
        group_symbol_traits::create(i, f, this));

      if (!this->group_symbol_) {
        this->group_symbol_.set(::std::move(r));
        continue;
      }
    }

    // group-barline
    //
    if (n.name() == "group-barline" && n.namespace_().empty()) {
      ::std::unique_ptr<group_barline_type> r(
        group_barline_traits::create(i, f, this));

      if (!this->group_barline_) {
        this->group_barline_.set(::std::move(r));
        continue;
      }
    }

    // group-time
    //
    if (n.name() == "group-time" && n.namespace_().empty()) {
      ::std::unique_ptr<group_time_type> r(
        group_time_traits::create(i, f, this));

      if (!this->group_time_) {
        this->group_time_.set(::std::move(r));
        continue;
      }
    }

    // footnote
    //
    if (n.name() == "footnote" && n.namespace_().empty()) {
      ::std::unique_ptr<footnote_type> r(footnote_traits::create(i, f, this));

      if (!this->footnote_) {
        this->footnote_.set(::std::move(r));
        continue;
      }
    }

    // level
    //
    if (n.name() == "level" && n.namespace_().empty()) {
      ::std::unique_ptr<level_type> r(level_traits::create(i, f, this));

      if (!this->level_) {
        this->level_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }
  }

  if (!type_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("type", "");
  }

  if (!number_.present()) { this->number_.set(number_default_value()); }
}

part_group *part_group::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class part_group(*this, f, c);
}

part_group &part_group::operator=(const part_group &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->group_name_ = x.group_name_;
    this->group_name_display_ = x.group_name_display_;
    this->group_abbreviation_ = x.group_abbreviation_;
    this->group_abbreviation_display_ = x.group_abbreviation_display_;
    this->group_symbol_ = x.group_symbol_;
    this->group_barline_ = x.group_barline_;
    this->group_time_ = x.group_time_;
    this->footnote_ = x.footnote_;
    this->level_ = x.level_;
    this->type_ = x.type_;
    this->number_ = x.number_;
  }

  return *this;
}

part_group::~part_group() {}

// part_list
//

part_list::part_list()
: ::xml_schema::type(), part_group_(this), score_part_(this) {}

part_list::part_list(const part_list &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, part_group_(x.part_group_, f, this)
, score_part_(x.score_part_, f, this) {}

part_list::part_list(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, part_group_(this)
, score_part_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void part_list::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // part-group
    //
    if (n.name() == "part-group" && n.namespace_().empty()) {
      ::std::unique_ptr<part_group_type> r(
        part_group_traits::create(i, f, this));

      this->part_group_.push_back(::std::move(r));
      continue;
    }

    // score-part
    //
    if (n.name() == "score-part" && n.namespace_().empty()) {
      ::std::unique_ptr<score_part_type> r(
        score_part_traits::create(i, f, this));

      this->score_part_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

part_list *part_list::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class part_list(*this, f, c);
}

part_list &part_list::operator=(const part_list &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->part_group_ = x.part_group_;
    this->score_part_ = x.score_part_;
  }

  return *this;
}

part_list::~part_list() {}

// part_name
//

part_name::part_name()
: ::xml_schema::string()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, justify_(this) {}

part_name::part_name(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, justify_(this) {}

part_name::part_name(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, justify_(this) {}

part_name::part_name(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, justify_(this) {}

part_name::part_name(const part_name &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, print_object_(x.print_object_, f, this)
, justify_(x.justify_, f, this) {}

part_name::part_name(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, print_object_(this)
, justify_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void part_name::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "print-object" && n.namespace_().empty()) {
      this->print_object_.set(print_object_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "justify" && n.namespace_().empty()) {
      this->justify_.set(justify_traits::create(i, f, this));
      continue;
    }
  }
}

part_name *part_name::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class part_name(*this, f, c);
}

part_name &part_name::operator=(const part_name &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->print_object_ = x.print_object_;
    this->justify_ = x.justify_;
  }

  return *this;
}

part_name::~part_name() {}

// score_instrument
//

score_instrument::score_instrument(const instrument_name_type &instrument_name,
                                   const id_type &id)
: ::xml_schema::type()
, instrument_name_(instrument_name, this)
, instrument_abbreviation_(this)
, instrument_sound_(this)
, solo_(this)
, ensemble_(this)
, virtual_instrument_(this)
, id_(id, this) {}

score_instrument::score_instrument(const score_instrument &x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, instrument_name_(x.instrument_name_, f, this)
, instrument_abbreviation_(x.instrument_abbreviation_, f, this)
, instrument_sound_(x.instrument_sound_, f, this)
, solo_(x.solo_, f, this)
, ensemble_(x.ensemble_, f, this)
, virtual_instrument_(x.virtual_instrument_, f, this)
, id_(x.id_, f, this) {}

score_instrument::score_instrument(const ::xercesc::DOMElement &e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, instrument_name_(this)
, instrument_abbreviation_(this)
, instrument_sound_(this)
, solo_(this)
, ensemble_(this)
, virtual_instrument_(this)
, id_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void score_instrument::parse(::xsd::cxx::xml::dom::parser<char> &p,
                             ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // instrument-name
    //
    if (n.name() == "instrument-name" && n.namespace_().empty()) {
      ::std::unique_ptr<instrument_name_type> r(
        instrument_name_traits::create(i, f, this));

      if (!instrument_name_.present()) {
        this->instrument_name_.set(::std::move(r));
        continue;
      }
    }

    // instrument-abbreviation
    //
    if (n.name() == "instrument-abbreviation" && n.namespace_().empty()) {
      ::std::unique_ptr<instrument_abbreviation_type> r(
        instrument_abbreviation_traits::create(i, f, this));

      if (!this->instrument_abbreviation_) {
        this->instrument_abbreviation_.set(::std::move(r));
        continue;
      }
    }

    // instrument-sound
    //
    if (n.name() == "instrument-sound" && n.namespace_().empty()) {
      ::std::unique_ptr<instrument_sound_type> r(
        instrument_sound_traits::create(i, f, this));

      if (!this->instrument_sound_) {
        this->instrument_sound_.set(::std::move(r));
        continue;
      }
    }

    // solo
    //
    if (n.name() == "solo" && n.namespace_().empty()) {
      ::std::unique_ptr<solo_type> r(solo_traits::create(i, f, this));

      if (!this->solo_) {
        this->solo_.set(::std::move(r));
        continue;
      }
    }

    // ensemble
    //
    if (n.name() == "ensemble" && n.namespace_().empty()) {
      ::std::unique_ptr<ensemble_type> r(ensemble_traits::create(i, f, this));

      if (!this->ensemble_) {
        this->ensemble_.set(::std::move(r));
        continue;
      }
    }

    // virtual-instrument
    //
    if (n.name() == "virtual-instrument" && n.namespace_().empty()) {
      ::std::unique_ptr<virtual_instrument_type> r(
        virtual_instrument_traits::create(i, f, this));

      if (!this->virtual_instrument_) {
        this->virtual_instrument_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!instrument_name_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("instrument-name", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }
  }

  if (!id_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("id", "");
  }
}

score_instrument *score_instrument::_clone(::xml_schema::flags f,
                                           ::xml_schema::container *c) const {
  return new class score_instrument(*this, f, c);
}

score_instrument &score_instrument::operator=(const score_instrument &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->instrument_name_ = x.instrument_name_;
    this->instrument_abbreviation_ = x.instrument_abbreviation_;
    this->instrument_sound_ = x.instrument_sound_;
    this->solo_ = x.solo_;
    this->ensemble_ = x.ensemble_;
    this->virtual_instrument_ = x.virtual_instrument_;
    this->id_ = x.id_;
  }

  return *this;
}

score_instrument::~score_instrument() {}

// score_part
//

score_part::score_part(const part_name_type &part_name, const id_type &id)
: ::xml_schema::type()
, identification_(this)
, part_name_(part_name, this)
, part_name_display_(this)
, part_abbreviation_(this)
, part_abbreviation_display_(this)
, group_(this)
, score_instrument_(this)
, midi_device_(this)
, midi_instrument_(this)
, id_(id, this) {}

score_part::score_part(::std::unique_ptr<part_name_type> part_name,
                       const id_type &id)
: ::xml_schema::type()
, identification_(this)
, part_name_(std::move(part_name), this)
, part_name_display_(this)
, part_abbreviation_(this)
, part_abbreviation_display_(this)
, group_(this)
, score_instrument_(this)
, midi_device_(this)
, midi_instrument_(this)
, id_(id, this) {}

score_part::score_part(const score_part &x, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, identification_(x.identification_, f, this)
, part_name_(x.part_name_, f, this)
, part_name_display_(x.part_name_display_, f, this)
, part_abbreviation_(x.part_abbreviation_, f, this)
, part_abbreviation_display_(x.part_abbreviation_display_, f, this)
, group_(x.group_, f, this)
, score_instrument_(x.score_instrument_, f, this)
, midi_device_(x.midi_device_, f, this)
, midi_instrument_(x.midi_instrument_, f, this)
, id_(x.id_, f, this) {}

score_part::score_part(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, identification_(this)
, part_name_(this)
, part_name_display_(this)
, part_abbreviation_(this)
, part_abbreviation_display_(this)
, group_(this)
, score_instrument_(this)
, midi_device_(this)
, midi_instrument_(this)
, id_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void score_part::parse(::xsd::cxx::xml::dom::parser<char> &p,
                       ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // identification
    //
    if (n.name() == "identification" && n.namespace_().empty()) {
      ::std::unique_ptr<identification_type> r(
        identification_traits::create(i, f, this));

      if (!this->identification_) {
        this->identification_.set(::std::move(r));
        continue;
      }
    }

    // part-name
    //
    if (n.name() == "part-name" && n.namespace_().empty()) {
      ::std::unique_ptr<part_name_type> r(part_name_traits::create(i, f, this));

      if (!part_name_.present()) {
        this->part_name_.set(::std::move(r));
        continue;
      }
    }

    // part-name-display
    //
    if (n.name() == "part-name-display" && n.namespace_().empty()) {
      ::std::unique_ptr<part_name_display_type> r(
        part_name_display_traits::create(i, f, this));

      if (!this->part_name_display_) {
        this->part_name_display_.set(::std::move(r));
        continue;
      }
    }

    // part-abbreviation
    //
    if (n.name() == "part-abbreviation" && n.namespace_().empty()) {
      ::std::unique_ptr<part_abbreviation_type> r(
        part_abbreviation_traits::create(i, f, this));

      if (!this->part_abbreviation_) {
        this->part_abbreviation_.set(::std::move(r));
        continue;
      }
    }

    // part-abbreviation-display
    //
    if (n.name() == "part-abbreviation-display" && n.namespace_().empty()) {
      ::std::unique_ptr<part_abbreviation_display_type> r(
        part_abbreviation_display_traits::create(i, f, this));

      if (!this->part_abbreviation_display_) {
        this->part_abbreviation_display_.set(::std::move(r));
        continue;
      }
    }

    // group
    //
    if (n.name() == "group" && n.namespace_().empty()) {
      ::std::unique_ptr<group_type> r(group_traits::create(i, f, this));

      this->group_.push_back(::std::move(r));
      continue;
    }

    // score-instrument
    //
    if (n.name() == "score-instrument" && n.namespace_().empty()) {
      ::std::unique_ptr<score_instrument_type> r(
        score_instrument_traits::create(i, f, this));

      this->score_instrument_.push_back(::std::move(r));
      continue;
    }

    // midi-device
    //
    if (n.name() == "midi-device" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_device_type> r(
        midi_device_traits::create(i, f, this));

      this->midi_device_.push_back(::std::move(r));
      continue;
    }

    // midi-instrument
    //
    if (n.name() == "midi-instrument" && n.namespace_().empty()) {
      ::std::unique_ptr<midi_instrument_type> r(
        midi_instrument_traits::create(i, f, this));

      this->midi_instrument_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  if (!part_name_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("part-name", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }
  }

  if (!id_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("id", "");
  }
}

score_part *score_part::_clone(::xml_schema::flags f,
                               ::xml_schema::container *c) const {
  return new class score_part(*this, f, c);
}

score_part &score_part::operator=(const score_part &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->identification_ = x.identification_;
    this->part_name_ = x.part_name_;
    this->part_name_display_ = x.part_name_display_;
    this->part_abbreviation_ = x.part_abbreviation_;
    this->part_abbreviation_display_ = x.part_abbreviation_display_;
    this->group_ = x.group_;
    this->score_instrument_ = x.score_instrument_;
    this->midi_device_ = x.midi_device_;
    this->midi_instrument_ = x.midi_instrument_;
    this->id_ = x.id_;
  }

  return *this;
}

score_part::~score_part() {}

// virtual_instrument
//

virtual_instrument::virtual_instrument()
: ::xml_schema::type(), virtual_library_(this), virtual_name_(this) {}

virtual_instrument::virtual_instrument(const virtual_instrument &x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, virtual_library_(x.virtual_library_, f, this)
, virtual_name_(x.virtual_name_, f, this) {}

virtual_instrument::virtual_instrument(const ::xercesc::DOMElement &e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, virtual_library_(this)
, virtual_name_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void virtual_instrument::parse(::xsd::cxx::xml::dom::parser<char> &p,
                               ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // virtual-library
    //
    if (n.name() == "virtual-library" && n.namespace_().empty()) {
      ::std::unique_ptr<virtual_library_type> r(
        virtual_library_traits::create(i, f, this));

      if (!this->virtual_library_) {
        this->virtual_library_.set(::std::move(r));
        continue;
      }
    }

    // virtual-name
    //
    if (n.name() == "virtual-name" && n.namespace_().empty()) {
      ::std::unique_ptr<virtual_name_type> r(
        virtual_name_traits::create(i, f, this));

      if (!this->virtual_name_) {
        this->virtual_name_.set(::std::move(r));
        continue;
      }
    }

    break;
  }
}

virtual_instrument *
virtual_instrument::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class virtual_instrument(*this, f, c);
}

virtual_instrument &virtual_instrument::operator=(const virtual_instrument &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->virtual_library_ = x.virtual_library_;
    this->virtual_name_ = x.virtual_name_;
  }

  return *this;
}

virtual_instrument::~virtual_instrument() {}

// work
//

work::work()
: ::xml_schema::type(), work_number_(this), work_title_(this), opus_(this) {}

work::work(const work &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, work_number_(x.work_number_, f, this)
, work_title_(x.work_title_, f, this)
, opus_(x.opus_, f, this) {}

work::work(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, work_number_(this)
, work_title_(this)
, opus_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void work::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // work-number
    //
    if (n.name() == "work-number" && n.namespace_().empty()) {
      ::std::unique_ptr<work_number_type> r(
        work_number_traits::create(i, f, this));

      if (!this->work_number_) {
        this->work_number_.set(::std::move(r));
        continue;
      }
    }

    // work-title
    //
    if (n.name() == "work-title" && n.namespace_().empty()) {
      ::std::unique_ptr<work_title_type> r(
        work_title_traits::create(i, f, this));

      if (!this->work_title_) {
        this->work_title_.set(::std::move(r));
        continue;
      }
    }

    // opus
    //
    if (n.name() == "opus" && n.namespace_().empty()) {
      ::std::unique_ptr<opus_type> r(opus_traits::create(i, f, this));

      if (!this->opus_) {
        this->opus_.set(::std::move(r));
        continue;
      }
    }

    break;
  }
}

work *work::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class work(*this, f, c);
}

work &work::operator=(const work &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->work_number_ = x.work_number_;
    this->work_title_ = x.work_title_;
    this->opus_ = x.opus_;
  }

  return *this;
}

work::~work() {}

// number_or_normal_member
//

number_or_normal_member::number_or_normal_member(const ::xercesc::DOMElement &e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container *c)
: ::xml_schema::token(e, f, c) {
  _xsd_number_or_normal_member_convert();
}

number_or_normal_member::number_or_normal_member(const ::xercesc::DOMAttr &a,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container *c)
: ::xml_schema::token(a, f, c) {
  _xsd_number_or_normal_member_convert();
}

number_or_normal_member::number_or_normal_member(const ::std::string &s,
                                                 const ::xercesc::DOMElement *e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container *c)
: ::xml_schema::token(s, e, f, c) {
  _xsd_number_or_normal_member_convert();
}

number_or_normal_member *
number_or_normal_member::_clone(::xml_schema::flags f,
                                ::xml_schema::container *c) const {
  return new class number_or_normal_member(*this, f, c);
}

number_or_normal_member::value
number_or_normal_member::_xsd_number_or_normal_member_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(
    _xsd_number_or_normal_member_literals_);
  const value *i(::std::lower_bound(_xsd_number_or_normal_member_indexes_,
                                    _xsd_number_or_normal_member_indexes_ + 1,
                                    *this, c));

  if (i == _xsd_number_or_normal_member_indexes_ + 1 ||
      _xsd_number_or_normal_member_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const
  number_or_normal_member::_xsd_number_or_normal_member_literals_[1] = {
    "normal"};

const number_or_normal_member::value
  number_or_normal_member::_xsd_number_or_normal_member_indexes_[1] = {
    ::musicxml::number_or_normal_member::normal};

// positive_integer_or_empty_member
//

positive_integer_or_empty_member::positive_integer_or_empty_member(
  const ::xercesc::DOMElement &e, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(e, f, c) {
  _xsd_positive_integer_or_empty_member_convert();
}

positive_integer_or_empty_member::positive_integer_or_empty_member(
  const ::xercesc::DOMAttr &a, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(a, f, c) {
  _xsd_positive_integer_or_empty_member_convert();
}

positive_integer_or_empty_member::positive_integer_or_empty_member(
  const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
  ::xml_schema::container *c)
: ::xml_schema::string(s, e, f, c) {
  _xsd_positive_integer_or_empty_member_convert();
}

positive_integer_or_empty_member *
positive_integer_or_empty_member::_clone(::xml_schema::flags f,
                                         ::xml_schema::container *c) const {
  return new class positive_integer_or_empty_member(*this, f, c);
}

positive_integer_or_empty_member::value positive_integer_or_empty_member::
  _xsd_positive_integer_or_empty_member_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(
    _xsd_positive_integer_or_empty_member_literals_);
  const value *i(::std::lower_bound(
    _xsd_positive_integer_or_empty_member_indexes_,
    _xsd_positive_integer_or_empty_member_indexes_ + 1, *this, c));

  if (i == _xsd_positive_integer_or_empty_member_indexes_ + 1 ||
      _xsd_positive_integer_or_empty_member_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const positive_integer_or_empty_member::
  _xsd_positive_integer_or_empty_member_literals_[1] = {""};

const positive_integer_or_empty_member::value positive_integer_or_empty_member::
  _xsd_positive_integer_or_empty_member_indexes_[1] = {
    ::musicxml::positive_integer_or_empty_member::empty};

// directive
//

directive::directive()
: ::xml_schema::string()
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, lang_(this) {}

directive::directive(const char *_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, lang_(this) {}

directive::directive(const ::std::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, lang_(this) {}

directive::directive(const ::xml_schema::string &_xsd_string_base)
: ::xml_schema::string(_xsd_string_base)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, lang_(this) {}

directive::directive(const directive &x, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(x, f, c)
, default_x_(x.default_x_, f, this)
, default_y_(x.default_y_, f, this)
, relative_x_(x.relative_x_, f, this)
, relative_y_(x.relative_y_, f, this)
, font_family_(x.font_family_, f, this)
, font_style_(x.font_style_, f, this)
, font_size_(x.font_size_, f, this)
, font_weight_(x.font_weight_, f, this)
, color_(x.color_, f, this)
, lang_(x.lang_, f, this) {}

directive::directive(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
: ::xml_schema::string(e, f | ::xml_schema::flags::base, c)
, default_x_(this)
, default_y_(this)
, relative_x_(this)
, relative_y_(this)
, font_family_(this)
, font_style_(this)
, font_size_(this)
, font_weight_(this)
, color_(this)
, lang_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void directive::parse(::xsd::cxx::xml::dom::parser<char> &p,
                      ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "default-x" && n.namespace_().empty()) {
      this->default_x_.set(default_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "default-y" && n.namespace_().empty()) {
      this->default_y_.set(default_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-x" && n.namespace_().empty()) {
      this->relative_x_.set(relative_x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "relative-y" && n.namespace_().empty()) {
      this->relative_y_.set(relative_y_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-family" && n.namespace_().empty()) {
      this->font_family_.set(font_family_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-style" && n.namespace_().empty()) {
      this->font_style_.set(font_style_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-size" && n.namespace_().empty()) {
      this->font_size_.set(font_size_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "font-weight" && n.namespace_().empty()) {
      this->font_weight_.set(font_weight_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "color" && n.namespace_().empty()) {
      this->color_.set(color_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "lang" &&
        n.namespace_() == "http://www.w3.org/XML/1998/namespace") {
      this->lang_.set(lang_traits::create(i, f, this));
      continue;
    }
  }
}

directive *directive::_clone(::xml_schema::flags f,
                             ::xml_schema::container *c) const {
  return new class directive(*this, f, c);
}

directive &directive::operator=(const directive &x) {
  if (this != &x) {
    static_cast<::xml_schema::string &>(*this) = x;
    this->default_x_ = x.default_x_;
    this->default_y_ = x.default_y_;
    this->relative_x_ = x.relative_x_;
    this->relative_y_ = x.relative_y_;
    this->font_family_ = x.font_family_;
    this->font_style_ = x.font_style_;
    this->font_size_ = x.font_size_;
    this->font_weight_ = x.font_weight_;
    this->color_ = x.color_;
    this->lang_ = x.lang_;
  }

  return *this;
}

directive::~directive() {}

// score_partwise
//

const score_partwise::version_type
  score_partwise::version_default_value_("1.0");

score_partwise::score_partwise(const part_list_type &part_list)
: ::xml_schema::type()
, work_(this)
, movement_number_(this)
, movement_title_(this)
, identification_(this)
, defaults_(this)
, credit_(this)
, part_list_(part_list, this)
, part_(this)
, version_(version_default_value(), this) {}

score_partwise::score_partwise(::std::unique_ptr<part_list_type> part_list)
: ::xml_schema::type()
, work_(this)
, movement_number_(this)
, movement_title_(this)
, identification_(this)
, defaults_(this)
, credit_(this)
, part_list_(std::move(part_list), this)
, part_(this)
, version_(version_default_value(), this) {}

score_partwise::score_partwise(const score_partwise &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, work_(x.work_, f, this)
, movement_number_(x.movement_number_, f, this)
, movement_title_(x.movement_title_, f, this)
, identification_(x.identification_, f, this)
, defaults_(x.defaults_, f, this)
, credit_(x.credit_, f, this)
, part_list_(x.part_list_, f, this)
, part_(x.part_, f, this)
, version_(x.version_, f, this) {}

score_partwise::score_partwise(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, work_(this)
, movement_number_(this)
, movement_title_(this)
, identification_(this)
, defaults_(this)
, credit_(this)
, part_list_(this)
, part_(this)
, version_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void score_partwise::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // work
    //
    if (n.name() == "work" && n.namespace_().empty()) {
      ::std::unique_ptr<work_type> r(work_traits::create(i, f, this));

      if (!this->work_) {
        this->work_.set(::std::move(r));
        continue;
      }
    }

    // movement-number
    //
    if (n.name() == "movement-number" && n.namespace_().empty()) {
      ::std::unique_ptr<movement_number_type> r(
        movement_number_traits::create(i, f, this));

      if (!this->movement_number_) {
        this->movement_number_.set(::std::move(r));
        continue;
      }
    }

    // movement-title
    //
    if (n.name() == "movement-title" && n.namespace_().empty()) {
      ::std::unique_ptr<movement_title_type> r(
        movement_title_traits::create(i, f, this));

      if (!this->movement_title_) {
        this->movement_title_.set(::std::move(r));
        continue;
      }
    }

    // identification
    //
    if (n.name() == "identification" && n.namespace_().empty()) {
      ::std::unique_ptr<identification_type> r(
        identification_traits::create(i, f, this));

      if (!this->identification_) {
        this->identification_.set(::std::move(r));
        continue;
      }
    }

    // defaults
    //
    if (n.name() == "defaults" && n.namespace_().empty()) {
      ::std::unique_ptr<defaults_type> r(defaults_traits::create(i, f, this));

      if (!this->defaults_) {
        this->defaults_.set(::std::move(r));
        continue;
      }
    }

    // credit
    //
    if (n.name() == "credit" && n.namespace_().empty()) {
      ::std::unique_ptr<credit_type> r(credit_traits::create(i, f, this));

      this->credit_.push_back(::std::move(r));
      continue;
    }

    // part-list
    //
    if (n.name() == "part-list" && n.namespace_().empty()) {
      ::std::unique_ptr<part_list_type> r(part_list_traits::create(i, f, this));

      if (!part_list_.present()) {
        this->part_list_.set(::std::move(r));
        continue;
      }
    }

    // part
    //
    if (n.name() == "part" && n.namespace_().empty()) {
      ::std::unique_ptr<part_type> r(part_traits::create(i, f, this));

      this->part_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  if (!part_list_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("part-list", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "version" && n.namespace_().empty()) {
      this->version_.set(version_traits::create(i, f, this));
      continue;
    }
  }

  if (!version_.present()) { this->version_.set(version_default_value()); }
}

score_partwise *score_partwise::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class score_partwise(*this, f, c);
}

score_partwise &score_partwise::operator=(const score_partwise &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->work_ = x.work_;
    this->movement_number_ = x.movement_number_;
    this->movement_title_ = x.movement_title_;
    this->identification_ = x.identification_;
    this->defaults_ = x.defaults_;
    this->credit_ = x.credit_;
    this->part_list_ = x.part_list_;
    this->part_ = x.part_;
    this->version_ = x.version_;
  }

  return *this;
}

score_partwise::~score_partwise() {}

// score_timewise
//

const score_timewise::version_type
  score_timewise::version_default_value_("1.0");

score_timewise::score_timewise(const part_list_type &part_list)
: ::xml_schema::type()
, work_(this)
, movement_number_(this)
, movement_title_(this)
, identification_(this)
, defaults_(this)
, credit_(this)
, part_list_(part_list, this)
, measure_(this)
, version_(version_default_value(), this) {}

score_timewise::score_timewise(::std::unique_ptr<part_list_type> part_list)
: ::xml_schema::type()
, work_(this)
, movement_number_(this)
, movement_title_(this)
, identification_(this)
, defaults_(this)
, credit_(this)
, part_list_(std::move(part_list), this)
, measure_(this)
, version_(version_default_value(), this) {}

score_timewise::score_timewise(const score_timewise &x, ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, work_(x.work_, f, this)
, movement_number_(x.movement_number_, f, this)
, movement_title_(x.movement_title_, f, this)
, identification_(x.identification_, f, this)
, defaults_(x.defaults_, f, this)
, credit_(x.credit_, f, this)
, part_list_(x.part_list_, f, this)
, measure_(x.measure_, f, this)
, version_(x.version_, f, this) {}

score_timewise::score_timewise(const ::xercesc::DOMElement &e,
                               ::xml_schema::flags f,
                               ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, work_(this)
, movement_number_(this)
, movement_title_(this)
, identification_(this)
, defaults_(this)
, credit_(this)
, part_list_(this)
, measure_(this)
, version_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void score_timewise::parse(::xsd::cxx::xml::dom::parser<char> &p,
                           ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // work
    //
    if (n.name() == "work" && n.namespace_().empty()) {
      ::std::unique_ptr<work_type> r(work_traits::create(i, f, this));

      if (!this->work_) {
        this->work_.set(::std::move(r));
        continue;
      }
    }

    // movement-number
    //
    if (n.name() == "movement-number" && n.namespace_().empty()) {
      ::std::unique_ptr<movement_number_type> r(
        movement_number_traits::create(i, f, this));

      if (!this->movement_number_) {
        this->movement_number_.set(::std::move(r));
        continue;
      }
    }

    // movement-title
    //
    if (n.name() == "movement-title" && n.namespace_().empty()) {
      ::std::unique_ptr<movement_title_type> r(
        movement_title_traits::create(i, f, this));

      if (!this->movement_title_) {
        this->movement_title_.set(::std::move(r));
        continue;
      }
    }

    // identification
    //
    if (n.name() == "identification" && n.namespace_().empty()) {
      ::std::unique_ptr<identification_type> r(
        identification_traits::create(i, f, this));

      if (!this->identification_) {
        this->identification_.set(::std::move(r));
        continue;
      }
    }

    // defaults
    //
    if (n.name() == "defaults" && n.namespace_().empty()) {
      ::std::unique_ptr<defaults_type> r(defaults_traits::create(i, f, this));

      if (!this->defaults_) {
        this->defaults_.set(::std::move(r));
        continue;
      }
    }

    // credit
    //
    if (n.name() == "credit" && n.namespace_().empty()) {
      ::std::unique_ptr<credit_type> r(credit_traits::create(i, f, this));

      this->credit_.push_back(::std::move(r));
      continue;
    }

    // part-list
    //
    if (n.name() == "part-list" && n.namespace_().empty()) {
      ::std::unique_ptr<part_list_type> r(part_list_traits::create(i, f, this));

      if (!part_list_.present()) {
        this->part_list_.set(::std::move(r));
        continue;
      }
    }

    // measure
    //
    if (n.name() == "measure" && n.namespace_().empty()) {
      ::std::unique_ptr<measure_type> r(measure_traits::create(i, f, this));

      this->measure_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  if (!part_list_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("part-list", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "version" && n.namespace_().empty()) {
      this->version_.set(version_traits::create(i, f, this));
      continue;
    }
  }

  if (!version_.present()) { this->version_.set(version_default_value()); }
}

score_timewise *score_timewise::_clone(::xml_schema::flags f,
                                       ::xml_schema::container *c) const {
  return new class score_timewise(*this, f, c);
}

score_timewise &score_timewise::operator=(const score_timewise &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->work_ = x.work_;
    this->movement_number_ = x.movement_number_;
    this->movement_title_ = x.movement_title_;
    this->identification_ = x.identification_;
    this->defaults_ = x.defaults_;
    this->credit_ = x.credit_;
    this->part_list_ = x.part_list_;
    this->measure_ = x.measure_;
    this->version_ = x.version_;
  }

  return *this;
}

score_timewise::~score_timewise() {}

// part
//

part::part(const id_type &id)
: ::xml_schema::type(), measure_(this), id_(id, this) {}

part::part(const part &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, measure_(x.measure_, f, this)
, id_(x.id_, f, this) {}

part::part(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
           ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, measure_(this)
, id_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void part::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // measure
    //
    if (n.name() == "measure" && n.namespace_().empty()) {
      ::std::unique_ptr<measure_type> r(measure_traits::create(i, f, this));

      this->measure_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }
  }

  if (!id_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("id", "");
  }
}

part *part::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class part(*this, f, c);
}

part &part::operator=(const part &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->measure_ = x.measure_;
    this->id_ = x.id_;
  }

  return *this;
}

part::~part() {}

// measure
//

measure::measure(const number_type &number)
: ::xml_schema::type()
, part_(this)
, number_(number, this)
, implicit_(this)
, non_controlling_(this)
, width_(this) {}

measure::measure(const measure &x, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, part_(x.part_, f, this)
, number_(x.number_, f, this)
, implicit_(x.implicit_, f, this)
, non_controlling_(x.non_controlling_, f, this)
, width_(x.width_, f, this) {}

measure::measure(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                 ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, part_(this)
, number_(this)
, implicit_(this)
, non_controlling_(this)
, width_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void measure::parse(::xsd::cxx::xml::dom::parser<char> &p,
                    ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // part
    //
    if (n.name() == "part" && n.namespace_().empty()) {
      ::std::unique_ptr<part_type> r(part_traits::create(i, f, this));

      this->part_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "implicit" && n.namespace_().empty()) {
      this->implicit_.set(implicit_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "non-controlling" && n.namespace_().empty()) {
      this->non_controlling_.set(non_controlling_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "width" && n.namespace_().empty()) {
      this->width_.set(width_traits::create(i, f, this));
      continue;
    }
  }

  if (!number_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("number", "");
  }
}

measure *measure::_clone(::xml_schema::flags f,
                         ::xml_schema::container *c) const {
  return new class measure(*this, f, c);
}

measure &measure::operator=(const measure &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->part_ = x.part_;
    this->number_ = x.number_;
    this->implicit_ = x.implicit_;
    this->non_controlling_ = x.non_controlling_;
    this->width_ = x.width_;
  }

  return *this;
}

measure::~measure() {}

// measure1
//

measure1::measure1(const number_type &number)
: ::xml_schema::type()
, note_(this)
, backup_(this)
, forward_(this)
, direction_(this)
, attributes_(this)
, harmony_(this)
, figured_bass_(this)
, print_(this)
, sound_(this)
, barline_(this)
, grouping_(this)
, link_(this)
, bookmark_(this)
, number_(number, this)
, implicit_(this)
, non_controlling_(this)
, width_(this) {}

measure1::measure1(const measure1 &x, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, content_order_(x.content_order_)
, note_(x.note_, f, this)
, backup_(x.backup_, f, this)
, forward_(x.forward_, f, this)
, direction_(x.direction_, f, this)
, attributes_(x.attributes_, f, this)
, harmony_(x.harmony_, f, this)
, figured_bass_(x.figured_bass_, f, this)
, print_(x.print_, f, this)
, sound_(x.sound_, f, this)
, barline_(x.barline_, f, this)
, grouping_(x.grouping_, f, this)
, link_(x.link_, f, this)
, bookmark_(x.bookmark_, f, this)
, number_(x.number_, f, this)
, implicit_(x.implicit_, f, this)
, non_controlling_(x.non_controlling_, f, this)
, width_(x.width_, f, this) {}

measure1::measure1(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, note_(this)
, backup_(this)
, forward_(this)
, direction_(this)
, attributes_(this)
, harmony_(this)
, figured_bass_(this)
, print_(this)
, sound_(this)
, barline_(this)
, grouping_(this)
, link_(this)
, bookmark_(this)
, number_(this)
, implicit_(this)
, non_controlling_(this)
, width_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void measure1::parse(::xsd::cxx::xml::dom::parser<char> &p,
                     ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // note
    //
    if (n.name() == "note" && n.namespace_().empty()) {
      ::std::unique_ptr<note_type> r(note_traits::create(i, f, this));

      this->note_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(note_id, this->note_.size() - 1));
      continue;
    }

    // backup
    //
    if (n.name() == "backup" && n.namespace_().empty()) {
      ::std::unique_ptr<backup_type> r(backup_traits::create(i, f, this));

      this->backup_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(backup_id, this->backup_.size() - 1));
      continue;
    }

    // forward
    //
    if (n.name() == "forward" && n.namespace_().empty()) {
      ::std::unique_ptr<forward_type> r(forward_traits::create(i, f, this));

      this->forward_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(forward_id, this->forward_.size() - 1));
      continue;
    }

    // direction
    //
    if (n.name() == "direction" && n.namespace_().empty()) {
      ::std::unique_ptr<direction_type> r(direction_traits::create(i, f, this));

      this->direction_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(direction_id, this->direction_.size() - 1));
      continue;
    }

    // attributes
    //
    if (n.name() == "attributes" && n.namespace_().empty()) {
      ::std::unique_ptr<attributes_type> r(
        attributes_traits::create(i, f, this));

      this->attributes_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(attributes_id, this->attributes_.size() - 1));
      continue;
    }

    // harmony
    //
    if (n.name() == "harmony" && n.namespace_().empty()) {
      ::std::unique_ptr<harmony_type> r(harmony_traits::create(i, f, this));

      this->harmony_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(harmony_id, this->harmony_.size() - 1));
      continue;
    }

    // figured-bass
    //
    if (n.name() == "figured-bass" && n.namespace_().empty()) {
      ::std::unique_ptr<figured_bass_type> r(
        figured_bass_traits::create(i, f, this));

      this->figured_bass_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(figured_bass_id, this->figured_bass_.size() - 1));
      continue;
    }

    // print
    //
    if (n.name() == "print" && n.namespace_().empty()) {
      ::std::unique_ptr<print_type> r(print_traits::create(i, f, this));

      this->print_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(print_id, this->print_.size() - 1));
      continue;
    }

    // sound
    //
    if (n.name() == "sound" && n.namespace_().empty()) {
      ::std::unique_ptr<sound_type> r(sound_traits::create(i, f, this));

      this->sound_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(sound_id, this->sound_.size() - 1));
      continue;
    }

    // barline
    //
    if (n.name() == "barline" && n.namespace_().empty()) {
      ::std::unique_ptr<barline_type> r(barline_traits::create(i, f, this));

      this->barline_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(barline_id, this->barline_.size() - 1));
      continue;
    }

    // grouping
    //
    if (n.name() == "grouping" && n.namespace_().empty()) {
      ::std::unique_ptr<grouping_type> r(grouping_traits::create(i, f, this));

      this->grouping_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(grouping_id, this->grouping_.size() - 1));
      continue;
    }

    // link
    //
    if (n.name() == "link" && n.namespace_().empty()) {
      ::std::unique_ptr<link_type> r(link_traits::create(i, f, this));

      this->link_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(link_id, this->link_.size() - 1));
      continue;
    }

    // bookmark
    //
    if (n.name() == "bookmark" && n.namespace_().empty()) {
      ::std::unique_ptr<bookmark_type> r(bookmark_traits::create(i, f, this));

      this->bookmark_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(bookmark_id, this->bookmark_.size() - 1));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "number" && n.namespace_().empty()) {
      this->number_.set(number_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "implicit" && n.namespace_().empty()) {
      this->implicit_.set(implicit_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "non-controlling" && n.namespace_().empty()) {
      this->non_controlling_.set(non_controlling_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "width" && n.namespace_().empty()) {
      this->width_.set(width_traits::create(i, f, this));
      continue;
    }
  }

  if (!number_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("number", "");
  }
}

measure1 *measure1::_clone(::xml_schema::flags f,
                           ::xml_schema::container *c) const {
  return new class measure1(*this, f, c);
}

measure1 &measure1::operator=(const measure1 &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->content_order_ = x.content_order_;
    this->note_ = x.note_;
    this->backup_ = x.backup_;
    this->forward_ = x.forward_;
    this->direction_ = x.direction_;
    this->attributes_ = x.attributes_;
    this->harmony_ = x.harmony_;
    this->figured_bass_ = x.figured_bass_;
    this->print_ = x.print_;
    this->sound_ = x.sound_;
    this->barline_ = x.barline_;
    this->grouping_ = x.grouping_;
    this->link_ = x.link_;
    this->bookmark_ = x.bookmark_;
    this->number_ = x.number_;
    this->implicit_ = x.implicit_;
    this->non_controlling_ = x.non_controlling_;
    this->width_ = x.width_;
  }

  return *this;
}

measure1::~measure1() {}

// part1
//

part1::part1(const id_type &id)
: ::xml_schema::type()
, note_(this)
, backup_(this)
, forward_(this)
, direction_(this)
, attributes_(this)
, harmony_(this)
, figured_bass_(this)
, print_(this)
, sound_(this)
, barline_(this)
, grouping_(this)
, link_(this)
, bookmark_(this)
, id_(id, this) {}

part1::part1(const part1 &x, ::xml_schema::flags f, ::xml_schema::container *c)
: ::xml_schema::type(x, f, c)
, content_order_(x.content_order_)
, note_(x.note_, f, this)
, backup_(x.backup_, f, this)
, forward_(x.forward_, f, this)
, direction_(x.direction_, f, this)
, attributes_(x.attributes_, f, this)
, harmony_(x.harmony_, f, this)
, figured_bass_(x.figured_bass_, f, this)
, print_(x.print_, f, this)
, sound_(x.sound_, f, this)
, barline_(x.barline_, f, this)
, grouping_(x.grouping_, f, this)
, link_(x.link_, f, this)
, bookmark_(x.bookmark_, f, this)
, id_(x.id_, f, this) {}

part1::part1(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
             ::xml_schema::container *c)
: ::xml_schema::type(e, f | ::xml_schema::flags::base, c)
, note_(this)
, backup_(this)
, forward_(this)
, direction_(this)
, attributes_(this)
, harmony_(this)
, figured_bass_(this)
, print_(this)
, sound_(this)
, barline_(this)
, grouping_(this)
, link_(this)
, bookmark_(this)
, id_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void part1::parse(::xsd::cxx::xml::dom::parser<char> &p,
                  ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    // note
    //
    if (n.name() == "note" && n.namespace_().empty()) {
      ::std::unique_ptr<note_type> r(note_traits::create(i, f, this));

      this->note_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(note_id, this->note_.size() - 1));
      continue;
    }

    // backup
    //
    if (n.name() == "backup" && n.namespace_().empty()) {
      ::std::unique_ptr<backup_type> r(backup_traits::create(i, f, this));

      this->backup_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(backup_id, this->backup_.size() - 1));
      continue;
    }

    // forward
    //
    if (n.name() == "forward" && n.namespace_().empty()) {
      ::std::unique_ptr<forward_type> r(forward_traits::create(i, f, this));

      this->forward_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(forward_id, this->forward_.size() - 1));
      continue;
    }

    // direction
    //
    if (n.name() == "direction" && n.namespace_().empty()) {
      ::std::unique_ptr<direction_type> r(direction_traits::create(i, f, this));

      this->direction_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(direction_id, this->direction_.size() - 1));
      continue;
    }

    // attributes
    //
    if (n.name() == "attributes" && n.namespace_().empty()) {
      ::std::unique_ptr<attributes_type> r(
        attributes_traits::create(i, f, this));

      this->attributes_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(attributes_id, this->attributes_.size() - 1));
      continue;
    }

    // harmony
    //
    if (n.name() == "harmony" && n.namespace_().empty()) {
      ::std::unique_ptr<harmony_type> r(harmony_traits::create(i, f, this));

      this->harmony_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(harmony_id, this->harmony_.size() - 1));
      continue;
    }

    // figured-bass
    //
    if (n.name() == "figured-bass" && n.namespace_().empty()) {
      ::std::unique_ptr<figured_bass_type> r(
        figured_bass_traits::create(i, f, this));

      this->figured_bass_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(figured_bass_id, this->figured_bass_.size() - 1));
      continue;
    }

    // print
    //
    if (n.name() == "print" && n.namespace_().empty()) {
      ::std::unique_ptr<print_type> r(print_traits::create(i, f, this));

      this->print_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(print_id, this->print_.size() - 1));
      continue;
    }

    // sound
    //
    if (n.name() == "sound" && n.namespace_().empty()) {
      ::std::unique_ptr<sound_type> r(sound_traits::create(i, f, this));

      this->sound_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(sound_id, this->sound_.size() - 1));
      continue;
    }

    // barline
    //
    if (n.name() == "barline" && n.namespace_().empty()) {
      ::std::unique_ptr<barline_type> r(barline_traits::create(i, f, this));

      this->barline_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(barline_id, this->barline_.size() - 1));
      continue;
    }

    // grouping
    //
    if (n.name() == "grouping" && n.namespace_().empty()) {
      ::std::unique_ptr<grouping_type> r(grouping_traits::create(i, f, this));

      this->grouping_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(grouping_id, this->grouping_.size() - 1));
      continue;
    }

    // link
    //
    if (n.name() == "link" && n.namespace_().empty()) {
      ::std::unique_ptr<link_type> r(link_traits::create(i, f, this));

      this->link_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(link_id, this->link_.size() - 1));
      continue;
    }

    // bookmark
    //
    if (n.name() == "bookmark" && n.namespace_().empty()) {
      ::std::unique_ptr<bookmark_type> r(bookmark_traits::create(i, f, this));

      this->bookmark_.push_back(::std::move(r));
      this->content_order_.push_back(
        content_order_type(bookmark_id, this->bookmark_.size() - 1));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(
      ::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "id" && n.namespace_().empty()) {
      this->id_.set(id_traits::create(i, f, this));
      continue;
    }
  }

  if (!id_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("id", "");
  }
}

part1 *part1::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class part1(*this, f, c);
}

part1 &part1::operator=(const part1 &x) {
  if (this != &x) {
    static_cast<::xml_schema::type &>(*this) = x;
    this->content_order_ = x.content_order_;
    this->note_ = x.note_;
    this->backup_ = x.backup_;
    this->forward_ = x.forward_;
    this->direction_ = x.direction_;
    this->attributes_ = x.attributes_;
    this->harmony_ = x.harmony_;
    this->figured_bass_ = x.figured_bass_;
    this->print_ = x.print_;
    this->sound_ = x.sound_;
    this->barline_ = x.barline_;
    this->grouping_ = x.grouping_;
    this->link_ = x.link_;
    this->bookmark_ = x.bookmark_;
    this->id_ = x.id_;
  }

  return *this;
}

part1::~part1() {}
} // namespace musicxml

#include <ostream>

namespace musicxml {
::std::ostream &operator<<(::std::ostream &o, above_below::value i) {
  return o << above_below::_xsd_above_below_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const above_below &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const beam_level &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const color &i) {
  o << static_cast<const ::xml_schema::token &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const comma_separated_text &i) {
  o << static_cast<const ::xml_schema::token &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, css_font_size::value i) {
  return o << css_font_size::_xsd_css_font_size_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const css_font_size &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const divisions &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, enclosure_shape::value i) {
  return o << enclosure_shape::_xsd_enclosure_shape_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const enclosure_shape &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, fermata_shape::value i) {
  return o << fermata_shape::_xsd_fermata_shape_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const fermata_shape &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const font_size &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, font_style::value i) {
  return o << font_style::_xsd_font_style_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const font_style &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, font_weight::value i) {
  return o << font_weight::_xsd_font_weight_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const font_weight &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, left_center_right::value i) {
  return o << left_center_right::_xsd_left_center_right_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const left_center_right &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, left_right::value i) {
  return o << left_right::_xsd_left_right_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const left_right &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, line_shape::value i) {
  return o << line_shape::_xsd_line_shape_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const line_shape &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, line_type::value i) {
  return o << line_type::_xsd_line_type_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const line_type &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const midi_16 &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const midi_128 &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const midi_16384 &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, mute::value i) {
  return o << mute::_xsd_mute_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const mute &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const non_negative_decimal &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const number_level &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const number_of_lines &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const number_or_normal &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, over_under::value i) {
  return o << over_under::_xsd_over_under_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const over_under &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const percent &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const positive_decimal &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const positive_divisions &i) {
  o << static_cast<const ::musicxml::divisions &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o,
                           const positive_integer_or_empty &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const rotation_degrees &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, semi_pitched::value i) {
  return o << semi_pitched::_xsd_semi_pitched_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const semi_pitched &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, start_note::value i) {
  return o << start_note::_xsd_start_note_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const start_note &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, start_stop::value i) {
  return o << start_stop::_xsd_start_stop_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const start_stop &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, start_stop_continue::value i) {
  return o << start_stop_continue::_xsd_start_stop_continue_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const start_stop_continue &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, start_stop_single::value i) {
  return o << start_stop_single::_xsd_start_stop_single_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const start_stop_single &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const string_number &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, symbol_size::value i) {
  return o << symbol_size::_xsd_symbol_size_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const symbol_size &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const tenths &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, text_direction::value i) {
  return o << text_direction::_xsd_text_direction_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const text_direction &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const time_only &i) {
  o << static_cast<const ::xml_schema::token &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, top_bottom::value i) {
  return o << top_bottom::_xsd_top_bottom_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const top_bottom &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const trill_beats &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, trill_step::value i) {
  return o << trill_step::_xsd_trill_step_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const trill_step &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, two_note_turn::value i) {
  return o << two_note_turn::_xsd_two_note_turn_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const two_note_turn &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, up_down::value i) {
  return o << up_down::_xsd_up_down_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const up_down &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, upright_inverted::value i) {
  return o << upright_inverted::_xsd_upright_inverted_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const upright_inverted &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, valign::value i) {
  return o << valign::_xsd_valign_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const valign &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, valign_image::value i) {
  return o << valign_image::_xsd_valign_image_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const valign_image &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, yes_no::value i) {
  return o << yes_no::_xsd_yes_no_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const yes_no &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const yes_no_number &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const yyyy_mm_dd &i) {
  o << static_cast<const ::xml_schema::date &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, cancel_location::value i) {
  return o << cancel_location::_xsd_cancel_location_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const cancel_location &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, clef_sign::value i) {
  return o << clef_sign::_xsd_clef_sign_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const clef_sign &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const fifths &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const mode &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, show_frets::value i) {
  return o << show_frets::_xsd_show_frets_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const show_frets &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const staff_line &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const staff_number &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, staff_type::value i) {
  return o << staff_type::_xsd_staff_type_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const staff_type &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, time_relation::value i) {
  return o << time_relation::_xsd_time_relation_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const time_relation &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, time_separator::value i) {
  return o << time_separator::_xsd_time_separator_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const time_separator &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, time_symbol::value i) {
  return o << time_symbol::_xsd_time_symbol_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const time_symbol &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, backward_forward::value i) {
  return o << backward_forward::_xsd_backward_forward_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const backward_forward &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, bar_style::value i) {
  return o << bar_style::_xsd_bar_style_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const bar_style &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const ending_number &i) {
  o << static_cast<const ::xml_schema::token &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, right_left_middle::value i) {
  return o << right_left_middle::_xsd_right_left_middle_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const right_left_middle &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, start_stop_discontinue::value i) {
  return o << start_stop_discontinue::_xsd_start_stop_discontinue_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const start_stop_discontinue &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, winged::value i) {
  return o << winged::_xsd_winged_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const winged &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const accordion_middle &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, beater_value::value i) {
  return o << beater_value::_xsd_beater_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const beater_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, degree_symbol_value::value i) {
  return o << degree_symbol_value::_xsd_degree_symbol_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const degree_symbol_value &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, degree_type_value::value i) {
  return o << degree_type_value::_xsd_degree_type_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const degree_type_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, effect::value i) {
  return o << effect::_xsd_effect_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const effect &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, glass::value i) {
  return o << glass::_xsd_glass_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const glass &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, harmony_type::value i) {
  return o << harmony_type::_xsd_harmony_type_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const harmony_type &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, kind_value::value i) {
  return o << kind_value::_xsd_kind_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const kind_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, line_end::value i) {
  return o << line_end::_xsd_line_end_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const line_end &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o,
                           measure_numbering_value::value i) {
  return o
         << measure_numbering_value::_xsd_measure_numbering_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o,
                           const measure_numbering_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, membrane::value i) {
  return o << membrane::_xsd_membrane_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const membrane &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, metal::value i) {
  return o << metal::_xsd_metal_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const metal &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, on_off::value i) {
  return o << on_off::_xsd_on_off_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const on_off &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, pitched::value i) {
  return o << pitched::_xsd_pitched_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const pitched &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, principal_voice_symbol::value i) {
  return o << principal_voice_symbol::_xsd_principal_voice_symbol_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const principal_voice_symbol &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o,
                           start_stop_change_continue::value i) {
  return o << start_stop_change_continue::
           _xsd_start_stop_change_continue_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o,
                           const start_stop_change_continue &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, tip_direction::value i) {
  return o << tip_direction::_xsd_tip_direction_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const tip_direction &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, stick_location::value i) {
  return o << stick_location::_xsd_stick_location_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const stick_location &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, stick_material::value i) {
  return o << stick_material::_xsd_stick_material_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const stick_material &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, stick_type::value i) {
  return o << stick_type::_xsd_stick_type_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const stick_type &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, up_down_stop_continue::value i) {
  return o << up_down_stop_continue::_xsd_up_down_stop_continue_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const up_down_stop_continue &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, wedge_type::value i) {
  return o << wedge_type::_xsd_wedge_type_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const wedge_type &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, wood::value i) {
  return o << wood::_xsd_wood_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const wood &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const distance_type &i) {
  o << static_cast<const ::xml_schema::token &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const line_width_type &i) {
  o << static_cast<const ::xml_schema::token &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, margin_type::value i) {
  return o << margin_type::_xsd_margin_type_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const margin_type &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const millimeters &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, note_size_type::value i) {
  return o << note_size_type::_xsd_note_size_type_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const note_size_type &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, accidental_value::value i) {
  return o << accidental_value::_xsd_accidental_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const accidental_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, arrow_direction::value i) {
  return o << arrow_direction::_xsd_arrow_direction_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const arrow_direction &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, arrow_style::value i) {
  return o << arrow_style::_xsd_arrow_style_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const arrow_style &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, beam_value::value i) {
  return o << beam_value::_xsd_beam_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const beam_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, breath_mark_value::value i) {
  return o << breath_mark_value::_xsd_breath_mark_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const breath_mark_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, circular_arrow::value i) {
  return o << circular_arrow::_xsd_circular_arrow_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const circular_arrow &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, fan::value i) {
  return o << fan::_xsd_fan_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const fan &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, handbell_value::value i) {
  return o << handbell_value::_xsd_handbell_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const handbell_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, hole_closed_location::value i) {
  return o << hole_closed_location::_xsd_hole_closed_location_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const hole_closed_location &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, hole_closed_value::value i) {
  return o << hole_closed_value::_xsd_hole_closed_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const hole_closed_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, note_type_value::value i) {
  return o << note_type_value::_xsd_note_type_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const note_type_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, notehead_value::value i) {
  return o << notehead_value::_xsd_notehead_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const notehead_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const octave &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const semitones &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, show_tuplet::value i) {
  return o << show_tuplet::_xsd_show_tuplet_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const show_tuplet &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o, stem_value::value i) {
  return o << stem_value::_xsd_stem_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const stem_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, step::value i) {
  return o << step::_xsd_step_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const step &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, syllabic::value i) {
  return o << syllabic::_xsd_syllabic_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const syllabic &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const tremolo_marks &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);

  return o;
}

::std::ostream &operator<<(::std::ostream &o, group_barline_value::value i) {
  return o << group_barline_value::_xsd_group_barline_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const group_barline_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, group_symbol_value::value i) {
  return o << group_symbol_value::_xsd_group_symbol_value_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o, const group_symbol_value &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const accidental_text &i) {
  o << static_cast<const ::musicxml::accidental_value &>(i);

  if (i.justify()) { o << ::std::endl << "justify: " << *i.justify(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  if (i.underline()) { o << ::std::endl << "underline: " << *i.underline(); }

  if (i.overline()) { o << ::std::endl << "overline: " << *i.overline(); }

  if (i.line_through()) {
    o << ::std::endl << "line-through: " << *i.line_through();
  }

  if (i.rotation()) { o << ::std::endl << "rotation: " << *i.rotation(); }

  if (i.letter_spacing()) {
    o << ::std::endl << "letter-spacing: " << *i.letter_spacing();
  }

  if (i.line_height()) {
    o << ::std::endl << "line-height: " << *i.line_height();
  }

  if (i.lang()) { o << ::std::endl << "lang: " << *i.lang(); }

  if (i.space()) { o << ::std::endl << "space: " << *i.space(); }

  if (i.dir()) { o << ::std::endl << "dir: " << *i.dir(); }

  if (i.enclosure()) { o << ::std::endl << "enclosure: " << *i.enclosure(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const dynamics &i) {
  for (const auto &elem : i.p()) { o << ::std::endl << "p: " << elem; }

  for (const auto &elem : i.pp()) { o << ::std::endl << "pp: " << elem; }

  for (const auto &elem : i.ppp()) { o << ::std::endl << "ppp: " << elem; }

  for (const auto &elem : i.pppp()) { o << ::std::endl << "pppp: " << elem; }

  for (const auto &elem : i.ppppp()) { o << ::std::endl << "ppppp: " << elem; }

  for (const auto &elem : i.pppppp()) {
    o << ::std::endl << "pppppp: " << elem;
  }

  for (const auto &elem : i.f()) { o << ::std::endl << "f: " << elem; }

  for (const auto &elem : i.ff()) { o << ::std::endl << "ff: " << elem; }

  for (const auto &elem : i.fff()) { o << ::std::endl << "fff: " << elem; }

  for (const auto &elem : i.ffff()) { o << ::std::endl << "ffff: " << elem; }

  for (const auto &elem : i.fffff()) { o << ::std::endl << "fffff: " << elem; }

  for (const auto &elem : i.ffffff()) {
    o << ::std::endl << "ffffff: " << elem;
  }

  for (const auto &elem : i.mp()) { o << ::std::endl << "mp: " << elem; }

  for (const auto &elem : i.mf()) { o << ::std::endl << "mf: " << elem; }

  for (const auto &elem : i.sf()) { o << ::std::endl << "sf: " << elem; }

  for (const auto &elem : i.sfp()) { o << ::std::endl << "sfp: " << elem; }

  for (const auto &elem : i.sfpp()) { o << ::std::endl << "sfpp: " << elem; }

  for (const auto &elem : i.fp()) { o << ::std::endl << "fp: " << elem; }

  for (const auto &elem : i.rf()) { o << ::std::endl << "rf: " << elem; }

  for (const auto &elem : i.rfz()) { o << ::std::endl << "rfz: " << elem; }

  for (const auto &elem : i.sfz()) { o << ::std::endl << "sfz: " << elem; }

  for (const auto &elem : i.sffz()) { o << ::std::endl << "sffz: " << elem; }

  for (const auto &elem : i.fz()) { o << ::std::endl << "fz: " << elem; }

  for (const auto &elem : i.other_dynamics()) {
    o << ::std::endl << "other-dynamics: " << elem;
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.underline()) { o << ::std::endl << "underline: " << *i.underline(); }

  if (i.overline()) { o << ::std::endl << "overline: " << *i.overline(); }

  if (i.line_through()) {
    o << ::std::endl << "line-through: " << *i.line_through();
  }

  if (i.enclosure()) { o << ::std::endl << "enclosure: " << *i.enclosure(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const empty &) { return o; }

::std::ostream &operator<<(::std::ostream &o, const empty_placement &i) {
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const empty_print_style &i) {
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o,
                           const empty_print_style_align &i) {
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o,
                           const empty_print_object_style_align &i) {
  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const empty_trill_sound &i) {
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.start_note()) { o << ::std::endl << "start-note: " << *i.start_note(); }

  if (i.trill_step()) { o << ::std::endl << "trill-step: " << *i.trill_step(); }

  if (i.two_note_turn()) {
    o << ::std::endl << "two-note-turn: " << *i.two_note_turn();
  }

  if (i.accelerate()) { o << ::std::endl << "accelerate: " << *i.accelerate(); }

  if (i.beats()) { o << ::std::endl << "beats: " << *i.beats(); }

  if (i.second_beat()) {
    o << ::std::endl << "second-beat: " << *i.second_beat();
  }

  if (i.last_beat()) { o << ::std::endl << "last-beat: " << *i.last_beat(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const horizontal_turn &i) {
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.start_note()) { o << ::std::endl << "start-note: " << *i.start_note(); }

  if (i.trill_step()) { o << ::std::endl << "trill-step: " << *i.trill_step(); }

  if (i.two_note_turn()) {
    o << ::std::endl << "two-note-turn: " << *i.two_note_turn();
  }

  if (i.accelerate()) { o << ::std::endl << "accelerate: " << *i.accelerate(); }

  if (i.beats()) { o << ::std::endl << "beats: " << *i.beats(); }

  if (i.second_beat()) {
    o << ::std::endl << "second-beat: " << *i.second_beat();
  }

  if (i.last_beat()) { o << ::std::endl << "last-beat: " << *i.last_beat(); }

  if (i.slash()) { o << ::std::endl << "slash: " << *i.slash(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const fermata &i) {
  o << static_cast<const ::musicxml::fermata_shape &>(i);

  if (i.type()) { o << ::std::endl << "type: " << *i.type(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const fingering &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.substitution()) {
    o << ::std::endl << "substitution: " << *i.substitution();
  }

  if (i.alternate()) { o << ::std::endl << "alternate: " << *i.alternate(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const formatted_text &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.justify()) { o << ::std::endl << "justify: " << *i.justify(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  if (i.underline()) { o << ::std::endl << "underline: " << *i.underline(); }

  if (i.overline()) { o << ::std::endl << "overline: " << *i.overline(); }

  if (i.line_through()) {
    o << ::std::endl << "line-through: " << *i.line_through();
  }

  if (i.rotation()) { o << ::std::endl << "rotation: " << *i.rotation(); }

  if (i.letter_spacing()) {
    o << ::std::endl << "letter-spacing: " << *i.letter_spacing();
  }

  if (i.line_height()) {
    o << ::std::endl << "line-height: " << *i.line_height();
  }

  if (i.lang()) { o << ::std::endl << "lang: " << *i.lang(); }

  if (i.space()) { o << ::std::endl << "space: " << *i.space(); }

  if (i.dir()) { o << ::std::endl << "dir: " << *i.dir(); }

  if (i.enclosure()) { o << ::std::endl << "enclosure: " << *i.enclosure(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const fret &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const level &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.reference()) { o << ::std::endl << "reference: " << *i.reference(); }

  if (i.parentheses()) {
    o << ::std::endl << "parentheses: " << *i.parentheses();
  }

  if (i.bracket()) { o << ::std::endl << "bracket: " << *i.bracket(); }

  if (i.size()) { o << ::std::endl << "size: " << *i.size(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const midi_device &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.port()) { o << ::std::endl << "port: " << *i.port(); }

  if (i.id()) { o << ::std::endl << "id: " << *i.id(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const midi_instrument &i) {
  if (i.midi_channel()) {
    o << ::std::endl << "midi-channel: " << *i.midi_channel();
  }

  if (i.midi_name()) { o << ::std::endl << "midi-name: " << *i.midi_name(); }

  if (i.midi_bank()) { o << ::std::endl << "midi-bank: " << *i.midi_bank(); }

  if (i.midi_program()) {
    o << ::std::endl << "midi-program: " << *i.midi_program();
  }

  if (i.midi_unpitched()) {
    o << ::std::endl << "midi-unpitched: " << *i.midi_unpitched();
  }

  if (i.volume()) { o << ::std::endl << "volume: " << *i.volume(); }

  if (i.pan()) { o << ::std::endl << "pan: " << *i.pan(); }

  if (i.elevation()) { o << ::std::endl << "elevation: " << *i.elevation(); }

  o << ::std::endl << "id: " << i.id();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const name_display &i) {
  for (const auto &elem : i.display_text()) {
    o << ::std::endl << "display-text: " << elem;
  }

  for (const auto &elem : i.accidental_text()) {
    o << ::std::endl << "accidental-text: " << elem;
  }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const other_play &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "type: " << i.type();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const play &i) {
  for (const auto &elem : i.ipa()) { o << ::std::endl << "ipa: " << elem; }

  for (const auto &elem : i.mute()) { o << ::std::endl << "mute: " << elem; }

  for (const auto &elem : i.semi_pitched()) {
    o << ::std::endl << "semi-pitched: " << elem;
  }

  for (const auto &elem : i.other_play()) {
    o << ::std::endl << "other-play: " << elem;
  }

  if (i.id()) { o << ::std::endl << "id: " << *i.id(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const string &i) {
  o << static_cast<const ::musicxml::string_number &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const typed_text &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.type()) { o << ::std::endl << "type: " << *i.type(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const wavy_line &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.start_note()) { o << ::std::endl << "start-note: " << *i.start_note(); }

  if (i.trill_step()) { o << ::std::endl << "trill-step: " << *i.trill_step(); }

  if (i.two_note_turn()) {
    o << ::std::endl << "two-note-turn: " << *i.two_note_turn();
  }

  if (i.accelerate()) { o << ::std::endl << "accelerate: " << *i.accelerate(); }

  if (i.beats()) { o << ::std::endl << "beats: " << *i.beats(); }

  if (i.second_beat()) {
    o << ::std::endl << "second-beat: " << *i.second_beat();
  }

  if (i.last_beat()) { o << ::std::endl << "last-beat: " << *i.last_beat(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const attributes &i) {
  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  if (i.divisions()) { o << ::std::endl << "divisions: " << *i.divisions(); }

  for (const auto &elem : i.key()) { o << ::std::endl << "key: " << elem; }

  for (const auto &elem : i.time()) { o << ::std::endl << "time: " << elem; }

  if (i.staves()) { o << ::std::endl << "staves: " << *i.staves(); }

  if (i.part_symbol()) {
    o << ::std::endl << "part-symbol: " << *i.part_symbol();
  }

  if (i.instruments()) {
    o << ::std::endl << "instruments: " << *i.instruments();
  }

  for (const auto &elem : i.clef()) { o << ::std::endl << "clef: " << elem; }

  for (const auto &elem : i.staff_details()) {
    o << ::std::endl << "staff-details: " << elem;
  }

  for (const auto &elem : i.transpose()) {
    o << ::std::endl << "transpose: " << elem;
  }

  for (const auto &elem : i.directive()) {
    o << ::std::endl << "directive: " << elem;
  }

  for (const auto &elem : i.measure_style()) {
    o << ::std::endl << "measure-style: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const beat_repeat &i) {
  if (i.slash_type()) { o << ::std::endl << "slash-type: " << *i.slash_type(); }

  for (const auto &elem : i.slash_dot()) {
    o << ::std::endl << "slash-dot: " << elem;
  }

  o << ::std::endl << "type: " << i.type();
  if (i.slashes()) { o << ::std::endl << "slashes: " << *i.slashes(); }

  if (i.use_dots()) { o << ::std::endl << "use-dots: " << *i.use_dots(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const cancel &i) {
  o << static_cast<const ::musicxml::fifths &>(i);

  if (i.location()) { o << ::std::endl << "location: " << *i.location(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const clef &i) {
  o << ::std::endl << "sign: " << i.sign();
  if (i.line()) { o << ::std::endl << "line: " << *i.line(); }

  if (i.clef_octave_change()) {
    o << ::std::endl << "clef-octave-change: " << *i.clef_octave_change();
  }

  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.additional()) { o << ::std::endl << "additional: " << *i.additional(); }

  if (i.size()) { o << ::std::endl << "size: " << *i.size(); }

  if (i.after_barline()) {
    o << ::std::endl << "after-barline: " << *i.after_barline();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const interchangeable &i) {
  if (i.time_relation()) {
    o << ::std::endl << "time-relation: " << *i.time_relation();
  }

  for (const auto &elem : i.beats()) { o << ::std::endl << "beats: " << elem; }

  for (const auto &elem : i.beat_type()) {
    o << ::std::endl << "beat-type: " << elem;
  }

  if (i.symbol()) { o << ::std::endl << "symbol: " << *i.symbol(); }

  if (i.separator()) { o << ::std::endl << "separator: " << *i.separator(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const key &i) {
  if (i.cancel()) { o << ::std::endl << "cancel: " << *i.cancel(); }

  if (i.fifths()) { o << ::std::endl << "fifths: " << *i.fifths(); }

  if (i.mode()) { o << ::std::endl << "mode: " << *i.mode(); }

  for (const auto &elem : i.key_step()) {
    o << ::std::endl << "key-step: " << elem;
  }

  for (const auto &elem : i.key_alter()) {
    o << ::std::endl << "key-alter: " << elem;
  }

  for (const auto &elem : i.key_accidental()) {
    o << ::std::endl << "key-accidental: " << elem;
  }

  for (const auto &elem : i.key_octave()) {
    o << ::std::endl << "key-octave: " << elem;
  }

  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const key_octave &i) {
  o << static_cast<const ::musicxml::octave &>(i);

  o << ::std::endl << "number: " << i.number();
  if (i.cancel()) { o << ::std::endl << "cancel: " << *i.cancel(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const measure_repeat &i) {
  o << static_cast<const ::musicxml::positive_integer_or_empty &>(i);

  o << ::std::endl << "type: " << i.type();
  if (i.slashes()) { o << ::std::endl << "slashes: " << *i.slashes(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const measure_style &i) {
  if (i.multiple_rest()) {
    o << ::std::endl << "multiple-rest: " << *i.multiple_rest();
  }

  if (i.measure_repeat()) {
    o << ::std::endl << "measure-repeat: " << *i.measure_repeat();
  }

  if (i.beat_repeat()) {
    o << ::std::endl << "beat-repeat: " << *i.beat_repeat();
  }

  if (i.slash()) { o << ::std::endl << "slash: " << *i.slash(); }

  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const multiple_rest &i) {
  o << static_cast<const ::musicxml::positive_integer_or_empty &>(i);

  if (i.use_symbols()) {
    o << ::std::endl << "use-symbols: " << *i.use_symbols();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const part_symbol &i) {
  o << static_cast<const ::musicxml::group_symbol_value &>(i);

  if (i.top_staff()) { o << ::std::endl << "top-staff: " << *i.top_staff(); }

  if (i.bottom_staff()) {
    o << ::std::endl << "bottom-staff: " << *i.bottom_staff();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const slash &i) {
  if (i.slash_type()) { o << ::std::endl << "slash-type: " << *i.slash_type(); }

  for (const auto &elem : i.slash_dot()) {
    o << ::std::endl << "slash-dot: " << elem;
  }

  o << ::std::endl << "type: " << i.type();
  if (i.use_dots()) { o << ::std::endl << "use-dots: " << *i.use_dots(); }

  if (i.use_stems()) { o << ::std::endl << "use-stems: " << *i.use_stems(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const staff_details &i) {
  if (i.staff_type()) { o << ::std::endl << "staff-type: " << *i.staff_type(); }

  if (i.staff_lines()) {
    o << ::std::endl << "staff-lines: " << *i.staff_lines();
  }

  for (const auto &elem : i.staff_tuning()) {
    o << ::std::endl << "staff-tuning: " << elem;
  }

  if (i.capo()) { o << ::std::endl << "capo: " << *i.capo(); }

  if (i.staff_size()) { o << ::std::endl << "staff-size: " << *i.staff_size(); }

  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.show_frets()) { o << ::std::endl << "show-frets: " << *i.show_frets(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.print_spacing()) {
    o << ::std::endl << "print-spacing: " << *i.print_spacing();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const staff_tuning &i) {
  o << ::std::endl << "tuning-step: " << i.tuning_step();
  if (i.tuning_alter()) {
    o << ::std::endl << "tuning-alter: " << *i.tuning_alter();
  }

  o << ::std::endl << "tuning-octave: " << i.tuning_octave();
  if (i.line()) { o << ::std::endl << "line: " << *i.line(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const time &i) {
  for (const auto &elem : i.beats()) { o << ::std::endl << "beats: " << elem; }

  for (const auto &elem : i.beat_type()) {
    o << ::std::endl << "beat-type: " << elem;
  }

  if (i.interchangeable()) {
    o << ::std::endl << "interchangeable: " << *i.interchangeable();
  }

  if (i.senza_misura()) {
    o << ::std::endl << "senza-misura: " << *i.senza_misura();
  }

  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.symbol()) { o << ::std::endl << "symbol: " << *i.symbol(); }

  if (i.separator()) { o << ::std::endl << "separator: " << *i.separator(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const transpose &i) {
  if (i.diatonic()) { o << ::std::endl << "diatonic: " << *i.diatonic(); }

  o << ::std::endl << "chromatic: " << i.chromatic();
  if (i.octave_change()) {
    o << ::std::endl << "octave-change: " << *i.octave_change();
  }

  if (i.double_()) { o << ::std::endl << "double: " << *i.double_(); }

  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const bar_style_color &i) {
  o << static_cast<const ::musicxml::bar_style &>(i);

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const barline &i) {
  if (i.bar_style()) { o << ::std::endl << "bar-style: " << *i.bar_style(); }

  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  if (i.wavy_line()) { o << ::std::endl << "wavy-line: " << *i.wavy_line(); }

  if (i.segno()) { o << ::std::endl << "segno: " << *i.segno(); }

  if (i.coda()) { o << ::std::endl << "coda: " << *i.coda(); }

  for (const auto &elem : i.fermata()) {
    o << ::std::endl << "fermata: " << elem;
  }

  if (i.ending()) { o << ::std::endl << "ending: " << *i.ending(); }

  if (i.repeat()) { o << ::std::endl << "repeat: " << *i.repeat(); }

  o << ::std::endl << "location: " << i.location();
  if (i.segno1()) { o << ::std::endl << "segno: " << *i.segno1(); }

  if (i.coda1()) { o << ::std::endl << "coda: " << *i.coda1(); }

  if (i.divisions()) { o << ::std::endl << "divisions: " << *i.divisions(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const ending &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "number: " << i.number();
  o << ::std::endl << "type: " << i.type();
  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.end_length()) { o << ::std::endl << "end-length: " << *i.end_length(); }

  if (i.text_x()) { o << ::std::endl << "text-x: " << *i.text_x(); }

  if (i.text_y()) { o << ::std::endl << "text-y: " << *i.text_y(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const repeat &i) {
  o << ::std::endl << "direction: " << i.direction();
  if (i.times()) { o << ::std::endl << "times: " << *i.times(); }

  if (i.winged()) { o << ::std::endl << "winged: " << *i.winged(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const accord &i) {
  o << ::std::endl << "tuning-step: " << i.tuning_step();
  if (i.tuning_alter()) {
    o << ::std::endl << "tuning-alter: " << *i.tuning_alter();
  }

  o << ::std::endl << "tuning-octave: " << i.tuning_octave();
  if (i.string()) { o << ::std::endl << "string: " << *i.string(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const accordion_registration &i) {
  if (i.accordion_high()) {
    o << ::std::endl << "accordion-high: " << *i.accordion_high();
  }

  if (i.accordion_middle()) {
    o << ::std::endl << "accordion-middle: " << *i.accordion_middle();
  }

  if (i.accordion_low()) {
    o << ::std::endl << "accordion-low: " << *i.accordion_low();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const barre &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const bass &i) {
  o << ::std::endl << "bass-step: " << i.bass_step();
  if (i.bass_alter()) { o << ::std::endl << "bass-alter: " << *i.bass_alter(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const bass_alter &i) {
  o << static_cast<const ::musicxml::semitones &>(i);

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.location()) { o << ::std::endl << "location: " << *i.location(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const bass_step &i) {
  o << static_cast<const ::musicxml::step &>(i);

  if (i.text()) { o << ::std::endl << "text: " << *i.text(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const beater &i) {
  o << static_cast<const ::musicxml::beater_value &>(i);

  if (i.tip()) { o << ::std::endl << "tip: " << *i.tip(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const bracket &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  o << ::std::endl << "line-end: " << i.line_end();
  if (i.end_length()) { o << ::std::endl << "end-length: " << *i.end_length(); }

  if (i.line_type()) { o << ::std::endl << "line-type: " << *i.line_type(); }

  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const dashes &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const degree &i) {
  o << ::std::endl << "degree-value: " << i.degree_value();
  o << ::std::endl << "degree-alter: " << i.degree_alter();
  o << ::std::endl << "degree-type: " << i.degree_type();
  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const degree_alter &i) {
  o << static_cast<const ::musicxml::semitones &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.plus_minus()) { o << ::std::endl << "plus-minus: " << *i.plus_minus(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const degree_type &i) {
  o << static_cast<const ::musicxml::degree_type_value &>(i);

  if (i.text()) { o << ::std::endl << "text: " << *i.text(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const degree_value &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  if (i.symbol()) { o << ::std::endl << "symbol: " << *i.symbol(); }

  if (i.text()) { o << ::std::endl << "text: " << *i.text(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const direction &i) {
  for (const auto &elem : i.direction_type()) {
    o << ::std::endl << "direction-type: " << elem;
  }

  if (i.offset()) { o << ::std::endl << "offset: " << *i.offset(); }

  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  if (i.voice()) { o << ::std::endl << "voice: " << *i.voice(); }

  if (i.staff()) { o << ::std::endl << "staff: " << *i.staff(); }

  if (i.sound()) { o << ::std::endl << "sound: " << *i.sound(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.directive()) { o << ::std::endl << "directive: " << *i.directive(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const direction_type &i) {
  for (const auto &elem : i.rehearsal()) {
    o << ::std::endl << "rehearsal: " << elem;
  }

  for (const auto &elem : i.segno()) { o << ::std::endl << "segno: " << elem; }

  for (const auto &elem : i.words()) { o << ::std::endl << "words: " << elem; }

  for (const auto &elem : i.coda()) { o << ::std::endl << "coda: " << elem; }

  if (i.wedge()) { o << ::std::endl << "wedge: " << *i.wedge(); }

  for (const auto &elem : i.dynamics()) {
    o << ::std::endl << "dynamics: " << elem;
  }

  if (i.dashes()) { o << ::std::endl << "dashes: " << *i.dashes(); }

  if (i.bracket()) { o << ::std::endl << "bracket: " << *i.bracket(); }

  if (i.pedal()) { o << ::std::endl << "pedal: " << *i.pedal(); }

  if (i.metronome()) { o << ::std::endl << "metronome: " << *i.metronome(); }

  if (i.octave_shift()) {
    o << ::std::endl << "octave-shift: " << *i.octave_shift();
  }

  if (i.harp_pedals()) {
    o << ::std::endl << "harp-pedals: " << *i.harp_pedals();
  }

  if (i.damp()) { o << ::std::endl << "damp: " << *i.damp(); }

  if (i.damp_all()) { o << ::std::endl << "damp-all: " << *i.damp_all(); }

  if (i.eyeglasses()) { o << ::std::endl << "eyeglasses: " << *i.eyeglasses(); }

  if (i.string_mute()) {
    o << ::std::endl << "string-mute: " << *i.string_mute();
  }

  if (i.scordatura()) { o << ::std::endl << "scordatura: " << *i.scordatura(); }

  if (i.image()) { o << ::std::endl << "image: " << *i.image(); }

  if (i.principal_voice()) {
    o << ::std::endl << "principal-voice: " << *i.principal_voice();
  }

  if (i.accordion_registration()) {
    o << ::std::endl
      << "accordion-registration: " << *i.accordion_registration();
  }

  for (const auto &elem : i.percussion()) {
    o << ::std::endl << "percussion: " << elem;
  }

  if (i.other_direction()) {
    o << ::std::endl << "other-direction: " << *i.other_direction();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const feature &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.type()) { o << ::std::endl << "type: " << *i.type(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const first_fret &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  if (i.text()) { o << ::std::endl << "text: " << *i.text(); }

  if (i.location()) { o << ::std::endl << "location: " << *i.location(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const frame &i) {
  o << ::std::endl << "frame-strings: " << i.frame_strings();
  o << ::std::endl << "frame-frets: " << i.frame_frets();
  if (i.first_fret()) { o << ::std::endl << "first-fret: " << *i.first_fret(); }

  for (const auto &elem : i.frame_note()) {
    o << ::std::endl << "frame-note: " << elem;
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  if (i.height()) { o << ::std::endl << "height: " << *i.height(); }

  if (i.width()) { o << ::std::endl << "width: " << *i.width(); }

  if (i.unplayed()) { o << ::std::endl << "unplayed: " << *i.unplayed(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const frame_note &i) {
  o << ::std::endl << "string: " << i.string();
  o << ::std::endl << "fret: " << i.fret();
  if (i.fingering()) { o << ::std::endl << "fingering: " << *i.fingering(); }

  if (i.barre()) { o << ::std::endl << "barre: " << *i.barre(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const grouping &i) {
  for (const auto &elem : i.feature()) {
    o << ::std::endl << "feature: " << elem;
  }

  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "number: " << i.number();
  if (i.member_of()) { o << ::std::endl << "member-of: " << *i.member_of(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const harmony &i) {
  for (const auto &elem : i.root()) { o << ::std::endl << "root: " << elem; }

  for (const auto &elem : i.function()) {
    o << ::std::endl << "function: " << elem;
  }

  for (const auto &elem : i.kind()) { o << ::std::endl << "kind: " << elem; }

  for (const auto &elem : i.inversion()) {
    o << ::std::endl << "inversion: " << elem;
  }

  for (const auto &elem : i.bass()) { o << ::std::endl << "bass: " << elem; }

  for (const auto &elem : i.degree()) {
    o << ::std::endl << "degree: " << elem;
  }

  if (i.frame()) { o << ::std::endl << "frame: " << *i.frame(); }

  if (i.offset()) { o << ::std::endl << "offset: " << *i.offset(); }

  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  if (i.staff()) { o << ::std::endl << "staff: " << *i.staff(); }

  if (i.type()) { o << ::std::endl << "type: " << *i.type(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.print_frame()) {
    o << ::std::endl << "print-frame: " << *i.print_frame();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const harp_pedals &i) {
  for (const auto &elem : i.pedal_tuning()) {
    o << ::std::endl << "pedal-tuning: " << elem;
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const image &i) {
  o << ::std::endl << "source: " << i.source();
  o << ::std::endl << "type: " << i.type();
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const inversion &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const kind &i) {
  o << static_cast<const ::musicxml::kind_value &>(i);

  if (i.use_symbols()) {
    o << ::std::endl << "use-symbols: " << *i.use_symbols();
  }

  if (i.text()) { o << ::std::endl << "text: " << *i.text(); }

  if (i.stack_degrees()) {
    o << ::std::endl << "stack-degrees: " << *i.stack_degrees();
  }

  if (i.parentheses_degrees()) {
    o << ::std::endl << "parentheses-degrees: " << *i.parentheses_degrees();
  }

  if (i.bracket_degrees()) {
    o << ::std::endl << "bracket-degrees: " << *i.bracket_degrees();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const measure_numbering &i) {
  o << static_cast<const ::musicxml::measure_numbering_value &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const metronome &i) {
  for (const auto &elem : i.beat_unit()) {
    o << ::std::endl << "beat-unit: " << elem;
  }

  for (const auto &elem : i.beat_unit_dot()) {
    o << ::std::endl << "beat-unit-dot: " << elem;
  }

  if (i.per_minute()) { o << ::std::endl << "per-minute: " << *i.per_minute(); }

  for (const auto &elem : i.metronome_note()) {
    o << ::std::endl << "metronome-note: " << elem;
  }

  if (i.metronome_relation()) {
    o << ::std::endl << "metronome-relation: " << *i.metronome_relation();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  if (i.justify()) { o << ::std::endl << "justify: " << *i.justify(); }

  if (i.parentheses()) {
    o << ::std::endl << "parentheses: " << *i.parentheses();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const metronome_beam &i) {
  o << static_cast<const ::musicxml::beam_value &>(i);

  o << ::std::endl << "number: " << i.number();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const metronome_note &i) {
  o << ::std::endl << "metronome-type: " << i.metronome_type();
  for (const auto &elem : i.metronome_dot()) {
    o << ::std::endl << "metronome-dot: " << elem;
  }

  for (const auto &elem : i.metronome_beam()) {
    o << ::std::endl << "metronome-beam: " << elem;
  }

  if (i.metronome_tuplet()) {
    o << ::std::endl << "metronome-tuplet: " << *i.metronome_tuplet();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const time_modification &i) {
  o << ::std::endl << "actual-notes: " << i.actual_notes();
  o << ::std::endl << "normal-notes: " << i.normal_notes();
  if (i.normal_type()) {
    o << ::std::endl << "normal-type: " << *i.normal_type();
  }

  for (const auto &elem : i.normal_dot()) {
    o << ::std::endl << "normal-dot: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const metronome_tuplet &i) {
  o << static_cast<const ::musicxml::time_modification &>(i);

  o << ::std::endl << "type: " << i.type();
  if (i.bracket()) { o << ::std::endl << "bracket: " << *i.bracket(); }

  if (i.show_number()) {
    o << ::std::endl << "show-number: " << *i.show_number();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const octave_shift &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  o << ::std::endl << "size: " << i.size();
  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const offset &i) {
  o << static_cast<const ::musicxml::divisions &>(i);

  if (i.sound()) { o << ::std::endl << "sound: " << *i.sound(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const other_direction &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const pedal &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.line()) { o << ::std::endl << "line: " << *i.line(); }

  if (i.sign()) { o << ::std::endl << "sign: " << *i.sign(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const pedal_tuning &i) {
  o << ::std::endl << "pedal-step: " << i.pedal_step();
  o << ::std::endl << "pedal-alter: " << i.pedal_alter();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const per_minute &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const percussion &i) {
  if (i.glass()) { o << ::std::endl << "glass: " << *i.glass(); }

  if (i.metal()) { o << ::std::endl << "metal: " << *i.metal(); }

  if (i.wood()) { o << ::std::endl << "wood: " << *i.wood(); }

  if (i.pitched()) { o << ::std::endl << "pitched: " << *i.pitched(); }

  if (i.membrane()) { o << ::std::endl << "membrane: " << *i.membrane(); }

  if (i.effect()) { o << ::std::endl << "effect: " << *i.effect(); }

  if (i.timpani()) { o << ::std::endl << "timpani: " << *i.timpani(); }

  if (i.beater()) { o << ::std::endl << "beater: " << *i.beater(); }

  if (i.stick()) { o << ::std::endl << "stick: " << *i.stick(); }

  if (i.stick_location()) {
    o << ::std::endl << "stick-location: " << *i.stick_location();
  }

  if (i.other_percussion()) {
    o << ::std::endl << "other-percussion: " << *i.other_percussion();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  if (i.enclosure()) { o << ::std::endl << "enclosure: " << *i.enclosure(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const principal_voice &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "symbol: " << i.symbol();
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const print &i) {
  if (i.page_layout()) {
    o << ::std::endl << "page-layout: " << *i.page_layout();
  }

  if (i.system_layout()) {
    o << ::std::endl << "system-layout: " << *i.system_layout();
  }

  for (const auto &elem : i.staff_layout()) {
    o << ::std::endl << "staff-layout: " << elem;
  }

  if (i.measure_layout()) {
    o << ::std::endl << "measure-layout: " << *i.measure_layout();
  }

  if (i.measure_numbering()) {
    o << ::std::endl << "measure-numbering: " << *i.measure_numbering();
  }

  if (i.part_name_display()) {
    o << ::std::endl << "part-name-display: " << *i.part_name_display();
  }

  if (i.part_abbreviation_display()) {
    o << ::std::endl
      << "part-abbreviation-display: " << *i.part_abbreviation_display();
  }

  if (i.staff_spacing()) {
    o << ::std::endl << "staff-spacing: " << *i.staff_spacing();
  }

  if (i.new_system()) { o << ::std::endl << "new-system: " << *i.new_system(); }

  if (i.new_page()) { o << ::std::endl << "new-page: " << *i.new_page(); }

  if (i.blank_page()) { o << ::std::endl << "blank-page: " << *i.blank_page(); }

  if (i.page_number()) {
    o << ::std::endl << "page-number: " << *i.page_number();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const root &i) {
  o << ::std::endl << "root-step: " << i.root_step();
  if (i.root_alter()) { o << ::std::endl << "root-alter: " << *i.root_alter(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const root_alter &i) {
  o << static_cast<const ::musicxml::semitones &>(i);

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.location()) { o << ::std::endl << "location: " << *i.location(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const root_step &i) {
  o << static_cast<const ::musicxml::step &>(i);

  if (i.text()) { o << ::std::endl << "text: " << *i.text(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const scordatura &i) {
  for (const auto &elem : i.accord()) {
    o << ::std::endl << "accord: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const sound &i) {
  for (const auto &elem : i.midi_device()) {
    o << ::std::endl << "midi-device: " << elem;
  }

  for (const auto &elem : i.midi_instrument()) {
    o << ::std::endl << "midi-instrument: " << elem;
  }

  for (const auto &elem : i.play()) { o << ::std::endl << "play: " << elem; }

  if (i.offset()) { o << ::std::endl << "offset: " << *i.offset(); }

  if (i.tempo()) { o << ::std::endl << "tempo: " << *i.tempo(); }

  if (i.dynamics()) { o << ::std::endl << "dynamics: " << *i.dynamics(); }

  if (i.dacapo()) { o << ::std::endl << "dacapo: " << *i.dacapo(); }

  if (i.segno()) { o << ::std::endl << "segno: " << *i.segno(); }

  if (i.dalsegno()) { o << ::std::endl << "dalsegno: " << *i.dalsegno(); }

  if (i.coda()) { o << ::std::endl << "coda: " << *i.coda(); }

  if (i.tocoda()) { o << ::std::endl << "tocoda: " << *i.tocoda(); }

  if (i.divisions()) { o << ::std::endl << "divisions: " << *i.divisions(); }

  if (i.forward_repeat()) {
    o << ::std::endl << "forward-repeat: " << *i.forward_repeat();
  }

  if (i.fine()) { o << ::std::endl << "fine: " << *i.fine(); }

  if (i.time_only()) { o << ::std::endl << "time-only: " << *i.time_only(); }

  if (i.pizzicato()) { o << ::std::endl << "pizzicato: " << *i.pizzicato(); }

  if (i.pan()) { o << ::std::endl << "pan: " << *i.pan(); }

  if (i.elevation()) { o << ::std::endl << "elevation: " << *i.elevation(); }

  if (i.damper_pedal()) {
    o << ::std::endl << "damper-pedal: " << *i.damper_pedal();
  }

  if (i.soft_pedal()) { o << ::std::endl << "soft-pedal: " << *i.soft_pedal(); }

  if (i.sostenuto_pedal()) {
    o << ::std::endl << "sostenuto-pedal: " << *i.sostenuto_pedal();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const stick &i) {
  o << ::std::endl << "stick-type: " << i.stick_type();
  o << ::std::endl << "stick-material: " << i.stick_material();
  if (i.tip()) { o << ::std::endl << "tip: " << *i.tip(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const string_mute &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.halign()) { o << ::std::endl << "halign: " << *i.halign(); }

  if (i.valign()) { o << ::std::endl << "valign: " << *i.valign(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const wedge &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.spread()) { o << ::std::endl << "spread: " << *i.spread(); }

  if (i.niente()) { o << ::std::endl << "niente: " << *i.niente(); }

  if (i.line_type()) { o << ::std::endl << "line-type: " << *i.line_type(); }

  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const encoding &i) {
  for (const auto &elem : i.encoding_date()) {
    o << ::std::endl << "encoding-date: " << elem;
  }

  for (const auto &elem : i.encoder()) {
    o << ::std::endl << "encoder: " << elem;
  }

  for (const auto &elem : i.software()) {
    o << ::std::endl << "software: " << elem;
  }

  for (const auto &elem : i.encoding_description()) {
    o << ::std::endl << "encoding-description: " << elem;
  }

  for (const auto &elem : i.supports()) {
    o << ::std::endl << "supports: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const identification &i) {
  for (const auto &elem : i.creator()) {
    o << ::std::endl << "creator: " << elem;
  }

  for (const auto &elem : i.rights()) {
    o << ::std::endl << "rights: " << elem;
  }

  if (i.encoding()) { o << ::std::endl << "encoding: " << *i.encoding(); }

  if (i.source()) { o << ::std::endl << "source: " << *i.source(); }

  for (const auto &elem : i.relation()) {
    o << ::std::endl << "relation: " << elem;
  }

  if (i.miscellaneous()) {
    o << ::std::endl << "miscellaneous: " << *i.miscellaneous();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const miscellaneous &i) {
  for (const auto &elem : i.miscellaneous_field()) {
    o << ::std::endl << "miscellaneous-field: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const miscellaneous_field &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "name: " << i.name();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const supports &i) {
  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "element: " << i.element();
  if (i.attribute()) { o << ::std::endl << "attribute: " << *i.attribute(); }

  if (i.value()) { o << ::std::endl << "value: " << *i.value(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const appearance &i) {
  for (const auto &elem : i.line_width()) {
    o << ::std::endl << "line-width: " << elem;
  }

  for (const auto &elem : i.note_size()) {
    o << ::std::endl << "note-size: " << elem;
  }

  for (const auto &elem : i.distance()) {
    o << ::std::endl << "distance: " << elem;
  }

  for (const auto &elem : i.other_appearance()) {
    o << ::std::endl << "other-appearance: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const distance &i) {
  o << static_cast<const ::musicxml::tenths &>(i);

  o << ::std::endl << "type: " << i.type();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const line_width &i) {
  o << static_cast<const ::musicxml::tenths &>(i);

  o << ::std::endl << "type: " << i.type();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const measure_layout &i) {
  if (i.measure_distance()) {
    o << ::std::endl << "measure-distance: " << *i.measure_distance();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const note_size &i) {
  o << static_cast<const ::musicxml::non_negative_decimal &>(i);

  o << ::std::endl << "type: " << i.type();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const other_appearance &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "type: " << i.type();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const page_layout &i) {
  if (i.page_height()) {
    o << ::std::endl << "page-height: " << *i.page_height();
  }

  if (i.page_width()) { o << ::std::endl << "page-width: " << *i.page_width(); }

  for (const auto &elem : i.page_margins()) {
    o << ::std::endl << "page-margins: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const page_margins &i) {
  o << ::std::endl << "left-margin: " << i.left_margin();
  o << ::std::endl << "right-margin: " << i.right_margin();
  o << ::std::endl << "top-margin: " << i.top_margin();
  o << ::std::endl << "bottom-margin: " << i.bottom_margin();
  if (i.type()) { o << ::std::endl << "type: " << *i.type(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const scaling &i) {
  o << ::std::endl << "millimeters: " << i.millimeters();
  o << ::std::endl << "tenths: " << i.tenths();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const staff_layout &i) {
  if (i.staff_distance()) {
    o << ::std::endl << "staff-distance: " << *i.staff_distance();
  }

  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const system_dividers &i) {
  o << ::std::endl << "left-divider: " << i.left_divider();
  o << ::std::endl << "right-divider: " << i.right_divider();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const system_layout &i) {
  if (i.system_margins()) {
    o << ::std::endl << "system-margins: " << *i.system_margins();
  }

  if (i.system_distance()) {
    o << ::std::endl << "system-distance: " << *i.system_distance();
  }

  if (i.top_system_distance()) {
    o << ::std::endl << "top-system-distance: " << *i.top_system_distance();
  }

  if (i.system_dividers()) {
    o << ::std::endl << "system-dividers: " << *i.system_dividers();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const system_margins &i) {
  o << ::std::endl << "left-margin: " << i.left_margin();
  o << ::std::endl << "right-margin: " << i.right_margin();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const bookmark &i) {
  o << ::std::endl << "id: " << i.id();
  if (i.name()) { o << ::std::endl << "name: " << *i.name(); }

  if (i.element()) { o << ::std::endl << "element: " << *i.element(); }

  if (i.position()) { o << ::std::endl << "position: " << *i.position(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const link &i) {
  o << ::std::endl << "href: " << i.href();
  o << ::std::endl << "type: " << i.type();
  if (i.role()) { o << ::std::endl << "role: " << *i.role(); }

  if (i.title()) { o << ::std::endl << "title: " << *i.title(); }

  o << ::std::endl << "show: " << i.show();
  o << ::std::endl << "actuate: " << i.actuate();
  if (i.name()) { o << ::std::endl << "name: " << *i.name(); }

  if (i.element()) { o << ::std::endl << "element: " << *i.element(); }

  if (i.position()) { o << ::std::endl << "position: " << *i.position(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const accidental &i) {
  o << static_cast<const ::musicxml::accidental_value &>(i);

  if (i.cautionary()) { o << ::std::endl << "cautionary: " << *i.cautionary(); }

  if (i.editorial()) { o << ::std::endl << "editorial: " << *i.editorial(); }

  if (i.parentheses()) {
    o << ::std::endl << "parentheses: " << *i.parentheses();
  }

  if (i.bracket()) { o << ::std::endl << "bracket: " << *i.bracket(); }

  if (i.size()) { o << ::std::endl << "size: " << *i.size(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const accidental_mark &i) {
  o << static_cast<const ::musicxml::accidental_value &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const arpeggiate &i) {
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.direction()) { o << ::std::endl << "direction: " << *i.direction(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const articulations &i) {
  for (const auto &elem : i.accent()) {
    o << ::std::endl << "accent: " << elem;
  }

  for (const auto &elem : i.strong_accent()) {
    o << ::std::endl << "strong-accent: " << elem;
  }

  for (const auto &elem : i.staccato()) {
    o << ::std::endl << "staccato: " << elem;
  }

  for (const auto &elem : i.tenuto()) {
    o << ::std::endl << "tenuto: " << elem;
  }

  for (const auto &elem : i.detached_legato()) {
    o << ::std::endl << "detached-legato: " << elem;
  }

  for (const auto &elem : i.staccatissimo()) {
    o << ::std::endl << "staccatissimo: " << elem;
  }

  for (const auto &elem : i.spiccato()) {
    o << ::std::endl << "spiccato: " << elem;
  }

  for (const auto &elem : i.scoop()) { o << ::std::endl << "scoop: " << elem; }

  for (const auto &elem : i.plop()) { o << ::std::endl << "plop: " << elem; }

  for (const auto &elem : i.doit()) { o << ::std::endl << "doit: " << elem; }

  for (const auto &elem : i.falloff()) {
    o << ::std::endl << "falloff: " << elem;
  }

  for (const auto &elem : i.breath_mark()) {
    o << ::std::endl << "breath-mark: " << elem;
  }

  for (const auto &elem : i.caesura()) {
    o << ::std::endl << "caesura: " << elem;
  }

  for (const auto &elem : i.stress()) {
    o << ::std::endl << "stress: " << elem;
  }

  for (const auto &elem : i.unstress()) {
    o << ::std::endl << "unstress: " << elem;
  }

  for (const auto &elem : i.other_articulation()) {
    o << ::std::endl << "other-articulation: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const arrow &i) {
  if (i.arrow_direction()) {
    o << ::std::endl << "arrow-direction: " << *i.arrow_direction();
  }

  if (i.arrow_style()) {
    o << ::std::endl << "arrow-style: " << *i.arrow_style();
  }

  if (i.circular_arrow()) {
    o << ::std::endl << "circular-arrow: " << *i.circular_arrow();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const backup &i) {
  o << ::std::endl << "duration: " << i.duration();
  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const beam &i) {
  o << static_cast<const ::musicxml::beam_value &>(i);

  o << ::std::endl << "number: " << i.number();
  if (i.repeater()) { o << ::std::endl << "repeater: " << *i.repeater(); }

  if (i.fan()) { o << ::std::endl << "fan: " << *i.fan(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const bend &i) {
  o << ::std::endl << "bend-alter: " << i.bend_alter();
  if (i.pre_bend()) { o << ::std::endl << "pre-bend: " << *i.pre_bend(); }

  if (i.release()) { o << ::std::endl << "release: " << *i.release(); }

  if (i.with_bar()) { o << ::std::endl << "with-bar: " << *i.with_bar(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.accelerate()) { o << ::std::endl << "accelerate: " << *i.accelerate(); }

  if (i.beats()) { o << ::std::endl << "beats: " << *i.beats(); }

  if (i.first_beat()) { o << ::std::endl << "first-beat: " << *i.first_beat(); }

  if (i.last_beat()) { o << ::std::endl << "last-beat: " << *i.last_beat(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const breath_mark &i) {
  o << static_cast<const ::musicxml::breath_mark_value &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const empty_line &i) {
  if (i.line_shape()) { o << ::std::endl << "line-shape: " << *i.line_shape(); }

  if (i.line_type()) { o << ::std::endl << "line-type: " << *i.line_type(); }

  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const extend &i) {
  if (i.type()) { o << ::std::endl << "type: " << *i.type(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const figure &i) {
  if (i.prefix()) { o << ::std::endl << "prefix: " << *i.prefix(); }

  if (i.figure_number()) {
    o << ::std::endl << "figure-number: " << *i.figure_number();
  }

  if (i.suffix()) { o << ::std::endl << "suffix: " << *i.suffix(); }

  if (i.extend()) { o << ::std::endl << "extend: " << *i.extend(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const figured_bass &i) {
  for (const auto &elem : i.figure()) {
    o << ::std::endl << "figure: " << elem;
  }

  if (i.duration()) { o << ::std::endl << "duration: " << *i.duration(); }

  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.print_dot()) { o << ::std::endl << "print-dot: " << *i.print_dot(); }

  if (i.print_spacing()) {
    o << ::std::endl << "print-spacing: " << *i.print_spacing();
  }

  if (i.print_lyric()) {
    o << ::std::endl << "print-lyric: " << *i.print_lyric();
  }

  if (i.parentheses()) {
    o << ::std::endl << "parentheses: " << *i.parentheses();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const forward &i) {
  o << ::std::endl << "duration: " << i.duration();
  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  if (i.voice()) { o << ::std::endl << "voice: " << *i.voice(); }

  if (i.staff()) { o << ::std::endl << "staff: " << *i.staff(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const glissando &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "number: " << i.number();
  if (i.line_type()) { o << ::std::endl << "line-type: " << *i.line_type(); }

  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const grace &i) {
  if (i.steal_time_previous()) {
    o << ::std::endl << "steal-time-previous: " << *i.steal_time_previous();
  }

  if (i.steal_time_following()) {
    o << ::std::endl << "steal-time-following: " << *i.steal_time_following();
  }

  if (i.make_time()) { o << ::std::endl << "make-time: " << *i.make_time(); }

  if (i.slash()) { o << ::std::endl << "slash: " << *i.slash(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const hammer_on_pull_off &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "number: " << i.number();
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const handbell &i) {
  o << static_cast<const ::musicxml::handbell_value &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const harmonic &i) {
  if (i.natural()) { o << ::std::endl << "natural: " << *i.natural(); }

  if (i.artificial()) { o << ::std::endl << "artificial: " << *i.artificial(); }

  if (i.base_pitch()) { o << ::std::endl << "base-pitch: " << *i.base_pitch(); }

  if (i.touching_pitch()) {
    o << ::std::endl << "touching-pitch: " << *i.touching_pitch();
  }

  if (i.sounding_pitch()) {
    o << ::std::endl << "sounding-pitch: " << *i.sounding_pitch();
  }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const heel_toe &i) {
  o << static_cast<const ::musicxml::empty_placement &>(i);

  if (i.substitution()) {
    o << ::std::endl << "substitution: " << *i.substitution();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const hole &i) {
  if (i.hole_type()) { o << ::std::endl << "hole-type: " << *i.hole_type(); }

  o << ::std::endl << "hole-closed: " << i.hole_closed();
  if (i.hole_shape()) { o << ::std::endl << "hole-shape: " << *i.hole_shape(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const hole_closed &i) {
  o << static_cast<const ::musicxml::hole_closed_value &>(i);

  if (i.location()) { o << ::std::endl << "location: " << *i.location(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const instrument &i) {
  o << ::std::endl << "id: " << i.id();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const lyric &i) {
  for (const auto &elem : i.syllabic()) {
    o << ::std::endl << "syllabic: " << elem;
  }

  for (const auto &elem : i.text()) { o << ::std::endl << "text: " << elem; }

  for (const auto &elem : i.elision()) {
    o << ::std::endl << "elision: " << elem;
  }

  if (i.extend()) { o << ::std::endl << "extend: " << *i.extend(); }

  if (i.laughing()) { o << ::std::endl << "laughing: " << *i.laughing(); }

  if (i.humming()) { o << ::std::endl << "humming: " << *i.humming(); }

  if (i.end_line()) { o << ::std::endl << "end-line: " << *i.end_line(); }

  if (i.end_paragraph()) {
    o << ::std::endl << "end-paragraph: " << *i.end_paragraph();
  }

  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.name()) { o << ::std::endl << "name: " << *i.name(); }

  if (i.justify()) { o << ::std::endl << "justify: " << *i.justify(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const mordent &i) {
  o << static_cast<const ::musicxml::empty_trill_sound &>(i);

  if (i.long_()) { o << ::std::endl << "long: " << *i.long_(); }

  if (i.approach()) { o << ::std::endl << "approach: " << *i.approach(); }

  if (i.departure()) { o << ::std::endl << "departure: " << *i.departure(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const non_arpeggiate &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const notations &i) {
  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  for (const auto &elem : i.tied()) { o << ::std::endl << "tied: " << elem; }

  for (const auto &elem : i.slur()) { o << ::std::endl << "slur: " << elem; }

  for (const auto &elem : i.tuplet()) {
    o << ::std::endl << "tuplet: " << elem;
  }

  for (const auto &elem : i.glissando()) {
    o << ::std::endl << "glissando: " << elem;
  }

  for (const auto &elem : i.slide()) { o << ::std::endl << "slide: " << elem; }

  for (const auto &elem : i.ornaments()) {
    o << ::std::endl << "ornaments: " << elem;
  }

  for (const auto &elem : i.technical()) {
    o << ::std::endl << "technical: " << elem;
  }

  for (const auto &elem : i.articulations()) {
    o << ::std::endl << "articulations: " << elem;
  }

  for (const auto &elem : i.dynamics()) {
    o << ::std::endl << "dynamics: " << elem;
  }

  for (const auto &elem : i.fermata()) {
    o << ::std::endl << "fermata: " << elem;
  }

  for (const auto &elem : i.arpeggiate()) {
    o << ::std::endl << "arpeggiate: " << elem;
  }

  for (const auto &elem : i.non_arpeggiate()) {
    o << ::std::endl << "non-arpeggiate: " << elem;
  }

  for (const auto &elem : i.accidental_mark()) {
    o << ::std::endl << "accidental-mark: " << elem;
  }

  for (const auto &elem : i.other_notation()) {
    o << ::std::endl << "other-notation: " << elem;
  }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const note &i) {
  if (i.grace()) { o << ::std::endl << "grace: " << *i.grace(); }

  if (i.chord()) { o << ::std::endl << "chord: " << *i.chord(); }

  if (i.pitch()) { o << ::std::endl << "pitch: " << *i.pitch(); }

  if (i.unpitched()) { o << ::std::endl << "unpitched: " << *i.unpitched(); }

  if (i.rest()) { o << ::std::endl << "rest: " << *i.rest(); }

  for (const auto &elem : i.tie()) { o << ::std::endl << "tie: " << elem; }

  if (i.cue()) { o << ::std::endl << "cue: " << *i.cue(); }

  if (i.duration()) { o << ::std::endl << "duration: " << *i.duration(); }

  if (i.instrument()) { o << ::std::endl << "instrument: " << *i.instrument(); }

  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  if (i.voice()) { o << ::std::endl << "voice: " << *i.voice(); }

  if (i.type()) { o << ::std::endl << "type: " << *i.type(); }

  for (const auto &elem : i.dot()) { o << ::std::endl << "dot: " << elem; }

  if (i.accidental()) { o << ::std::endl << "accidental: " << *i.accidental(); }

  if (i.time_modification()) {
    o << ::std::endl << "time-modification: " << *i.time_modification();
  }

  if (i.stem()) { o << ::std::endl << "stem: " << *i.stem(); }

  if (i.notehead()) { o << ::std::endl << "notehead: " << *i.notehead(); }

  if (i.notehead_text()) {
    o << ::std::endl << "notehead-text: " << *i.notehead_text();
  }

  if (i.staff()) { o << ::std::endl << "staff: " << *i.staff(); }

  for (const auto &elem : i.beam()) { o << ::std::endl << "beam: " << elem; }

  for (const auto &elem : i.notations()) {
    o << ::std::endl << "notations: " << elem;
  }

  for (const auto &elem : i.lyric()) { o << ::std::endl << "lyric: " << elem; }

  if (i.play()) { o << ::std::endl << "play: " << *i.play(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.print_dot()) { o << ::std::endl << "print-dot: " << *i.print_dot(); }

  if (i.print_spacing()) {
    o << ::std::endl << "print-spacing: " << *i.print_spacing();
  }

  if (i.print_lyric()) {
    o << ::std::endl << "print-lyric: " << *i.print_lyric();
  }

  if (i.dynamics()) { o << ::std::endl << "dynamics: " << *i.dynamics(); }

  if (i.end_dynamics()) {
    o << ::std::endl << "end-dynamics: " << *i.end_dynamics();
  }

  if (i.attack()) { o << ::std::endl << "attack: " << *i.attack(); }

  if (i.release()) { o << ::std::endl << "release: " << *i.release(); }

  if (i.time_only()) { o << ::std::endl << "time-only: " << *i.time_only(); }

  if (i.pizzicato()) { o << ::std::endl << "pizzicato: " << *i.pizzicato(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const note_type &i) {
  o << static_cast<const ::musicxml::note_type_value &>(i);

  if (i.size()) { o << ::std::endl << "size: " << *i.size(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const notehead &i) {
  o << static_cast<const ::musicxml::notehead_value &>(i);

  if (i.filled()) { o << ::std::endl << "filled: " << *i.filled(); }

  if (i.parentheses()) {
    o << ::std::endl << "parentheses: " << *i.parentheses();
  }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const notehead_text &i) {
  for (const auto &elem : i.display_text()) {
    o << ::std::endl << "display-text: " << elem;
  }

  for (const auto &elem : i.accidental_text()) {
    o << ::std::endl << "accidental-text: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const ornaments &i) {
  for (const auto &elem : i.trill_mark()) {
    o << ::std::endl << "trill-mark: " << elem;
  }

  for (const auto &elem : i.turn()) { o << ::std::endl << "turn: " << elem; }

  for (const auto &elem : i.delayed_turn()) {
    o << ::std::endl << "delayed-turn: " << elem;
  }

  for (const auto &elem : i.inverted_turn()) {
    o << ::std::endl << "inverted-turn: " << elem;
  }

  for (const auto &elem : i.delayed_inverted_turn()) {
    o << ::std::endl << "delayed-inverted-turn: " << elem;
  }

  for (const auto &elem : i.vertical_turn()) {
    o << ::std::endl << "vertical-turn: " << elem;
  }

  for (const auto &elem : i.shake()) { o << ::std::endl << "shake: " << elem; }

  for (const auto &elem : i.wavy_line()) {
    o << ::std::endl << "wavy-line: " << elem;
  }

  for (const auto &elem : i.mordent()) {
    o << ::std::endl << "mordent: " << elem;
  }

  for (const auto &elem : i.inverted_mordent()) {
    o << ::std::endl << "inverted-mordent: " << elem;
  }

  for (const auto &elem : i.schleifer()) {
    o << ::std::endl << "schleifer: " << elem;
  }

  for (const auto &elem : i.tremolo()) {
    o << ::std::endl << "tremolo: " << elem;
  }

  for (const auto &elem : i.other_ornament()) {
    o << ::std::endl << "other-ornament: " << elem;
  }

  for (const auto &elem : i.accidental_mark()) {
    o << ::std::endl << "accidental-mark: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const other_notation &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "number: " << i.number();
  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const pitch &i) {
  o << ::std::endl << "step: " << i.step();
  if (i.alter()) { o << ::std::endl << "alter: " << *i.alter(); }

  o << ::std::endl << "octave: " << i.octave();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const placement_text &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const rest &i) {
  if (i.display_step()) {
    o << ::std::endl << "display-step: " << *i.display_step();
  }

  if (i.display_octave()) {
    o << ::std::endl << "display-octave: " << *i.display_octave();
  }

  if (i.measure()) { o << ::std::endl << "measure: " << *i.measure(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const slide &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "number: " << i.number();
  if (i.line_type()) { o << ::std::endl << "line-type: " << *i.line_type(); }

  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.accelerate()) { o << ::std::endl << "accelerate: " << *i.accelerate(); }

  if (i.beats()) { o << ::std::endl << "beats: " << *i.beats(); }

  if (i.first_beat()) { o << ::std::endl << "first-beat: " << *i.first_beat(); }

  if (i.last_beat()) { o << ::std::endl << "last-beat: " << *i.last_beat(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const slur &i) {
  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "number: " << i.number();
  if (i.line_type()) { o << ::std::endl << "line-type: " << *i.line_type(); }

  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.orientation()) {
    o << ::std::endl << "orientation: " << *i.orientation();
  }

  if (i.bezier_offset()) {
    o << ::std::endl << "bezier-offset: " << *i.bezier_offset();
  }

  if (i.bezier_offset2()) {
    o << ::std::endl << "bezier-offset2: " << *i.bezier_offset2();
  }

  if (i.bezier_x()) { o << ::std::endl << "bezier-x: " << *i.bezier_x(); }

  if (i.bezier_y()) { o << ::std::endl << "bezier-y: " << *i.bezier_y(); }

  if (i.bezier_x2()) { o << ::std::endl << "bezier-x2: " << *i.bezier_x2(); }

  if (i.bezier_y2()) { o << ::std::endl << "bezier-y2: " << *i.bezier_y2(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const stem &i) {
  o << static_cast<const ::musicxml::stem_value &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const strong_accent &i) {
  o << static_cast<const ::musicxml::empty_placement &>(i);

  o << ::std::endl << "type: " << i.type();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const style_text &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const technical &i) {
  for (const auto &elem : i.up_bow()) {
    o << ::std::endl << "up-bow: " << elem;
  }

  for (const auto &elem : i.down_bow()) {
    o << ::std::endl << "down-bow: " << elem;
  }

  for (const auto &elem : i.harmonic()) {
    o << ::std::endl << "harmonic: " << elem;
  }

  for (const auto &elem : i.open_string()) {
    o << ::std::endl << "open-string: " << elem;
  }

  for (const auto &elem : i.thumb_position()) {
    o << ::std::endl << "thumb-position: " << elem;
  }

  for (const auto &elem : i.fingering()) {
    o << ::std::endl << "fingering: " << elem;
  }

  for (const auto &elem : i.pluck()) { o << ::std::endl << "pluck: " << elem; }

  for (const auto &elem : i.double_tongue()) {
    o << ::std::endl << "double-tongue: " << elem;
  }

  for (const auto &elem : i.triple_tongue()) {
    o << ::std::endl << "triple-tongue: " << elem;
  }

  for (const auto &elem : i.stopped()) {
    o << ::std::endl << "stopped: " << elem;
  }

  for (const auto &elem : i.snap_pizzicato()) {
    o << ::std::endl << "snap-pizzicato: " << elem;
  }

  for (const auto &elem : i.fret()) { o << ::std::endl << "fret: " << elem; }

  for (const auto &elem : i.string()) {
    o << ::std::endl << "string: " << elem;
  }

  for (const auto &elem : i.hammer_on()) {
    o << ::std::endl << "hammer-on: " << elem;
  }

  for (const auto &elem : i.pull_off()) {
    o << ::std::endl << "pull-off: " << elem;
  }

  for (const auto &elem : i.bend()) { o << ::std::endl << "bend: " << elem; }

  for (const auto &elem : i.tap()) { o << ::std::endl << "tap: " << elem; }

  for (const auto &elem : i.heel()) { o << ::std::endl << "heel: " << elem; }

  for (const auto &elem : i.toe()) { o << ::std::endl << "toe: " << elem; }

  for (const auto &elem : i.fingernails()) {
    o << ::std::endl << "fingernails: " << elem;
  }

  for (const auto &elem : i.hole()) { o << ::std::endl << "hole: " << elem; }

  for (const auto &elem : i.arrow()) { o << ::std::endl << "arrow: " << elem; }

  for (const auto &elem : i.handbell()) {
    o << ::std::endl << "handbell: " << elem;
  }

  for (const auto &elem : i.other_technical()) {
    o << ::std::endl << "other-technical: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const text_element_data &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.underline()) { o << ::std::endl << "underline: " << *i.underline(); }

  if (i.overline()) { o << ::std::endl << "overline: " << *i.overline(); }

  if (i.line_through()) {
    o << ::std::endl << "line-through: " << *i.line_through();
  }

  if (i.rotation()) { o << ::std::endl << "rotation: " << *i.rotation(); }

  if (i.letter_spacing()) {
    o << ::std::endl << "letter-spacing: " << *i.letter_spacing();
  }

  if (i.lang()) { o << ::std::endl << "lang: " << *i.lang(); }

  if (i.dir()) { o << ::std::endl << "dir: " << *i.dir(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const text_font_color &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.underline()) { o << ::std::endl << "underline: " << *i.underline(); }

  if (i.overline()) { o << ::std::endl << "overline: " << *i.overline(); }

  if (i.line_through()) {
    o << ::std::endl << "line-through: " << *i.line_through();
  }

  if (i.rotation()) { o << ::std::endl << "rotation: " << *i.rotation(); }

  if (i.letter_spacing()) {
    o << ::std::endl << "letter-spacing: " << *i.letter_spacing();
  }

  if (i.lang()) { o << ::std::endl << "lang: " << *i.lang(); }

  if (i.dir()) { o << ::std::endl << "dir: " << *i.dir(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const tie &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.time_only()) { o << ::std::endl << "time-only: " << *i.time_only(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const tied &i) {
  o << ::std::endl << "type: " << i.type();
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.line_type()) { o << ::std::endl << "line-type: " << *i.line_type(); }

  if (i.dash_length()) {
    o << ::std::endl << "dash-length: " << *i.dash_length();
  }

  if (i.space_length()) {
    o << ::std::endl << "space-length: " << *i.space_length();
  }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  if (i.orientation()) {
    o << ::std::endl << "orientation: " << *i.orientation();
  }

  if (i.bezier_offset()) {
    o << ::std::endl << "bezier-offset: " << *i.bezier_offset();
  }

  if (i.bezier_offset2()) {
    o << ::std::endl << "bezier-offset2: " << *i.bezier_offset2();
  }

  if (i.bezier_x()) { o << ::std::endl << "bezier-x: " << *i.bezier_x(); }

  if (i.bezier_y()) { o << ::std::endl << "bezier-y: " << *i.bezier_y(); }

  if (i.bezier_x2()) { o << ::std::endl << "bezier-x2: " << *i.bezier_x2(); }

  if (i.bezier_y2()) { o << ::std::endl << "bezier-y2: " << *i.bezier_y2(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const tremolo &i) {
  o << static_cast<const ::musicxml::tremolo_marks &>(i);

  o << ::std::endl << "type: " << i.type();
  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const tuplet &i) {
  if (i.tuplet_actual()) {
    o << ::std::endl << "tuplet-actual: " << *i.tuplet_actual();
  }

  if (i.tuplet_normal()) {
    o << ::std::endl << "tuplet-normal: " << *i.tuplet_normal();
  }

  o << ::std::endl << "type: " << i.type();
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.bracket()) { o << ::std::endl << "bracket: " << *i.bracket(); }

  if (i.show_number()) {
    o << ::std::endl << "show-number: " << *i.show_number();
  }

  if (i.show_type()) { o << ::std::endl << "show-type: " << *i.show_type(); }

  if (i.line_shape()) { o << ::std::endl << "line-shape: " << *i.line_shape(); }

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.placement()) { o << ::std::endl << "placement: " << *i.placement(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const tuplet_dot &i) {
  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const tuplet_number &i) {
  o << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const tuplet_portion &i) {
  if (i.tuplet_number()) {
    o << ::std::endl << "tuplet-number: " << *i.tuplet_number();
  }

  if (i.tuplet_type()) {
    o << ::std::endl << "tuplet-type: " << *i.tuplet_type();
  }

  for (const auto &elem : i.tuplet_dot()) {
    o << ::std::endl << "tuplet-dot: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const tuplet_type &i) {
  o << static_cast<const ::musicxml::note_type_value &>(i);

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const unpitched &i) {
  if (i.display_step()) {
    o << ::std::endl << "display-step: " << *i.display_step();
  }

  if (i.display_octave()) {
    o << ::std::endl << "display-octave: " << *i.display_octave();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const credit &i) {
  for (const auto &elem : i.credit_type()) {
    o << ::std::endl << "credit-type: " << elem;
  }

  for (const auto &elem : i.link()) { o << ::std::endl << "link: " << elem; }

  for (const auto &elem : i.bookmark()) {
    o << ::std::endl << "bookmark: " << elem;
  }

  if (i.credit_image()) {
    o << ::std::endl << "credit-image: " << *i.credit_image();
  }

  for (const auto &elem : i.credit_words()) {
    o << ::std::endl << "credit-words: " << elem;
  }

  if (i.page()) { o << ::std::endl << "page: " << *i.page(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const defaults &i) {
  if (i.scaling()) { o << ::std::endl << "scaling: " << *i.scaling(); }

  if (i.page_layout()) {
    o << ::std::endl << "page-layout: " << *i.page_layout();
  }

  if (i.system_layout()) {
    o << ::std::endl << "system-layout: " << *i.system_layout();
  }

  for (const auto &elem : i.staff_layout()) {
    o << ::std::endl << "staff-layout: " << elem;
  }

  if (i.appearance()) { o << ::std::endl << "appearance: " << *i.appearance(); }

  if (i.music_font()) { o << ::std::endl << "music-font: " << *i.music_font(); }

  if (i.word_font()) { o << ::std::endl << "word-font: " << *i.word_font(); }

  for (const auto &elem : i.lyric_font()) {
    o << ::std::endl << "lyric-font: " << elem;
  }

  for (const auto &elem : i.lyric_language()) {
    o << ::std::endl << "lyric-language: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const empty_font &i) {
  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const group_barline &i) {
  o << static_cast<const ::musicxml::group_barline_value &>(i);

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const group_name &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.justify()) { o << ::std::endl << "justify: " << *i.justify(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const group_symbol &i) {
  o << static_cast<const ::musicxml::group_symbol_value &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const lyric_font &i) {
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.name()) { o << ::std::endl << "name: " << *i.name(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const lyric_language &i) {
  if (i.number()) { o << ::std::endl << "number: " << *i.number(); }

  if (i.name()) { o << ::std::endl << "name: " << *i.name(); }

  o << ::std::endl << "lang: " << i.lang();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const opus &i) {
  o << ::std::endl << "href: " << i.href();
  o << ::std::endl << "type: " << i.type();
  if (i.role()) { o << ::std::endl << "role: " << *i.role(); }

  if (i.title()) { o << ::std::endl << "title: " << *i.title(); }

  o << ::std::endl << "show: " << i.show();
  o << ::std::endl << "actuate: " << i.actuate();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const part_group &i) {
  if (i.group_name()) { o << ::std::endl << "group-name: " << *i.group_name(); }

  if (i.group_name_display()) {
    o << ::std::endl << "group-name-display: " << *i.group_name_display();
  }

  if (i.group_abbreviation()) {
    o << ::std::endl << "group-abbreviation: " << *i.group_abbreviation();
  }

  if (i.group_abbreviation_display()) {
    o << ::std::endl
      << "group-abbreviation-display: " << *i.group_abbreviation_display();
  }

  if (i.group_symbol()) {
    o << ::std::endl << "group-symbol: " << *i.group_symbol();
  }

  if (i.group_barline()) {
    o << ::std::endl << "group-barline: " << *i.group_barline();
  }

  if (i.group_time()) { o << ::std::endl << "group-time: " << *i.group_time(); }

  if (i.footnote()) { o << ::std::endl << "footnote: " << *i.footnote(); }

  if (i.level()) { o << ::std::endl << "level: " << *i.level(); }

  o << ::std::endl << "type: " << i.type();
  o << ::std::endl << "number: " << i.number();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const part_list &i) {
  for (const auto &elem : i.part_group()) {
    o << ::std::endl << "part-group: " << elem;
  }

  for (const auto &elem : i.score_part()) {
    o << ::std::endl << "score-part: " << elem;
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const part_name &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.print_object()) {
    o << ::std::endl << "print-object: " << *i.print_object();
  }

  if (i.justify()) { o << ::std::endl << "justify: " << *i.justify(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const score_instrument &i) {
  o << ::std::endl << "instrument-name: " << i.instrument_name();
  if (i.instrument_abbreviation()) {
    o << ::std::endl
      << "instrument-abbreviation: " << *i.instrument_abbreviation();
  }

  if (i.instrument_sound()) {
    o << ::std::endl << "instrument-sound: " << *i.instrument_sound();
  }

  if (i.solo()) { o << ::std::endl << "solo: " << *i.solo(); }

  if (i.ensemble()) { o << ::std::endl << "ensemble: " << *i.ensemble(); }

  if (i.virtual_instrument()) {
    o << ::std::endl << "virtual-instrument: " << *i.virtual_instrument();
  }

  o << ::std::endl << "id: " << i.id();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const score_part &i) {
  if (i.identification()) {
    o << ::std::endl << "identification: " << *i.identification();
  }

  o << ::std::endl << "part-name: " << i.part_name();
  if (i.part_name_display()) {
    o << ::std::endl << "part-name-display: " << *i.part_name_display();
  }

  if (i.part_abbreviation()) {
    o << ::std::endl << "part-abbreviation: " << *i.part_abbreviation();
  }

  if (i.part_abbreviation_display()) {
    o << ::std::endl
      << "part-abbreviation-display: " << *i.part_abbreviation_display();
  }

  for (const auto &elem : i.group()) { o << ::std::endl << "group: " << elem; }

  for (const auto &elem : i.score_instrument()) {
    o << ::std::endl << "score-instrument: " << elem;
  }

  for (const auto &elem : i.midi_device()) {
    o << ::std::endl << "midi-device: " << elem;
  }

  for (const auto &elem : i.midi_instrument()) {
    o << ::std::endl << "midi-instrument: " << elem;
  }

  o << ::std::endl << "id: " << i.id();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const virtual_instrument &i) {
  if (i.virtual_library()) {
    o << ::std::endl << "virtual-library: " << *i.virtual_library();
  }

  if (i.virtual_name()) {
    o << ::std::endl << "virtual-name: " << *i.virtual_name();
  }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const work &i) {
  if (i.work_number()) {
    o << ::std::endl << "work-number: " << *i.work_number();
  }

  if (i.work_title()) { o << ::std::endl << "work-title: " << *i.work_title(); }

  if (i.opus()) { o << ::std::endl << "opus: " << *i.opus(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o,
                           number_or_normal_member::value i) {
  return o
         << number_or_normal_member::_xsd_number_or_normal_member_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o,
                           const number_or_normal_member &i) {
  return o << static_cast<const ::xml_schema::token &>(i);
}

::std::ostream &operator<<(::std::ostream &o,
                           positive_integer_or_empty_member::value i) {
  return o << positive_integer_or_empty_member::
           _xsd_positive_integer_or_empty_member_literals_[i];
}

::std::ostream &operator<<(::std::ostream &o,
                           const positive_integer_or_empty_member &i) {
  return o << static_cast<const ::xml_schema::string &>(i);
}

::std::ostream &operator<<(::std::ostream &o, const directive &i) {
  o << static_cast<const ::xml_schema::string &>(i);

  if (i.default_x()) { o << ::std::endl << "default-x: " << *i.default_x(); }

  if (i.default_y()) { o << ::std::endl << "default-y: " << *i.default_y(); }

  if (i.relative_x()) { o << ::std::endl << "relative-x: " << *i.relative_x(); }

  if (i.relative_y()) { o << ::std::endl << "relative-y: " << *i.relative_y(); }

  if (i.font_family()) {
    o << ::std::endl << "font-family: " << *i.font_family();
  }

  if (i.font_style()) { o << ::std::endl << "font-style: " << *i.font_style(); }

  if (i.font_size()) { o << ::std::endl << "font-size: " << *i.font_size(); }

  if (i.font_weight()) {
    o << ::std::endl << "font-weight: " << *i.font_weight();
  }

  if (i.color()) { o << ::std::endl << "color: " << *i.color(); }

  if (i.lang()) { o << ::std::endl << "lang: " << *i.lang(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const score_partwise &i) {
  if (i.work()) { o << ::std::endl << "work: " << *i.work(); }

  if (i.movement_number()) {
    o << ::std::endl << "movement-number: " << *i.movement_number();
  }

  if (i.movement_title()) {
    o << ::std::endl << "movement-title: " << *i.movement_title();
  }

  if (i.identification()) {
    o << ::std::endl << "identification: " << *i.identification();
  }

  if (i.defaults()) { o << ::std::endl << "defaults: " << *i.defaults(); }

  for (const auto &elem : i.credit()) {
    o << ::std::endl << "credit: " << elem;
  }

  o << ::std::endl << "part-list: " << i.part_list();
  for (const auto &elem : i.part()) { o << ::std::endl << "part: " << elem; }

  o << ::std::endl << "version: " << i.version();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const score_timewise &i) {
  if (i.work()) { o << ::std::endl << "work: " << *i.work(); }

  if (i.movement_number()) {
    o << ::std::endl << "movement-number: " << *i.movement_number();
  }

  if (i.movement_title()) {
    o << ::std::endl << "movement-title: " << *i.movement_title();
  }

  if (i.identification()) {
    o << ::std::endl << "identification: " << *i.identification();
  }

  if (i.defaults()) { o << ::std::endl << "defaults: " << *i.defaults(); }

  for (const auto &elem : i.credit()) {
    o << ::std::endl << "credit: " << elem;
  }

  o << ::std::endl << "part-list: " << i.part_list();
  for (const auto &elem : i.measure()) {
    o << ::std::endl << "measure: " << elem;
  }

  o << ::std::endl << "version: " << i.version();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const part &i) {
  for (const auto &elem : i.measure()) {
    o << ::std::endl << "measure: " << elem;
  }

  o << ::std::endl << "id: " << i.id();
  return o;
}

::std::ostream &operator<<(::std::ostream &o, const measure &i) {
  for (const auto &elem : i.part()) { o << ::std::endl << "part: " << elem; }

  o << ::std::endl << "number: " << i.number();
  if (i.implicit()) { o << ::std::endl << "implicit: " << *i.implicit(); }

  if (i.non_controlling()) {
    o << ::std::endl << "non-controlling: " << *i.non_controlling();
  }

  if (i.width()) { o << ::std::endl << "width: " << *i.width(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const measure1 &i) {
  for (const auto &elem : i.note()) { o << ::std::endl << "note: " << elem; }

  for (const auto &elem : i.backup()) {
    o << ::std::endl << "backup: " << elem;
  }

  for (const auto &elem : i.forward()) {
    o << ::std::endl << "forward: " << elem;
  }

  for (const auto &elem : i.direction()) {
    o << ::std::endl << "direction: " << elem;
  }

  for (const auto &elem : i.attributes()) {
    o << ::std::endl << "attributes: " << elem;
  }

  for (const auto &elem : i.harmony()) {
    o << ::std::endl << "harmony: " << elem;
  }

  for (const auto &elem : i.figured_bass()) {
    o << ::std::endl << "figured-bass: " << elem;
  }

  for (const auto &elem : i.print()) { o << ::std::endl << "print: " << elem; }

  for (const auto &elem : i.sound()) { o << ::std::endl << "sound: " << elem; }

  for (const auto &elem : i.barline()) {
    o << ::std::endl << "barline: " << elem;
  }

  for (const auto &elem : i.grouping()) {
    o << ::std::endl << "grouping: " << elem;
  }

  for (const auto &elem : i.link()) { o << ::std::endl << "link: " << elem; }

  for (const auto &elem : i.bookmark()) {
    o << ::std::endl << "bookmark: " << elem;
  }

  o << ::std::endl << "number: " << i.number();
  if (i.implicit()) { o << ::std::endl << "implicit: " << *i.implicit(); }

  if (i.non_controlling()) {
    o << ::std::endl << "non-controlling: " << *i.non_controlling();
  }

  if (i.width()) { o << ::std::endl << "width: " << *i.width(); }

  return o;
}

::std::ostream &operator<<(::std::ostream &o, const part1 &i) {
  for (const auto &elem : i.note()) { o << ::std::endl << "note: " << elem; }

  for (const auto &elem : i.backup()) {
    o << ::std::endl << "backup: " << elem;
  }

  for (const auto &elem : i.forward()) {
    o << ::std::endl << "forward: " << elem;
  }

  for (const auto &elem : i.direction()) {
    o << ::std::endl << "direction: " << elem;
  }

  for (const auto &elem : i.attributes()) {
    o << ::std::endl << "attributes: " << elem;
  }

  for (const auto &elem : i.harmony()) {
    o << ::std::endl << "harmony: " << elem;
  }

  for (const auto &elem : i.figured_bass()) {
    o << ::std::endl << "figured-bass: " << elem;
  }

  for (const auto &elem : i.print()) { o << ::std::endl << "print: " << elem; }

  for (const auto &elem : i.sound()) { o << ::std::endl << "sound: " << elem; }

  for (const auto &elem : i.barline()) {
    o << ::std::endl << "barline: " << elem;
  }

  for (const auto &elem : i.grouping()) {
    o << ::std::endl << "grouping: " << elem;
  }

  for (const auto &elem : i.link()) { o << ::std::endl << "link: " << elem; }

  for (const auto &elem : i.bookmark()) {
    o << ::std::endl << "bookmark: " << elem;
  }

  o << ::std::endl << "id: " << i.id();
  return o;
}
} // namespace musicxml

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace musicxml {
::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(const ::std::string &u, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  h.throw_if_failed<::xsd::cxx::tree::parsing<char>>();

  return ::std::unique_ptr<::musicxml::score_partwise>(
    ::musicxml::score_partwise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(const ::std::string &u, ::xml_schema::error_handler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::musicxml::score_partwise>(
    ::musicxml::score_partwise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(const ::std::string &u, ::xercesc::DOMErrorHandler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::musicxml::score_partwise>(
    ::musicxml::score_partwise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::musicxml::score_partwise_(isrc, f, p);
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, ::xml_schema::error_handler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::musicxml::score_partwise_(isrc, h, f, p);
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, ::xercesc::DOMErrorHandler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::musicxml::score_partwise_(isrc, h, f, p);
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, const ::std::string &sid,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::musicxml::score_partwise_(isrc, f, p);
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, const ::std::string &sid,
                ::xml_schema::error_handler &h, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::musicxml::score_partwise_(isrc, h, f, p);
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::std::istream &is, const ::std::string &sid,
                ::xercesc::DOMErrorHandler &h, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::musicxml::score_partwise_(isrc, h, f, p);
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::xercesc::InputSource &i, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  h.throw_if_failed<::xsd::cxx::tree::parsing<char>>();

  return ::std::unique_ptr<::musicxml::score_partwise>(
    ::musicxml::score_partwise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::xercesc::InputSource &i, ::xml_schema::error_handler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::musicxml::score_partwise>(
    ::musicxml::score_partwise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::xercesc::InputSource &i, ::xercesc::DOMErrorHandler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::musicxml::score_partwise>(
    ::musicxml::score_partwise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(const ::xercesc::DOMDocument &doc, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  if (f & ::xml_schema::flags::keep_dom) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
      static_cast<::xercesc::DOMDocument *>(doc.cloneNode(true)));

    return ::std::unique_ptr<::musicxml::score_partwise>(
      ::musicxml::score_partwise_(std::move(d),
                                  f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement &e(*doc.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
    ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "score-partwise" && n.namespace_() == "") {
    ::std::unique_ptr<::musicxml::score_partwise> r(
      ::xsd::cxx::tree::traits<::musicxml::score_partwise, char>::create(
        e, f, nullptr));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "score-partwise", "");
}

::std::unique_ptr<::musicxml::score_partwise>
score_partwise_(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d,
                ::xml_schema::flags f, const ::xml_schema::properties &) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> c(
    ((f & ::xml_schema::flags::keep_dom) && !(f & ::xml_schema::flags::own_dom))
      ? static_cast<::xercesc::DOMDocument *>(d->cloneNode(true))
      : nullptr);

  ::xercesc::DOMDocument &doc(c.get() ? *c : *d);
  const ::xercesc::DOMElement &e(*doc.getDocumentElement());

  const ::xsd::cxx::xml::qualified_name<char> n(
    ::xsd::cxx::xml::dom::name<char>(e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d),
                    nullptr);

  if (n.name() == "score-partwise" && n.namespace_() == "") {
    ::std::unique_ptr<::musicxml::score_partwise> r(
      ::xsd::cxx::tree::traits<::musicxml::score_partwise, char>::create(
        e, f, nullptr));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "score-partwise", "");
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(const ::std::string &u, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  h.throw_if_failed<::xsd::cxx::tree::parsing<char>>();

  return ::std::unique_ptr<::musicxml::score_timewise>(
    ::musicxml::score_timewise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(const ::std::string &u, ::xml_schema::error_handler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::musicxml::score_timewise>(
    ::musicxml::score_timewise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(const ::std::string &u, ::xercesc::DOMErrorHandler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::musicxml::score_timewise>(
    ::musicxml::score_timewise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::musicxml::score_timewise_(isrc, f, p);
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, ::xml_schema::error_handler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::musicxml::score_timewise_(isrc, h, f, p);
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, ::xercesc::DOMErrorHandler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::musicxml::score_timewise_(isrc, h, f, p);
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, const ::std::string &sid,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::musicxml::score_timewise_(isrc, f, p);
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, const ::std::string &sid,
                ::xml_schema::error_handler &h, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::musicxml::score_timewise_(isrc, h, f, p);
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::std::istream &is, const ::std::string &sid,
                ::xercesc::DOMErrorHandler &h, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::musicxml::score_timewise_(isrc, h, f, p);
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::xercesc::InputSource &i, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  h.throw_if_failed<::xsd::cxx::tree::parsing<char>>();

  return ::std::unique_ptr<::musicxml::score_timewise>(
    ::musicxml::score_timewise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::xercesc::InputSource &i, ::xml_schema::error_handler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::musicxml::score_timewise>(
    ::musicxml::score_timewise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::xercesc::InputSource &i, ::xercesc::DOMErrorHandler &h,
                ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::musicxml::score_timewise>(
    ::musicxml::score_timewise_(std::move(d), f | ::xml_schema::flags::own_dom,
                                p));
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(const ::xercesc::DOMDocument &doc, ::xml_schema::flags f,
                const ::xml_schema::properties &p) {
  if (f & ::xml_schema::flags::keep_dom) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
      static_cast<::xercesc::DOMDocument *>(doc.cloneNode(true)));

    return ::std::unique_ptr<::musicxml::score_timewise>(
      ::musicxml::score_timewise_(std::move(d),
                                  f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement &e(*doc.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
    ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "score-timewise" && n.namespace_() == "") {
    ::std::unique_ptr<::musicxml::score_timewise> r(
      ::xsd::cxx::tree::traits<::musicxml::score_timewise, char>::create(
        e, f, nullptr));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "score-timewise", "");
}

::std::unique_ptr<::musicxml::score_timewise>
score_timewise_(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d,
                ::xml_schema::flags f, const ::xml_schema::properties &) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> c(
    ((f & ::xml_schema::flags::keep_dom) && !(f & ::xml_schema::flags::own_dom))
      ? static_cast<::xercesc::DOMDocument *>(d->cloneNode(true))
      : nullptr);

  ::xercesc::DOMDocument &doc(c.get() ? *c : *d);
  const ::xercesc::DOMElement &e(*doc.getDocumentElement());

  const ::xsd::cxx::xml::qualified_name<char> n(
    ::xsd::cxx::xml::dom::name<char>(e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d),
                    nullptr);

  if (n.name() == "score-timewise" && n.namespace_() == "") {
    ::std::unique_ptr<::musicxml::score_timewise> r(
      ::xsd::cxx::tree::traits<::musicxml::score_timewise, char>::create(
        e, f, nullptr));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                   "score-timewise", "");
}
} // namespace musicxml

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace musicxml {
void operator<<(::xercesc::DOMElement &e, const above_below &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const above_below &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const above_below &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const beam_level &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const beam_level &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const beam_level &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const color &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const color &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const color &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const comma_separated_text &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const comma_separated_text &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const comma_separated_text &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const css_font_size &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const css_font_size &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const css_font_size &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const divisions &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const divisions &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const divisions &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const enclosure_shape &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const enclosure_shape &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const enclosure_shape &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const fermata_shape &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const fermata_shape &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const fermata_shape &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const font_size &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const font_size &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const font_size &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const font_style &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const font_style &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const font_style &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const font_weight &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const font_weight &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const font_weight &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const left_center_right &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const left_center_right &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const left_center_right &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const left_right &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const left_right &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const left_right &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const line_shape &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const line_shape &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const line_shape &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const line_type &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const line_type &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const line_type &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const midi_16 &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const midi_16 &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const midi_16 &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const midi_128 &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const midi_128 &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const midi_128 &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const midi_16384 &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const midi_16384 &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const midi_16384 &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const mute &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const mute &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const mute &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const non_negative_decimal &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const non_negative_decimal &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const non_negative_decimal &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const number_level &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const number_level &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const number_level &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const number_of_lines &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const number_of_lines &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const number_of_lines &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const number_or_normal &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const number_or_normal &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const number_or_normal &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const over_under &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const over_under &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const over_under &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const percent &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const percent &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const percent &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const positive_decimal &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const positive_decimal &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const positive_decimal &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const positive_divisions &i) {
  e << static_cast<const ::musicxml::divisions &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const positive_divisions &i) {
  a << static_cast<const ::musicxml::divisions &>(i);
}

void operator<<(::xml_schema::list_stream &l, const positive_divisions &i) {
  l << static_cast<const ::musicxml::divisions &>(i);
}

void operator<<(::xercesc::DOMElement &e, const positive_integer_or_empty &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const positive_integer_or_empty &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l,
                const positive_integer_or_empty &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const rotation_degrees &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const rotation_degrees &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const rotation_degrees &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const semi_pitched &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const semi_pitched &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const semi_pitched &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const start_note &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const start_note &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const start_note &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const start_stop &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const start_stop &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const start_stop &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const start_stop_continue &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const start_stop_continue &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const start_stop_continue &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const start_stop_single &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const start_stop_single &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const start_stop_single &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const string_number &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const string_number &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const string_number &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const symbol_size &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const symbol_size &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const symbol_size &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const tenths &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const tenths &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const tenths &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const text_direction &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const text_direction &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const text_direction &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const time_only &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const time_only &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const time_only &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const top_bottom &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const top_bottom &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const top_bottom &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const trill_beats &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const trill_beats &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const trill_beats &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const trill_step &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const trill_step &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const trill_step &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const two_note_turn &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const two_note_turn &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const two_note_turn &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const up_down &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const up_down &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const up_down &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const upright_inverted &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const upright_inverted &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const upright_inverted &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const valign &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const valign &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const valign &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const valign_image &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const valign_image &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const valign_image &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const yes_no &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const yes_no &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const yes_no &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const yes_no_number &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const yes_no_number &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const yes_no_number &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const yyyy_mm_dd &i) {
  e << static_cast<const ::xml_schema::date &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const yyyy_mm_dd &i) {
  a << static_cast<const ::xml_schema::date &>(i);
}

void operator<<(::xml_schema::list_stream &l, const yyyy_mm_dd &i) {
  l << static_cast<const ::xml_schema::date &>(i);
}

void operator<<(::xercesc::DOMElement &e, const cancel_location &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const cancel_location &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const cancel_location &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const clef_sign &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const clef_sign &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const clef_sign &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const fifths &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const fifths &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const fifths &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const mode &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const mode &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const mode &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const show_frets &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const show_frets &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const show_frets &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const staff_line &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const staff_line &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const staff_line &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const staff_number &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const staff_number &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const staff_number &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const staff_type &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const staff_type &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const staff_type &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const time_relation &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const time_relation &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const time_relation &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const time_separator &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const time_separator &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const time_separator &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const time_symbol &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const time_symbol &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const time_symbol &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const backward_forward &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const backward_forward &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const backward_forward &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const bar_style &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const bar_style &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const bar_style &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const ending_number &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const ending_number &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const ending_number &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const right_left_middle &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const right_left_middle &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const right_left_middle &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const start_stop_discontinue &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const start_stop_discontinue &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const start_stop_discontinue &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const winged &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const winged &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const winged &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const accordion_middle &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const accordion_middle &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const accordion_middle &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const beater_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const beater_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const beater_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const degree_symbol_value &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const degree_symbol_value &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const degree_symbol_value &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const degree_type_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const degree_type_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const degree_type_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const effect &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const effect &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const effect &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const glass &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const glass &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const glass &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const harmony_type &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const harmony_type &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const harmony_type &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const kind_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const kind_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const kind_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const line_end &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const line_end &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const line_end &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const measure_numbering_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const measure_numbering_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l,
                const measure_numbering_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const membrane &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const membrane &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const membrane &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const metal &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const metal &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const metal &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const on_off &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const on_off &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const on_off &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const pitched &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const pitched &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const pitched &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const principal_voice_symbol &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const principal_voice_symbol &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const principal_voice_symbol &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const start_stop_change_continue &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const start_stop_change_continue &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l,
                const start_stop_change_continue &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const tip_direction &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const tip_direction &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const tip_direction &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const stick_location &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const stick_location &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const stick_location &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const stick_material &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const stick_material &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const stick_material &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const stick_type &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const stick_type &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const stick_type &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const up_down_stop_continue &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const up_down_stop_continue &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const up_down_stop_continue &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const wedge_type &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const wedge_type &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const wedge_type &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const wood &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const wood &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const wood &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const distance_type &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const distance_type &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const distance_type &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const line_width_type &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const line_width_type &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const line_width_type &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const margin_type &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const margin_type &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const margin_type &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const millimeters &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const millimeters &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const millimeters &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const note_size_type &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const note_size_type &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const note_size_type &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const accidental_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const accidental_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const accidental_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const arrow_direction &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const arrow_direction &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const arrow_direction &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const arrow_style &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const arrow_style &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const arrow_style &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const beam_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const beam_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const beam_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const breath_mark_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const breath_mark_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const breath_mark_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const circular_arrow &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const circular_arrow &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const circular_arrow &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const fan &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const fan &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const fan &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const handbell_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const handbell_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const handbell_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const hole_closed_location &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const hole_closed_location &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const hole_closed_location &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const hole_closed_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const hole_closed_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const hole_closed_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const note_type_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const note_type_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const note_type_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const notehead_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const notehead_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const notehead_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const octave &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const octave &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const octave &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const semitones &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const semitones &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const semitones &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::decimal, char, ::xml_schema::simple_type,
    ::xsd::cxx::tree::schema_type::decimal> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const show_tuplet &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const show_tuplet &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l, const show_tuplet &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e, const stem_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const stem_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const stem_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const step &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const step &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const step &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const syllabic &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const syllabic &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const syllabic &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const tremolo_marks &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const tremolo_marks &i) {
  a << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xml_schema::list_stream &l, const tremolo_marks &i) {
  l << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::integer, char, ::xml_schema::simple_type> &>(i);
}

void operator<<(::xercesc::DOMElement &e, const group_barline_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const group_barline_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const group_barline_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const group_symbol_value &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const group_symbol_value &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l, const group_symbol_value &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const accidental_text &i) {
  e << static_cast<const ::musicxml::accidental_value &>(i);

  // justify
  //
  if (i.justify()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("justify", e));

    a << *i.justify();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }

  // underline
  //
  if (i.underline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("underline", e));

    a << *i.underline();
  }

  // overline
  //
  if (i.overline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("overline", e));

    a << *i.overline();
  }

  // line-through
  //
  if (i.line_through()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-through", e));

    a << *i.line_through();
  }

  // rotation
  //
  if (i.rotation()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("rotation", e));

    a << *i.rotation();
  }

  // letter-spacing
  //
  if (i.letter_spacing()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("letter-spacing", e));

    a << *i.letter_spacing();
  }

  // line-height
  //
  if (i.line_height()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-height", e));

    a << *i.line_height();
  }

  // lang
  //
  if (i.lang()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "lang", "http://www.w3.org/XML/1998/namespace", e));

    a << *i.lang();
  }

  // space
  //
  if (i.space()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "space", "http://www.w3.org/XML/1998/namespace", e));

    a << *i.space();
  }

  // dir
  //
  if (i.dir()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("dir", e));

    a << *i.dir();
  }

  // enclosure
  //
  if (i.enclosure()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("enclosure", e));

    a << *i.enclosure();
  }
}

void operator<<(::xercesc::DOMElement &e, const dynamics &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // p
  //
  for (const auto &elem : i.p()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("p", e));

    s << elem;
  }

  // pp
  //
  for (const auto &elem : i.pp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("pp", e));

    s << elem;
  }

  // ppp
  //
  for (const auto &elem : i.ppp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("ppp", e));

    s << elem;
  }

  // pppp
  //
  for (const auto &elem : i.pppp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("pppp", e));

    s << elem;
  }

  // ppppp
  //
  for (const auto &elem : i.ppppp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("ppppp", e));

    s << elem;
  }

  // pppppp
  //
  for (const auto &elem : i.pppppp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("pppppp", e));

    s << elem;
  }

  // f
  //
  for (const auto &elem : i.f()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("f", e));

    s << elem;
  }

  // ff
  //
  for (const auto &elem : i.ff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("ff", e));

    s << elem;
  }

  // fff
  //
  for (const auto &elem : i.fff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("fff", e));

    s << elem;
  }

  // ffff
  //
  for (const auto &elem : i.ffff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("ffff", e));

    s << elem;
  }

  // fffff
  //
  for (const auto &elem : i.fffff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("fffff", e));

    s << elem;
  }

  // ffffff
  //
  for (const auto &elem : i.ffffff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("ffffff", e));

    s << elem;
  }

  // mp
  //
  for (const auto &elem : i.mp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("mp", e));

    s << elem;
  }

  // mf
  //
  for (const auto &elem : i.mf()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("mf", e));

    s << elem;
  }

  // sf
  //
  for (const auto &elem : i.sf()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sf", e));

    s << elem;
  }

  // sfp
  //
  for (const auto &elem : i.sfp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sfp", e));

    s << elem;
  }

  // sfpp
  //
  for (const auto &elem : i.sfpp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sfpp", e));

    s << elem;
  }

  // fp
  //
  for (const auto &elem : i.fp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("fp", e));

    s << elem;
  }

  // rf
  //
  for (const auto &elem : i.rf()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("rf", e));

    s << elem;
  }

  // rfz
  //
  for (const auto &elem : i.rfz()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("rfz", e));

    s << elem;
  }

  // sfz
  //
  for (const auto &elem : i.sfz()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sfz", e));

    s << elem;
  }

  // sffz
  //
  for (const auto &elem : i.sffz()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sffz", e));

    s << elem;
  }

  // fz
  //
  for (const auto &elem : i.fz()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("fz", e));

    s << elem;
  }

  // other-dynamics
  //
  for (const auto &elem : i.other_dynamics()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-dynamics", e));

    s << elem;
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // underline
  //
  if (i.underline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("underline", e));

    a << *i.underline();
  }

  // overline
  //
  if (i.overline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("overline", e));

    a << *i.overline();
  }

  // line-through
  //
  if (i.line_through()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-through", e));

    a << *i.line_through();
  }

  // enclosure
  //
  if (i.enclosure()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("enclosure", e));

    a << *i.enclosure();
  }
}

void operator<<(::xercesc::DOMElement &e, const empty &i) {
  e << static_cast<const ::xml_schema::type &>(i);
}

void operator<<(::xercesc::DOMAttr &, const empty &) {}

void operator<<(::xml_schema::list_stream &, const empty &) {}

void operator<<(::xercesc::DOMElement &e, const empty_placement &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const empty_print_style &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const empty_print_style_align &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e,
                const empty_print_object_style_align &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const empty_trill_sound &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // start-note
  //
  if (i.start_note()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("start-note", e));

    a << *i.start_note();
  }

  // trill-step
  //
  if (i.trill_step()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("trill-step", e));

    a << *i.trill_step();
  }

  // two-note-turn
  //
  if (i.two_note_turn()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("two-note-turn", e));

    a << *i.two_note_turn();
  }

  // accelerate
  //
  if (i.accelerate()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("accelerate", e));

    a << *i.accelerate();
  }

  // beats
  //
  if (i.beats()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("beats", e));

    a << *i.beats();
  }

  // second-beat
  //
  if (i.second_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("second-beat", e));

    a << *i.second_beat();
  }

  // last-beat
  //
  if (i.last_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("last-beat", e));

    a << *i.last_beat();
  }
}

void operator<<(::xercesc::DOMElement &e, const horizontal_turn &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // start-note
  //
  if (i.start_note()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("start-note", e));

    a << *i.start_note();
  }

  // trill-step
  //
  if (i.trill_step()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("trill-step", e));

    a << *i.trill_step();
  }

  // two-note-turn
  //
  if (i.two_note_turn()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("two-note-turn", e));

    a << *i.two_note_turn();
  }

  // accelerate
  //
  if (i.accelerate()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("accelerate", e));

    a << *i.accelerate();
  }

  // beats
  //
  if (i.beats()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("beats", e));

    a << *i.beats();
  }

  // second-beat
  //
  if (i.second_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("second-beat", e));

    a << *i.second_beat();
  }

  // last-beat
  //
  if (i.last_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("last-beat", e));

    a << *i.last_beat();
  }

  // slash
  //
  if (i.slash()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("slash", e));

    a << *i.slash();
  }
}

void operator<<(::xercesc::DOMElement &e, const fermata &i) {
  e << static_cast<const ::musicxml::fermata_shape &>(i);

  // type
  //
  if (i.type()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << *i.type();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const fingering &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // substitution
  //
  if (i.substitution()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("substitution", e));

    a << *i.substitution();
  }

  // alternate
  //
  if (i.alternate()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("alternate", e));

    a << *i.alternate();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const formatted_text &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // justify
  //
  if (i.justify()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("justify", e));

    a << *i.justify();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }

  // underline
  //
  if (i.underline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("underline", e));

    a << *i.underline();
  }

  // overline
  //
  if (i.overline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("overline", e));

    a << *i.overline();
  }

  // line-through
  //
  if (i.line_through()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-through", e));

    a << *i.line_through();
  }

  // rotation
  //
  if (i.rotation()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("rotation", e));

    a << *i.rotation();
  }

  // letter-spacing
  //
  if (i.letter_spacing()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("letter-spacing", e));

    a << *i.letter_spacing();
  }

  // line-height
  //
  if (i.line_height()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-height", e));

    a << *i.line_height();
  }

  // lang
  //
  if (i.lang()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "lang", "http://www.w3.org/XML/1998/namespace", e));

    a << *i.lang();
  }

  // space
  //
  if (i.space()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "space", "http://www.w3.org/XML/1998/namespace", e));

    a << *i.space();
  }

  // dir
  //
  if (i.dir()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("dir", e));

    a << *i.dir();
  }

  // enclosure
  //
  if (i.enclosure()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("enclosure", e));

    a << *i.enclosure();
  }
}

void operator<<(::xercesc::DOMElement &e, const fret &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const level &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // reference
  //
  if (i.reference()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("reference", e));

    a << *i.reference();
  }

  // parentheses
  //
  if (i.parentheses()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("parentheses", e));

    a << *i.parentheses();
  }

  // bracket
  //
  if (i.bracket()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("bracket", e));

    a << *i.bracket();
  }

  // size
  //
  if (i.size()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("size", e));

    a << *i.size();
  }
}

void operator<<(::xercesc::DOMElement &e, const midi_device &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // port
  //
  if (i.port()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("port", e));

    a << *i.port();
  }

  // id
  //
  if (i.id()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << *i.id();
  }
}

void operator<<(::xercesc::DOMElement &e, const midi_instrument &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // midi-channel
  //
  if (i.midi_channel()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-channel", e));

    s << *i.midi_channel();
  }

  // midi-name
  //
  if (i.midi_name()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-name", e));

    s << *i.midi_name();
  }

  // midi-bank
  //
  if (i.midi_bank()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-bank", e));

    s << *i.midi_bank();
  }

  // midi-program
  //
  if (i.midi_program()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-program", e));

    s << *i.midi_program();
  }

  // midi-unpitched
  //
  if (i.midi_unpitched()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-unpitched", e));

    s << *i.midi_unpitched();
  }

  // volume
  //
  if (i.volume()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("volume", e));

    s << *i.volume();
  }

  // pan
  //
  if (i.pan()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("pan", e));

    s << *i.pan();
  }

  // elevation
  //
  if (i.elevation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("elevation", e));

    s << *i.elevation();
  }

  // id
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << i.id();
  }
}

void operator<<(::xercesc::DOMElement &e, const name_display &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // display-text
  //
  for (const auto &elem : i.display_text()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("display-text", e));

    s << elem;
  }

  // accidental-text
  //
  for (const auto &elem : i.accidental_text()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accidental-text", e));

    s << elem;
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }
}

void operator<<(::xercesc::DOMElement &e, const other_play &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const play &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // ipa
  //
  for (const auto &elem : i.ipa()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("ipa", e));

    s << elem;
  }

  // mute
  //
  for (const auto &elem : i.mute()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("mute", e));

    s << elem;
  }

  // semi-pitched
  //
  for (const auto &elem : i.semi_pitched()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("semi-pitched", e));

    s << elem;
  }

  // other-play
  //
  for (const auto &elem : i.other_play()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-play", e));

    s << elem;
  }

  // id
  //
  if (i.id()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << *i.id();
  }
}

void operator<<(::xercesc::DOMElement &e, const string &i) {
  e << static_cast<const ::musicxml::string_number &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const typed_text &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  if (i.type()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << *i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const wavy_line &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // start-note
  //
  if (i.start_note()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("start-note", e));

    a << *i.start_note();
  }

  // trill-step
  //
  if (i.trill_step()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("trill-step", e));

    a << *i.trill_step();
  }

  // two-note-turn
  //
  if (i.two_note_turn()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("two-note-turn", e));

    a << *i.two_note_turn();
  }

  // accelerate
  //
  if (i.accelerate()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("accelerate", e));

    a << *i.accelerate();
  }

  // beats
  //
  if (i.beats()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("beats", e));

    a << *i.beats();
  }

  // second-beat
  //
  if (i.second_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("second-beat", e));

    a << *i.second_beat();
  }

  // last-beat
  //
  if (i.last_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("last-beat", e));

    a << *i.last_beat();
  }
}

void operator<<(::xercesc::DOMElement &e, const attributes &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // divisions
  //
  if (i.divisions()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("divisions", e));

    s << *i.divisions();
  }

  // key
  //
  for (const auto &elem : i.key()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("key", e));

    s << elem;
  }

  // time
  //
  for (const auto &elem : i.time()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("time", e));

    s << elem;
  }

  // staves
  //
  if (i.staves()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("staves", e));

    s << *i.staves();
  }

  // part-symbol
  //
  if (i.part_symbol()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-symbol", e));

    s << *i.part_symbol();
  }

  // instruments
  //
  if (i.instruments()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("instruments", e));

    s << *i.instruments();
  }

  // clef
  //
  for (const auto &elem : i.clef()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("clef", e));

    s << elem;
  }

  // staff-details
  //
  for (const auto &elem : i.staff_details()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staff-details", e));

    s << elem;
  }

  // transpose
  //
  for (const auto &elem : i.transpose()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("transpose", e));

    s << elem;
  }

  // directive
  //
  for (const auto &elem : i.directive()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("directive", e));

    s << elem;
  }

  // measure-style
  //
  for (const auto &elem : i.measure_style()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("measure-style", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const beat_repeat &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // slash-type
  //
  if (i.slash_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("slash-type", e));

    s << *i.slash_type();
  }

  // slash-dot
  //
  for (const auto &elem : i.slash_dot()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("slash-dot", e));

    s << elem;
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // slashes
  //
  if (i.slashes()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("slashes", e));

    a << *i.slashes();
  }

  // use-dots
  //
  if (i.use_dots()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("use-dots", e));

    a << *i.use_dots();
  }
}

void operator<<(::xercesc::DOMElement &e, const cancel &i) {
  e << static_cast<const ::musicxml::fifths &>(i);

  // location
  //
  if (i.location()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("location", e));

    a << *i.location();
  }
}

void operator<<(::xercesc::DOMElement &e, const clef &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // sign
  //
  {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sign", e));

    s << i.sign();
  }

  // line
  //
  if (i.line()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("line", e));

    s << *i.line();
  }

  // clef-octave-change
  //
  if (i.clef_octave_change()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("clef-octave-change", e));

    s << *i.clef_octave_change();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // additional
  //
  if (i.additional()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("additional", e));

    a << *i.additional();
  }

  // size
  //
  if (i.size()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("size", e));

    a << *i.size();
  }

  // after-barline
  //
  if (i.after_barline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("after-barline", e));

    a << *i.after_barline();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }
}

void operator<<(::xercesc::DOMElement &e, const interchangeable &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // time-relation
  //
  if (i.time_relation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("time-relation", e));

    s << *i.time_relation();
  }

  // beats
  //
  for (const auto &elem : i.beats()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("beats", e));

    s << elem;
  }

  // beat-type
  //
  for (const auto &elem : i.beat_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("beat-type", e));

    s << elem;
  }

  // symbol
  //
  if (i.symbol()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("symbol", e));

    a << *i.symbol();
  }

  // separator
  //
  if (i.separator()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("separator", e));

    a << *i.separator();
  }
}

void operator<<(::xercesc::DOMElement &e, const key &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // cancel
  //
  if (i.cancel()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("cancel", e));

    s << *i.cancel();
  }

  // fifths
  //
  if (i.fifths()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("fifths", e));

    s << *i.fifths();
  }

  // mode
  //
  if (i.mode()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("mode", e));

    s << *i.mode();
  }

  // key-step
  //
  for (const auto &elem : i.key_step()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("key-step", e));

    s << elem;
  }

  // key-alter
  //
  for (const auto &elem : i.key_alter()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("key-alter", e));

    s << elem;
  }

  // key-accidental
  //
  for (const auto &elem : i.key_accidental()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("key-accidental", e));

    s << elem;
  }

  // key-octave
  //
  for (const auto &elem : i.key_octave()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("key-octave", e));

    s << elem;
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }
}

void operator<<(::xercesc::DOMElement &e, const key_octave &i) {
  e << static_cast<const ::musicxml::octave &>(i);

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // cancel
  //
  if (i.cancel()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("cancel", e));

    a << *i.cancel();
  }
}

void operator<<(::xercesc::DOMElement &e, const measure_repeat &i) {
  e << static_cast<const ::musicxml::positive_integer_or_empty &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // slashes
  //
  if (i.slashes()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("slashes", e));

    a << *i.slashes();
  }
}

void operator<<(::xercesc::DOMElement &e, const measure_style &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // multiple-rest
  //
  if (i.multiple_rest()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("multiple-rest", e));

    s << *i.multiple_rest();
  }

  // measure-repeat
  //
  if (i.measure_repeat()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("measure-repeat", e));

    s << *i.measure_repeat();
  }

  // beat-repeat
  //
  if (i.beat_repeat()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("beat-repeat", e));

    s << *i.beat_repeat();
  }

  // slash
  //
  if (i.slash()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("slash", e));

    s << *i.slash();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const multiple_rest &i) {
  e << static_cast<const ::musicxml::positive_integer_or_empty &>(i);

  // use-symbols
  //
  if (i.use_symbols()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("use-symbols", e));

    a << *i.use_symbols();
  }
}

void operator<<(::xercesc::DOMElement &e, const part_symbol &i) {
  e << static_cast<const ::musicxml::group_symbol_value &>(i);

  // top-staff
  //
  if (i.top_staff()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("top-staff", e));

    a << *i.top_staff();
  }

  // bottom-staff
  //
  if (i.bottom_staff()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bottom-staff", e));

    a << *i.bottom_staff();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const slash &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // slash-type
  //
  if (i.slash_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("slash-type", e));

    s << *i.slash_type();
  }

  // slash-dot
  //
  for (const auto &elem : i.slash_dot()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("slash-dot", e));

    s << elem;
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // use-dots
  //
  if (i.use_dots()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("use-dots", e));

    a << *i.use_dots();
  }

  // use-stems
  //
  if (i.use_stems()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("use-stems", e));

    a << *i.use_stems();
  }
}

void operator<<(::xercesc::DOMElement &e, const staff_details &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // staff-type
  //
  if (i.staff_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staff-type", e));

    s << *i.staff_type();
  }

  // staff-lines
  //
  if (i.staff_lines()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staff-lines", e));

    s << *i.staff_lines();
  }

  // staff-tuning
  //
  for (const auto &elem : i.staff_tuning()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staff-tuning", e));

    s << elem;
  }

  // capo
  //
  if (i.capo()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("capo", e));

    s << *i.capo();
  }

  // staff-size
  //
  if (i.staff_size()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staff-size", e));

    s << *i.staff_size();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // show-frets
  //
  if (i.show_frets()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("show-frets", e));

    a << *i.show_frets();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // print-spacing
  //
  if (i.print_spacing()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-spacing", e));

    a << *i.print_spacing();
  }
}

void operator<<(::xercesc::DOMElement &e, const staff_tuning &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // tuning-step
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuning-step", e));

    s << i.tuning_step();
  }

  // tuning-alter
  //
  if (i.tuning_alter()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuning-alter", e));

    s << *i.tuning_alter();
  }

  // tuning-octave
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuning-octave", e));

    s << i.tuning_octave();
  }

  // line
  //
  if (i.line()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("line", e));

    a << *i.line();
  }
}

void operator<<(::xercesc::DOMElement &e, const time &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // beats
  //
  for (const auto &elem : i.beats()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("beats", e));

    s << elem;
  }

  // beat-type
  //
  for (const auto &elem : i.beat_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("beat-type", e));

    s << elem;
  }

  // interchangeable
  //
  if (i.interchangeable()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("interchangeable", e));

    s << *i.interchangeable();
  }

  // senza-misura
  //
  if (i.senza_misura()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("senza-misura", e));

    s << *i.senza_misura();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // symbol
  //
  if (i.symbol()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("symbol", e));

    a << *i.symbol();
  }

  // separator
  //
  if (i.separator()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("separator", e));

    a << *i.separator();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }
}

void operator<<(::xercesc::DOMElement &e, const transpose &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // diatonic
  //
  if (i.diatonic()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("diatonic", e));

    s << *i.diatonic();
  }

  // chromatic
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("chromatic", e));

    s << i.chromatic();
  }

  // octave-change
  //
  if (i.octave_change()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("octave-change", e));

    s << *i.octave_change();
  }

  // double
  //
  if (i.double_()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("double", e));

    s << *i.double_();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }
}

void operator<<(::xercesc::DOMElement &e, const bar_style_color &i) {
  e << static_cast<const ::musicxml::bar_style &>(i);

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const barline &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // bar-style
  //
  if (i.bar_style()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("bar-style", e));

    s << *i.bar_style();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // wavy-line
  //
  if (i.wavy_line()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("wavy-line", e));

    s << *i.wavy_line();
  }

  // segno
  //
  if (i.segno()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("segno", e));

    s << *i.segno();
  }

  // coda
  //
  if (i.coda()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("coda", e));

    s << *i.coda();
  }

  // fermata
  //
  for (const auto &elem : i.fermata()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("fermata", e));

    s << elem;
  }

  // ending
  //
  if (i.ending()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("ending", e));

    s << *i.ending();
  }

  // repeat
  //
  if (i.repeat()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("repeat", e));

    s << *i.repeat();
  }

  // location
  //
  {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("location", e));

    a << i.location();
  }

  // segno
  //
  if (i.segno1()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("segno", e));

    a << *i.segno1();
  }

  // coda
  //
  if (i.coda1()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("coda", e));

    a << *i.coda1();
  }

  // divisions
  //
  if (i.divisions()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("divisions", e));

    a << *i.divisions();
  }
}

void operator<<(::xercesc::DOMElement &e, const ending &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // end-length
  //
  if (i.end_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("end-length", e));

    a << *i.end_length();
  }

  // text-x
  //
  if (i.text_x()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("text-x", e));

    a << *i.text_x();
  }

  // text-y
  //
  if (i.text_y()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("text-y", e));

    a << *i.text_y();
  }
}

void operator<<(::xercesc::DOMElement &e, const repeat &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // direction
  //
  {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("direction", e));

    a << i.direction();
  }

  // times
  //
  if (i.times()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("times", e));

    a << *i.times();
  }

  // winged
  //
  if (i.winged()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("winged", e));

    a << *i.winged();
  }
}

void operator<<(::xercesc::DOMElement &e, const accord &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // tuning-step
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuning-step", e));

    s << i.tuning_step();
  }

  // tuning-alter
  //
  if (i.tuning_alter()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuning-alter", e));

    s << *i.tuning_alter();
  }

  // tuning-octave
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuning-octave", e));

    s << i.tuning_octave();
  }

  // string
  //
  if (i.string()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("string", e));

    a << *i.string();
  }
}

void operator<<(::xercesc::DOMElement &e, const accordion_registration &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // accordion-high
  //
  if (i.accordion_high()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accordion-high", e));

    s << *i.accordion_high();
  }

  // accordion-middle
  //
  if (i.accordion_middle()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accordion-middle", e));

    s << *i.accordion_middle();
  }

  // accordion-low
  //
  if (i.accordion_low()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accordion-low", e));

    s << *i.accordion_low();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const barre &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const bass &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // bass-step
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("bass-step", e));

    s << i.bass_step();
  }

  // bass-alter
  //
  if (i.bass_alter()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("bass-alter", e));

    s << *i.bass_alter();
  }
}

void operator<<(::xercesc::DOMElement &e, const bass_alter &i) {
  e << static_cast<const ::musicxml::semitones &>(i);

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // location
  //
  if (i.location()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("location", e));

    a << *i.location();
  }
}

void operator<<(::xercesc::DOMElement &e, const bass_step &i) {
  e << static_cast<const ::musicxml::step &>(i);

  // text
  //
  if (i.text()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("text", e));

    a << *i.text();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const beater &i) {
  e << static_cast<const ::musicxml::beater_value &>(i);

  // tip
  //
  if (i.tip()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("tip", e));

    a << *i.tip();
  }
}

void operator<<(::xercesc::DOMElement &e, const bracket &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // line-end
  //
  {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-end", e));

    a << i.line_end();
  }

  // end-length
  //
  if (i.end_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("end-length", e));

    a << *i.end_length();
  }

  // line-type
  //
  if (i.line_type()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-type", e));

    a << *i.line_type();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const dashes &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const degree &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // degree-value
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("degree-value", e));

    s << i.degree_value();
  }

  // degree-alter
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("degree-alter", e));

    s << i.degree_alter();
  }

  // degree-type
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("degree-type", e));

    s << i.degree_type();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }
}

void operator<<(::xercesc::DOMElement &e, const degree_alter &i) {
  e << static_cast<const ::musicxml::semitones &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // plus-minus
  //
  if (i.plus_minus()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("plus-minus", e));

    a << *i.plus_minus();
  }
}

void operator<<(::xercesc::DOMElement &e, const degree_type &i) {
  e << static_cast<const ::musicxml::degree_type_value &>(i);

  // text
  //
  if (i.text()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("text", e));

    a << *i.text();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const degree_value &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  // symbol
  //
  if (i.symbol()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("symbol", e));

    a << *i.symbol();
  }

  // text
  //
  if (i.text()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("text", e));

    a << *i.text();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const direction &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // direction-type
  //
  for (const auto &elem : i.direction_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("direction-type", e));

    s << elem;
  }

  // offset
  //
  if (i.offset()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("offset", e));

    s << *i.offset();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // voice
  //
  if (i.voice()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("voice", e));

    s << *i.voice();
  }

  // staff
  //
  if (i.staff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("staff", e));

    s << *i.staff();
  }

  // sound
  //
  if (i.sound()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sound", e));

    s << *i.sound();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // directive
  //
  if (i.directive()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("directive", e));

    a << *i.directive();
  }
}

void operator<<(::xercesc::DOMElement &e, const direction_type &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // rehearsal
  //
  for (const auto &elem : i.rehearsal()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("rehearsal", e));

    s << elem;
  }

  // segno
  //
  for (const auto &elem : i.segno()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("segno", e));

    s << elem;
  }

  // words
  //
  for (const auto &elem : i.words()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("words", e));

    s << elem;
  }

  // coda
  //
  for (const auto &elem : i.coda()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("coda", e));

    s << elem;
  }

  // wedge
  //
  if (i.wedge()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("wedge", e));

    s << *i.wedge();
  }

  // dynamics
  //
  for (const auto &elem : i.dynamics()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("dynamics", e));

    s << elem;
  }

  // dashes
  //
  if (i.dashes()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("dashes", e));

    s << *i.dashes();
  }

  // bracket
  //
  if (i.bracket()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("bracket", e));

    s << *i.bracket();
  }

  // pedal
  //
  if (i.pedal()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("pedal", e));

    s << *i.pedal();
  }

  // metronome
  //
  if (i.metronome()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("metronome", e));

    s << *i.metronome();
  }

  // octave-shift
  //
  if (i.octave_shift()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("octave-shift", e));

    s << *i.octave_shift();
  }

  // harp-pedals
  //
  if (i.harp_pedals()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("harp-pedals", e));

    s << *i.harp_pedals();
  }

  // damp
  //
  if (i.damp()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("damp", e));

    s << *i.damp();
  }

  // damp-all
  //
  if (i.damp_all()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("damp-all", e));

    s << *i.damp_all();
  }

  // eyeglasses
  //
  if (i.eyeglasses()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("eyeglasses", e));

    s << *i.eyeglasses();
  }

  // string-mute
  //
  if (i.string_mute()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("string-mute", e));

    s << *i.string_mute();
  }

  // scordatura
  //
  if (i.scordatura()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("scordatura", e));

    s << *i.scordatura();
  }

  // image
  //
  if (i.image()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("image", e));

    s << *i.image();
  }

  // principal-voice
  //
  if (i.principal_voice()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("principal-voice", e));

    s << *i.principal_voice();
  }

  // accordion-registration
  //
  if (i.accordion_registration()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accordion-registration", e));

    s << *i.accordion_registration();
  }

  // percussion
  //
  for (const auto &elem : i.percussion()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("percussion", e));

    s << elem;
  }

  // other-direction
  //
  if (i.other_direction()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-direction", e));

    s << *i.other_direction();
  }
}

void operator<<(::xercesc::DOMElement &e, const feature &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  if (i.type()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << *i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const first_fret &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::positive_integer, char, ::xml_schema::simple_type> &>(i);

  // text
  //
  if (i.text()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("text", e));

    a << *i.text();
  }

  // location
  //
  if (i.location()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("location", e));

    a << *i.location();
  }
}

void operator<<(::xercesc::DOMElement &e, const frame &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // frame-strings
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("frame-strings", e));

    s << i.frame_strings();
  }

  // frame-frets
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("frame-frets", e));

    s << i.frame_frets();
  }

  // first-fret
  //
  if (i.first_fret()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("first-fret", e));

    s << *i.first_fret();
  }

  // frame-note
  //
  for (const auto &elem : i.frame_note()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("frame-note", e));

    s << elem;
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }

  // height
  //
  if (i.height()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("height", e));

    a << *i.height();
  }

  // width
  //
  if (i.width()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("width", e));

    a << *i.width();
  }

  // unplayed
  //
  if (i.unplayed()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("unplayed", e));

    a << *i.unplayed();
  }
}

void operator<<(::xercesc::DOMElement &e, const frame_note &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // string
  //
  {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("string", e));

    s << i.string();
  }

  // fret
  //
  {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("fret", e));

    s << i.fret();
  }

  // fingering
  //
  if (i.fingering()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("fingering", e));

    s << *i.fingering();
  }

  // barre
  //
  if (i.barre()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("barre", e));

    s << *i.barre();
  }
}

void operator<<(::xercesc::DOMElement &e, const grouping &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // feature
  //
  for (const auto &elem : i.feature()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("feature", e));

    s << elem;
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // member-of
  //
  if (i.member_of()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("member-of", e));

    a << *i.member_of();
  }
}

void operator<<(::xercesc::DOMElement &e, const harmony &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // root
  //
  for (const auto &elem : i.root()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("root", e));

    s << elem;
  }

  // function
  //
  for (const auto &elem : i.function()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("function", e));

    s << elem;
  }

  // kind
  //
  for (const auto &elem : i.kind()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("kind", e));

    s << elem;
  }

  // inversion
  //
  for (const auto &elem : i.inversion()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("inversion", e));

    s << elem;
  }

  // bass
  //
  for (const auto &elem : i.bass()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("bass", e));

    s << elem;
  }

  // degree
  //
  for (const auto &elem : i.degree()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("degree", e));

    s << elem;
  }

  // frame
  //
  if (i.frame()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("frame", e));

    s << *i.frame();
  }

  // offset
  //
  if (i.offset()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("offset", e));

    s << *i.offset();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // staff
  //
  if (i.staff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("staff", e));

    s << *i.staff();
  }

  // type
  //
  if (i.type()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << *i.type();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // print-frame
  //
  if (i.print_frame()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-frame", e));

    a << *i.print_frame();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const harp_pedals &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // pedal-tuning
  //
  for (const auto &elem : i.pedal_tuning()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("pedal-tuning", e));

    s << elem;
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const image &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // source
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("source", e));

    a << i.source();
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const inversion &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const kind &i) {
  e << static_cast<const ::musicxml::kind_value &>(i);

  // use-symbols
  //
  if (i.use_symbols()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("use-symbols", e));

    a << *i.use_symbols();
  }

  // text
  //
  if (i.text()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("text", e));

    a << *i.text();
  }

  // stack-degrees
  //
  if (i.stack_degrees()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("stack-degrees", e));

    a << *i.stack_degrees();
  }

  // parentheses-degrees
  //
  if (i.parentheses_degrees()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("parentheses-degrees", e));

    a << *i.parentheses_degrees();
  }

  // bracket-degrees
  //
  if (i.bracket_degrees()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bracket-degrees", e));

    a << *i.bracket_degrees();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const measure_numbering &i) {
  e << static_cast<const ::musicxml::measure_numbering_value &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const metronome &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // beat-unit
  //
  for (const auto &elem : i.beat_unit()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("beat-unit", e));

    s << elem;
  }

  // beat-unit-dot
  //
  for (const auto &elem : i.beat_unit_dot()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("beat-unit-dot", e));

    s << elem;
  }

  // per-minute
  //
  if (i.per_minute()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("per-minute", e));

    s << *i.per_minute();
  }

  // metronome-note
  //
  for (const auto &elem : i.metronome_note()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("metronome-note", e));

    s << elem;
  }

  // metronome-relation
  //
  if (i.metronome_relation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("metronome-relation", e));

    s << *i.metronome_relation();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }

  // justify
  //
  if (i.justify()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("justify", e));

    a << *i.justify();
  }

  // parentheses
  //
  if (i.parentheses()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("parentheses", e));

    a << *i.parentheses();
  }
}

void operator<<(::xercesc::DOMElement &e, const metronome_beam &i) {
  e << static_cast<const ::musicxml::beam_value &>(i);

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }
}

void operator<<(::xercesc::DOMElement &e, const metronome_note &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // metronome-type
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("metronome-type", e));

    s << i.metronome_type();
  }

  // metronome-dot
  //
  for (const auto &elem : i.metronome_dot()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("metronome-dot", e));

    s << elem;
  }

  // metronome-beam
  //
  for (const auto &elem : i.metronome_beam()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("metronome-beam", e));

    s << elem;
  }

  // metronome-tuplet
  //
  if (i.metronome_tuplet()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("metronome-tuplet", e));

    s << *i.metronome_tuplet();
  }
}

void operator<<(::xercesc::DOMElement &e, const time_modification &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // actual-notes
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("actual-notes", e));

    s << i.actual_notes();
  }

  // normal-notes
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("normal-notes", e));

    s << i.normal_notes();
  }

  // normal-type
  //
  if (i.normal_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("normal-type", e));

    s << *i.normal_type();
  }

  // normal-dot
  //
  for (const auto &elem : i.normal_dot()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("normal-dot", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const metronome_tuplet &i) {
  e << static_cast<const ::musicxml::time_modification &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // bracket
  //
  if (i.bracket()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("bracket", e));

    a << *i.bracket();
  }

  // show-number
  //
  if (i.show_number()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("show-number", e));

    a << *i.show_number();
  }
}

void operator<<(::xercesc::DOMElement &e, const octave_shift &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // size
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("size", e));

    a << i.size();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const offset &i) {
  e << static_cast<const ::musicxml::divisions &>(i);

  // sound
  //
  if (i.sound()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("sound", e));

    a << *i.sound();
  }
}

void operator<<(::xercesc::DOMElement &e, const other_direction &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const pedal &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // line
  //
  if (i.line()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("line", e));

    a << *i.line();
  }

  // sign
  //
  if (i.sign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("sign", e));

    a << *i.sign();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const pedal_tuning &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // pedal-step
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("pedal-step", e));

    s << i.pedal_step();
  }

  // pedal-alter
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("pedal-alter", e));

    s << i.pedal_alter();
  }
}

void operator<<(::xercesc::DOMElement &e, const per_minute &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }
}

void operator<<(::xercesc::DOMElement &e, const percussion &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // glass
  //
  if (i.glass()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("glass", e));

    s << *i.glass();
  }

  // metal
  //
  if (i.metal()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("metal", e));

    s << *i.metal();
  }

  // wood
  //
  if (i.wood()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("wood", e));

    s << *i.wood();
  }

  // pitched
  //
  if (i.pitched()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("pitched", e));

    s << *i.pitched();
  }

  // membrane
  //
  if (i.membrane()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("membrane", e));

    s << *i.membrane();
  }

  // effect
  //
  if (i.effect()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("effect", e));

    s << *i.effect();
  }

  // timpani
  //
  if (i.timpani()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("timpani", e));

    s << *i.timpani();
  }

  // beater
  //
  if (i.beater()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("beater", e));

    s << *i.beater();
  }

  // stick
  //
  if (i.stick()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("stick", e));

    s << *i.stick();
  }

  // stick-location
  //
  if (i.stick_location()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("stick-location", e));

    s << *i.stick_location();
  }

  // other-percussion
  //
  if (i.other_percussion()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-percussion", e));

    s << *i.other_percussion();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }

  // enclosure
  //
  if (i.enclosure()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("enclosure", e));

    a << *i.enclosure();
  }
}

void operator<<(::xercesc::DOMElement &e, const principal_voice &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // symbol
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("symbol", e));

    a << i.symbol();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const print &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // page-layout
  //
  if (i.page_layout()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("page-layout", e));

    s << *i.page_layout();
  }

  // system-layout
  //
  if (i.system_layout()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("system-layout", e));

    s << *i.system_layout();
  }

  // staff-layout
  //
  for (const auto &elem : i.staff_layout()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staff-layout", e));

    s << elem;
  }

  // measure-layout
  //
  if (i.measure_layout()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("measure-layout", e));

    s << *i.measure_layout();
  }

  // measure-numbering
  //
  if (i.measure_numbering()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("measure-numbering", e));

    s << *i.measure_numbering();
  }

  // part-name-display
  //
  if (i.part_name_display()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-name-display", e));

    s << *i.part_name_display();
  }

  // part-abbreviation-display
  //
  if (i.part_abbreviation_display()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-abbreviation-display", e));

    s << *i.part_abbreviation_display();
  }

  // staff-spacing
  //
  if (i.staff_spacing()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("staff-spacing", e));

    a << *i.staff_spacing();
  }

  // new-system
  //
  if (i.new_system()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("new-system", e));

    a << *i.new_system();
  }

  // new-page
  //
  if (i.new_page()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("new-page", e));

    a << *i.new_page();
  }

  // blank-page
  //
  if (i.blank_page()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("blank-page", e));

    a << *i.blank_page();
  }

  // page-number
  //
  if (i.page_number()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("page-number", e));

    a << *i.page_number();
  }
}

void operator<<(::xercesc::DOMElement &e, const root &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // root-step
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("root-step", e));

    s << i.root_step();
  }

  // root-alter
  //
  if (i.root_alter()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("root-alter", e));

    s << *i.root_alter();
  }
}

void operator<<(::xercesc::DOMElement &e, const root_alter &i) {
  e << static_cast<const ::musicxml::semitones &>(i);

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // location
  //
  if (i.location()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("location", e));

    a << *i.location();
  }
}

void operator<<(::xercesc::DOMElement &e, const root_step &i) {
  e << static_cast<const ::musicxml::step &>(i);

  // text
  //
  if (i.text()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("text", e));

    a << *i.text();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const scordatura &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // accord
  //
  for (const auto &elem : i.accord()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("accord", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const sound &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // midi-device
  //
  for (const auto &elem : i.midi_device()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-device", e));

    s << elem;
  }

  // midi-instrument
  //
  for (const auto &elem : i.midi_instrument()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-instrument", e));

    s << elem;
  }

  // play
  //
  for (const auto &elem : i.play()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("play", e));

    s << elem;
  }

  // offset
  //
  if (i.offset()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("offset", e));

    s << *i.offset();
  }

  // tempo
  //
  if (i.tempo()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("tempo", e));

    a << *i.tempo();
  }

  // dynamics
  //
  if (i.dynamics()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dynamics", e));

    a << *i.dynamics();
  }

  // dacapo
  //
  if (i.dacapo()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("dacapo", e));

    a << *i.dacapo();
  }

  // segno
  //
  if (i.segno()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("segno", e));

    a << *i.segno();
  }

  // dalsegno
  //
  if (i.dalsegno()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dalsegno", e));

    a << *i.dalsegno();
  }

  // coda
  //
  if (i.coda()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("coda", e));

    a << *i.coda();
  }

  // tocoda
  //
  if (i.tocoda()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("tocoda", e));

    a << *i.tocoda();
  }

  // divisions
  //
  if (i.divisions()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("divisions", e));

    a << *i.divisions();
  }

  // forward-repeat
  //
  if (i.forward_repeat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("forward-repeat", e));

    a << *i.forward_repeat();
  }

  // fine
  //
  if (i.fine()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("fine", e));

    a << *i.fine();
  }

  // time-only
  //
  if (i.time_only()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("time-only", e));

    a << *i.time_only();
  }

  // pizzicato
  //
  if (i.pizzicato()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("pizzicato", e));

    a << *i.pizzicato();
  }

  // pan
  //
  if (i.pan()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("pan", e));

    a << *i.pan();
  }

  // elevation
  //
  if (i.elevation()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("elevation", e));

    a << *i.elevation();
  }

  // damper-pedal
  //
  if (i.damper_pedal()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("damper-pedal", e));

    a << *i.damper_pedal();
  }

  // soft-pedal
  //
  if (i.soft_pedal()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("soft-pedal", e));

    a << *i.soft_pedal();
  }

  // sostenuto-pedal
  //
  if (i.sostenuto_pedal()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("sostenuto-pedal", e));

    a << *i.sostenuto_pedal();
  }
}

void operator<<(::xercesc::DOMElement &e, const stick &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // stick-type
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("stick-type", e));

    s << i.stick_type();
  }

  // stick-material
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("stick-material", e));

    s << i.stick_material();
  }

  // tip
  //
  if (i.tip()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("tip", e));

    a << *i.tip();
  }
}

void operator<<(::xercesc::DOMElement &e, const string_mute &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // halign
  //
  if (i.halign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("halign", e));

    a << *i.halign();
  }

  // valign
  //
  if (i.valign()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("valign", e));

    a << *i.valign();
  }
}

void operator<<(::xercesc::DOMElement &e, const wedge &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // spread
  //
  if (i.spread()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("spread", e));

    a << *i.spread();
  }

  // niente
  //
  if (i.niente()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("niente", e));

    a << *i.niente();
  }

  // line-type
  //
  if (i.line_type()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-type", e));

    a << *i.line_type();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const encoding &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // encoding-date
  //
  for (const auto &elem : i.encoding_date()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("encoding-date", e));

    s << elem;
  }

  // encoder
  //
  for (const auto &elem : i.encoder()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("encoder", e));

    s << elem;
  }

  // software
  //
  for (const auto &elem : i.software()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("software", e));

    s << elem;
  }

  // encoding-description
  //
  for (const auto &elem : i.encoding_description()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("encoding-description", e));

    s << elem;
  }

  // supports
  //
  for (const auto &elem : i.supports()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("supports", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const identification &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // creator
  //
  for (const auto &elem : i.creator()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("creator", e));

    s << elem;
  }

  // rights
  //
  for (const auto &elem : i.rights()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("rights", e));

    s << elem;
  }

  // encoding
  //
  if (i.encoding()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("encoding", e));

    s << *i.encoding();
  }

  // source
  //
  if (i.source()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("source", e));

    s << *i.source();
  }

  // relation
  //
  for (const auto &elem : i.relation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("relation", e));

    s << elem;
  }

  // miscellaneous
  //
  if (i.miscellaneous()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("miscellaneous", e));

    s << *i.miscellaneous();
  }
}

void operator<<(::xercesc::DOMElement &e, const miscellaneous &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // miscellaneous-field
  //
  for (const auto &elem : i.miscellaneous_field()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("miscellaneous-field", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const miscellaneous_field &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // name
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("name", e));

    a << i.name();
  }
}

void operator<<(::xercesc::DOMElement &e, const supports &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // element
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("element", e));

    a << i.element();
  }

  // attribute
  //
  if (i.attribute()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("attribute", e));

    a << *i.attribute();
  }

  // value
  //
  if (i.value()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("value", e));

    a << *i.value();
  }
}

void operator<<(::xercesc::DOMElement &e, const appearance &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // line-width
  //
  for (const auto &elem : i.line_width()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("line-width", e));

    s << elem;
  }

  // note-size
  //
  for (const auto &elem : i.note_size()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("note-size", e));

    s << elem;
  }

  // distance
  //
  for (const auto &elem : i.distance()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("distance", e));

    s << elem;
  }

  // other-appearance
  //
  for (const auto &elem : i.other_appearance()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-appearance", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const distance &i) {
  e << static_cast<const ::musicxml::tenths &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const line_width &i) {
  e << static_cast<const ::musicxml::tenths &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const measure_layout &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // measure-distance
  //
  if (i.measure_distance()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("measure-distance", e));

    s << *i.measure_distance();
  }
}

void operator<<(::xercesc::DOMElement &e, const note_size &i) {
  e << static_cast<const ::musicxml::non_negative_decimal &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const other_appearance &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const page_layout &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // page-height
  //
  if (i.page_height()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("page-height", e));

    s << *i.page_height();
  }

  // page-width
  //
  if (i.page_width()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("page-width", e));

    s << *i.page_width();
  }

  // page-margins
  //
  for (const auto &elem : i.page_margins()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("page-margins", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const page_margins &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // left-margin
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("left-margin", e));

    s << i.left_margin();
  }

  // right-margin
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("right-margin", e));

    s << i.right_margin();
  }

  // top-margin
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("top-margin", e));

    s << i.top_margin();
  }

  // bottom-margin
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("bottom-margin", e));

    s << i.bottom_margin();
  }

  // type
  //
  if (i.type()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << *i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const scaling &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // millimeters
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("millimeters", e));

    s << i.millimeters();
  }

  // tenths
  //
  {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("tenths", e));

    s << i.tenths();
  }
}

void operator<<(::xercesc::DOMElement &e, const staff_layout &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // staff-distance
  //
  if (i.staff_distance()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staff-distance", e));

    s << *i.staff_distance();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }
}

void operator<<(::xercesc::DOMElement &e, const system_dividers &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // left-divider
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("left-divider", e));

    s << i.left_divider();
  }

  // right-divider
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("right-divider", e));

    s << i.right_divider();
  }
}

void operator<<(::xercesc::DOMElement &e, const system_layout &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // system-margins
  //
  if (i.system_margins()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("system-margins", e));

    s << *i.system_margins();
  }

  // system-distance
  //
  if (i.system_distance()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("system-distance", e));

    s << *i.system_distance();
  }

  // top-system-distance
  //
  if (i.top_system_distance()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("top-system-distance", e));

    s << *i.top_system_distance();
  }

  // system-dividers
  //
  if (i.system_dividers()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("system-dividers", e));

    s << *i.system_dividers();
  }
}

void operator<<(::xercesc::DOMElement &e, const system_margins &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // left-margin
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("left-margin", e));

    s << i.left_margin();
  }

  // right-margin
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("right-margin", e));

    s << i.right_margin();
  }
}

void operator<<(::xercesc::DOMElement &e, const bookmark &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // id
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << i.id();
  }

  // name
  //
  if (i.name()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("name", e));

    a << *i.name();
  }

  // element
  //
  if (i.element()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("element", e));

    a << *i.element();
  }

  // position
  //
  if (i.position()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("position", e));

    a << *i.position();
  }
}

void operator<<(::xercesc::DOMElement &e, const link &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // href
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "href", "http://www.w3.org/1999/xlink", e));

    a << i.href();
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "type", "http://www.w3.org/1999/xlink", e));

    a << i.type();
  }

  // role
  //
  if (i.role()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "role", "http://www.w3.org/1999/xlink", e));

    a << *i.role();
  }

  // title
  //
  if (i.title()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "title", "http://www.w3.org/1999/xlink", e));

    a << *i.title();
  }

  // show
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "show", "http://www.w3.org/1999/xlink", e));

    a << i.show();
  }

  // actuate
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "actuate", "http://www.w3.org/1999/xlink", e));

    a << i.actuate();
  }

  // name
  //
  if (i.name()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("name", e));

    a << *i.name();
  }

  // element
  //
  if (i.element()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("element", e));

    a << *i.element();
  }

  // position
  //
  if (i.position()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("position", e));

    a << *i.position();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }
}

void operator<<(::xercesc::DOMElement &e, const accidental &i) {
  e << static_cast<const ::musicxml::accidental_value &>(i);

  // cautionary
  //
  if (i.cautionary()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("cautionary", e));

    a << *i.cautionary();
  }

  // editorial
  //
  if (i.editorial()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("editorial", e));

    a << *i.editorial();
  }

  // parentheses
  //
  if (i.parentheses()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("parentheses", e));

    a << *i.parentheses();
  }

  // bracket
  //
  if (i.bracket()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("bracket", e));

    a << *i.bracket();
  }

  // size
  //
  if (i.size()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("size", e));

    a << *i.size();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const accidental_mark &i) {
  e << static_cast<const ::musicxml::accidental_value &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const arpeggiate &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // direction
  //
  if (i.direction()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("direction", e));

    a << *i.direction();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const articulations &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // accent
  //
  for (const auto &elem : i.accent()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("accent", e));

    s << elem;
  }

  // strong-accent
  //
  for (const auto &elem : i.strong_accent()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("strong-accent", e));

    s << elem;
  }

  // staccato
  //
  for (const auto &elem : i.staccato()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staccato", e));

    s << elem;
  }

  // tenuto
  //
  for (const auto &elem : i.tenuto()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("tenuto", e));

    s << elem;
  }

  // detached-legato
  //
  for (const auto &elem : i.detached_legato()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("detached-legato", e));

    s << elem;
  }

  // staccatissimo
  //
  for (const auto &elem : i.staccatissimo()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staccatissimo", e));

    s << elem;
  }

  // spiccato
  //
  for (const auto &elem : i.spiccato()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("spiccato", e));

    s << elem;
  }

  // scoop
  //
  for (const auto &elem : i.scoop()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("scoop", e));

    s << elem;
  }

  // plop
  //
  for (const auto &elem : i.plop()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("plop", e));

    s << elem;
  }

  // doit
  //
  for (const auto &elem : i.doit()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("doit", e));

    s << elem;
  }

  // falloff
  //
  for (const auto &elem : i.falloff()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("falloff", e));

    s << elem;
  }

  // breath-mark
  //
  for (const auto &elem : i.breath_mark()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("breath-mark", e));

    s << elem;
  }

  // caesura
  //
  for (const auto &elem : i.caesura()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("caesura", e));

    s << elem;
  }

  // stress
  //
  for (const auto &elem : i.stress()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("stress", e));

    s << elem;
  }

  // unstress
  //
  for (const auto &elem : i.unstress()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("unstress", e));

    s << elem;
  }

  // other-articulation
  //
  for (const auto &elem : i.other_articulation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-articulation", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const arrow &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // arrow-direction
  //
  if (i.arrow_direction()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("arrow-direction", e));

    s << *i.arrow_direction();
  }

  // arrow-style
  //
  if (i.arrow_style()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("arrow-style", e));

    s << *i.arrow_style();
  }

  // circular-arrow
  //
  if (i.circular_arrow()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("circular-arrow", e));

    s << *i.circular_arrow();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const backup &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // duration
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("duration", e));

    s << i.duration();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }
}

void operator<<(::xercesc::DOMElement &e, const beam &i) {
  e << static_cast<const ::musicxml::beam_value &>(i);

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // repeater
  //
  if (i.repeater()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("repeater", e));

    a << *i.repeater();
  }

  // fan
  //
  if (i.fan()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("fan", e));

    a << *i.fan();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const bend &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // bend-alter
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("bend-alter", e));

    s << i.bend_alter();
  }

  // pre-bend
  //
  if (i.pre_bend()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("pre-bend", e));

    s << *i.pre_bend();
  }

  // release
  //
  if (i.release()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("release", e));

    s << *i.release();
  }

  // with-bar
  //
  if (i.with_bar()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("with-bar", e));

    s << *i.with_bar();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // accelerate
  //
  if (i.accelerate()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("accelerate", e));

    a << *i.accelerate();
  }

  // beats
  //
  if (i.beats()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("beats", e));

    a << *i.beats();
  }

  // first-beat
  //
  if (i.first_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("first-beat", e));

    a << *i.first_beat();
  }

  // last-beat
  //
  if (i.last_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("last-beat", e));

    a << *i.last_beat();
  }
}

void operator<<(::xercesc::DOMElement &e, const breath_mark &i) {
  e << static_cast<const ::musicxml::breath_mark_value &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const empty_line &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // line-shape
  //
  if (i.line_shape()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-shape", e));

    a << *i.line_shape();
  }

  // line-type
  //
  if (i.line_type()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-type", e));

    a << *i.line_type();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const extend &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  if (i.type()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << *i.type();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const figure &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // prefix
  //
  if (i.prefix()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("prefix", e));

    s << *i.prefix();
  }

  // figure-number
  //
  if (i.figure_number()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("figure-number", e));

    s << *i.figure_number();
  }

  // suffix
  //
  if (i.suffix()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("suffix", e));

    s << *i.suffix();
  }

  // extend
  //
  if (i.extend()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("extend", e));

    s << *i.extend();
  }
}

void operator<<(::xercesc::DOMElement &e, const figured_bass &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // figure
  //
  for (const auto &elem : i.figure()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("figure", e));

    s << elem;
  }

  // duration
  //
  if (i.duration()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("duration", e));

    s << *i.duration();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // print-dot
  //
  if (i.print_dot()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-dot", e));

    a << *i.print_dot();
  }

  // print-spacing
  //
  if (i.print_spacing()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-spacing", e));

    a << *i.print_spacing();
  }

  // print-lyric
  //
  if (i.print_lyric()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-lyric", e));

    a << *i.print_lyric();
  }

  // parentheses
  //
  if (i.parentheses()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("parentheses", e));

    a << *i.parentheses();
  }
}

void operator<<(::xercesc::DOMElement &e, const forward &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // duration
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("duration", e));

    s << i.duration();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // voice
  //
  if (i.voice()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("voice", e));

    s << *i.voice();
  }

  // staff
  //
  if (i.staff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("staff", e));

    s << *i.staff();
  }
}

void operator<<(::xercesc::DOMElement &e, const glissando &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // line-type
  //
  if (i.line_type()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-type", e));

    a << *i.line_type();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const grace &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // steal-time-previous
  //
  if (i.steal_time_previous()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("steal-time-previous", e));

    a << *i.steal_time_previous();
  }

  // steal-time-following
  //
  if (i.steal_time_following()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("steal-time-following", e));

    a << *i.steal_time_following();
  }

  // make-time
  //
  if (i.make_time()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("make-time", e));

    a << *i.make_time();
  }

  // slash
  //
  if (i.slash()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("slash", e));

    a << *i.slash();
  }
}

void operator<<(::xercesc::DOMElement &e, const hammer_on_pull_off &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const handbell &i) {
  e << static_cast<const ::musicxml::handbell_value &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const harmonic &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // natural
  //
  if (i.natural()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("natural", e));

    s << *i.natural();
  }

  // artificial
  //
  if (i.artificial()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("artificial", e));

    s << *i.artificial();
  }

  // base-pitch
  //
  if (i.base_pitch()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("base-pitch", e));

    s << *i.base_pitch();
  }

  // touching-pitch
  //
  if (i.touching_pitch()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("touching-pitch", e));

    s << *i.touching_pitch();
  }

  // sounding-pitch
  //
  if (i.sounding_pitch()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("sounding-pitch", e));

    s << *i.sounding_pitch();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const heel_toe &i) {
  e << static_cast<const ::musicxml::empty_placement &>(i);

  // substitution
  //
  if (i.substitution()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("substitution", e));

    a << *i.substitution();
  }
}

void operator<<(::xercesc::DOMElement &e, const hole &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // hole-type
  //
  if (i.hole_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("hole-type", e));

    s << *i.hole_type();
  }

  // hole-closed
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("hole-closed", e));

    s << i.hole_closed();
  }

  // hole-shape
  //
  if (i.hole_shape()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("hole-shape", e));

    s << *i.hole_shape();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const hole_closed &i) {
  e << static_cast<const ::musicxml::hole_closed_value &>(i);

  // location
  //
  if (i.location()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("location", e));

    a << *i.location();
  }
}

void operator<<(::xercesc::DOMElement &e, const instrument &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // id
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << i.id();
  }
}

void operator<<(::xercesc::DOMElement &e, const lyric &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // syllabic
  //
  for (const auto &elem : i.syllabic()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("syllabic", e));

    s << elem;
  }

  // text
  //
  for (const auto &elem : i.text()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("text", e));

    s << elem;
  }

  // elision
  //
  for (const auto &elem : i.elision()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("elision", e));

    s << elem;
  }

  // extend
  //
  if (i.extend()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("extend", e));

    s << *i.extend();
  }

  // laughing
  //
  if (i.laughing()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("laughing", e));

    s << *i.laughing();
  }

  // humming
  //
  if (i.humming()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("humming", e));

    s << *i.humming();
  }

  // end-line
  //
  if (i.end_line()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("end-line", e));

    s << *i.end_line();
  }

  // end-paragraph
  //
  if (i.end_paragraph()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("end-paragraph", e));

    s << *i.end_paragraph();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // name
  //
  if (i.name()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("name", e));

    a << *i.name();
  }

  // justify
  //
  if (i.justify()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("justify", e));

    a << *i.justify();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }
}

void operator<<(::xercesc::DOMElement &e, const mordent &i) {
  e << static_cast<const ::musicxml::empty_trill_sound &>(i);

  // long
  //
  if (i.long_()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("long", e));

    a << *i.long_();
  }

  // approach
  //
  if (i.approach()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("approach", e));

    a << *i.approach();
  }

  // departure
  //
  if (i.departure()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("departure", e));

    a << *i.departure();
  }
}

void operator<<(::xercesc::DOMElement &e, const non_arpeggiate &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const notations &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // tied
  //
  for (const auto &elem : i.tied()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("tied", e));

    s << elem;
  }

  // slur
  //
  for (const auto &elem : i.slur()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("slur", e));

    s << elem;
  }

  // tuplet
  //
  for (const auto &elem : i.tuplet()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("tuplet", e));

    s << elem;
  }

  // glissando
  //
  for (const auto &elem : i.glissando()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("glissando", e));

    s << elem;
  }

  // slide
  //
  for (const auto &elem : i.slide()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("slide", e));

    s << elem;
  }

  // ornaments
  //
  for (const auto &elem : i.ornaments()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("ornaments", e));

    s << elem;
  }

  // technical
  //
  for (const auto &elem : i.technical()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("technical", e));

    s << elem;
  }

  // articulations
  //
  for (const auto &elem : i.articulations()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("articulations", e));

    s << elem;
  }

  // dynamics
  //
  for (const auto &elem : i.dynamics()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("dynamics", e));

    s << elem;
  }

  // fermata
  //
  for (const auto &elem : i.fermata()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("fermata", e));

    s << elem;
  }

  // arpeggiate
  //
  for (const auto &elem : i.arpeggiate()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("arpeggiate", e));

    s << elem;
  }

  // non-arpeggiate
  //
  for (const auto &elem : i.non_arpeggiate()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("non-arpeggiate", e));

    s << elem;
  }

  // accidental-mark
  //
  for (const auto &elem : i.accidental_mark()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accidental-mark", e));

    s << elem;
  }

  // other-notation
  //
  for (const auto &elem : i.other_notation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-notation", e));

    s << elem;
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }
}

void operator<<(::xercesc::DOMElement &e, const note &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // grace
  //
  if (i.grace()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("grace", e));

    s << *i.grace();
  }

  // chord
  //
  if (i.chord()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("chord", e));

    s << *i.chord();
  }

  // pitch
  //
  if (i.pitch()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("pitch", e));

    s << *i.pitch();
  }

  // unpitched
  //
  if (i.unpitched()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("unpitched", e));

    s << *i.unpitched();
  }

  // rest
  //
  if (i.rest()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("rest", e));

    s << *i.rest();
  }

  // tie
  //
  for (const auto &elem : i.tie()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("tie", e));

    s << elem;
  }

  // cue
  //
  if (i.cue()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("cue", e));

    s << *i.cue();
  }

  // duration
  //
  if (i.duration()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("duration", e));

    s << *i.duration();
  }

  // instrument
  //
  if (i.instrument()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("instrument", e));

    s << *i.instrument();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // voice
  //
  if (i.voice()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("voice", e));

    s << *i.voice();
  }

  // type
  //
  if (i.type()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("type", e));

    s << *i.type();
  }

  // dot
  //
  for (const auto &elem : i.dot()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("dot", e));

    s << elem;
  }

  // accidental
  //
  if (i.accidental()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accidental", e));

    s << *i.accidental();
  }

  // time-modification
  //
  if (i.time_modification()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("time-modification", e));

    s << *i.time_modification();
  }

  // stem
  //
  if (i.stem()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("stem", e));

    s << *i.stem();
  }

  // notehead
  //
  if (i.notehead()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("notehead", e));

    s << *i.notehead();
  }

  // notehead-text
  //
  if (i.notehead_text()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("notehead-text", e));

    s << *i.notehead_text();
  }

  // staff
  //
  if (i.staff()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("staff", e));

    s << *i.staff();
  }

  // beam
  //
  for (const auto &elem : i.beam()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("beam", e));

    s << elem;
  }

  // notations
  //
  for (const auto &elem : i.notations()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("notations", e));

    s << elem;
  }

  // lyric
  //
  for (const auto &elem : i.lyric()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("lyric", e));

    s << elem;
  }

  // play
  //
  if (i.play()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("play", e));

    s << *i.play();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // print-dot
  //
  if (i.print_dot()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-dot", e));

    a << *i.print_dot();
  }

  // print-spacing
  //
  if (i.print_spacing()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-spacing", e));

    a << *i.print_spacing();
  }

  // print-lyric
  //
  if (i.print_lyric()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-lyric", e));

    a << *i.print_lyric();
  }

  // dynamics
  //
  if (i.dynamics()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dynamics", e));

    a << *i.dynamics();
  }

  // end-dynamics
  //
  if (i.end_dynamics()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("end-dynamics", e));

    a << *i.end_dynamics();
  }

  // attack
  //
  if (i.attack()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("attack", e));

    a << *i.attack();
  }

  // release
  //
  if (i.release()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("release", e));

    a << *i.release();
  }

  // time-only
  //
  if (i.time_only()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("time-only", e));

    a << *i.time_only();
  }

  // pizzicato
  //
  if (i.pizzicato()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("pizzicato", e));

    a << *i.pizzicato();
  }
}

void operator<<(::xercesc::DOMElement &e, const note_type &i) {
  e << static_cast<const ::musicxml::note_type_value &>(i);

  // size
  //
  if (i.size()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("size", e));

    a << *i.size();
  }
}

void operator<<(::xercesc::DOMElement &e, const notehead &i) {
  e << static_cast<const ::musicxml::notehead_value &>(i);

  // filled
  //
  if (i.filled()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("filled", e));

    a << *i.filled();
  }

  // parentheses
  //
  if (i.parentheses()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("parentheses", e));

    a << *i.parentheses();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const notehead_text &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // display-text
  //
  for (const auto &elem : i.display_text()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("display-text", e));

    s << elem;
  }

  // accidental-text
  //
  for (const auto &elem : i.accidental_text()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accidental-text", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const ornaments &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // trill-mark
  //
  for (const auto &elem : i.trill_mark()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("trill-mark", e));

    s << elem;
  }

  // turn
  //
  for (const auto &elem : i.turn()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("turn", e));

    s << elem;
  }

  // delayed-turn
  //
  for (const auto &elem : i.delayed_turn()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("delayed-turn", e));

    s << elem;
  }

  // inverted-turn
  //
  for (const auto &elem : i.inverted_turn()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("inverted-turn", e));

    s << elem;
  }

  // delayed-inverted-turn
  //
  for (const auto &elem : i.delayed_inverted_turn()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("delayed-inverted-turn", e));

    s << elem;
  }

  // vertical-turn
  //
  for (const auto &elem : i.vertical_turn()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("vertical-turn", e));

    s << elem;
  }

  // shake
  //
  for (const auto &elem : i.shake()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("shake", e));

    s << elem;
  }

  // wavy-line
  //
  for (const auto &elem : i.wavy_line()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("wavy-line", e));

    s << elem;
  }

  // mordent
  //
  for (const auto &elem : i.mordent()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("mordent", e));

    s << elem;
  }

  // inverted-mordent
  //
  for (const auto &elem : i.inverted_mordent()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("inverted-mordent", e));

    s << elem;
  }

  // schleifer
  //
  for (const auto &elem : i.schleifer()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("schleifer", e));

    s << elem;
  }

  // tremolo
  //
  for (const auto &elem : i.tremolo()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tremolo", e));

    s << elem;
  }

  // other-ornament
  //
  for (const auto &elem : i.other_ornament()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-ornament", e));

    s << elem;
  }

  // accidental-mark
  //
  for (const auto &elem : i.accidental_mark()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("accidental-mark", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const other_notation &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const pitch &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // step
  //
  {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("step", e));

    s << i.step();
  }

  // alter
  //
  if (i.alter()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("alter", e));

    s << *i.alter();
  }

  // octave
  //
  {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("octave", e));

    s << i.octave();
  }
}

void operator<<(::xercesc::DOMElement &e, const placement_text &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const rest &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // display-step
  //
  if (i.display_step()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("display-step", e));

    s << *i.display_step();
  }

  // display-octave
  //
  if (i.display_octave()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("display-octave", e));

    s << *i.display_octave();
  }

  // measure
  //
  if (i.measure()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("measure", e));

    a << *i.measure();
  }
}

void operator<<(::xercesc::DOMElement &e, const slide &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // line-type
  //
  if (i.line_type()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-type", e));

    a << *i.line_type();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // accelerate
  //
  if (i.accelerate()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("accelerate", e));

    a << *i.accelerate();
  }

  // beats
  //
  if (i.beats()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("beats", e));

    a << *i.beats();
  }

  // first-beat
  //
  if (i.first_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("first-beat", e));

    a << *i.first_beat();
  }

  // last-beat
  //
  if (i.last_beat()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("last-beat", e));

    a << *i.last_beat();
  }
}

void operator<<(::xercesc::DOMElement &e, const slur &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // line-type
  //
  if (i.line_type()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-type", e));

    a << *i.line_type();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // orientation
  //
  if (i.orientation()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("orientation", e));

    a << *i.orientation();
  }

  // bezier-offset
  //
  if (i.bezier_offset()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-offset", e));

    a << *i.bezier_offset();
  }

  // bezier-offset2
  //
  if (i.bezier_offset2()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-offset2", e));

    a << *i.bezier_offset2();
  }

  // bezier-x
  //
  if (i.bezier_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-x", e));

    a << *i.bezier_x();
  }

  // bezier-y
  //
  if (i.bezier_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-y", e));

    a << *i.bezier_y();
  }

  // bezier-x2
  //
  if (i.bezier_x2()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-x2", e));

    a << *i.bezier_x2();
  }

  // bezier-y2
  //
  if (i.bezier_y2()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-y2", e));

    a << *i.bezier_y2();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const stem &i) {
  e << static_cast<const ::musicxml::stem_value &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const strong_accent &i) {
  e << static_cast<const ::musicxml::empty_placement &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }
}

void operator<<(::xercesc::DOMElement &e, const style_text &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const technical &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // up-bow
  //
  for (const auto &elem : i.up_bow()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("up-bow", e));

    s << elem;
  }

  // down-bow
  //
  for (const auto &elem : i.down_bow()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("down-bow", e));

    s << elem;
  }

  // harmonic
  //
  for (const auto &elem : i.harmonic()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("harmonic", e));

    s << elem;
  }

  // open-string
  //
  for (const auto &elem : i.open_string()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("open-string", e));

    s << elem;
  }

  // thumb-position
  //
  for (const auto &elem : i.thumb_position()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("thumb-position", e));

    s << elem;
  }

  // fingering
  //
  for (const auto &elem : i.fingering()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("fingering", e));

    s << elem;
  }

  // pluck
  //
  for (const auto &elem : i.pluck()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("pluck", e));

    s << elem;
  }

  // double-tongue
  //
  for (const auto &elem : i.double_tongue()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("double-tongue", e));

    s << elem;
  }

  // triple-tongue
  //
  for (const auto &elem : i.triple_tongue()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("triple-tongue", e));

    s << elem;
  }

  // stopped
  //
  for (const auto &elem : i.stopped()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("stopped", e));

    s << elem;
  }

  // snap-pizzicato
  //
  for (const auto &elem : i.snap_pizzicato()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("snap-pizzicato", e));

    s << elem;
  }

  // fret
  //
  for (const auto &elem : i.fret()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("fret", e));

    s << elem;
  }

  // string
  //
  for (const auto &elem : i.string()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("string", e));

    s << elem;
  }

  // hammer-on
  //
  for (const auto &elem : i.hammer_on()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("hammer-on", e));

    s << elem;
  }

  // pull-off
  //
  for (const auto &elem : i.pull_off()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("pull-off", e));

    s << elem;
  }

  // bend
  //
  for (const auto &elem : i.bend()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("bend", e));

    s << elem;
  }

  // tap
  //
  for (const auto &elem : i.tap()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("tap", e));

    s << elem;
  }

  // heel
  //
  for (const auto &elem : i.heel()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("heel", e));

    s << elem;
  }

  // toe
  //
  for (const auto &elem : i.toe()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("toe", e));

    s << elem;
  }

  // fingernails
  //
  for (const auto &elem : i.fingernails()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("fingernails", e));

    s << elem;
  }

  // hole
  //
  for (const auto &elem : i.hole()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("hole", e));

    s << elem;
  }

  // arrow
  //
  for (const auto &elem : i.arrow()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("arrow", e));

    s << elem;
  }

  // handbell
  //
  for (const auto &elem : i.handbell()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("handbell", e));

    s << elem;
  }

  // other-technical
  //
  for (const auto &elem : i.other_technical()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("other-technical", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const text_element_data &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // underline
  //
  if (i.underline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("underline", e));

    a << *i.underline();
  }

  // overline
  //
  if (i.overline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("overline", e));

    a << *i.overline();
  }

  // line-through
  //
  if (i.line_through()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-through", e));

    a << *i.line_through();
  }

  // rotation
  //
  if (i.rotation()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("rotation", e));

    a << *i.rotation();
  }

  // letter-spacing
  //
  if (i.letter_spacing()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("letter-spacing", e));

    a << *i.letter_spacing();
  }

  // lang
  //
  if (i.lang()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "lang", "http://www.w3.org/XML/1998/namespace", e));

    a << *i.lang();
  }

  // dir
  //
  if (i.dir()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("dir", e));

    a << *i.dir();
  }
}

void operator<<(::xercesc::DOMElement &e, const text_font_color &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // underline
  //
  if (i.underline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("underline", e));

    a << *i.underline();
  }

  // overline
  //
  if (i.overline()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("overline", e));

    a << *i.overline();
  }

  // line-through
  //
  if (i.line_through()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-through", e));

    a << *i.line_through();
  }

  // rotation
  //
  if (i.rotation()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("rotation", e));

    a << *i.rotation();
  }

  // letter-spacing
  //
  if (i.letter_spacing()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("letter-spacing", e));

    a << *i.letter_spacing();
  }

  // lang
  //
  if (i.lang()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "lang", "http://www.w3.org/XML/1998/namespace", e));

    a << *i.lang();
  }

  // dir
  //
  if (i.dir()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("dir", e));

    a << *i.dir();
  }
}

void operator<<(::xercesc::DOMElement &e, const tie &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // time-only
  //
  if (i.time_only()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("time-only", e));

    a << *i.time_only();
  }
}

void operator<<(::xercesc::DOMElement &e, const tied &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // line-type
  //
  if (i.line_type()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-type", e));

    a << *i.line_type();
  }

  // dash-length
  //
  if (i.dash_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("dash-length", e));

    a << *i.dash_length();
  }

  // space-length
  //
  if (i.space_length()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("space-length", e));

    a << *i.space_length();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }

  // orientation
  //
  if (i.orientation()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("orientation", e));

    a << *i.orientation();
  }

  // bezier-offset
  //
  if (i.bezier_offset()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-offset", e));

    a << *i.bezier_offset();
  }

  // bezier-offset2
  //
  if (i.bezier_offset2()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-offset2", e));

    a << *i.bezier_offset2();
  }

  // bezier-x
  //
  if (i.bezier_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-x", e));

    a << *i.bezier_x();
  }

  // bezier-y
  //
  if (i.bezier_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-y", e));

    a << *i.bezier_y();
  }

  // bezier-x2
  //
  if (i.bezier_x2()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-x2", e));

    a << *i.bezier_x2();
  }

  // bezier-y2
  //
  if (i.bezier_y2()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("bezier-y2", e));

    a << *i.bezier_y2();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const tremolo &i) {
  e << static_cast<const ::musicxml::tremolo_marks &>(i);

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const tuplet &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // tuplet-actual
  //
  if (i.tuplet_actual()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuplet-actual", e));

    s << *i.tuplet_actual();
  }

  // tuplet-normal
  //
  if (i.tuplet_normal()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuplet-normal", e));

    s << *i.tuplet_normal();
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // bracket
  //
  if (i.bracket()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("bracket", e));

    a << *i.bracket();
  }

  // show-number
  //
  if (i.show_number()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("show-number", e));

    a << *i.show_number();
  }

  // show-type
  //
  if (i.show_type()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("show-type", e));

    a << *i.show_type();
  }

  // line-shape
  //
  if (i.line_shape()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("line-shape", e));

    a << *i.line_shape();
  }

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // placement
  //
  if (i.placement()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("placement", e));

    a << *i.placement();
  }
}

void operator<<(::xercesc::DOMElement &e, const tuplet_dot &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const tuplet_number &i) {
  e << static_cast<const ::xsd::cxx::tree::fundamental_base<
    ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type> &>(i);

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const tuplet_portion &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // tuplet-number
  //
  if (i.tuplet_number()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuplet-number", e));

    s << *i.tuplet_number();
  }

  // tuplet-type
  //
  if (i.tuplet_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuplet-type", e));

    s << *i.tuplet_type();
  }

  // tuplet-dot
  //
  for (const auto &elem : i.tuplet_dot()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("tuplet-dot", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const tuplet_type &i) {
  e << static_cast<const ::musicxml::note_type_value &>(i);

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const unpitched &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // display-step
  //
  if (i.display_step()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("display-step", e));

    s << *i.display_step();
  }

  // display-octave
  //
  if (i.display_octave()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("display-octave", e));

    s << *i.display_octave();
  }
}

void operator<<(::xercesc::DOMElement &e, const credit &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // credit-type
  //
  for (const auto &elem : i.credit_type()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("credit-type", e));

    s << elem;
  }

  // link
  //
  for (const auto &elem : i.link()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("link", e));

    s << elem;
  }

  // bookmark
  //
  for (const auto &elem : i.bookmark()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("bookmark", e));

    s << elem;
  }

  // credit-image
  //
  if (i.credit_image()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("credit-image", e));

    s << *i.credit_image();
  }

  // credit-words
  //
  for (const auto &elem : i.credit_words()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("credit-words", e));

    s << elem;
  }

  // page
  //
  if (i.page()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("page", e));

    a << *i.page();
  }
}

void operator<<(::xercesc::DOMElement &e, const defaults &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // scaling
  //
  if (i.scaling()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("scaling", e));

    s << *i.scaling();
  }

  // page-layout
  //
  if (i.page_layout()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("page-layout", e));

    s << *i.page_layout();
  }

  // system-layout
  //
  if (i.system_layout()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("system-layout", e));

    s << *i.system_layout();
  }

  // staff-layout
  //
  for (const auto &elem : i.staff_layout()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("staff-layout", e));

    s << elem;
  }

  // appearance
  //
  if (i.appearance()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("appearance", e));

    s << *i.appearance();
  }

  // music-font
  //
  if (i.music_font()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("music-font", e));

    s << *i.music_font();
  }

  // word-font
  //
  if (i.word_font()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("word-font", e));

    s << *i.word_font();
  }

  // lyric-font
  //
  for (const auto &elem : i.lyric_font()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("lyric-font", e));

    s << elem;
  }

  // lyric-language
  //
  for (const auto &elem : i.lyric_language()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("lyric-language", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const empty_font &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }
}

void operator<<(::xercesc::DOMElement &e, const group_barline &i) {
  e << static_cast<const ::musicxml::group_barline_value &>(i);

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const group_name &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // justify
  //
  if (i.justify()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("justify", e));

    a << *i.justify();
  }
}

void operator<<(::xercesc::DOMElement &e, const group_symbol &i) {
  e << static_cast<const ::musicxml::group_symbol_value &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }
}

void operator<<(::xercesc::DOMElement &e, const lyric_font &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // name
  //
  if (i.name()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("name", e));

    a << *i.name();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }
}

void operator<<(::xercesc::DOMElement &e, const lyric_language &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // number
  //
  if (i.number()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << *i.number();
  }

  // name
  //
  if (i.name()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("name", e));

    a << *i.name();
  }

  // lang
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "lang", "http://www.w3.org/XML/1998/namespace", e));

    a << i.lang();
  }
}

void operator<<(::xercesc::DOMElement &e, const opus &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // href
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "href", "http://www.w3.org/1999/xlink", e));

    a << i.href();
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "type", "http://www.w3.org/1999/xlink", e));

    a << i.type();
  }

  // role
  //
  if (i.role()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "role", "http://www.w3.org/1999/xlink", e));

    a << *i.role();
  }

  // title
  //
  if (i.title()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "title", "http://www.w3.org/1999/xlink", e));

    a << *i.title();
  }

  // show
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "show", "http://www.w3.org/1999/xlink", e));

    a << i.show();
  }

  // actuate
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "actuate", "http://www.w3.org/1999/xlink", e));

    a << i.actuate();
  }
}

void operator<<(::xercesc::DOMElement &e, const part_group &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // group-name
  //
  if (i.group_name()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("group-name", e));

    s << *i.group_name();
  }

  // group-name-display
  //
  if (i.group_name_display()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("group-name-display", e));

    s << *i.group_name_display();
  }

  // group-abbreviation
  //
  if (i.group_abbreviation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("group-abbreviation", e));

    s << *i.group_abbreviation();
  }

  // group-abbreviation-display
  //
  if (i.group_abbreviation_display()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("group-abbreviation-display", e));

    s << *i.group_abbreviation_display();
  }

  // group-symbol
  //
  if (i.group_symbol()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("group-symbol", e));

    s << *i.group_symbol();
  }

  // group-barline
  //
  if (i.group_barline()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("group-barline", e));

    s << *i.group_barline();
  }

  // group-time
  //
  if (i.group_time()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("group-time", e));

    s << *i.group_time();
  }

  // footnote
  //
  if (i.footnote()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("footnote", e));

    s << *i.footnote();
  }

  // level
  //
  if (i.level()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("level", e));

    s << *i.level();
  }

  // type
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("type", e));

    a << i.type();
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }
}

void operator<<(::xercesc::DOMElement &e, const part_list &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // part-group
  //
  for (const auto &elem : i.part_group()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-group", e));

    s << elem;
  }

  // score-part
  //
  for (const auto &elem : i.score_part()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("score-part", e));

    s << elem;
  }
}

void operator<<(::xercesc::DOMElement &e, const part_name &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // print-object
  //
  if (i.print_object()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("print-object", e));

    a << *i.print_object();
  }

  // justify
  //
  if (i.justify()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("justify", e));

    a << *i.justify();
  }
}

void operator<<(::xercesc::DOMElement &e, const score_instrument &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // instrument-name
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("instrument-name", e));

    s << i.instrument_name();
  }

  // instrument-abbreviation
  //
  if (i.instrument_abbreviation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("instrument-abbreviation", e));

    s << *i.instrument_abbreviation();
  }

  // instrument-sound
  //
  if (i.instrument_sound()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("instrument-sound", e));

    s << *i.instrument_sound();
  }

  // solo
  //
  if (i.solo()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("solo", e));

    s << *i.solo();
  }

  // ensemble
  //
  if (i.ensemble()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("ensemble", e));

    s << *i.ensemble();
  }

  // virtual-instrument
  //
  if (i.virtual_instrument()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("virtual-instrument", e));

    s << *i.virtual_instrument();
  }

  // id
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << i.id();
  }
}

void operator<<(::xercesc::DOMElement &e, const score_part &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // identification
  //
  if (i.identification()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("identification", e));

    s << *i.identification();
  }

  // part-name
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-name", e));

    s << i.part_name();
  }

  // part-name-display
  //
  if (i.part_name_display()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-name-display", e));

    s << *i.part_name_display();
  }

  // part-abbreviation
  //
  if (i.part_abbreviation()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-abbreviation", e));

    s << *i.part_abbreviation();
  }

  // part-abbreviation-display
  //
  if (i.part_abbreviation_display()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-abbreviation-display", e));

    s << *i.part_abbreviation_display();
  }

  // group
  //
  for (const auto &elem : i.group()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("group", e));

    s << elem;
  }

  // score-instrument
  //
  for (const auto &elem : i.score_instrument()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("score-instrument", e));

    s << elem;
  }

  // midi-device
  //
  for (const auto &elem : i.midi_device()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-device", e));

    s << elem;
  }

  // midi-instrument
  //
  for (const auto &elem : i.midi_instrument()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("midi-instrument", e));

    s << elem;
  }

  // id
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << i.id();
  }
}

void operator<<(::xercesc::DOMElement &e, const virtual_instrument &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // virtual-library
  //
  if (i.virtual_library()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("virtual-library", e));

    s << *i.virtual_library();
  }

  // virtual-name
  //
  if (i.virtual_name()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("virtual-name", e));

    s << *i.virtual_name();
  }
}

void operator<<(::xercesc::DOMElement &e, const work &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // work-number
  //
  if (i.work_number()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("work-number", e));

    s << *i.work_number();
  }

  // work-title
  //
  if (i.work_title()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("work-title", e));

    s << *i.work_title();
  }

  // opus
  //
  if (i.opus()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("opus", e));

    s << *i.opus();
  }
}

void score_partwise_(::std::ostream &o, const ::musicxml::score_partwise &s,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_partwise_(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed<::xsd::cxx::tree::serialization<char>>();
  }
}

void score_partwise_(::std::ostream &o, const ::musicxml::score_partwise &s,
                     ::xml_schema::error_handler &h,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_partwise_(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void score_partwise_(::std::ostream &o, const ::musicxml::score_partwise &s,
                     ::xercesc::DOMErrorHandler &h,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_partwise_(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void score_partwise_(::xercesc::XMLFormatTarget &t,
                     const ::musicxml::score_partwise &s,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_partwise_(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed<::xsd::cxx::tree::serialization<char>>();
  }
}

void score_partwise_(::xercesc::XMLFormatTarget &t,
                     const ::musicxml::score_partwise &s,
                     ::xml_schema::error_handler &h,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_partwise_(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void score_partwise_(::xercesc::XMLFormatTarget &t,
                     const ::musicxml::score_partwise &s,
                     ::xercesc::DOMErrorHandler &h,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_partwise_(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void score_partwise_(::xercesc::DOMDocument &d,
                     const ::musicxml::score_partwise &s, ::xml_schema::flags) {
  ::xercesc::DOMElement &e(*d.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
    ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "score-partwise" && n.namespace_() == "") { e << s; } else {
    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                     "score-partwise", "");
  }
}

::xml_schema::dom::unique_ptr<::xercesc::DOMDocument>
score_partwise_(const ::musicxml::score_partwise &s,
                const ::xml_schema::namespace_infomap &m,
                ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::serialize<char>("score-partwise", "", m, f));

  ::musicxml::score_partwise_(*d, s, f);
  return d;
}

void score_timewise_(::std::ostream &o, const ::musicxml::score_timewise &s,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_timewise_(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed<::xsd::cxx::tree::serialization<char>>();
  }
}

void score_timewise_(::std::ostream &o, const ::musicxml::score_timewise &s,
                     ::xml_schema::error_handler &h,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xsd::cxx::xml::auto_initializer i(
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_timewise_(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void score_timewise_(::std::ostream &o, const ::musicxml::score_timewise &s,
                     ::xercesc::DOMErrorHandler &h,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_timewise_(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void score_timewise_(::xercesc::XMLFormatTarget &t,
                     const ::musicxml::score_timewise &s,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_timewise_(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed<::xsd::cxx::tree::serialization<char>>();
  }
}

void score_timewise_(::xercesc::XMLFormatTarget &t,
                     const ::musicxml::score_timewise &s,
                     ::xml_schema::error_handler &h,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_timewise_(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void score_timewise_(::xercesc::XMLFormatTarget &t,
                     const ::musicxml::score_timewise &s,
                     ::xercesc::DOMErrorHandler &h,
                     const ::xml_schema::namespace_infomap &m,
                     const ::std::string &e, ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::musicxml::score_timewise_(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void score_timewise_(::xercesc::DOMDocument &d,
                     const ::musicxml::score_timewise &s, ::xml_schema::flags) {
  ::xercesc::DOMElement &e(*d.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(
    ::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "score-timewise" && n.namespace_() == "") { e << s; } else {
    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(),
                                                     "score-timewise", "");
  }
}

::xml_schema::dom::unique_ptr<::xercesc::DOMDocument>
score_timewise_(const ::musicxml::score_timewise &s,
                const ::xml_schema::namespace_infomap &m,
                ::xml_schema::flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
    ::xsd::cxx::xml::dom::serialize<char>("score-timewise", "", m, f));

  ::musicxml::score_timewise_(*d, s, f);
  return d;
}

void operator<<(::xercesc::DOMElement &e, const number_or_normal_member &i) {
  e << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const number_or_normal_member &i) {
  a << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xml_schema::list_stream &l,
                const number_or_normal_member &i) {
  l << static_cast<const ::xml_schema::token &>(i);
}

void operator<<(::xercesc::DOMElement &e,
                const positive_integer_or_empty_member &i) {
  e << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMAttr &a,
                const positive_integer_or_empty_member &i) {
  a << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xml_schema::list_stream &l,
                const positive_integer_or_empty_member &i) {
  l << static_cast<const ::xml_schema::string &>(i);
}

void operator<<(::xercesc::DOMElement &e, const directive &i) {
  e << static_cast<const ::xml_schema::string &>(i);

  // default-x
  //
  if (i.default_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-x", e));

    a << *i.default_x();
  }

  // default-y
  //
  if (i.default_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("default-y", e));

    a << *i.default_y();
  }

  // relative-x
  //
  if (i.relative_x()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-x", e));

    a << *i.relative_x();
  }

  // relative-y
  //
  if (i.relative_y()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("relative-y", e));

    a << *i.relative_y();
  }

  // font-family
  //
  if (i.font_family()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-family", e));

    a << *i.font_family();
  }

  // font-style
  //
  if (i.font_style()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-style", e));

    a << *i.font_style();
  }

  // font-size
  //
  if (i.font_size()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-size", e));

    a << *i.font_size();
  }

  // font-weight
  //
  if (i.font_weight()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("font-weight", e));

    a << *i.font_weight();
  }

  // color
  //
  if (i.color()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("color", e));

    a << *i.color();
  }

  // lang
  //
  if (i.lang()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute(
      "lang", "http://www.w3.org/XML/1998/namespace", e));

    a << *i.lang();
  }
}

void operator<<(::xercesc::DOMElement &e, const score_partwise &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // work
  //
  if (i.work()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("work", e));

    s << *i.work();
  }

  // movement-number
  //
  if (i.movement_number()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("movement-number", e));

    s << *i.movement_number();
  }

  // movement-title
  //
  if (i.movement_title()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("movement-title", e));

    s << *i.movement_title();
  }

  // identification
  //
  if (i.identification()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("identification", e));

    s << *i.identification();
  }

  // defaults
  //
  if (i.defaults()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("defaults", e));

    s << *i.defaults();
  }

  // credit
  //
  for (const auto &elem : i.credit()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("credit", e));

    s << elem;
  }

  // part-list
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-list", e));

    s << i.part_list();
  }

  // part
  //
  for (const auto &elem : i.part()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("part", e));

    s << elem;
  }

  // version
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("version", e));

    a << i.version();
  }
}

void operator<<(::xercesc::DOMElement &e, const score_timewise &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // work
  //
  if (i.work()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("work", e));

    s << *i.work();
  }

  // movement-number
  //
  if (i.movement_number()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("movement-number", e));

    s << *i.movement_number();
  }

  // movement-title
  //
  if (i.movement_title()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("movement-title", e));

    s << *i.movement_title();
  }

  // identification
  //
  if (i.identification()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("identification", e));

    s << *i.identification();
  }

  // defaults
  //
  if (i.defaults()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("defaults", e));

    s << *i.defaults();
  }

  // credit
  //
  for (const auto &elem : i.credit()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("credit", e));

    s << elem;
  }

  // part-list
  //
  {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("part-list", e));

    s << i.part_list();
  }

  // measure
  //
  for (const auto &elem : i.measure()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("measure", e));

    s << elem;
  }

  // version
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("version", e));

    a << i.version();
  }
}

void operator<<(::xercesc::DOMElement &e, const part &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // measure
  //
  for (const auto &elem : i.measure()) {
    ::xercesc::DOMElement &s(
      ::xsd::cxx::xml::dom::create_element("measure", e));

    s << elem;
  }

  // id
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << i.id();
  }
}

void operator<<(::xercesc::DOMElement &e, const measure &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  // part
  //
  for (const auto &elem : i.part()) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("part", e));

    s << elem;
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // implicit
  //
  if (i.implicit()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("implicit", e));

    a << *i.implicit();
  }

  // non-controlling
  //
  if (i.non_controlling()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("non-controlling", e));

    a << *i.non_controlling();
  }

  // width
  //
  if (i.width()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("width", e));

    a << *i.width();
  }
}

void operator<<(::xercesc::DOMElement &e, const measure1 &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  for (const auto &elem : i.content_order()) {
    switch (elem.id) {
    // note
    //
    case measure1::note_id: {
      const measure1::note_type &x(i.note()[elem.index]);

      ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("note", e));

      s << x;
      continue;
    }
    // backup
    //
    case measure1::backup_id: {
      const measure1::backup_type &x(i.backup()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("backup", e));

      s << x;
      continue;
    }
    // forward
    //
    case measure1::forward_id: {
      const measure1::forward_type &x(i.forward()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("forward", e));

      s << x;
      continue;
    }
    // direction
    //
    case measure1::direction_id: {
      const measure1::direction_type &x(i.direction()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("direction", e));

      s << x;
      continue;
    }
    // attributes
    //
    case measure1::attributes_id: {
      const measure1::attributes_type &x(i.attributes()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("attributes", e));

      s << x;
      continue;
    }
    // harmony
    //
    case measure1::harmony_id: {
      const measure1::harmony_type &x(i.harmony()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("harmony", e));

      s << x;
      continue;
    }
    // figured-bass
    //
    case measure1::figured_bass_id: {
      const measure1::figured_bass_type &x(i.figured_bass()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("figured-bass", e));

      s << x;
      continue;
    }
    // print
    //
    case measure1::print_id: {
      const measure1::print_type &x(i.print()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("print", e));

      s << x;
      continue;
    }
    // sound
    //
    case measure1::sound_id: {
      const measure1::sound_type &x(i.sound()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("sound", e));

      s << x;
      continue;
    }
    // barline
    //
    case measure1::barline_id: {
      const measure1::barline_type &x(i.barline()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("barline", e));

      s << x;
      continue;
    }
    // grouping
    //
    case measure1::grouping_id: {
      const measure1::grouping_type &x(i.grouping()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("grouping", e));

      s << x;
      continue;
    }
    // link
    //
    case measure1::link_id: {
      const measure1::link_type &x(i.link()[elem.index]);

      ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("link", e));

      s << x;
      continue;
    }
    // bookmark
    //
    case measure1::bookmark_id: {
      const measure1::bookmark_type &x(i.bookmark()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("bookmark", e));

      s << x;
      continue;
    }
    default: { break; }
    }

    break;
  }

  // number
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("number", e));

    a << i.number();
  }

  // implicit
  //
  if (i.implicit()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("implicit", e));

    a << *i.implicit();
  }

  // non-controlling
  //
  if (i.non_controlling()) {
    ::xercesc::DOMAttr &a(
      ::xsd::cxx::xml::dom::create_attribute("non-controlling", e));

    a << *i.non_controlling();
  }

  // width
  //
  if (i.width()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("width", e));

    a << *i.width();
  }
}

void operator<<(::xercesc::DOMElement &e, const part1 &i) {
  e << static_cast<const ::xml_schema::type &>(i);

  for (const auto &elem : i.content_order()) {
    switch (elem.id) {
    // note
    //
    case part1::note_id: {
      const part1::note_type &x(i.note()[elem.index]);

      ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("note", e));

      s << x;
      continue;
    }
    // backup
    //
    case part1::backup_id: {
      const part1::backup_type &x(i.backup()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("backup", e));

      s << x;
      continue;
    }
    // forward
    //
    case part1::forward_id: {
      const part1::forward_type &x(i.forward()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("forward", e));

      s << x;
      continue;
    }
    // direction
    //
    case part1::direction_id: {
      const part1::direction_type &x(i.direction()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("direction", e));

      s << x;
      continue;
    }
    // attributes
    //
    case part1::attributes_id: {
      const part1::attributes_type &x(i.attributes()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("attributes", e));

      s << x;
      continue;
    }
    // harmony
    //
    case part1::harmony_id: {
      const part1::harmony_type &x(i.harmony()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("harmony", e));

      s << x;
      continue;
    }
    // figured-bass
    //
    case part1::figured_bass_id: {
      const part1::figured_bass_type &x(i.figured_bass()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("figured-bass", e));

      s << x;
      continue;
    }
    // print
    //
    case part1::print_id: {
      const part1::print_type &x(i.print()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("print", e));

      s << x;
      continue;
    }
    // sound
    //
    case part1::sound_id: {
      const part1::sound_type &x(i.sound()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("sound", e));

      s << x;
      continue;
    }
    // barline
    //
    case part1::barline_id: {
      const part1::barline_type &x(i.barline()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("barline", e));

      s << x;
      continue;
    }
    // grouping
    //
    case part1::grouping_id: {
      const part1::grouping_type &x(i.grouping()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("grouping", e));

      s << x;
      continue;
    }
    // link
    //
    case part1::link_id: {
      const part1::link_type &x(i.link()[elem.index]);

      ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("link", e));

      s << x;
      continue;
    }
    // bookmark
    //
    case part1::bookmark_id: {
      const part1::bookmark_type &x(i.bookmark()[elem.index]);

      ::xercesc::DOMElement &s(
        ::xsd::cxx::xml::dom::create_element("bookmark", e));

      s << x;
      continue;
    }
    default: { break; }
    }

    break;
  }

  // id
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("id", e));

    a << i.id();
  }
}
} // namespace musicxml

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
